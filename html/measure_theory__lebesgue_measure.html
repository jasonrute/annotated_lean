<head>
<meta charset="UTF-8">
<link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro&display=swap" rel="stylesheet">
</head>

<body>
<pre>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  1  /-</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  2  Copyright (c) 2017 Johannes Hölzl. All rights reserved.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  3  Released under Apache 2.0 license as described in the file LICENSE.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  4  Authors: Johannes Hölzl</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  5  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  6  Lebesgue measure on the real line</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  7  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  8  import measure_theory.measure_space measure_theory.borel_space</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measure_space.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/borel_space.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  9  noncomputable theory</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 10  open classical set lattice filter</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 11  open nnreal (of_real)</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 12  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 13  namespace measure_theory</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 14  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 15  /-- Length of an interval. This is the largest monotonic function which correctly</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 16    measures all intervals. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 17  def lebesgue_length (s : set ℝ) : ennreal := ⨅a b (h : s ⊆ Ico a b), of_real (b - a)</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 18  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 19  @[simp] lemma lebesgue_length_empty : lebesgue_length ∅ = 0 :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 20  le_zero_iff_eq.1 $ infi_le_of_le 0 $ infi_le_of_le 0 $ by simp</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 21  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 22  @[simp] lemma lebesgue_length_Ico (a b : ℝ) :</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 23    lebesgue_length (Ico a b) = of_real (b - a) :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 24  begin</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 25    refine le_antisymm (infi_le_of_le a $ infi_le_of_le b $ infi_le _ (by refl))</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1263, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Shorter name for the tactic `reflexivity`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 26      (le_infi $ λ a&#x27;, le_infi $ λ b&#x27;, le_infi $ λ h, ennreal.coe_le_coe.2 _),</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 27    cases le_or_lt b a with ab ab,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 28    { rw nnreal.of_real_of_nonpos (sub_nonpos.2 ab), simp },</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 29    cases (Ico_subset_Ico_iff ab).1 h with h₁ h₂,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 30    exact nnreal.of_real_le_of_real (sub_le_sub h₂ h₁)</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 31  end</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 32  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 33  lemma lebesgue_length_mono {s₁ s₂ : set ℝ} (h : s₁ ⊆ s₂) : lebesgue_length s₁ ≤ lebesgue_length s₂ :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 34  infi_le_infi $ λ a, infi_le_infi $ λ b, infi_le_infi2 $ λ h&#x27;, ⟨subset.trans h h&#x27;, le_refl _⟩</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 35  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 36  lemma lebesgue_length_eq_infi_Ioo (s) : lebesgue_length s = ⨅a b (h : s ⊆ Ioo a b), of_real (b - a) :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 37  begin</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 38    refine le_antisymm</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 39      (infi_le_infi $ λ a, infi_le_infi $ λ b, infi_le_infi2 $ λ h,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 40        ⟨subset.trans h Ioo_subset_Ico_self, le_refl _⟩) _,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 41    refine le_infi (λ a, le_infi $ λ b, le_infi $ λ h, _),</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 42    refine ennreal.le_of_forall_epsilon_le (λ ε ε0 _, _),</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 43    refine infi_le_of_le (a - ε) (infi_le_of_le b $ infi_le_of_le</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 44      (subset.trans h $ Ico_subset_Ioo_left $ (sub_lt_self_iff _).2 ε0) _),</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 45    rw [← sub_add, ← ennreal.coe_add, ennreal.coe_le_coe],</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 46    apply le_trans nnreal.of_real_add_le _,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 47    simp,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 48  end</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 49  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 50  @[simp] lemma lebesgue_length_Ioo (a b : ℝ) :</code>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 51    lebesgue_length (Ioo a b) = of_real (b - a) :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 52  begin</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 53    rw ← lebesgue_length_Ico,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 54    refine le_antisymm (lebesgue_length_mono Ioo_subset_Ico_self) _,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 55    rw lebesgue_length_eq_infi_Ioo (Ioo a b),</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 56    refine (le_infi $ λ a&#x27;, le_infi $ λ b&#x27;, le_infi $ λ h, _),</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 57    cases le_or_lt b a with ab ab, {simp [ab]},</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 58    cases (Ioo_subset_Ioo_iff ab).1 h with h₁ h₂,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 59    rw [lebesgue_length_Ico, ennreal.coe_le_coe],</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                              </code><font color='lime'><a title='a b a&#x27; b&#x27; : real,
h :
  @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Ioo.{0} real real.preorder a b)
    (@set.Ioo.{0} real real.preorder a&#x27; b&#x27;),
ab :
  @has_lt.lt.{0} real
    (@preorder.to_has_lt.{0} real
       (@partial_order.to_preorder.{0} real (@linear_order.to_partial_order.{0} real real.linear_order)))
    a
    b,
h₁ :
  @has_le.le.{0} real
    (@preorder.to_has_le.{0} real
       (@partial_order.to_preorder.{0} real (@linear_order.to_partial_order.{0} real real.linear_order)))
    a&#x27;
    a,
h₂ :
  @has_le.le.{0} real
    (@preorder.to_has_le.{0} real
       (@partial_order.to_preorder.{0} real (@linear_order.to_partial_order.{0} real real.linear_order)))
    b
    b&#x27;
⊢ @has_le.le.{0} nnreal nnreal.has_le
    (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a))
    (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b&#x27; a&#x27;))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 60    exact nnreal.of_real_le_of_real (sub_le_sub h₂ h₁)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='nnreal.of_real_le_of_real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='sub_le_sub'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/nnreal.lean&#x27;, &#x27;line&#x27;: 309, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/ordered_group.lean&#x27;, &#x27;line&#x27;: 454, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {r p : real}, @has_le.le.{0} real real.has_le r p → @has_le.le.{0} nnreal nnreal.has_le (nnreal.of_real r) (nnreal.of_real p)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type} [_inst_1 : ordered_comm_group.{0} α] {a b c d : α}, @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@ordered_comm_group.to_partial_order.{0} α _inst_1))) a b → @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@ordered_comm_group.to_partial_order.{0} α _inst_1))) c d → @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@ordered_comm_group.to_partial_order.{0} α _inst_1))) (@has_sub.sub.{0} α (@add_group_has_sub.{0} α (@add_comm_group.to_add_group.{0} α (@ordered_comm_group.to_add_comm_group.{0} α _inst_1))) a d) (@has_sub.sub.{0} α (@add_group_has_sub.{0} α (@add_comm_group.to_add_group.{0} α (@ordered_comm_group.to_add_comm_group.{0} α _inst_1))) b c)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_le.le.{0} real (@preorder.to_has_le.{0} real (@partial_order.to_preorder.{0} real (@linear_order.to_partial_order.{0} real real.linear_order))) b b&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_le.le.{0} real (@preorder.to_has_le.{0} real (@partial_order.to_preorder.{0} real (@linear_order.to_partial_order.{0} real real.linear_order))) a&#x27; a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a b a&#x27; b&#x27; : real,
h :
  @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Ioo.{0} real real.preorder a b)
    (@set.Ioo.{0} real real.preorder a&#x27; b&#x27;),
ab :
  @has_lt.lt.{0} real
    (@preorder.to_has_lt.{0} real
       (@partial_order.to_preorder.{0} real (@linear_order.to_partial_order.{0} real real.linear_order)))
    a
    b,
h₁ :
  @has_le.le.{0} real
    (@preorder.to_has_le.{0} real
       (@partial_order.to_preorder.{0} real (@linear_order.to_partial_order.{0} real real.linear_order)))
    a&#x27;
    a,
h₂ :
  @has_le.le.{0} real
    (@preorder.to_has_le.{0} real
       (@partial_order.to_preorder.{0} real (@linear_order.to_partial_order.{0} real real.linear_order)))
    b
    b&#x27;
⊢ @has_le.le.{0} nnreal nnreal.has_le
    (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a))
    (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b&#x27; a&#x27;))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 61  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 62  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 63  lemma lebesgue_length_eq_infi_Icc (s) : lebesgue_length s = ⨅a b (h : s ⊆ Icc a b), of_real (b - a) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='blue'><a title='measure_theory.lebesgue_length'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='lattice.infi'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_subset.subset'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.Icc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='lattice.infi'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='nnreal.of_real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_sub.sub'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='red'><a title='{&#x27;line&#x27;: 17, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/complete_lattice.lean&#x27;, &#x27;line&#x27;: 28, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 327, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/intervals/basic.lean&#x27;, &#x27;line&#x27;: 49, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/complete_lattice.lean&#x27;, &#x27;line&#x27;: 28, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/nnreal.lean&#x27;, &#x27;line&#x27;: 32, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 315, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='green'><a title='set.{0} real → ennreal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) s (@set.Ico.{0} real real.preorder a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α ι : Type} [_inst_1 : lattice.has_Inf.{0} α], (ι → α) → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='set.{0} real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_subset.{0} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : preorder.{u} α], α → α → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α ι : Type} [_inst_1 : lattice.has_Inf.{0} α], (ι → α) → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real → nnreal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_sub.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='orange'><a title='Length of an interval. This is the largest monotonic function which correctly
 measures all intervals.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='Indexed infimum'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='Left-closed right-closed interval'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='Indexed infimum'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 64  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} real
⊢ @eq.{1} ennreal (measure_theory.lebesgue_length s)
    (@lattice.infi.{0 1} ennreal real
       (@lattice.conditionally_complete_lattice.to_has_Inf.{0} ennreal
          (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
             (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
       (λ (a : real),
          @lattice.infi.{0 1} ennreal real
            (@lattice.conditionally_complete_lattice.to_has_Inf.{0} ennreal
               (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
                  (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
            (λ (b : real),
               @lattice.infi.{0 0} ennreal
                 (@has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) s
                    (@set.Icc.{0} real real.preorder a b))
                 (@lattice.conditionally_complete_lattice.to_has_Inf.{0} ennreal
                    (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
                       (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal
                          ennreal.complete_linear_order_1)))
                 (λ
                  (h :
                    @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) s
                      (@set.Icc.{0} real real.preorder a b)),
                    @coe.{1 1} nnreal ennreal
                      (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
                      (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 65    refine le_antisymm _</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='le_antisymm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 45, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : partial_order.{0} α] {a b : α}, @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α _inst_1)) a b → @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α _inst_1)) b a → @eq.{1} α a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} real
⊢ @eq.{1} ennreal (measure_theory.lebesgue_length s)
    (@lattice.infi.{0 1} ennreal real
       (@lattice.conditionally_complete_lattice.to_has_Inf.{0} ennreal
          (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
             (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
       (λ (a : real),
          @lattice.infi.{0 1} ennreal real
            (@lattice.conditionally_complete_lattice.to_has_Inf.{0} ennreal
               (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
                  (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
            (λ (b : real),
               @lattice.infi.{0 0} ennreal
                 (@has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) s
                    (@set.Icc.{0} real real.preorder a b))
                 (@lattice.conditionally_complete_lattice.to_has_Inf.{0} ennreal
                    (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
                       (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal
                          ennreal.complete_linear_order_1)))
                 (λ
                  (h :
                    @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) s
                      (@set.Icc.{0} real real.preorder a b)),
                    @coe.{1 1} nnreal ennreal
                      (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
                      (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 66      (infi_le_infi $ λ a, infi_le_infi $ λ b, infi_le_infi2 $ λ h,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='blue'><a title='lattice.infi_le_infi'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='lattice.infi_le_infi2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/complete_lattice.lean&#x27;, &#x27;line&#x27;: 303, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/complete_lattice.lean&#x27;, &#x27;line&#x27;: 306, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α ι : Type} [_inst_1 : lattice.complete_lattice.{0} α] {s t : ι → α}, (∀ (i : ι), @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@lattice.order_bot.to_partial_order.{0} α (@lattice.bounded_lattice.to_order_bot.{0} α (@lattice.complete_lattice.to_bounded_lattice.{0} α _inst_1))))) (s i) (t i)) → @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@lattice.order_bot.to_partial_order.{0} α (@lattice.bounded_lattice.to_order_bot.{0} α (@lattice.complete_lattice.to_bounded_lattice.{0} α _inst_1))))) (@lattice.infi.{0 1} α ι (@lattice.complete_lattice.to_has_Inf.{0} α _inst_1) s) (@lattice.infi.{0 1} α ι (@lattice.complete_lattice.to_has_Inf.{0} α _inst_1) t)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} {ι ι₂ : Prop} [_inst_1 : lattice.complete_lattice.{0} α] {s : ι → α} {t : ι₂ → α}, (∀ (j : ι₂), @Exists.{0} ι (λ (i : ι), @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@lattice.order_bot.to_partial_order.{0} α (@lattice.bounded_lattice.to_order_bot.{0} α (@lattice.complete_lattice.to_bounded_lattice.{0} α _inst_1))))) (s i) (t j))) → @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@lattice.order_bot.to_partial_order.{0} α (@lattice.bounded_lattice.to_order_bot.{0} α (@lattice.complete_lattice.to_bounded_lattice.{0} α _inst_1))))) (@lattice.infi.{0 0} α ι (@lattice.complete_lattice.to_has_Inf.{0} α _inst_1) s) (@lattice.infi.{0 0} α ι₂ (@lattice.complete_lattice.to_has_Inf.{0} α _inst_1) t)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} real
⊢ @eq.{1} ennreal (measure_theory.lebesgue_length s)
    (@lattice.infi.{0 1} ennreal real
       (@lattice.conditionally_complete_lattice.to_has_Inf.{0} ennreal
          (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
             (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
       (λ (a : real),
          @lattice.infi.{0 1} ennreal real
            (@lattice.conditionally_complete_lattice.to_has_Inf.{0} ennreal
               (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
                  (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
            (λ (b : real),
               @lattice.infi.{0 0} ennreal
                 (@has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) s
                    (@set.Icc.{0} real real.preorder a b))
                 (@lattice.conditionally_complete_lattice.to_has_Inf.{0} ennreal
                    (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
                       (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal
                          ennreal.complete_linear_order_1)))
                 (λ
                  (h :
                    @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) s
                      (@set.Icc.{0} real real.preorder a b)),
                    @coe.{1 1} nnreal ennreal
                      (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
                      (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 67        ⟨subset.trans h Ico_subset_Icc_self, le_refl _⟩),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='set.subset.trans'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='set.Ico_subset_Icc_self'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='le_refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 94, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/intervals/basic.lean&#x27;, &#x27;line&#x27;: 188, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type} {a b c : set.{0} α}, @has_subset.subset.{0} (set.{0} α) (@set.has_subset.{0} α) a b → @has_subset.subset.{0} (set.{0} α) (@set.has_subset.{0} α) b c → @has_subset.subset.{0} (set.{0} α) (@set.has_subset.{0} α) a c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : preorder.{0} α] {a b : α}, @has_subset.subset.{0} (set.{0} α) (@set.has_subset.{0} α) (@set.Ico.{0} α _inst_1 a b) (@set.Icc.{0} α _inst_1 a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : preorder.{0} α] (a : α), @has_le.le.{0} α (@preorder.to_has_le.{0} α _inst_1) a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} real
⊢ @eq.{1} ennreal (measure_theory.lebesgue_length s)
    (@lattice.infi.{0 1} ennreal real
       (@lattice.conditionally_complete_lattice.to_has_Inf.{0} ennreal
          (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
             (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
       (λ (a : real),
          @lattice.infi.{0 1} ennreal real
            (@lattice.conditionally_complete_lattice.to_has_Inf.{0} ennreal
               (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
                  (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
            (λ (b : real),
               @lattice.infi.{0 0} ennreal
                 (@has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) s
                    (@set.Icc.{0} real real.preorder a b))
                 (@lattice.conditionally_complete_lattice.to_has_Inf.{0} ennreal
                    (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
                       (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal
                          ennreal.complete_linear_order_1)))
                 (λ
                  (h :
                    @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) s
                      (@set.Icc.{0} real real.preorder a b)),
                    @coe.{1 1} nnreal ennreal
                      (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
                      (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} real
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (measure_theory.lebesgue_length s)
    (@lattice.infi.{0 1} ennreal real
       (@lattice.conditionally_complete_lattice.to_has_Inf.{0} ennreal
          (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
             (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
       (λ (a : real),
          @lattice.infi.{0 1} ennreal real
            (@lattice.conditionally_complete_lattice.to_has_Inf.{0} ennreal
               (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
                  (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
            (λ (b : real),
               @lattice.infi.{0 0} ennreal
                 (@has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) s
                    (@set.Icc.{0} real real.preorder a b))
                 (@lattice.conditionally_complete_lattice.to_has_Inf.{0} ennreal
                    (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
                       (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal
                          ennreal.complete_linear_order_1)))
                 (λ
                  (h :
                    @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) s
                      (@set.Icc.{0} real real.preorder a b)),
                    @coe.{1 1} nnreal ennreal
                      (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
                      (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 68    refine le_infi (λ a, le_infi $ λ b, le_infi $ λ h, _),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='blue'><a title='lattice.le_infi'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/complete_lattice.lean&#x27;, &#x27;line&#x27;: 300, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α ι : Type} [_inst_1 : lattice.complete_lattice.{0} α] {s : ι → α} {a : α}, (∀ (i : ι), @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@lattice.order_bot.to_partial_order.{0} α (@lattice.bounded_lattice.to_order_bot.{0} α (@lattice.complete_lattice.to_bounded_lattice.{0} α _inst_1))))) a (s i)) → @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@lattice.order_bot.to_partial_order.{0} α (@lattice.bounded_lattice.to_order_bot.{0} α (@lattice.complete_lattice.to_bounded_lattice.{0} α _inst_1))))) a (@lattice.infi.{0 1} α ι (@lattice.complete_lattice.to_has_Inf.{0} α _inst_1) s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} real
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (measure_theory.lebesgue_length s)
    (@lattice.infi.{0 1} ennreal real
       (@lattice.conditionally_complete_lattice.to_has_Inf.{0} ennreal
          (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
             (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
       (λ (a : real),
          @lattice.infi.{0 1} ennreal real
            (@lattice.conditionally_complete_lattice.to_has_Inf.{0} ennreal
               (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
                  (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
            (λ (b : real),
               @lattice.infi.{0 0} ennreal
                 (@has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) s
                    (@set.Icc.{0} real real.preorder a b))
                 (@lattice.conditionally_complete_lattice.to_has_Inf.{0} ennreal
                    (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
                       (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal
                          ennreal.complete_linear_order_1)))
                 (λ
                  (h :
                    @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) s
                      (@set.Icc.{0} real real.preorder a b)),
                    @coe.{1 1} nnreal ennreal
                      (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
                      (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} real,
a b : real,
h : @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) s (@set.Icc.{0} real real.preorder a b)
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@lattice.order_bot.to_partial_order.{0} ennreal
             (@lattice.bounded_lattice.to_order_bot.{0} ennreal
                (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                   (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))))))
    (measure_theory.lebesgue_length s)
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 69    refine ennreal.le_of_forall_epsilon_le (λ ε ε0 _, _),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='ennreal.le_of_forall_epsilon_le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/ennreal.lean&#x27;, &#x27;line&#x27;: 259, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : ennreal}, (∀ (ε : nnreal), @has_lt.lt.{0} nnreal (@preorder.to_has_lt.{0} nnreal (@partial_order.to_preorder.{0} nnreal (@ordered_comm_monoid.to_partial_order.{0} nnreal (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring)))))) (@has_zero.zero.{0} nnreal nnreal.has_zero) ε → @has_lt.lt.{0} ennreal (@preorder.to_has_lt.{0} ennreal (@partial_order.to_preorder.{0} ennreal (@ordered_comm_monoid.to_partial_order.{0} ennreal (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal ennreal.canonically_ordered_comm_semiring_1))))) b (@lattice.has_top.top.{0} ennreal (@lattice.order_top.to_has_top.{0} ennreal (@lattice.bounded_lattice.to_order_top.{0} ennreal (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))))) → @has_le.le.{0} ennreal (@preorder.to_has_le.{0} ennreal (@partial_order.to_preorder.{0} ennreal (@ordered_comm_monoid.to_partial_order.{0} ennreal (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal ennreal.canonically_ordered_comm_semiring_1))))) a (@has_add.add.{0} ennreal (@distrib.to_has_add.{0} ennreal (@semiring.to_distrib.{0} ennreal (@comm_semiring.to_semiring.{0} ennreal (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal ennreal.canonically_ordered_comm_semiring_1)))) b (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe)) ε))) → @has_le.le.{0} ennreal (@preorder.to_has_le.{0} ennreal (@partial_order.to_preorder.{0} ennreal (@ordered_comm_monoid.to_partial_order.{0} ennreal (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal ennreal.canonically_ordered_comm_semiring_1))))) a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} real,
a b : real,
h : @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) s (@set.Icc.{0} real real.preorder a b)
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@lattice.order_bot.to_partial_order.{0} ennreal
             (@lattice.bounded_lattice.to_order_bot.{0} ennreal
                (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                   (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))))))
    (measure_theory.lebesgue_length s)
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} real,
a b : real,
h : @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) s (@set.Icc.{0} real real.preorder a b),
ε : nnreal,
ε0 :
  @has_lt.lt.{0} nnreal
    (@preorder.to_has_lt.{0} nnreal
       (@partial_order.to_preorder.{0} nnreal
          (@ordered_comm_monoid.to_partial_order.{0} nnreal
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                   (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
    (@has_zero.zero.{0} nnreal nnreal.has_zero)
    ε,
_x :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
    (@lattice.has_top.top.{0} ennreal
       (@lattice.order_top.to_has_top.{0} ennreal
          (@lattice.bounded_lattice.to_order_top.{0} ennreal
             (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))))
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (measure_theory.lebesgue_length s)
    (@has_add.add.{0} ennreal
       (@distrib.to_has_add.{0} ennreal
          (@semiring.to_distrib.{0} ennreal
             (@comm_semiring.to_semiring.{0} ennreal
                (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1))))
       (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
          (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
       (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
          ε))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 70    refine infi_le_of_le a (infi_le_of_le (b + ε) $ infi_le_of_le</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ε'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='lattice.infi_le_of_le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/complete_lattice.lean&#x27;, &#x27;line&#x27;: 297, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} [c : has_add.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nnreal'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α ι : Type} [_inst_1 : lattice.complete_lattice.{0} α] {s : ι → α} {a : α} (i : ι), @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@lattice.order_bot.to_partial_order.{0} α (@lattice.bounded_lattice.to_order_bot.{0} α (@lattice.complete_lattice.to_bounded_lattice.{0} α _inst_1))))) (s i) a → @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@lattice.order_bot.to_partial_order.{0} α (@lattice.bounded_lattice.to_order_bot.{0} α (@lattice.complete_lattice.to_bounded_lattice.{0} α _inst_1))))) (@lattice.infi.{0 1} α ι (@lattice.complete_lattice.to_has_Inf.{0} α _inst_1) s) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} real,
a b : real,
h : @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) s (@set.Icc.{0} real real.preorder a b),
ε : nnreal,
ε0 :
  @has_lt.lt.{0} nnreal
    (@preorder.to_has_lt.{0} nnreal
       (@partial_order.to_preorder.{0} nnreal
          (@ordered_comm_monoid.to_partial_order.{0} nnreal
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                   (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
    (@has_zero.zero.{0} nnreal nnreal.has_zero)
    ε,
_x :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
    (@lattice.has_top.top.{0} ennreal
       (@lattice.order_top.to_has_top.{0} ennreal
          (@lattice.bounded_lattice.to_order_top.{0} ennreal
             (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))))
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (measure_theory.lebesgue_length s)
    (@has_add.add.{0} ennreal
       (@distrib.to_has_add.{0} ennreal
          (@semiring.to_distrib.{0} ennreal
             (@comm_semiring.to_semiring.{0} ennreal
                (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1))))
       (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
          (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
       (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
          ε))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 71      (subset.trans h $ Icc_subset_Ico_right $ (lt_add_iff_pos_right _).2 ε0) _),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='set.subset.trans'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='set.Icc_subset_Ico_right'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='lt_add_iff_pos_right'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='ε0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 94, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/intervals/basic.lean&#x27;, &#x27;line&#x27;: 181, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/ordered_group.lean&#x27;, &#x27;line&#x27;: 428, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type} {a b c : set.{0} α}, @has_subset.subset.{0} (set.{0} α) (@set.has_subset.{0} α) a b → @has_subset.subset.{0} (set.{0} α) (@set.has_subset.{0} α) b c → @has_subset.subset.{0} (set.{0} α) (@set.has_subset.{0} α) a c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) s (@set.Icc.{0} real real.preorder a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : preorder.{0} α] {a b₁ b₂ : α}, @has_lt.lt.{0} α (@preorder.to_has_lt.{0} α _inst_1) b₁ b₂ → @has_subset.subset.{0} (set.{0} α) (@set.has_subset.{0} α) (@set.Icc.{0} α _inst_1 a b₁) (@set.Ico.{0} α _inst_1 a b₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type} [_inst_1 : ordered_cancel_comm_monoid.{0} α] (a : α) {b : α}, iff (@has_lt.lt.{0} α (@preorder.to_has_lt.{0} α (@partial_order.to_preorder.{0} α (@ordered_comm_monoid.to_partial_order.{0} α (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} α _inst_1)))) a (@has_add.add.{0} α (@add_semigroup.to_has_add.{0} α (@add_monoid.to_add_semigroup.{0} α (@add_comm_monoid.to_add_monoid.{0} α (@ordered_comm_monoid.to_add_comm_monoid.{0} α (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} α _inst_1))))) a b)) (@has_lt.lt.{0} α (@preorder.to_has_lt.{0} α (@partial_order.to_preorder.{0} α (@ordered_comm_monoid.to_partial_order.{0} α (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} α _inst_1)))) (@has_zero.zero.{0} α (@add_monoid.to_has_zero.{0} α (@add_comm_monoid.to_add_monoid.{0} α (@ordered_comm_monoid.to_add_comm_monoid.{0} α (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} α _inst_1))))) b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_lt.lt.{0} nnreal (@preorder.to_has_lt.{0} nnreal (@partial_order.to_preorder.{0} nnreal (@ordered_comm_monoid.to_partial_order.{0} nnreal (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring)))))) (@has_zero.zero.{0} nnreal nnreal.has_zero) ε'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} real,
a b : real,
h : @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) s (@set.Icc.{0} real real.preorder a b),
ε : nnreal,
ε0 :
  @has_lt.lt.{0} nnreal
    (@preorder.to_has_lt.{0} nnreal
       (@partial_order.to_preorder.{0} nnreal
          (@ordered_comm_monoid.to_partial_order.{0} nnreal
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                   (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
    (@has_zero.zero.{0} nnreal nnreal.has_zero)
    ε,
_x :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
    (@lattice.has_top.top.{0} ennreal
       (@lattice.order_top.to_has_top.{0} ennreal
          (@lattice.bounded_lattice.to_order_top.{0} ennreal
             (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))))
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (measure_theory.lebesgue_length s)
    (@has_add.add.{0} ennreal
       (@distrib.to_has_add.{0} ennreal
          (@semiring.to_distrib.{0} ennreal
             (@comm_semiring.to_semiring.{0} ennreal
                (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1))))
       (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
          (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
       (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
          ε))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} real,
a b : real,
h : @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) s (@set.Icc.{0} real real.preorder a b),
ε : nnreal,
ε0 :
  @has_lt.lt.{0} nnreal
    (@preorder.to_has_lt.{0} nnreal
       (@partial_order.to_preorder.{0} nnreal
          (@ordered_comm_monoid.to_partial_order.{0} nnreal
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                   (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
    (@has_zero.zero.{0} nnreal nnreal.has_zero)
    ε,
_x :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
    (@lattice.has_top.top.{0} ennreal
       (@lattice.order_top.to_has_top.{0} ennreal
          (@lattice.bounded_lattice.to_order_top.{0} ennreal
             (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))))
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@lattice.order_bot.to_partial_order.{0} ennreal
             (@lattice.bounded_lattice.to_order_bot.{0} ennreal
                (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                   (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real
          (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group)
             (@has_add.add.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring)) b
                (@coe.{1 1} nnreal real (@coe_to_lift.{1 1} nnreal real (@coe_base.{1 1} nnreal real nnreal.has_coe))
                   ε))
             a)))
    (@has_add.add.{0} ennreal
       (@distrib.to_has_add.{0} ennreal
          (@semiring.to_distrib.{0} ennreal
             (@comm_semiring.to_semiring.{0} ennreal
                (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1))))
       (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
          (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
       (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
          ε))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 72    rw [sub_eq_add_neg, add_right_comm, ←ennreal.coe_add, ennreal.coe_le_coe],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='sub_eq_add_neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='add_right_comm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='ennreal.coe_add'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ennreal.coe_le_coe'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 324, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 226, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/ennreal.lean&#x27;, &#x27;line&#x27;: 128, &#x27;column&#x27;: 25}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/ennreal.lean&#x27;, &#x27;line&#x27;: 117, &#x27;column&#x27;: 25}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : add_group.{0} α] (a b : α), @eq.{1} α (@has_sub.sub.{0} α (@add_group_has_sub.{0} α _inst_1) a b) (@has_add.add.{0} α (@add_semigroup.to_has_add.{0} α (@add_monoid.to_add_semigroup.{0} α (@add_group.to_add_monoid.{0} α _inst_1))) a (@has_neg.neg.{0} α (@add_group.to_has_neg.{0} α _inst_1) b))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : add_comm_semigroup.{0} α] (a b c : α), @eq.{1} α (@has_add.add.{0} α (@add_semigroup.to_has_add.{0} α (@add_comm_semigroup.to_add_semigroup.{0} α _inst_1)) (@has_add.add.{0} α (@add_semigroup.to_has_add.{0} α (@add_comm_semigroup.to_add_semigroup.{0} α _inst_1)) a b) c) (@has_add.add.{0} α (@add_semigroup.to_has_add.{0} α (@add_comm_semigroup.to_add_semigroup.{0} α _inst_1)) (@has_add.add.{0} α (@add_semigroup.to_has_add.{0} α (@add_comm_semigroup.to_add_semigroup.{0} α _inst_1)) a c) b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {r p : nnreal}, @eq.{1} ennreal (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe)) (@has_add.add.{0} nnreal nnreal.has_add r p)) (@has_add.add.{0} ennreal (@distrib.to_has_add.{0} ennreal (@semiring.to_distrib.{0} ennreal (@comm_semiring.to_semiring.{0} ennreal (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal ennreal.canonically_ordered_comm_semiring_1)))) (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe)) r) (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe)) p))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {r q : nnreal}, iff (@has_le.le.{0} ennreal (@preorder.to_has_le.{0} ennreal (@partial_order.to_preorder.{0} ennreal (@ordered_comm_monoid.to_partial_order.{0} ennreal (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal ennreal.canonically_ordered_comm_semiring_1))))) (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe)) r) (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe)) q)) (@has_le.le.{0} nnreal nnreal.has_le r q)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} real,
a b : real,
h : @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) s (@set.Icc.{0} real real.preorder a b),
ε : nnreal,
ε0 :
  @has_lt.lt.{0} nnreal
    (@preorder.to_has_lt.{0} nnreal
       (@partial_order.to_preorder.{0} nnreal
          (@ordered_comm_monoid.to_partial_order.{0} nnreal
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                   (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
    (@has_zero.zero.{0} nnreal nnreal.has_zero)
    ε,
_x :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
    (@lattice.has_top.top.{0} ennreal
       (@lattice.order_top.to_has_top.{0} ennreal
          (@lattice.bounded_lattice.to_order_top.{0} ennreal
             (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))))
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@lattice.order_bot.to_partial_order.{0} ennreal
             (@lattice.bounded_lattice.to_order_bot.{0} ennreal
                (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                   (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real
          (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group)
             (@has_add.add.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring)) b
                (@coe.{1 1} nnreal real (@coe_to_lift.{1 1} nnreal real (@coe_base.{1 1} nnreal real nnreal.has_coe))
                   ε))
             a)))
    (@has_add.add.{0} ennreal
       (@distrib.to_has_add.{0} ennreal
          (@semiring.to_distrib.{0} ennreal
             (@comm_semiring.to_semiring.{0} ennreal
                (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1))))
       (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
          (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
       (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
          ε))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} real,
a b : real,
h : @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) s (@set.Icc.{0} real real.preorder a b),
ε : nnreal,
ε0 :
  @has_lt.lt.{0} nnreal
    (@preorder.to_has_lt.{0} nnreal
       (@partial_order.to_preorder.{0} nnreal
          (@ordered_comm_monoid.to_partial_order.{0} nnreal
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                   (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
    (@has_zero.zero.{0} nnreal nnreal.has_zero)
    ε,
_x :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
    (@lattice.has_top.top.{0} ennreal
       (@lattice.order_top.to_has_top.{0} ennreal
          (@lattice.bounded_lattice.to_order_top.{0} ennreal
             (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))))
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@lattice.order_bot.to_partial_order.{0} ennreal
             (@lattice.bounded_lattice.to_order_bot.{0} ennreal
                (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                   (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real
          (@has_add.add.{0} real
             (@add_semigroup.to_has_add.{0} real
                (@add_monoid.to_add_semigroup.{0} real (@add_group.to_add_monoid.{0} real real.add_group)))
             (@has_add.add.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring)) b
                (@coe.{1 1} nnreal real (@coe_to_lift.{1 1} nnreal real (@coe_base.{1 1} nnreal real nnreal.has_coe))
                   ε))
             (@has_neg.neg.{0} real (@add_group.to_has_neg.{0} real real.add_group) a))))
    (@has_add.add.{0} ennreal
       (@distrib.to_has_add.{0} ennreal
          (@semiring.to_distrib.{0} ennreal
             (@comm_semiring.to_semiring.{0} ennreal
                (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1))))
       (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
          (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
       (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
          ε))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} real,
a b : real,
h : @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) s (@set.Icc.{0} real real.preorder a b),
ε : nnreal,
ε0 :
  @has_lt.lt.{0} nnreal
    (@preorder.to_has_lt.{0} nnreal
       (@partial_order.to_preorder.{0} nnreal
          (@ordered_comm_monoid.to_partial_order.{0} nnreal
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                   (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
    (@has_zero.zero.{0} nnreal nnreal.has_zero)
    ε,
_x :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
    (@lattice.has_top.top.{0} ennreal
       (@lattice.order_top.to_has_top.{0} ennreal
          (@lattice.bounded_lattice.to_order_top.{0} ennreal
             (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))))
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@lattice.order_bot.to_partial_order.{0} ennreal
             (@lattice.bounded_lattice.to_order_bot.{0} ennreal
                (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                   (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real
          (@has_add.add.{0} real
             (@add_semigroup.to_has_add.{0} real
                (@add_comm_semigroup.to_add_semigroup.{0} real real.add_comm_semigroup))
             (@has_add.add.{0} real
                (@add_semigroup.to_has_add.{0} real
                   (@add_comm_semigroup.to_add_semigroup.{0} real real.add_comm_semigroup))
                b
                (@has_neg.neg.{0} real (@add_group.to_has_neg.{0} real real.add_group) a))
             (@coe.{1 1} nnreal real (@coe_to_lift.{1 1} nnreal real (@coe_base.{1 1} nnreal real nnreal.has_coe))
                ε))))
    (@has_add.add.{0} ennreal
       (@distrib.to_has_add.{0} ennreal
          (@semiring.to_distrib.{0} ennreal
             (@comm_semiring.to_semiring.{0} ennreal
                (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1))))
       (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
          (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
       (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
          ε))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} real,
a b : real,
h : @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) s (@set.Icc.{0} real real.preorder a b),
ε : nnreal,
ε0 :
  @has_lt.lt.{0} nnreal
    (@preorder.to_has_lt.{0} nnreal
       (@partial_order.to_preorder.{0} nnreal
          (@ordered_comm_monoid.to_partial_order.{0} nnreal
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                   (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
    (@has_zero.zero.{0} nnreal nnreal.has_zero)
    ε,
_x :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
    (@lattice.has_top.top.{0} ennreal
       (@lattice.order_top.to_has_top.{0} ennreal
          (@lattice.bounded_lattice.to_order_top.{0} ennreal
             (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))))
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@lattice.order_bot.to_partial_order.{0} ennreal
             (@lattice.bounded_lattice.to_order_bot.{0} ennreal
                (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                   (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real
          (@has_add.add.{0} real
             (@add_semigroup.to_has_add.{0} real
                (@add_comm_semigroup.to_add_semigroup.{0} real real.add_comm_semigroup))
             (@has_add.add.{0} real
                (@add_semigroup.to_has_add.{0} real
                   (@add_comm_semigroup.to_add_semigroup.{0} real real.add_comm_semigroup))
                b
                (@has_neg.neg.{0} real (@add_group.to_has_neg.{0} real real.add_group) a))
             (@coe.{1 1} nnreal real (@coe_to_lift.{1 1} nnreal real (@coe_base.{1 1} nnreal real nnreal.has_coe))
                ε))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (@has_add.add.{0} nnreal nnreal.has_add
          (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a))
          ε))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} real,
a b : real,
h : @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) s (@set.Icc.{0} real real.preorder a b),
ε : nnreal,
ε0 :
  @has_lt.lt.{0} nnreal
    (@preorder.to_has_lt.{0} nnreal
       (@partial_order.to_preorder.{0} nnreal
          (@ordered_comm_monoid.to_partial_order.{0} nnreal
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                   (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
    (@has_zero.zero.{0} nnreal nnreal.has_zero)
    ε,
_x :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
    (@lattice.has_top.top.{0} ennreal
       (@lattice.order_top.to_has_top.{0} ennreal
          (@lattice.bounded_lattice.to_order_top.{0} ennreal
             (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))))
⊢ @has_le.le.{0} nnreal nnreal.has_le
    (nnreal.of_real
       (@has_add.add.{0} real
          (@add_semigroup.to_has_add.{0} real (@add_comm_semigroup.to_add_semigroup.{0} real real.add_comm_semigroup))
          (@has_add.add.{0} real
             (@add_semigroup.to_has_add.{0} real
                (@add_comm_semigroup.to_add_semigroup.{0} real real.add_comm_semigroup))
             b
             (@has_neg.neg.{0} real (@add_group.to_has_neg.{0} real real.add_group) a))
          (@coe.{1 1} nnreal real (@coe_to_lift.{1 1} nnreal real (@coe_base.{1 1} nnreal real nnreal.has_coe)) ε)))
    (@has_add.add.{0} nnreal nnreal.has_add
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a))
       ε)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 73    apply le_trans nnreal.of_real_add_le,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='le_trans'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='nnreal.of_real_add_le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 33, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/nnreal.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : preorder.{0} α] {a b c : α}, @has_le.le.{0} α (@preorder.to_has_le.{0} α _inst_1) a b → @has_le.le.{0} α (@preorder.to_has_le.{0} α _inst_1) b c → @has_le.le.{0} α (@preorder.to_has_le.{0} α _inst_1) a c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {r p : real}, @has_le.le.{0} nnreal nnreal.has_le (nnreal.of_real (@has_add.add.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring)) r p)) (@has_add.add.{0} nnreal nnreal.has_add (nnreal.of_real r) (nnreal.of_real p))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} real,
a b : real,
h : @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) s (@set.Icc.{0} real real.preorder a b),
ε : nnreal,
ε0 :
  @has_lt.lt.{0} nnreal
    (@preorder.to_has_lt.{0} nnreal
       (@partial_order.to_preorder.{0} nnreal
          (@ordered_comm_monoid.to_partial_order.{0} nnreal
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                   (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
    (@has_zero.zero.{0} nnreal nnreal.has_zero)
    ε,
_x :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
    (@lattice.has_top.top.{0} ennreal
       (@lattice.order_top.to_has_top.{0} ennreal
          (@lattice.bounded_lattice.to_order_top.{0} ennreal
             (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))))
⊢ @has_le.le.{0} nnreal nnreal.has_le
    (nnreal.of_real
       (@has_add.add.{0} real
          (@add_semigroup.to_has_add.{0} real (@add_comm_semigroup.to_add_semigroup.{0} real real.add_comm_semigroup))
          (@has_add.add.{0} real
             (@add_semigroup.to_has_add.{0} real
                (@add_comm_semigroup.to_add_semigroup.{0} real real.add_comm_semigroup))
             b
             (@has_neg.neg.{0} real (@add_group.to_has_neg.{0} real real.add_group) a))
          (@coe.{1 1} nnreal real (@coe_to_lift.{1 1} nnreal real (@coe_base.{1 1} nnreal real nnreal.has_coe)) ε)))
    (@has_add.add.{0} nnreal nnreal.has_add
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a))
       ε)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} real,
a b : real,
h : @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) s (@set.Icc.{0} real real.preorder a b),
ε : nnreal,
ε0 :
  @has_lt.lt.{0} nnreal
    (@preorder.to_has_lt.{0} nnreal
       (@partial_order.to_preorder.{0} nnreal
          (@ordered_comm_monoid.to_partial_order.{0} nnreal
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                   (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
    (@has_zero.zero.{0} nnreal nnreal.has_zero)
    ε,
_x :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
    (@lattice.has_top.top.{0} ennreal
       (@lattice.order_top.to_has_top.{0} ennreal
          (@lattice.bounded_lattice.to_order_top.{0} ennreal
             (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))))
⊢ @has_le.le.{0} nnreal
    (@preorder.to_has_le.{0} nnreal
       (@partial_order.to_preorder.{0} nnreal
          (@ordered_comm_monoid.to_partial_order.{0} nnreal
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                   (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
    (@has_add.add.{0} nnreal nnreal.has_add
       (nnreal.of_real
          (@has_add.add.{0} real
             (@add_semigroup.to_has_add.{0} real
                (@add_comm_semigroup.to_add_semigroup.{0} real real.add_comm_semigroup))
             b
             (@has_neg.neg.{0} real (@add_group.to_has_neg.{0} real real.add_group) a)))
       (nnreal.of_real
          (@coe.{1 1} nnreal real (@coe_to_lift.{1 1} nnreal real (@coe_base.{1 1} nnreal real nnreal.has_coe)) ε)))
    (@has_add.add.{0} nnreal nnreal.has_add
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a))
       ε)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 74    simp</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} real,
a b : real,
h : @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) s (@set.Icc.{0} real real.preorder a b),
ε : nnreal,
ε0 :
  @has_lt.lt.{0} nnreal
    (@preorder.to_has_lt.{0} nnreal
       (@partial_order.to_preorder.{0} nnreal
          (@ordered_comm_monoid.to_partial_order.{0} nnreal
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                   (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
    (@has_zero.zero.{0} nnreal nnreal.has_zero)
    ε,
_x :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
    (@lattice.has_top.top.{0} ennreal
       (@lattice.order_top.to_has_top.{0} ennreal
          (@lattice.bounded_lattice.to_order_top.{0} ennreal
             (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))))
⊢ @has_le.le.{0} nnreal
    (@preorder.to_has_le.{0} nnreal
       (@partial_order.to_preorder.{0} nnreal
          (@ordered_comm_monoid.to_partial_order.{0} nnreal
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                   (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
    (@has_add.add.{0} nnreal nnreal.has_add
       (nnreal.of_real
          (@has_add.add.{0} real
             (@add_semigroup.to_has_add.{0} real
                (@add_comm_semigroup.to_add_semigroup.{0} real real.add_comm_semigroup))
             b
             (@has_neg.neg.{0} real (@add_group.to_has_neg.{0} real real.add_group) a)))
       (nnreal.of_real
          (@coe.{1 1} nnreal real (@coe_to_lift.{1 1} nnreal real (@coe_base.{1 1} nnreal real nnreal.has_coe)) ε)))
    (@has_add.add.{0} nnreal nnreal.has_add
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a))
       ε)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 75  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 76  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 77  @[simp] lemma lebesgue_length_Icc (a b : ℝ) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='blue'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/basic.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 78    lebesgue_length (Icc a b) = of_real (b - a) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='measure_theory.lebesgue_length'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.Icc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='nnreal.of_real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_sub.sub'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 17, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/intervals/basic.lean&#x27;, &#x27;line&#x27;: 49, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/nnreal.lean&#x27;, &#x27;line&#x27;: 32, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 315, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='set.{0} real → ennreal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [_inst_1 : preorder.{u} α], α → α → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real → nnreal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_sub.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Length of an interval. This is the largest monotonic function which correctly
 measures all intervals.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Left-closed right-closed interval'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 79  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a b : real
⊢ @eq.{1} ennreal (measure_theory.lebesgue_length (@set.Icc.{0} real real.preorder a b))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 80    rw ← lebesgue_length_Ico,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='measure_theory.lebesgue_length_Ico'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 22, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (a b : real), @eq.{1} ennreal (measure_theory.lebesgue_length (@set.Ico.{0} real real.preorder a b)) (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe)) (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a b : real
⊢ @eq.{1} ennreal (measure_theory.lebesgue_length (@set.Icc.{0} real real.preorder a b))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a b : real
⊢ @eq.{1} ennreal (measure_theory.lebesgue_length (@set.Icc.{0} real real.preorder a b))
    (measure_theory.lebesgue_length (@set.Ico.{0} real real.preorder a b))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 81    refine le_antisymm _ (lebesgue_length_mono Ico_subset_Icc_self),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='le_antisymm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='measure_theory.lebesgue_length_mono'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.Ico_subset_Icc_self'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 45, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 33, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/intervals/basic.lean&#x27;, &#x27;line&#x27;: 188, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : partial_order.{0} α] {a b : α}, @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α _inst_1)) a b → @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α _inst_1)) b a → @eq.{1} α a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {s₁ s₂ : set.{0} real}, @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) s₁ s₂ → @has_le.le.{0} ennreal (@preorder.to_has_le.{0} ennreal (@partial_order.to_preorder.{0} ennreal (@ordered_comm_monoid.to_partial_order.{0} ennreal (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal ennreal.canonically_ordered_comm_semiring_1))))) (measure_theory.lebesgue_length s₁) (measure_theory.lebesgue_length s₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : preorder.{0} α] {a b : α}, @has_subset.subset.{0} (set.{0} α) (@set.has_subset.{0} α) (@set.Ico.{0} α _inst_1 a b) (@set.Icc.{0} α _inst_1 a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a b : real
⊢ @eq.{1} ennreal (measure_theory.lebesgue_length (@set.Icc.{0} real real.preorder a b))
    (measure_theory.lebesgue_length (@set.Ico.{0} real real.preorder a b))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a b : real
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (measure_theory.lebesgue_length (@set.Icc.{0} real real.preorder a b))
    (measure_theory.lebesgue_length (@set.Ico.{0} real real.preorder a b))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 82    rw lebesgue_length_eq_infi_Icc (Icc a b),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='measure_theory.lebesgue_length_eq_infi_Icc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.Icc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 63, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/intervals/basic.lean&#x27;, &#x27;line&#x27;: 49, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (s : set.{0} real), @eq.{1} ennreal (measure_theory.lebesgue_length s) (@lattice.infi.{0 1} ennreal real (@lattice.conditionally_complete_lattice.to_has_Inf.{0} ennreal (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))) (λ (a : real), @lattice.infi.{0 1} ennreal real (@lattice.conditionally_complete_lattice.to_has_Inf.{0} ennreal (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))) (λ (b : real), @lattice.infi.{0 0} ennreal (@has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) s (@set.Icc.{0} real real.preorder a b)) (@lattice.conditionally_complete_lattice.to_has_Inf.{0} ennreal (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))) (λ (h : @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) s (@set.Icc.{0} real real.preorder a b)), @coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe)) (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [_inst_1 : preorder.{0} α], α → α → set.{0} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Left-closed right-closed interval'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a b : real
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (measure_theory.lebesgue_length (@set.Icc.{0} real real.preorder a b))
    (measure_theory.lebesgue_length (@set.Ico.{0} real real.preorder a b))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a b : real
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@lattice.infi.{0 1} ennreal real
       (@lattice.conditionally_complete_lattice.to_has_Inf.{0} ennreal
          (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
             (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
       (λ (a_1 : real),
          @lattice.infi.{0 1} ennreal real
            (@lattice.conditionally_complete_lattice.to_has_Inf.{0} ennreal
               (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
                  (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
            (λ (b_1 : real),
               @lattice.infi.{0 0} ennreal
                 (@has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
                    (@set.Icc.{0} real real.preorder a_1 b_1))
                 (@lattice.conditionally_complete_lattice.to_has_Inf.{0} ennreal
                    (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
                       (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal
                          ennreal.complete_linear_order_1)))
                 (λ
                  (h :
                    @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real)
                      (@set.Icc.{0} real real.preorder a b)
                      (@set.Icc.{0} real real.preorder a_1 b_1)),
                    @coe.{1 1} nnreal ennreal
                      (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
                      (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b_1 a_1))))))
    (measure_theory.lebesgue_length (@set.Ico.{0} real real.preorder a b))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 83    exact infi_le_of_le a (infi_le_of_le b $ infi_le_of_le (by refl) (by simp))</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='lattice.infi_le_of_le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/complete_lattice.lean&#x27;, &#x27;line&#x27;: 297, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1263, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α ι : Type} [_inst_1 : lattice.complete_lattice.{0} α] {s : ι → α} {a : α} (i : ι), @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@lattice.order_bot.to_partial_order.{0} α (@lattice.bounded_lattice.to_order_bot.{0} α (@lattice.complete_lattice.to_bounded_lattice.{0} α _inst_1))))) (s i) a → @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@lattice.order_bot.to_partial_order.{0} α (@lattice.bounded_lattice.to_order_bot.{0} α (@lattice.complete_lattice.to_bounded_lattice.{0} α _inst_1))))) (@lattice.infi.{0 1} α ι (@lattice.complete_lattice.to_has_Inf.{0} α _inst_1) s) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Shorter name for the tactic `reflexivity`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a b : real
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@lattice.infi.{0 1} ennreal real
       (@lattice.conditionally_complete_lattice.to_has_Inf.{0} ennreal
          (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
             (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
       (λ (a_1 : real),
          @lattice.infi.{0 1} ennreal real
            (@lattice.conditionally_complete_lattice.to_has_Inf.{0} ennreal
               (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
                  (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
            (λ (b_1 : real),
               @lattice.infi.{0 0} ennreal
                 (@has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
                    (@set.Icc.{0} real real.preorder a_1 b_1))
                 (@lattice.conditionally_complete_lattice.to_has_Inf.{0} ennreal
                    (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
                       (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal
                          ennreal.complete_linear_order_1)))
                 (λ
                  (h :
                    @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real)
                      (@set.Icc.{0} real real.preorder a b)
                      (@set.Icc.{0} real real.preorder a_1 b_1)),
                    @coe.{1 1} nnreal ennreal
                      (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
                      (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b_1 a_1))))))
    (measure_theory.lebesgue_length (@set.Ico.{0} real real.preorder a b))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a b : real
⊢ @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
    (@set.Icc.{0} real real.preorder a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a b : real
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@lattice.infi.{0 1} ennreal real
       (@lattice.conditionally_complete_lattice.to_has_Inf.{0} ennreal
          (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
             (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
       (λ (a_1 : real),
          @lattice.infi.{0 1} ennreal real
            (@lattice.conditionally_complete_lattice.to_has_Inf.{0} ennreal
               (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
                  (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
            (λ (b_1 : real),
               @lattice.infi.{0 0} ennreal
                 (@has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
                    (@set.Icc.{0} real real.preorder a_1 b_1))
                 (@lattice.conditionally_complete_lattice.to_has_Inf.{0} ennreal
                    (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
                       (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal
                          ennreal.complete_linear_order_1)))
                 (λ
                  (h :
                    @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real)
                      (@set.Icc.{0} real real.preorder a b)
                      (@set.Icc.{0} real real.preorder a_1 b_1)),
                    @coe.{1 1} nnreal ennreal
                      (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
                      (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b_1 a_1))))))
    (measure_theory.lebesgue_length (@set.Ico.{0} real real.preorder a b))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a b : real
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@lattice.order_bot.to_partial_order.{0} ennreal
             (@lattice.bounded_lattice.to_order_bot.{0} ennreal
                (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                   (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
    (measure_theory.lebesgue_length (@set.Ico.{0} real real.preorder a b))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a b : real
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@lattice.infi.{0 1} ennreal real
       (@lattice.conditionally_complete_lattice.to_has_Inf.{0} ennreal
          (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
             (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
       (λ (a_1 : real),
          @lattice.infi.{0 1} ennreal real
            (@lattice.conditionally_complete_lattice.to_has_Inf.{0} ennreal
               (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
                  (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
            (λ (b_1 : real),
               @lattice.infi.{0 0} ennreal
                 (@has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
                    (@set.Icc.{0} real real.preorder a_1 b_1))
                 (@lattice.conditionally_complete_lattice.to_has_Inf.{0} ennreal
                    (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
                       (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal
                          ennreal.complete_linear_order_1)))
                 (λ
                  (h :
                    @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real)
                      (@set.Icc.{0} real real.preorder a b)
                      (@set.Icc.{0} real real.preorder a_1 b_1)),
                    @coe.{1 1} nnreal ennreal
                      (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
                      (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b_1 a_1))))))
    (measure_theory.lebesgue_length (@set.Ico.{0} real real.preorder a b))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 84  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 85  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 86  /-- The Lebesgue outer measure, as an outer measure of ℝ. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 87  def lebesgue_outer : outer_measure ℝ :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='blue'><a title='measure_theory.outer_measure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/outer_measure.lean&#x27;, &#x27;line&#x27;: 20, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/basic.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 88  outer_measure.of_function lebesgue_length lebesgue_length_empty</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='measure_theory.outer_measure.of_function'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='measure_theory.lebesgue_length'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='measure_theory.lebesgue_length_empty'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/outer_measure.lean&#x27;, &#x27;line&#x27;: 268, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 17, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 19, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} (m : set.{u_1} α → ennreal), @eq.{1} ennreal (m (@has_emptyc.emptyc.{u_1} (set.{u_1} α) (@set.has_emptyc.{u_1} α))) (@has_zero.zero.{0} ennreal (@zero_ne_one_class.to_has_zero.{0} ennreal (@canonically_ordered_comm_semiring.to_zero_ne_one_class.{0} ennreal ennreal.canonically_ordered_comm_semiring_1))) → measure_theory.outer_measure.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{0} real → ennreal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@eq.{1} ennreal (measure_theory.lebesgue_length (@has_emptyc.emptyc.{0} (set.{0} real) (@set.has_emptyc.{0} real))) (@has_zero.zero.{0} ennreal (@zero_ne_one_class.to_has_zero.{0} ennreal (@canonically_ordered_comm_semiring.to_zero_ne_one_class.{0} ennreal ennreal.canonically_ordered_comm_semiring_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Given any function `m` assigning measures to sets satisying `m ∅ = 0`, there is
 a unique maximal outer measure `μ` satisfying `μ s ≤ m s` for all `s : set α`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Length of an interval. This is the largest monotonic function which correctly
 measures all intervals.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 89  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 90  lemma lebesgue_outer_le_length (s : set ℝ) : lebesgue_outer s ≤ lebesgue_length s :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='measure_theory.lebesgue_outer'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_le.le'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='measure_theory.lebesgue_length'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/basic.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 87, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 319, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 17, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='measure_theory.outer_measure.{0} real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{0} real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_le.{0} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{0} real → ennreal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{0} real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                             </code><font color='orange'><a title='The Lebesgue outer measure, as an outer measure of ℝ.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='Length of an interval. This is the largest monotonic function which correctly
 measures all intervals.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 91  outer_measure.of_function_le _ _ _</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='measure_theory.outer_measure.of_function_le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/outer_measure.lean&#x27;, &#x27;line&#x27;: 299, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} (m : set.{0} α → ennreal) (m_empty : @eq.{1} ennreal (m (@has_emptyc.emptyc.{0} (set.{0} α) (@set.has_emptyc.{0} α))) (@has_zero.zero.{0} ennreal (@zero_ne_one_class.to_has_zero.{0} ennreal (@canonically_ordered_comm_semiring.to_zero_ne_one_class.{0} ennreal ennreal.canonically_ordered_comm_semiring_1)))) (s : set.{0} α), @has_le.le.{0} ennreal (@preorder.to_has_le.{0} ennreal (@partial_order.to_preorder.{0} ennreal (@ordered_comm_monoid.to_partial_order.{0} ennreal (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal ennreal.canonically_ordered_comm_semiring_1))))) (@coe_fn.{1 1} (measure_theory.outer_measure.{0} α) (@measure_theory.outer_measure.has_coe_to_fun.{0} α) (@measure_theory.outer_measure.of_function.{0} α m m_empty) s) (m s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 92  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 93  lemma lebesgue_length_subadditive {a b : ℝ} {c d : ℕ → ℝ}</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='blue'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/basic.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 293, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/basic.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 94    (ss : Icc a b ⊆ ⋃i, Ioo (c i) (d i)) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='set.Icc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_subset.subset'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.Union'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='set.Union'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.Ioo'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/intervals/basic.lean&#x27;, &#x27;line&#x27;: 49, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 327, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/lattice.lean&#x27;, &#x27;line&#x27;: 72, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/lattice.lean&#x27;, &#x27;line&#x27;: 72, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/intervals/basic.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {α : Type u} [_inst_1 : preorder.{u} α], α → α → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='finset.{0} nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_subset.{0} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {β ι : Type}, (ι → set.{0} β) → set.{0} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {β ι : Type}, (ι → set.{0} β) → set.{0} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : preorder.{u} α], α → α → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='nat → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='Left-closed right-closed interval'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='Indexed union of a family of sets'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Indexed union of a family of sets'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Left-open right-open interval'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 95    (of_real (b - a) : ennreal) ≤ ∑ i, of_real (d i - c i) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='nnreal.of_real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_sub.sub'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='ennreal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_le.le'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='tsum'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='tsum'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='nnreal.of_real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='d'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_sub.sub'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/nnreal.lean&#x27;, &#x27;line&#x27;: 32, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 315, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/ennreal.lean&#x27;, &#x27;line&#x27;: 18, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 319, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/algebra/infinite_sum.lean&#x27;, &#x27;line&#x27;: 53, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/algebra/infinite_sum.lean&#x27;, &#x27;line&#x27;: 53, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/nnreal.lean&#x27;, &#x27;line&#x27;: 32, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 315, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='real → nnreal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_sub.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type} [c : has_le.{0} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α β : Type} [_inst_1 : add_comm_monoid.{0} α] [_inst_2 : topological_space.{0} α], (β → α) → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Type} [_inst_1 : add_comm_monoid.{0} α] [_inst_2 : topological_space.{0} α], (β → α) → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real → nnreal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='nat → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_sub.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='The extended nonnegative real numbers. This is usually denoted [0, ∞],
 and is relevant as the codomain of a measure.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`tsum f` is the sum of `f` it exists, or 0 otherwise'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`tsum f` is the sum of `f` it exists, or 0 otherwise'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 96  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a b : real,
c d : nat → real,
ss :
  @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
    (@set.Union.{0 1} real nat (λ (i : nat), @set.Ioo.{0} real real.preorder (c i) (d i)))
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat),
          @coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
            (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (d i) (c i)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 97    suffices : ∀ (s:finset ℕ) b</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='finset'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/finset.lean&#x27;, &#x27;line&#x27;: 17, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type → Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`finset α` is the type of finite sets of elements of `α`. It is implemented
 as a multiset (a list up to permutation) which has no duplicate elements.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a b : real,
c d : nat → real,
ss :
  @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
    (@set.Union.{0 1} real nat (λ (i : nat), @set.Ioo.{0} real real.preorder (c i) (d i)))
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat),
          @coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
            (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (d i) (c i)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 98      (cv : Icc a b ⊆ ⋃ i ∈ (↑s:set ℕ), Ioo (c i) (d i)),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='set.Icc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='has_subset.subset'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.Union'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='coe'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='set.Union'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.Ioo'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/intervals/basic.lean&#x27;, &#x27;line&#x27;: 49, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 327, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/lattice.lean&#x27;, &#x27;line&#x27;: 72, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/coe.lean&#x27;, &#x27;line&#x27;: 67, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/lattice.lean&#x27;, &#x27;line&#x27;: 72, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/intervals/basic.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} [_inst_1 : preorder.{0} α], α → α → set.{0} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} [c : has_subset.{0} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {β ι : Type}, (ι → set.{0} β) → set.{0} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {a b : Type} [_inst_1 : has_lift_t.{1 1} a b], a → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type → Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {β ι : Type}, (ι → set.{0} β) → set.{0} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} [_inst_1 : preorder.{0} α], α → α → set.{0} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Left-closed right-closed interval'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Indexed union of a family of sets'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Indexed union of a family of sets'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Left-open right-open interval'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a b : real,
c d : nat → real,
ss :
  @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
    (@set.Union.{0 1} real nat (λ (i : nat), @set.Ioo.{0} real real.preorder (c i) (d i)))
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat),
          @coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
            (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (d i) (c i)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 99      (of_real (b - a) : ennreal) ≤ s.sum (λ i, of_real (d i - c i)),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='has_sub.sub'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='ennreal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_le.le'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='finset.sum'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='nnreal.of_real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='d'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 315, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/ennreal.lean&#x27;, &#x27;line&#x27;: 18, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 319, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/big_operators.lean&#x27;, &#x27;line&#x27;: 33, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/nnreal.lean&#x27;, &#x27;line&#x27;: 32, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} [c : has_sub.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} [c : has_le.{0} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α β : Type} [_inst_1 : add_comm_monoid.{0} β], finset.{0} α → (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='real → nnreal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The extended nonnegative real numbers. This is usually denoted [0, ∞],
 and is relevant as the codomain of a measure.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a b : real,
c d : nat → real,
ss :
  @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
    (@set.Union.{0 1} real nat (λ (i : nat), @set.Ioo.{0} real real.preorder (c i) (d i)))
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat),
          @coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
            (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (d i) (c i)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
a b : real,
c d : nat → real,
ss :
  @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
    (@set.Union.{0 1} real nat (λ (i : nat), @set.Ioo.{0} real real.preorder (c i) (d i))),
this :
  ∀ (s : finset.{0} nat) (b : real),
    @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
      (@set.Union.{0 1} real nat
         (λ (i : nat),
            @set.Union.{0 0} real
              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                 (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                    (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                    s))
              (λ
               (H :
                 @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                   (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                      (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                      s)), @set.Ioo.{0} real real.preorder (c i) (d i)))) →
    @has_le.le.{0} ennreal
      (@preorder.to_has_le.{0} ennreal
         (@partial_order.to_preorder.{0} ennreal
            (@ordered_comm_monoid.to_partial_order.{0} ennreal
               (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                  (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                     ennreal.canonically_ordered_comm_semiring_1)))))
      (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
         (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
      (@finset.sum.{0 0} nat ennreal
         (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
            (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
               (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                  ennreal.canonically_ordered_comm_semiring_1)))
         s
         (λ (i : nat),
            @coe.{1 1} nnreal ennreal
              (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
              (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (d i) (c i)))))
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat),
          @coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
            (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (d i) (c i)))))

a b : real,
c d : nat → real,
ss :
  @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
    (@set.Union.{0 1} real nat (λ (i : nat), @set.Ioo.{0} real real.preorder (c i) (d i)))
⊢ ∀ (s : finset.{0} nat) (b : real),
    @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
      (@set.Union.{0 1} real nat
         (λ (i : nat),
            @set.Union.{0 0} real
              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                 (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                    (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                    s))
              (λ
               (H :
                 @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                   (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                      (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                      s)), @set.Ioo.{0} real real.preorder (c i) (d i)))) →
    @has_le.le.{0} ennreal
      (@preorder.to_has_le.{0} ennreal
         (@partial_order.to_preorder.{0} ennreal
            (@ordered_comm_monoid.to_partial_order.{0} ennreal
               (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                  (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                     ennreal.canonically_ordered_comm_semiring_1)))))
      (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
         (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
      (@finset.sum.{0 0} nat ennreal
         (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
            (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
               (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                  ennreal.canonically_ordered_comm_semiring_1)))
         s
         (λ (i : nat),
            @coe.{1 1} nnreal ennreal
              (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
              (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (d i) (c i)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>100    { rcases compact_Icc.elim_finite_subcover_image (λ (i : ℕ) (_ : i ∈ univ),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='compact_Icc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/instances/real.lean&#x27;, &#x27;line&#x27;: 316, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : real}, @compact.{0} real (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)) (@set.Icc.{0} real real.preorder a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i (@set.univ.{0} nat)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type}, set.{0} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
a b : real,
c d : nat → real,
ss :
  @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
    (@set.Union.{0 1} real nat (λ (i : nat), @set.Ioo.{0} real real.preorder (c i) (d i))),
this :
  ∀ (s : finset.{0} nat) (b : real),
    @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
      (@set.Union.{0 1} real nat
         (λ (i : nat),
            @set.Union.{0 0} real
              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                 (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                    (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                    s))
              (λ
               (H :
                 @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                   (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                      (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                      s)), @set.Ioo.{0} real real.preorder (c i) (d i)))) →
    @has_le.le.{0} ennreal
      (@preorder.to_has_le.{0} ennreal
         (@partial_order.to_preorder.{0} ennreal
            (@ordered_comm_monoid.to_partial_order.{0} ennreal
               (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                  (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                     ennreal.canonically_ordered_comm_semiring_1)))))
      (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
         (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
      (@finset.sum.{0 0} nat ennreal
         (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
            (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
               (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                  ennreal.canonically_ordered_comm_semiring_1)))
         s
         (λ (i : nat),
            @coe.{1 1} nnreal ennreal
              (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
              (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (d i) (c i)))))
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat),
          @coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
            (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (d i) (c i)))))

a b : real,
c d : nat → real,
ss :
  @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
    (@set.Union.{0 1} real nat (λ (i : nat), @set.Ioo.{0} real real.preorder (c i) (d i)))
⊢ ∀ (s : finset.{0} nat) (b : real),
    @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
      (@set.Union.{0 1} real nat
         (λ (i : nat),
            @set.Union.{0 0} real
              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                 (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                    (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                    s))
              (λ
               (H :
                 @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                   (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                      (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                      s)), @set.Ioo.{0} real real.preorder (c i) (d i)))) →
    @has_le.le.{0} ennreal
      (@preorder.to_has_le.{0} ennreal
         (@partial_order.to_preorder.{0} ennreal
            (@ordered_comm_monoid.to_partial_order.{0} ennreal
               (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                  (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                     ennreal.canonically_ordered_comm_semiring_1)))))
      (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
         (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
      (@finset.sum.{0 0} nat ennreal
         (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
            (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
               (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                  ennreal.canonically_ordered_comm_semiring_1)))
         s
         (λ (i : nat),
            @coe.{1 1} nnreal ennreal
              (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
              (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (d i) (c i)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a b : real,
c d : nat → real,
ss :
  @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
    (@set.Union.{0 1} real nat (λ (i : nat), @set.Ioo.{0} real real.preorder (c i) (d i))),
this :
  ∀ (s : finset.{0} nat) (b : real),
    @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
      (@set.Union.{0 1} real nat
         (λ (i : nat),
            @set.Union.{0 0} real
              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                 (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                    (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                    s))
              (λ
               (H :
                 @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                   (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                      (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                      s)), @set.Ioo.{0} real real.preorder (c i) (d i)))) →
    @has_le.le.{0} ennreal
      (@preorder.to_has_le.{0} ennreal
         (@partial_order.to_preorder.{0} ennreal
            (@ordered_comm_monoid.to_partial_order.{0} ennreal
               (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                  (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                     ennreal.canonically_ordered_comm_semiring_1)))))
      (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
         (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
      (@finset.sum.{0 0} nat ennreal
         (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
            (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
               (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                  ennreal.canonically_ordered_comm_semiring_1)))
         s
         (λ (i : nat),
            @coe.{1 1} nnreal ennreal
              (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
              (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (d i) (c i)))))
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat),
          @coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
            (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (d i) (c i)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>101        @is_open_Ioo _ _ _ _ (c i) (d i)) (by simpa using ss) with ⟨s, su, hf, hs⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='is_open_Ioo'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='d'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='blue'><a title='ss'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/algebra/ordered.lean&#x27;, &#x27;line&#x27;: 206, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type} [_inst_1 : topological_space.{0} α] [_inst_2 : linear_order.{0} α] [_inst_3 : @order_closed_topology.{0} α _inst_1 (@partial_order.to_preorder.{0} α (@linear_order.to_partial_order.{0} α _inst_2))] {a b : α}, @is_open.{0} α _inst_1 (@set.Ioo.{0} α (@partial_order.to_preorder.{0} α (@linear_order.to_partial_order.{0} α _inst_2)) a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b) (@set.Union.{0 1} real nat (λ (i : nat), @set.Ioo.{0} real real.preorder (c i) (d i)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a b : real,
c d : nat → real,
ss :
  @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
    (@set.Union.{0 1} real nat (λ (i : nat), @set.Ioo.{0} real real.preorder (c i) (d i))),
this :
  ∀ (s : finset.{0} nat) (b : real),
    @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
      (@set.Union.{0 1} real nat
         (λ (i : nat),
            @set.Union.{0 0} real
              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                 (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                    (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                    s))
              (λ
               (H :
                 @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                   (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                      (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                      s)), @set.Ioo.{0} real real.preorder (c i) (d i)))) →
    @has_le.le.{0} ennreal
      (@preorder.to_has_le.{0} ennreal
         (@partial_order.to_preorder.{0} ennreal
            (@ordered_comm_monoid.to_partial_order.{0} ennreal
               (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                  (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                     ennreal.canonically_ordered_comm_semiring_1)))))
      (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
         (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
      (@finset.sum.{0 0} nat ennreal
         (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
            (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
               (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                  ennreal.canonically_ordered_comm_semiring_1)))
         s
         (λ (i : nat),
            @coe.{1 1} nnreal ennreal
              (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
              (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (d i) (c i)))))
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat),
          @coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
            (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (d i) (c i)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a b : real,
c d : nat → real,
ss :
  @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
    (@set.Union.{0 1} real nat (λ (i : nat), @set.Ioo.{0} real real.preorder (c i) (d i))),
this :
  ∀ (s : finset.{0} nat) (b : real),
    @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
      (@set.Union.{0 1} real nat
         (λ (i : nat),
            @set.Union.{0 0} real
              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                 (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                    (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                    s))
              (λ
               (H :
                 @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                   (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                      (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                      s)), @set.Ioo.{0} real real.preorder (c i) (d i)))) →
    @has_le.le.{0} ennreal
      (@preorder.to_has_le.{0} ennreal
         (@partial_order.to_preorder.{0} ennreal
            (@ordered_comm_monoid.to_partial_order.{0} ennreal
               (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                  (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                     ennreal.canonically_ordered_comm_semiring_1)))))
      (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
         (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
      (@finset.sum.{0 0} nat ennreal
         (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
            (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
               (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                  ennreal.canonically_ordered_comm_semiring_1)))
         s
         (λ (i : nat),
            @coe.{1 1} nnreal ennreal
              (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
              (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (d i) (c i)))))
⊢ @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder ?m_1 ?m_2)
    (@set.Union.{0 1} real nat
       (λ (i : nat),
          @set.Union.{0 0} real (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i (@set.univ.{0} nat))
            (λ (H : @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i (@set.univ.{0} nat)),
               @set.Ioo.{0} real
                 (@partial_order.to_preorder.{0} real (@linear_order.to_partial_order.{0} real real.linear_order))
                 (c i)
                 (d i))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a b : real,
c d : nat → real,
ss :
  @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
    (@set.Union.{0 1} real nat (λ (i : nat), @set.Ioo.{0} real real.preorder (c i) (d i))),
this :
  ∀ (s : finset.{0} nat) (b : real),
    @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
      (@set.Union.{0 1} real nat
         (λ (i : nat),
            @set.Union.{0 0} real
              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                 (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                    (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                    s))
              (λ
               (H :
                 @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                   (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                      (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                      s)), @set.Ioo.{0} real real.preorder (c i) (d i)))) →
    @has_le.le.{0} ennreal
      (@preorder.to_has_le.{0} ennreal
         (@partial_order.to_preorder.{0} ennreal
            (@ordered_comm_monoid.to_partial_order.{0} ennreal
               (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                  (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                     ennreal.canonically_ordered_comm_semiring_1)))))
      (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
         (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
      (@finset.sum.{0 0} nat ennreal
         (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
            (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
               (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                  ennreal.canonically_ordered_comm_semiring_1)))
         s
         (λ (i : nat),
            @coe.{1 1} nnreal ennreal
              (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
              (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (d i) (c i)))))
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat),
          @coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
            (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (d i) (c i)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a b : real,
c d : nat → real,
ss :
  @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
    (@set.Union.{0 1} real nat (λ (i : nat), @set.Ioo.{0} real real.preorder (c i) (d i))),
this :
  ∀ (s : finset.{0} nat) (b : real),
    @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
      (@set.Union.{0 1} real nat
         (λ (i : nat),
            @set.Union.{0 0} real
              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                 (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                    (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                    s))
              (λ
               (H :
                 @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                   (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                      (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                      s)), @set.Ioo.{0} real real.preorder (c i) (d i)))) →
    @has_le.le.{0} ennreal
      (@preorder.to_has_le.{0} ennreal
         (@partial_order.to_preorder.{0} ennreal
            (@ordered_comm_monoid.to_partial_order.{0} ennreal
               (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                  (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                     ennreal.canonically_ordered_comm_semiring_1)))))
      (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
         (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
      (@finset.sum.{0 0} nat ennreal
         (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
            (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
               (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                  ennreal.canonically_ordered_comm_semiring_1)))
         s
         (λ (i : nat),
            @coe.{1 1} nnreal ennreal
              (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
              (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (d i) (c i))))),
s : set.{0} nat,
su : @has_subset.subset.{0} (set.{0} nat) (@set.has_subset.{0} nat) s (@set.univ.{0} nat),
hf : @set.finite.{0} nat s,
hs :
  @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
    (@set.Union.{0 1} real nat
       (λ (i : nat),
          @set.Union.{0 0} real (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i s)
            (λ (H : @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i s),
               (λ (i : nat),
                  @set.Ioo.{0} real
                    (@partial_order.to_preorder.{0} real (@linear_order.to_partial_order.{0} real real.linear_order))
                    (c i)
                    (d i))
                 i)))
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat),
          @coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
            (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (d i) (c i)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>102      have e : (⋃ i ∈ (↑hf.to_finset:set ℕ),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='set.Union'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='set.Union'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/lattice.lean&#x27;, &#x27;line&#x27;: 72, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/finite.lean&#x27;, &#x27;line&#x27;: 32, &#x27;column&#x27;: 18}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/lattice.lean&#x27;, &#x27;line&#x27;: 72, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {β ι : Type}, (ι → set.{0} β) → set.{0} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@set.finite.{0} nat s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type → Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {β ι : Type}, (ι → set.{0} β) → set.{0} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Indexed union of a family of sets'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Get a finset from a finite set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Indexed union of a family of sets'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a b : real,
c d : nat → real,
ss :
  @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
    (@set.Union.{0 1} real nat (λ (i : nat), @set.Ioo.{0} real real.preorder (c i) (d i))),
this :
  ∀ (s : finset.{0} nat) (b : real),
    @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
      (@set.Union.{0 1} real nat
         (λ (i : nat),
            @set.Union.{0 0} real
              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                 (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                    (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                    s))
              (λ
               (H :
                 @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                   (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                      (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                      s)), @set.Ioo.{0} real real.preorder (c i) (d i)))) →
    @has_le.le.{0} ennreal
      (@preorder.to_has_le.{0} ennreal
         (@partial_order.to_preorder.{0} ennreal
            (@ordered_comm_monoid.to_partial_order.{0} ennreal
               (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                  (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                     ennreal.canonically_ordered_comm_semiring_1)))))
      (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
         (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
      (@finset.sum.{0 0} nat ennreal
         (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
            (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
               (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                  ennreal.canonically_ordered_comm_semiring_1)))
         s
         (λ (i : nat),
            @coe.{1 1} nnreal ennreal
              (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
              (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (d i) (c i))))),
s : set.{0} nat,
su : @has_subset.subset.{0} (set.{0} nat) (@set.has_subset.{0} nat) s (@set.univ.{0} nat),
hf : @set.finite.{0} nat s,
hs :
  @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
    (@set.Union.{0 1} real nat
       (λ (i : nat),
          @set.Union.{0 0} real (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i s)
            (λ (H : @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i s),
               (λ (i : nat),
                  @set.Ioo.{0} real
                    (@partial_order.to_preorder.{0} real (@linear_order.to_partial_order.{0} real real.linear_order))
                    (c i)
                    (d i))
                 i)))
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat),
          @coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
            (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (d i) (c i)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>103        Ioo (c i) (d i)) = (⋃ i ∈ s, Ioo (c i) (d i)), {simp [set.ext_iff]},</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.Ioo'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='d'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='set.ext_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/intervals/basic.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 58, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{0} nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} [_inst_1 : preorder.{0} α], α → α → set.{0} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} (s t : set.{?l_1} α), iff (@eq.{(max (?l_1+1) 1)} (set.{?l_1} α) s t) (∀ (x : α), iff (@has_mem.mem.{?l_1 ?l_1} α (set.{?l_1} α) (@set.has_mem.{?l_1} α) x s) (@has_mem.mem.{?l_1 ?l_1} α (set.{?l_1} α) (@set.has_mem.{?l_1} α) x t))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Left-open right-open interval'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a b : real,
c d : nat → real,
ss :
  @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
    (@set.Union.{0 1} real nat (λ (i : nat), @set.Ioo.{0} real real.preorder (c i) (d i))),
this :
  ∀ (s : finset.{0} nat) (b : real),
    @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
      (@set.Union.{0 1} real nat
         (λ (i : nat),
            @set.Union.{0 0} real
              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                 (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                    (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                    s))
              (λ
               (H :
                 @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                   (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                      (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                      s)), @set.Ioo.{0} real real.preorder (c i) (d i)))) →
    @has_le.le.{0} ennreal
      (@preorder.to_has_le.{0} ennreal
         (@partial_order.to_preorder.{0} ennreal
            (@ordered_comm_monoid.to_partial_order.{0} ennreal
               (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                  (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                     ennreal.canonically_ordered_comm_semiring_1)))))
      (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
         (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
      (@finset.sum.{0 0} nat ennreal
         (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
            (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
               (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                  ennreal.canonically_ordered_comm_semiring_1)))
         s
         (λ (i : nat),
            @coe.{1 1} nnreal ennreal
              (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
              (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (d i) (c i))))),
s : set.{0} nat,
su : @has_subset.subset.{0} (set.{0} nat) (@set.has_subset.{0} nat) s (@set.univ.{0} nat),
hf : @set.finite.{0} nat s,
hs :
  @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
    (@set.Union.{0 1} real nat
       (λ (i : nat),
          @set.Union.{0 0} real (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i s)
            (λ (H : @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i s),
               (λ (i : nat),
                  @set.Ioo.{0} real
                    (@partial_order.to_preorder.{0} real (@linear_order.to_partial_order.{0} real real.linear_order))
                    (c i)
                    (d i))
                 i)))
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat),
          @coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
            (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (d i) (c i)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
a b : real,
c d : nat → real,
ss :
  @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
    (@set.Union.{0 1} real nat (λ (i : nat), @set.Ioo.{0} real real.preorder (c i) (d i))),
this :
  ∀ (s : finset.{0} nat) (b : real),
    @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
      (@set.Union.{0 1} real nat
         (λ (i : nat),
            @set.Union.{0 0} real
              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                 (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                    (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                    s))
              (λ
               (H :
                 @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                   (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                      (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                      s)), @set.Ioo.{0} real real.preorder (c i) (d i)))) →
    @has_le.le.{0} ennreal
      (@preorder.to_has_le.{0} ennreal
         (@partial_order.to_preorder.{0} ennreal
            (@ordered_comm_monoid.to_partial_order.{0} ennreal
               (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                  (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                     ennreal.canonically_ordered_comm_semiring_1)))))
      (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
         (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
      (@finset.sum.{0 0} nat ennreal
         (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
            (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
               (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                  ennreal.canonically_ordered_comm_semiring_1)))
         s
         (λ (i : nat),
            @coe.{1 1} nnreal ennreal
              (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
              (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (d i) (c i))))),
s : set.{0} nat,
su : @has_subset.subset.{0} (set.{0} nat) (@set.has_subset.{0} nat) s (@set.univ.{0} nat),
hf : @set.finite.{0} nat s,
hs :
  @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
    (@set.Union.{0 1} real nat
       (λ (i : nat),
          @set.Union.{0 0} real (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i s)
            (λ (H : @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i s),
               (λ (i : nat),
                  @set.Ioo.{0} real
                    (@partial_order.to_preorder.{0} real (@linear_order.to_partial_order.{0} real real.linear_order))
                    (c i)
                    (d i))
                 i)))
⊢ @eq.{1} (set.{0} real)
    (@set.Union.{0 1} real nat
       (λ (i : nat),
          @set.Union.{0 0} real
            (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
               (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                  (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                  (@set.finite.to_finset.{0} nat s hf)))
            (λ
             (H :
               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                 (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                    (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                    (@set.finite.to_finset.{0} nat s hf))), @set.Ioo.{0} real real.preorder (c i) (d i))))
    (@set.Union.{0 1} real nat
       (λ (i : nat),
          @set.Union.{0 0} real (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i s)
            (λ (H : @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i s),
               @set.Ioo.{0} real real.preorder (c i) (d i))))

a b : real,
c d : nat → real,
ss :
  @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
    (@set.Union.{0 1} real nat (λ (i : nat), @set.Ioo.{0} real real.preorder (c i) (d i))),
this :
  ∀ (s : finset.{0} nat) (b : real),
    @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
      (@set.Union.{0 1} real nat
         (λ (i : nat),
            @set.Union.{0 0} real
              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                 (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                    (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                    s))
              (λ
               (H :
                 @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                   (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                      (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                      s)), @set.Ioo.{0} real real.preorder (c i) (d i)))) →
    @has_le.le.{0} ennreal
      (@preorder.to_has_le.{0} ennreal
         (@partial_order.to_preorder.{0} ennreal
            (@ordered_comm_monoid.to_partial_order.{0} ennreal
               (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                  (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                     ennreal.canonically_ordered_comm_semiring_1)))))
      (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
         (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
      (@finset.sum.{0 0} nat ennreal
         (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
            (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
               (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                  ennreal.canonically_ordered_comm_semiring_1)))
         s
         (λ (i : nat),
            @coe.{1 1} nnreal ennreal
              (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
              (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (d i) (c i))))),
s : set.{0} nat,
su : @has_subset.subset.{0} (set.{0} nat) (@set.has_subset.{0} nat) s (@set.univ.{0} nat),
hf : @set.finite.{0} nat s,
hs :
  @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
    (@set.Union.{0 1} real nat
       (λ (i : nat),
          @set.Union.{0 0} real (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i s)
            (λ (H : @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i s),
               (λ (i : nat),
                  @set.Ioo.{0} real
                    (@partial_order.to_preorder.{0} real (@linear_order.to_partial_order.{0} real real.linear_order))
                    (c i)
                    (d i))
                 i))),
e :
  @eq.{1} (set.{0} real)
    (@set.Union.{0 1} real nat
       (λ (i : nat),
          @set.Union.{0 0} real
            (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
               (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                  (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                  (@set.finite.to_finset.{0} nat s hf)))
            (λ
             (H :
               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                 (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                    (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                    (@set.finite.to_finset.{0} nat s hf))), @set.Ioo.{0} real real.preorder (c i) (d i))))
    (@set.Union.{0 1} real nat
       (λ (i : nat),
          @set.Union.{0 0} real (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i s)
            (λ (H : @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i s),
               @set.Ioo.{0} real real.preorder (c i) (d i))))
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat),
          @coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
            (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (d i) (c i)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a b : real,
c d : nat → real,
ss :
  @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
    (@set.Union.{0 1} real nat (λ (i : nat), @set.Ioo.{0} real real.preorder (c i) (d i))),
this :
  ∀ (s : finset.{0} nat) (b : real),
    @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
      (@set.Union.{0 1} real nat
         (λ (i : nat),
            @set.Union.{0 0} real
              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                 (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                    (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                    s))
              (λ
               (H :
                 @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                   (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                      (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                      s)), @set.Ioo.{0} real real.preorder (c i) (d i)))) →
    @has_le.le.{0} ennreal
      (@preorder.to_has_le.{0} ennreal
         (@partial_order.to_preorder.{0} ennreal
            (@ordered_comm_monoid.to_partial_order.{0} ennreal
               (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                  (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                     ennreal.canonically_ordered_comm_semiring_1)))))
      (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
         (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
      (@finset.sum.{0 0} nat ennreal
         (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
            (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
               (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                  ennreal.canonically_ordered_comm_semiring_1)))
         s
         (λ (i : nat),
            @coe.{1 1} nnreal ennreal
              (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
              (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (d i) (c i))))),
s : set.{0} nat,
su : @has_subset.subset.{0} (set.{0} nat) (@set.has_subset.{0} nat) s (@set.univ.{0} nat),
hf : @set.finite.{0} nat s,
hs :
  @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
    (@set.Union.{0 1} real nat
       (λ (i : nat),
          @set.Union.{0 0} real (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i s)
            (λ (H : @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i s),
               (λ (i : nat),
                  @set.Ioo.{0} real
                    (@partial_order.to_preorder.{0} real (@linear_order.to_partial_order.{0} real real.linear_order))
                    (c i)
                    (d i))
                 i))),
e :
  @eq.{1} (set.{0} real)
    (@set.Union.{0 1} real nat
       (λ (i : nat),
          @set.Union.{0 0} real
            (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
               (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                  (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                  (@set.finite.to_finset.{0} nat s hf)))
            (λ
             (H :
               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                 (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                    (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                    (@set.finite.to_finset.{0} nat s hf))), @set.Ioo.{0} real real.preorder (c i) (d i))))
    (@set.Union.{0 1} real nat
       (λ (i : nat),
          @set.Union.{0 0} real (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i s)
            (λ (H : @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i s),
               @set.Ioo.{0} real real.preorder (c i) (d i))))
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat),
          @coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
            (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (d i) (c i)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>104      rw ennreal.tsum_eq_supr_sum,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='ennreal.tsum_eq_supr_sum'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/instances/ennreal.lean&#x27;, &#x27;line&#x27;: 436, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} {f : α → ennreal}, @eq.{1} ennreal (@tsum.{0 0} ennreal α (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal ennreal.canonically_ordered_comm_semiring_1))) ennreal.topological_space (λ (a : α), f a)) (@lattice.supr.{0 1} ennreal (finset.{0} α) (@lattice.conditionally_complete_lattice.to_has_Sup.{0} ennreal (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))) (λ (s : finset.{0} α), @finset.sum.{0 0} α ennreal (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal ennreal.canonically_ordered_comm_semiring_1))) s f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a b : real,
c d : nat → real,
ss :
  @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
    (@set.Union.{0 1} real nat (λ (i : nat), @set.Ioo.{0} real real.preorder (c i) (d i))),
this :
  ∀ (s : finset.{0} nat) (b : real),
    @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
      (@set.Union.{0 1} real nat
         (λ (i : nat),
            @set.Union.{0 0} real
              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                 (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                    (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                    s))
              (λ
               (H :
                 @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                   (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                      (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                      s)), @set.Ioo.{0} real real.preorder (c i) (d i)))) →
    @has_le.le.{0} ennreal
      (@preorder.to_has_le.{0} ennreal
         (@partial_order.to_preorder.{0} ennreal
            (@ordered_comm_monoid.to_partial_order.{0} ennreal
               (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                  (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                     ennreal.canonically_ordered_comm_semiring_1)))))
      (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
         (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
      (@finset.sum.{0 0} nat ennreal
         (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
            (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
               (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                  ennreal.canonically_ordered_comm_semiring_1)))
         s
         (λ (i : nat),
            @coe.{1 1} nnreal ennreal
              (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
              (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (d i) (c i))))),
s : set.{0} nat,
su : @has_subset.subset.{0} (set.{0} nat) (@set.has_subset.{0} nat) s (@set.univ.{0} nat),
hf : @set.finite.{0} nat s,
hs :
  @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
    (@set.Union.{0 1} real nat
       (λ (i : nat),
          @set.Union.{0 0} real (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i s)
            (λ (H : @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i s),
               (λ (i : nat),
                  @set.Ioo.{0} real
                    (@partial_order.to_preorder.{0} real (@linear_order.to_partial_order.{0} real real.linear_order))
                    (c i)
                    (d i))
                 i))),
e :
  @eq.{1} (set.{0} real)
    (@set.Union.{0 1} real nat
       (λ (i : nat),
          @set.Union.{0 0} real
            (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
               (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                  (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                  (@set.finite.to_finset.{0} nat s hf)))
            (λ
             (H :
               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                 (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                    (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                    (@set.finite.to_finset.{0} nat s hf))), @set.Ioo.{0} real real.preorder (c i) (d i))))
    (@set.Union.{0 1} real nat
       (λ (i : nat),
          @set.Union.{0 0} real (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i s)
            (λ (H : @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i s),
               @set.Ioo.{0} real real.preorder (c i) (d i))))
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat),
          @coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
            (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (d i) (c i)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a b : real,
c d : nat → real,
ss :
  @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
    (@set.Union.{0 1} real nat (λ (i : nat), @set.Ioo.{0} real real.preorder (c i) (d i))),
this :
  ∀ (s : finset.{0} nat) (b : real),
    @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
      (@set.Union.{0 1} real nat
         (λ (i : nat),
            @set.Union.{0 0} real
              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                 (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                    (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                    s))
              (λ
               (H :
                 @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                   (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                      (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                      s)), @set.Ioo.{0} real real.preorder (c i) (d i)))) →
    @has_le.le.{0} ennreal
      (@preorder.to_has_le.{0} ennreal
         (@partial_order.to_preorder.{0} ennreal
            (@ordered_comm_monoid.to_partial_order.{0} ennreal
               (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                  (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                     ennreal.canonically_ordered_comm_semiring_1)))))
      (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
         (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
      (@finset.sum.{0 0} nat ennreal
         (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
            (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
               (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                  ennreal.canonically_ordered_comm_semiring_1)))
         s
         (λ (i : nat),
            @coe.{1 1} nnreal ennreal
              (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
              (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (d i) (c i))))),
s : set.{0} nat,
su : @has_subset.subset.{0} (set.{0} nat) (@set.has_subset.{0} nat) s (@set.univ.{0} nat),
hf : @set.finite.{0} nat s,
hs :
  @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
    (@set.Union.{0 1} real nat
       (λ (i : nat),
          @set.Union.{0 0} real (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i s)
            (λ (H : @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i s),
               (λ (i : nat),
                  @set.Ioo.{0} real
                    (@partial_order.to_preorder.{0} real (@linear_order.to_partial_order.{0} real real.linear_order))
                    (c i)
                    (d i))
                 i))),
e :
  @eq.{1} (set.{0} real)
    (@set.Union.{0 1} real nat
       (λ (i : nat),
          @set.Union.{0 0} real
            (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
               (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                  (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                  (@set.finite.to_finset.{0} nat s hf)))
            (λ
             (H :
               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                 (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                    (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                    (@set.finite.to_finset.{0} nat s hf))), @set.Ioo.{0} real real.preorder (c i) (d i))))
    (@set.Union.{0 1} real nat
       (λ (i : nat),
          @set.Union.{0 0} real (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i s)
            (λ (H : @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i s),
               @set.Ioo.{0} real real.preorder (c i) (d i))))
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
    (@lattice.supr.{0 1} ennreal (finset.{0} nat)
       (@lattice.conditionally_complete_lattice.to_has_Sup.{0} ennreal
          (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
             (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
       (λ (s : finset.{0} nat),
          @finset.sum.{0 0} nat ennreal
            (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
               (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                  (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                     ennreal.canonically_ordered_comm_semiring_1)))
            s
            (λ (a : nat),
               @coe.{1 1} nnreal ennreal
                 (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
                 (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (d a) (c a))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>105      refine le_trans _ (le_supr _ hf.to_finset),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='le_trans'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='lattice.le_supr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 33, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/complete_lattice.lean&#x27;, &#x27;line&#x27;: 231, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/finite.lean&#x27;, &#x27;line&#x27;: 32, &#x27;column&#x27;: 18}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : preorder.{0} α] {a b c : α}, @has_le.le.{0} α (@preorder.to_has_le.{0} α _inst_1) a b → @has_le.le.{0} α (@preorder.to_has_le.{0} α _inst_1) b c → @has_le.le.{0} α (@preorder.to_has_le.{0} α _inst_1) a c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α ι : Type} [_inst_1 : lattice.complete_lattice.{0} α] (s : ι → α) (i : ι), @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@lattice.order_bot.to_partial_order.{0} α (@lattice.bounded_lattice.to_order_bot.{0} α (@lattice.complete_lattice.to_bounded_lattice.{0} α _inst_1))))) (s i) (@lattice.supr.{0 1} α ι (@lattice.complete_lattice.to_has_Sup.{0} α _inst_1) s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@set.finite.{0} nat s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Get a finset from a finite set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a b : real,
c d : nat → real,
ss :
  @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
    (@set.Union.{0 1} real nat (λ (i : nat), @set.Ioo.{0} real real.preorder (c i) (d i))),
this :
  ∀ (s : finset.{0} nat) (b : real),
    @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
      (@set.Union.{0 1} real nat
         (λ (i : nat),
            @set.Union.{0 0} real
              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                 (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                    (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                    s))
              (λ
               (H :
                 @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                   (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                      (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                      s)), @set.Ioo.{0} real real.preorder (c i) (d i)))) →
    @has_le.le.{0} ennreal
      (@preorder.to_has_le.{0} ennreal
         (@partial_order.to_preorder.{0} ennreal
            (@ordered_comm_monoid.to_partial_order.{0} ennreal
               (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                  (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                     ennreal.canonically_ordered_comm_semiring_1)))))
      (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
         (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
      (@finset.sum.{0 0} nat ennreal
         (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
            (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
               (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                  ennreal.canonically_ordered_comm_semiring_1)))
         s
         (λ (i : nat),
            @coe.{1 1} nnreal ennreal
              (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
              (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (d i) (c i))))),
s : set.{0} nat,
su : @has_subset.subset.{0} (set.{0} nat) (@set.has_subset.{0} nat) s (@set.univ.{0} nat),
hf : @set.finite.{0} nat s,
hs :
  @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
    (@set.Union.{0 1} real nat
       (λ (i : nat),
          @set.Union.{0 0} real (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i s)
            (λ (H : @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i s),
               (λ (i : nat),
                  @set.Ioo.{0} real
                    (@partial_order.to_preorder.{0} real (@linear_order.to_partial_order.{0} real real.linear_order))
                    (c i)
                    (d i))
                 i))),
e :
  @eq.{1} (set.{0} real)
    (@set.Union.{0 1} real nat
       (λ (i : nat),
          @set.Union.{0 0} real
            (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
               (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                  (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                  (@set.finite.to_finset.{0} nat s hf)))
            (λ
             (H :
               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                 (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                    (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                    (@set.finite.to_finset.{0} nat s hf))), @set.Ioo.{0} real real.preorder (c i) (d i))))
    (@set.Union.{0 1} real nat
       (λ (i : nat),
          @set.Union.{0 0} real (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i s)
            (λ (H : @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i s),
               @set.Ioo.{0} real real.preorder (c i) (d i))))
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
    (@lattice.supr.{0 1} ennreal (finset.{0} nat)
       (@lattice.conditionally_complete_lattice.to_has_Sup.{0} ennreal
          (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
             (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
       (λ (s : finset.{0} nat),
          @finset.sum.{0 0} nat ennreal
            (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
               (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                  (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                     ennreal.canonically_ordered_comm_semiring_1)))
            s
            (λ (a : nat),
               @coe.{1 1} nnreal ennreal
                 (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
                 (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (d a) (c a))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a b : real,
c d : nat → real,
ss :
  @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
    (@set.Union.{0 1} real nat (λ (i : nat), @set.Ioo.{0} real real.preorder (c i) (d i))),
this :
  ∀ (s : finset.{0} nat) (b : real),
    @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
      (@set.Union.{0 1} real nat
         (λ (i : nat),
            @set.Union.{0 0} real
              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                 (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                    (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                    s))
              (λ
               (H :
                 @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                   (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                      (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                      s)), @set.Ioo.{0} real real.preorder (c i) (d i)))) →
    @has_le.le.{0} ennreal
      (@preorder.to_has_le.{0} ennreal
         (@partial_order.to_preorder.{0} ennreal
            (@ordered_comm_monoid.to_partial_order.{0} ennreal
               (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                  (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                     ennreal.canonically_ordered_comm_semiring_1)))))
      (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
         (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
      (@finset.sum.{0 0} nat ennreal
         (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
            (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
               (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                  ennreal.canonically_ordered_comm_semiring_1)))
         s
         (λ (i : nat),
            @coe.{1 1} nnreal ennreal
              (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
              (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (d i) (c i))))),
s : set.{0} nat,
su : @has_subset.subset.{0} (set.{0} nat) (@set.has_subset.{0} nat) s (@set.univ.{0} nat),
hf : @set.finite.{0} nat s,
hs :
  @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
    (@set.Union.{0 1} real nat
       (λ (i : nat),
          @set.Union.{0 0} real (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i s)
            (λ (H : @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i s),
               (λ (i : nat),
                  @set.Ioo.{0} real
                    (@partial_order.to_preorder.{0} real (@linear_order.to_partial_order.{0} real real.linear_order))
                    (c i)
                    (d i))
                 i))),
e :
  @eq.{1} (set.{0} real)
    (@set.Union.{0 1} real nat
       (λ (i : nat),
          @set.Union.{0 0} real
            (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
               (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                  (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                  (@set.finite.to_finset.{0} nat s hf)))
            (λ
             (H :
               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                 (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                    (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                    (@set.finite.to_finset.{0} nat s hf))), @set.Ioo.{0} real real.preorder (c i) (d i))))
    (@set.Union.{0 1} real nat
       (λ (i : nat),
          @set.Union.{0 0} real (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i s)
            (λ (H : @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i s),
               @set.Ioo.{0} real real.preorder (c i) (d i))))
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
    (@finset.sum.{0 0} nat ennreal
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       (@set.finite.to_finset.{0} nat s hf)
       (λ (a : nat),
          @coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
            (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (d a) (c a)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>106      exact this hf.to_finset _ (by simpa [e]) },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/finite.lean&#x27;, &#x27;line&#x27;: 32, &#x27;column&#x27;: 18}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (s : finset.{0} nat) (b : real), @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b) (@set.Union.{0 1} real nat (λ (i : nat), @set.Union.{0 0} real (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i (@coe.{1 1} (finset.{0} nat) (set.{0} nat) (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat)) s)) (λ (H : @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i (@coe.{1 1} (finset.{0} nat) (set.{0} nat) (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat)) s)), @set.Ioo.{0} real real.preorder (c i) (d i)))) → @has_le.le.{0} ennreal (@preorder.to_has_le.{0} ennreal (@partial_order.to_preorder.{0} ennreal (@ordered_comm_monoid.to_partial_order.{0} ennreal (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal ennreal.canonically_ordered_comm_semiring_1))))) (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe)) (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a))) (@finset.sum.{0 0} nat ennreal (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal ennreal.canonically_ordered_comm_semiring_1))) s (λ (i : nat), @coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe)) (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (d i) (c i)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@set.finite.{0} nat s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{1} (set.{0} real) (@set.Union.{0 1} real nat (λ (i : nat), @set.Union.{0 0} real (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i (@coe.{1 1} (finset.{0} nat) (set.{0} nat) (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat)) (@set.finite.to_finset.{0} nat s hf))) (λ (H : @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i (@coe.{1 1} (finset.{0} nat) (set.{0} nat) (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat)) (@set.finite.to_finset.{0} nat s hf))), @set.Ioo.{0} real real.preorder (c i) (d i)))) (@set.Union.{0 1} real nat (λ (i : nat), @set.Union.{0 0} real (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i s) (λ (H : @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i s), @set.Ioo.{0} real real.preorder (c i) (d i))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Get a finset from a finite set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a b : real,
c d : nat → real,
ss :
  @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
    (@set.Union.{0 1} real nat (λ (i : nat), @set.Ioo.{0} real real.preorder (c i) (d i))),
this :
  ∀ (s : finset.{0} nat) (b : real),
    @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
      (@set.Union.{0 1} real nat
         (λ (i : nat),
            @set.Union.{0 0} real
              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                 (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                    (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                    s))
              (λ
               (H :
                 @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                   (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                      (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                      s)), @set.Ioo.{0} real real.preorder (c i) (d i)))) →
    @has_le.le.{0} ennreal
      (@preorder.to_has_le.{0} ennreal
         (@partial_order.to_preorder.{0} ennreal
            (@ordered_comm_monoid.to_partial_order.{0} ennreal
               (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                  (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                     ennreal.canonically_ordered_comm_semiring_1)))))
      (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
         (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
      (@finset.sum.{0 0} nat ennreal
         (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
            (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
               (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                  ennreal.canonically_ordered_comm_semiring_1)))
         s
         (λ (i : nat),
            @coe.{1 1} nnreal ennreal
              (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
              (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (d i) (c i))))),
s : set.{0} nat,
su : @has_subset.subset.{0} (set.{0} nat) (@set.has_subset.{0} nat) s (@set.univ.{0} nat),
hf : @set.finite.{0} nat s,
hs :
  @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
    (@set.Union.{0 1} real nat
       (λ (i : nat),
          @set.Union.{0 0} real (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i s)
            (λ (H : @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i s),
               (λ (i : nat),
                  @set.Ioo.{0} real
                    (@partial_order.to_preorder.{0} real (@linear_order.to_partial_order.{0} real real.linear_order))
                    (c i)
                    (d i))
                 i))),
e :
  @eq.{1} (set.{0} real)
    (@set.Union.{0 1} real nat
       (λ (i : nat),
          @set.Union.{0 0} real
            (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
               (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                  (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                  (@set.finite.to_finset.{0} nat s hf)))
            (λ
             (H :
               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                 (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                    (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                    (@set.finite.to_finset.{0} nat s hf))), @set.Ioo.{0} real real.preorder (c i) (d i))))
    (@set.Union.{0 1} real nat
       (λ (i : nat),
          @set.Union.{0 0} real (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i s)
            (λ (H : @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i s),
               @set.Ioo.{0} real real.preorder (c i) (d i))))
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
    (@finset.sum.{0 0} nat ennreal
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       (@set.finite.to_finset.{0} nat s hf)
       (λ (a : nat),
          @coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
            (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (d a) (c a)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a b : real,
c d : nat → real,
ss :
  @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
    (@set.Union.{0 1} real nat (λ (i : nat), @set.Ioo.{0} real real.preorder (c i) (d i))),
this :
  ∀ (s : finset.{0} nat) (b : real),
    @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
      (@set.Union.{0 1} real nat
         (λ (i : nat),
            @set.Union.{0 0} real
              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                 (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                    (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                    s))
              (λ
               (H :
                 @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                   (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                      (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                      s)), @set.Ioo.{0} real real.preorder (c i) (d i)))) →
    @has_le.le.{0} ennreal
      (@preorder.to_has_le.{0} ennreal
         (@partial_order.to_preorder.{0} ennreal
            (@ordered_comm_monoid.to_partial_order.{0} ennreal
               (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                  (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                     ennreal.canonically_ordered_comm_semiring_1)))))
      (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
         (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
      (@finset.sum.{0 0} nat ennreal
         (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
            (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
               (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                  ennreal.canonically_ordered_comm_semiring_1)))
         s
         (λ (i : nat),
            @coe.{1 1} nnreal ennreal
              (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
              (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (d i) (c i))))),
s : set.{0} nat,
su : @has_subset.subset.{0} (set.{0} nat) (@set.has_subset.{0} nat) s (@set.univ.{0} nat),
hf : @set.finite.{0} nat s,
hs :
  @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
    (@set.Union.{0 1} real nat
       (λ (i : nat),
          @set.Union.{0 0} real (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i s)
            (λ (H : @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i s),
               (λ (i : nat),
                  @set.Ioo.{0} real
                    (@partial_order.to_preorder.{0} real (@linear_order.to_partial_order.{0} real real.linear_order))
                    (c i)
                    (d i))
                 i))),
e :
  @eq.{1} (set.{0} real)
    (@set.Union.{0 1} real nat
       (λ (i : nat),
          @set.Union.{0 0} real
            (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
               (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                  (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                  (@set.finite.to_finset.{0} nat s hf)))
            (λ
             (H :
               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                 (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                    (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                    (@set.finite.to_finset.{0} nat s hf))), @set.Ioo.{0} real real.preorder (c i) (d i))))
    (@set.Union.{0 1} real nat
       (λ (i : nat),
          @set.Union.{0 0} real (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i s)
            (λ (H : @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i s),
               @set.Ioo.{0} real real.preorder (c i) (d i))))
⊢ @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
    (@set.Union.{0 1} real nat
       (λ (i : nat),
          @set.Union.{0 0} real
            (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
               (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                  (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                  (@set.finite.to_finset.{0} nat s hf)))
            (λ
             (H :
               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                 (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                    (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                    (@set.finite.to_finset.{0} nat s hf))), @set.Ioo.{0} real real.preorder (c i) (d i))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a b : real,
c d : nat → real,
ss :
  @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
    (@set.Union.{0 1} real nat (λ (i : nat), @set.Ioo.{0} real real.preorder (c i) (d i))),
this :
  ∀ (s : finset.{0} nat) (b : real),
    @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
      (@set.Union.{0 1} real nat
         (λ (i : nat),
            @set.Union.{0 0} real
              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                 (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                    (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                    s))
              (λ
               (H :
                 @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                   (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                      (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                      s)), @set.Ioo.{0} real real.preorder (c i) (d i)))) →
    @has_le.le.{0} ennreal
      (@preorder.to_has_le.{0} ennreal
         (@partial_order.to_preorder.{0} ennreal
            (@ordered_comm_monoid.to_partial_order.{0} ennreal
               (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                  (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                     ennreal.canonically_ordered_comm_semiring_1)))))
      (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
         (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
      (@finset.sum.{0 0} nat ennreal
         (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
            (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
               (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                  ennreal.canonically_ordered_comm_semiring_1)))
         s
         (λ (i : nat),
            @coe.{1 1} nnreal ennreal
              (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
              (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (d i) (c i))))),
s : set.{0} nat,
su : @has_subset.subset.{0} (set.{0} nat) (@set.has_subset.{0} nat) s (@set.univ.{0} nat),
hf : @set.finite.{0} nat s,
hs :
  @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
    (@set.Union.{0 1} real nat
       (λ (i : nat),
          @set.Union.{0 0} real (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i s)
            (λ (H : @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i s),
               (λ (i : nat),
                  @set.Ioo.{0} real
                    (@partial_order.to_preorder.{0} real (@linear_order.to_partial_order.{0} real real.linear_order))
                    (c i)
                    (d i))
                 i))),
e :
  @eq.{1} (set.{0} real)
    (@set.Union.{0 1} real nat
       (λ (i : nat),
          @set.Union.{0 0} real
            (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
               (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                  (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                  (@set.finite.to_finset.{0} nat s hf)))
            (λ
             (H :
               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                 (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                    (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                    (@set.finite.to_finset.{0} nat s hf))), @set.Ioo.{0} real real.preorder (c i) (d i))))
    (@set.Union.{0 1} real nat
       (λ (i : nat),
          @set.Union.{0 0} real (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i s)
            (λ (H : @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i s),
               @set.Ioo.{0} real real.preorder (c i) (d i))))
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
    (@finset.sum.{0 0} nat ennreal
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       (@set.finite.to_finset.{0} nat s hf)
       (λ (a : nat),
          @coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
            (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (d a) (c a)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a b : real,
c d : nat → real,
ss :
  @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
    (@set.Union.{0 1} real nat (λ (i : nat), @set.Ioo.{0} real real.preorder (c i) (d i)))
⊢ ∀ (s : finset.{0} nat) (b : real),
    @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
      (@set.Union.{0 1} real nat
         (λ (i : nat),
            @set.Union.{0 0} real
              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                 (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                    (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                    s))
              (λ
               (H :
                 @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                   (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                      (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                      s)), @set.Ioo.{0} real real.preorder (c i) (d i)))) →
    @has_le.le.{0} ennreal
      (@preorder.to_has_le.{0} ennreal
         (@partial_order.to_preorder.{0} ennreal
            (@ordered_comm_monoid.to_partial_order.{0} ennreal
               (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                  (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                     ennreal.canonically_ordered_comm_semiring_1)))))
      (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
         (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
      (@finset.sum.{0 0} nat ennreal
         (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
            (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
               (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                  ennreal.canonically_ordered_comm_semiring_1)))
         s
         (λ (i : nat),
            @coe.{1 1} nnreal ennreal
              (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
              (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (d i) (c i)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>107    clear ss b,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1318, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`clear h₁ ... hₙ` tries to clear each hypothesis `hᵢ` from the local context.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='clear'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a b : real,
c d : nat → real,
ss :
  @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
    (@set.Union.{0 1} real nat (λ (i : nat), @set.Ioo.{0} real real.preorder (c i) (d i)))
⊢ ∀ (s : finset.{0} nat) (b : real),
    @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
      (@set.Union.{0 1} real nat
         (λ (i : nat),
            @set.Union.{0 0} real
              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                 (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                    (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                    s))
              (λ
               (H :
                 @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                   (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                      (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                      s)), @set.Ioo.{0} real real.preorder (c i) (d i)))) →
    @has_le.le.{0} ennreal
      (@preorder.to_has_le.{0} ennreal
         (@partial_order.to_preorder.{0} ennreal
            (@ordered_comm_monoid.to_partial_order.{0} ennreal
               (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                  (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                     ennreal.canonically_ordered_comm_semiring_1)))))
      (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
         (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
      (@finset.sum.{0 0} nat ennreal
         (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
            (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
               (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                  ennreal.canonically_ordered_comm_semiring_1)))
         s
         (λ (i : nat),
            @coe.{1 1} nnreal ennreal
              (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
              (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (d i) (c i)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a : real,
c d : nat → real
⊢ ∀ (s : finset.{0} nat) (b : real),
    @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
      (@set.Union.{0 1} real nat
         (λ (i : nat),
            @set.Union.{0 0} real
              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                 (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                    (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                    s))
              (λ
               (H :
                 @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                   (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                      (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                      s)), @set.Ioo.{0} real real.preorder (c i) (d i)))) →
    @has_le.le.{0} ennreal
      (@preorder.to_has_le.{0} ennreal
         (@partial_order.to_preorder.{0} ennreal
            (@ordered_comm_monoid.to_partial_order.{0} ennreal
               (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                  (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                     ennreal.canonically_ordered_comm_semiring_1)))))
      (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
         (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
      (@finset.sum.{0 0} nat ennreal
         (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
            (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
               (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                  ennreal.canonically_ordered_comm_semiring_1)))
         s
         (λ (i : nat),
            @coe.{1 1} nnreal ennreal
              (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
              (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (d i) (c i)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>108    refine λ s, finset.strong_induction_on s (λ s IH b cv, _),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='finset.strong_induction_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/finset.lean&#x27;, &#x27;line&#x27;: 1274, &#x27;column&#x27;: 26}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} {p : finset.{0} α → Prop} (s : finset.{0} α), (∀ (s : finset.{0} α), (∀ (t : finset.{0} α), @has_ssubset.ssubset.{0} (finset.{0} α) (@finset.has_ssubset.{0} α) t s → p t) → p s) → p s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a : real,
c d : nat → real
⊢ ∀ (s : finset.{0} nat) (b : real),
    @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
      (@set.Union.{0 1} real nat
         (λ (i : nat),
            @set.Union.{0 0} real
              (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                 (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                    (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                    s))
              (λ
               (H :
                 @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                   (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                      (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                      s)), @set.Ioo.{0} real real.preorder (c i) (d i)))) →
    @has_le.le.{0} ennreal
      (@preorder.to_has_le.{0} ennreal
         (@partial_order.to_preorder.{0} ennreal
            (@ordered_comm_monoid.to_partial_order.{0} ennreal
               (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                  (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                     ennreal.canonically_ordered_comm_semiring_1)))))
      (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
         (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
      (@finset.sum.{0 0} nat ennreal
         (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
            (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
               (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                  ennreal.canonically_ordered_comm_semiring_1)))
         s
         (λ (i : nat),
            @coe.{1 1} nnreal ennreal
              (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
              (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (d i) (c i)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a : real,
c d : nat → real,
s s : finset.{0} nat,
IH :
  ∀ (t : finset.{0} nat),
    @has_ssubset.ssubset.{0} (finset.{0} nat) (@finset.has_ssubset.{0} nat) t s →
    ∀ (b : real),
      @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
        (@set.Union.{0 1} real nat
           (λ (i : nat),
              @set.Union.{0 0} real
                (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                   (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                      (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                      t))
                (λ
                 (H :
                   @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                     (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                        (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                        t)), @set.Ioo.{0} real real.preorder (c i) (d i)))) →
      @has_le.le.{0} ennreal
        (@preorder.to_has_le.{0} ennreal
           (@partial_order.to_preorder.{0} ennreal
              (@ordered_comm_monoid.to_partial_order.{0} ennreal
                 (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                    (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                       ennreal.canonically_ordered_comm_semiring_1)))))
        (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
           (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
        (@finset.sum.{0 0} nat ennreal
           (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
              (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                 (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                    ennreal.canonically_ordered_comm_semiring_1)))
           t
           (λ (i : nat),
              @coe.{1 1} nnreal ennreal
                (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
                (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (d i) (c i))))),
b : real,
cv :
  @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
    (@set.Union.{0 1} real nat
       (λ (i : nat),
          @set.Union.{0 0} real
            (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
               (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                  (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                  s))
            (λ
             (H :
               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                 (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                    (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                    s)), @set.Ioo.{0} real real.preorder (c i) (d i))))
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
    (@finset.sum.{0 0} nat ennreal
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       s
       (λ (i : nat),
          @coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
            (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (d i) (c i)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>109    cases le_total b a with ab ab,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='le_total'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 57, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : linear_order.{0} α] (a b : α), or (@has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@linear_order.to_partial_order.{0} α _inst_1))) a b) (@has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@linear_order.to_partial_order.{0} α _inst_1))) b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a : real,
c d : nat → real,
s s : finset.{0} nat,
IH :
  ∀ (t : finset.{0} nat),
    @has_ssubset.ssubset.{0} (finset.{0} nat) (@finset.has_ssubset.{0} nat) t s →
    ∀ (b : real),
      @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
        (@set.Union.{0 1} real nat
           (λ (i : nat),
              @set.Union.{0 0} real
                (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                   (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                      (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                      t))
                (λ
                 (H :
                   @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                     (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                        (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                        t)), @set.Ioo.{0} real real.preorder (c i) (d i)))) →
      @has_le.le.{0} ennreal
        (@preorder.to_has_le.{0} ennreal
           (@partial_order.to_preorder.{0} ennreal
              (@ordered_comm_monoid.to_partial_order.{0} ennreal
                 (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                    (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                       ennreal.canonically_ordered_comm_semiring_1)))))
        (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
           (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
        (@finset.sum.{0 0} nat ennreal
           (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
              (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                 (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                    ennreal.canonically_ordered_comm_semiring_1)))
           t
           (λ (i : nat),
              @coe.{1 1} nnreal ennreal
                (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
                (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (d i) (c i))))),
b : real,
cv :
  @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
    (@set.Union.{0 1} real nat
       (λ (i : nat),
          @set.Union.{0 0} real
            (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
               (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                  (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                  s))
            (λ
             (H :
               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                 (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                    (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                    s)), @set.Ioo.{0} real real.preorder (c i) (d i))))
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
    (@finset.sum.{0 0} nat ennreal
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       s
       (λ (i : nat),
          @coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
            (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (d i) (c i)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
case or.inl
a : real,
c d : nat → real,
s s : finset.{0} nat,
IH :
  ∀ (t : finset.{0} nat),
    @has_ssubset.ssubset.{0} (finset.{0} nat) (@finset.has_ssubset.{0} nat) t s →
    ∀ (b : real),
      @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
        (@set.Union.{0 1} real nat
           (λ (i : nat),
              @set.Union.{0 0} real
                (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                   (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                      (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                      t))
                (λ
                 (H :
                   @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                     (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                        (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                        t)), @set.Ioo.{0} real real.preorder (c i) (d i)))) →
      @has_le.le.{0} ennreal
        (@preorder.to_has_le.{0} ennreal
           (@partial_order.to_preorder.{0} ennreal
              (@ordered_comm_monoid.to_partial_order.{0} ennreal
                 (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                    (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                       ennreal.canonically_ordered_comm_semiring_1)))))
        (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
           (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
        (@finset.sum.{0 0} nat ennreal
           (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
              (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                 (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                    ennreal.canonically_ordered_comm_semiring_1)))
           t
           (λ (i : nat),
              @coe.{1 1} nnreal ennreal
                (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
                (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (d i) (c i))))),
b : real,
cv :
  @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
    (@set.Union.{0 1} real nat
       (λ (i : nat),
          @set.Union.{0 0} real
            (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
               (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                  (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                  s))
            (λ
             (H :
               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                 (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                    (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                    s)), @set.Ioo.{0} real real.preorder (c i) (d i)))),
ab :
  @has_le.le.{0} real
    (@preorder.to_has_le.{0} real
       (@partial_order.to_preorder.{0} real (@linear_order.to_partial_order.{0} real real.linear_order)))
    b
    a
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
    (@finset.sum.{0 0} nat ennreal
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       s
       (λ (i : nat),
          @coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
            (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (d i) (c i)))))

case or.inr
a : real,
c d : nat → real,
s s : finset.{0} nat,
IH :
  ∀ (t : finset.{0} nat),
    @has_ssubset.ssubset.{0} (finset.{0} nat) (@finset.has_ssubset.{0} nat) t s →
    ∀ (b : real),
      @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
        (@set.Union.{0 1} real nat
           (λ (i : nat),
              @set.Union.{0 0} real
                (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                   (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                      (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                      t))
                (λ
                 (H :
                   @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                     (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                        (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                        t)), @set.Ioo.{0} real real.preorder (c i) (d i)))) →
      @has_le.le.{0} ennreal
        (@preorder.to_has_le.{0} ennreal
           (@partial_order.to_preorder.{0} ennreal
              (@ordered_comm_monoid.to_partial_order.{0} ennreal
                 (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                    (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                       ennreal.canonically_ordered_comm_semiring_1)))))
        (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
           (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
        (@finset.sum.{0 0} nat ennreal
           (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
              (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                 (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                    ennreal.canonically_ordered_comm_semiring_1)))
           t
           (λ (i : nat),
              @coe.{1 1} nnreal ennreal
                (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
                (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (d i) (c i))))),
b : real,
cv :
  @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
    (@set.Union.{0 1} real nat
       (λ (i : nat),
          @set.Union.{0 0} real
            (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
               (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                  (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                  s))
            (λ
             (H :
               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                 (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                    (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                    s)), @set.Ioo.{0} real real.preorder (c i) (d i)))),
ab :
  @has_le.le.{0} real
    (@preorder.to_has_le.{0} real
       (@partial_order.to_preorder.{0} real (@linear_order.to_partial_order.{0} real real.linear_order)))
    a
    b
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
    (@finset.sum.{0 0} nat ennreal
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       s
       (λ (i : nat),
          @coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
            (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (d i) (c i)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>110    { rw nnreal.of_real_of_nonpos (sub_nonpos.2 ab), simp },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='nnreal.of_real_of_nonpos'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='sub_nonpos'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='ab'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/nnreal.lean&#x27;, &#x27;line&#x27;: 282, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/ordered_group.lean&#x27;, &#x27;line&#x27;: 570, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {r : real}, @has_le.le.{0} real real.has_le r (@has_zero.zero.{0} real (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))) → @eq.{1} nnreal (nnreal.of_real r) (@has_zero.zero.{0} nnreal nnreal.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type} [_inst_1 : ordered_comm_group.{0} α] {a b : α}, iff (@has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@ordered_comm_monoid.to_partial_order.{0} α (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} α (@ordered_comm_group.to_ordered_cancel_comm_monoid.{0} α _inst_1))))) (@has_sub.sub.{0} α (@add_group_has_sub.{0} α (@add_comm_group.to_add_group.{0} α (@ordered_comm_group.to_add_comm_group.{0} α _inst_1))) a b) (@has_zero.zero.{0} α (@add_monoid.to_has_zero.{0} α (@add_group.to_add_monoid.{0} α (@add_comm_group.to_add_group.{0} α (@ordered_comm_group.to_add_comm_group.{0} α _inst_1)))))) (@has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@ordered_comm_monoid.to_partial_order.{0} α (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} α (@ordered_comm_group.to_ordered_cancel_comm_monoid.{0} α _inst_1))))) a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_le.le.{0} real (@preorder.to_has_le.{0} real (@partial_order.to_preorder.{0} real (@linear_order.to_partial_order.{0} real real.linear_order))) b a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
case or.inl
a : real,
c d : nat → real,
s s : finset.{0} nat,
IH :
  ∀ (t : finset.{0} nat),
    @has_ssubset.ssubset.{0} (finset.{0} nat) (@finset.has_ssubset.{0} nat) t s →
    ∀ (b : real),
      @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
        (@set.Union.{0 1} real nat
           (λ (i : nat),
              @set.Union.{0 0} real
                (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                   (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                      (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                      t))
                (λ
                 (H :
                   @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                     (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                        (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                        t)), @set.Ioo.{0} real real.preorder (c i) (d i)))) →
      @has_le.le.{0} ennreal
        (@preorder.to_has_le.{0} ennreal
           (@partial_order.to_preorder.{0} ennreal
              (@ordered_comm_monoid.to_partial_order.{0} ennreal
                 (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                    (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                       ennreal.canonically_ordered_comm_semiring_1)))))
        (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
           (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
        (@finset.sum.{0 0} nat ennreal
           (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
              (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                 (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                    ennreal.canonically_ordered_comm_semiring_1)))
           t
           (λ (i : nat),
              @coe.{1 1} nnreal ennreal
                (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
                (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (d i) (c i))))),
b : real,
cv :
  @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
    (@set.Union.{0 1} real nat
       (λ (i : nat),
          @set.Union.{0 0} real
            (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
               (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                  (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                  s))
            (λ
             (H :
               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                 (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                    (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                    s)), @set.Ioo.{0} real real.preorder (c i) (d i)))),
ab :
  @has_le.le.{0} real
    (@preorder.to_has_le.{0} real
       (@partial_order.to_preorder.{0} real (@linear_order.to_partial_order.{0} real real.linear_order)))
    b
    a
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
    (@finset.sum.{0 0} nat ennreal
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       s
       (λ (i : nat),
          @coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
            (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (d i) (c i)))))

case or.inr
a : real,
c d : nat → real,
s s : finset.{0} nat,
IH :
  ∀ (t : finset.{0} nat),
    @has_ssubset.ssubset.{0} (finset.{0} nat) (@finset.has_ssubset.{0} nat) t s →
    ∀ (b : real),
      @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
        (@set.Union.{0 1} real nat
           (λ (i : nat),
              @set.Union.{0 0} real
                (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                   (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                      (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                      t))
                (λ
                 (H :
                   @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                     (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                        (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                        t)), @set.Ioo.{0} real real.preorder (c i) (d i)))) →
      @has_le.le.{0} ennreal
        (@preorder.to_has_le.{0} ennreal
           (@partial_order.to_preorder.{0} ennreal
              (@ordered_comm_monoid.to_partial_order.{0} ennreal
                 (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                    (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                       ennreal.canonically_ordered_comm_semiring_1)))))
        (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
           (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
        (@finset.sum.{0 0} nat ennreal
           (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
              (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                 (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                    ennreal.canonically_ordered_comm_semiring_1)))
           t
           (λ (i : nat),
              @coe.{1 1} nnreal ennreal
                (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
                (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (d i) (c i))))),
b : real,
cv :
  @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
    (@set.Union.{0 1} real nat
       (λ (i : nat),
          @set.Union.{0 0} real
            (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
               (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                  (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                  s))
            (λ
             (H :
               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                 (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                    (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                    s)), @set.Ioo.{0} real real.preorder (c i) (d i)))),
ab :
  @has_le.le.{0} real
    (@preorder.to_has_le.{0} real
       (@partial_order.to_preorder.{0} real (@linear_order.to_partial_order.{0} real real.linear_order)))
    a
    b
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
    (@finset.sum.{0 0} nat ennreal
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       s
       (λ (i : nat),
          @coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
            (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (d i) (c i)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case or.inl
a : real,
c d : nat → real,
s s : finset.{0} nat,
IH :
  ∀ (t : finset.{0} nat),
    @has_ssubset.ssubset.{0} (finset.{0} nat) (@finset.has_ssubset.{0} nat) t s →
    ∀ (b : real),
      @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
        (@set.Union.{0 1} real nat
           (λ (i : nat),
              @set.Union.{0 0} real
                (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                   (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                      (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                      t))
                (λ
                 (H :
                   @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                     (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                        (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                        t)), @set.Ioo.{0} real real.preorder (c i) (d i)))) →
      @has_le.le.{0} ennreal
        (@preorder.to_has_le.{0} ennreal
           (@partial_order.to_preorder.{0} ennreal
              (@ordered_comm_monoid.to_partial_order.{0} ennreal
                 (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                    (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                       ennreal.canonically_ordered_comm_semiring_1)))))
        (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
           (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
        (@finset.sum.{0 0} nat ennreal
           (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
              (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                 (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                    ennreal.canonically_ordered_comm_semiring_1)))
           t
           (λ (i : nat),
              @coe.{1 1} nnreal ennreal
                (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
                (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (d i) (c i))))),
b : real,
cv :
  @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
    (@set.Union.{0 1} real nat
       (λ (i : nat),
          @set.Union.{0 0} real
            (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
               (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                  (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                  s))
            (λ
             (H :
               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                 (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                    (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                    s)), @set.Ioo.{0} real real.preorder (c i) (d i)))),
ab :
  @has_le.le.{0} real
    (@preorder.to_has_le.{0} real
       (@partial_order.to_preorder.{0} real (@linear_order.to_partial_order.{0} real real.linear_order)))
    b
    a
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
    (@finset.sum.{0 0} nat ennreal
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       s
       (λ (i : nat),
          @coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
            (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (d i) (c i)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case or.inl
a : real,
c d : nat → real,
s s : finset.{0} nat,
IH :
  ∀ (t : finset.{0} nat),
    @has_ssubset.ssubset.{0} (finset.{0} nat) (@finset.has_ssubset.{0} nat) t s →
    ∀ (b : real),
      @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
        (@set.Union.{0 1} real nat
           (λ (i : nat),
              @set.Union.{0 0} real
                (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                   (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                      (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                      t))
                (λ
                 (H :
                   @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                     (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                        (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                        t)), @set.Ioo.{0} real real.preorder (c i) (d i)))) →
      @has_le.le.{0} ennreal
        (@preorder.to_has_le.{0} ennreal
           (@partial_order.to_preorder.{0} ennreal
              (@ordered_comm_monoid.to_partial_order.{0} ennreal
                 (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                    (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                       ennreal.canonically_ordered_comm_semiring_1)))))
        (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
           (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
        (@finset.sum.{0 0} nat ennreal
           (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
              (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                 (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                    ennreal.canonically_ordered_comm_semiring_1)))
           t
           (λ (i : nat),
              @coe.{1 1} nnreal ennreal
                (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
                (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (d i) (c i))))),
b : real,
cv :
  @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
    (@set.Union.{0 1} real nat
       (λ (i : nat),
          @set.Union.{0 0} real
            (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
               (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                  (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                  s))
            (λ
             (H :
               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                 (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                    (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                    s)), @set.Ioo.{0} real real.preorder (c i) (d i)))),
ab :
  @has_le.le.{0} real
    (@preorder.to_has_le.{0} real
       (@partial_order.to_preorder.{0} real (@linear_order.to_partial_order.{0} real real.linear_order)))
    b
    a
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (@has_zero.zero.{0} nnreal nnreal.has_zero))
    (@finset.sum.{0 0} nat ennreal
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       s
       (λ (i : nat),
          @coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
            (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (d i) (c i)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case or.inr
a : real,
c d : nat → real,
s s : finset.{0} nat,
IH :
  ∀ (t : finset.{0} nat),
    @has_ssubset.ssubset.{0} (finset.{0} nat) (@finset.has_ssubset.{0} nat) t s →
    ∀ (b : real),
      @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
        (@set.Union.{0 1} real nat
           (λ (i : nat),
              @set.Union.{0 0} real
                (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                   (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                      (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                      t))
                (λ
                 (H :
                   @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                     (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                        (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                        t)), @set.Ioo.{0} real real.preorder (c i) (d i)))) →
      @has_le.le.{0} ennreal
        (@preorder.to_has_le.{0} ennreal
           (@partial_order.to_preorder.{0} ennreal
              (@ordered_comm_monoid.to_partial_order.{0} ennreal
                 (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                    (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                       ennreal.canonically_ordered_comm_semiring_1)))))
        (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
           (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
        (@finset.sum.{0 0} nat ennreal
           (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
              (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                 (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                    ennreal.canonically_ordered_comm_semiring_1)))
           t
           (λ (i : nat),
              @coe.{1 1} nnreal ennreal
                (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
                (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (d i) (c i))))),
b : real,
cv :
  @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
    (@set.Union.{0 1} real nat
       (λ (i : nat),
          @set.Union.{0 0} real
            (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
               (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                  (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                  s))
            (λ
             (H :
               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                 (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                    (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                    s)), @set.Ioo.{0} real real.preorder (c i) (d i)))),
ab :
  @has_le.le.{0} real
    (@preorder.to_has_le.{0} real
       (@partial_order.to_preorder.{0} real (@linear_order.to_partial_order.{0} real real.linear_order)))
    a
    b
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
    (@finset.sum.{0 0} nat ennreal
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       s
       (λ (i : nat),
          @coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
            (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (d i) (c i)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>111    have := cv ⟨ab, le_refl _⟩, simp at this,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='cv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ab'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='le_refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b) (@set.Union.{0 1} real nat (λ (i : nat), @set.Union.{0 0} real (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i (@coe.{1 1} (finset.{0} nat) (set.{0} nat) (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat)) s)) (λ (H : @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i (@coe.{1 1} (finset.{0} nat) (set.{0} nat) (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat)) s)), @set.Ioo.{0} real real.preorder (c i) (d i))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_le.le.{0} real (@preorder.to_has_le.{0} real (@partial_order.to_preorder.{0} real (@linear_order.to_partial_order.{0} real real.linear_order))) a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : preorder.{0} α] (a : α), @has_le.le.{0} α (@preorder.to_has_le.{0} α _inst_1) a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case or.inr
a : real,
c d : nat → real,
s s : finset.{0} nat,
IH :
  ∀ (t : finset.{0} nat),
    @has_ssubset.ssubset.{0} (finset.{0} nat) (@finset.has_ssubset.{0} nat) t s →
    ∀ (b : real),
      @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
        (@set.Union.{0 1} real nat
           (λ (i : nat),
              @set.Union.{0 0} real
                (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                   (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                      (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                      t))
                (λ
                 (H :
                   @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                     (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                        (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                        t)), @set.Ioo.{0} real real.preorder (c i) (d i)))) →
      @has_le.le.{0} ennreal
        (@preorder.to_has_le.{0} ennreal
           (@partial_order.to_preorder.{0} ennreal
              (@ordered_comm_monoid.to_partial_order.{0} ennreal
                 (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                    (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                       ennreal.canonically_ordered_comm_semiring_1)))))
        (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
           (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
        (@finset.sum.{0 0} nat ennreal
           (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
              (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                 (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                    ennreal.canonically_ordered_comm_semiring_1)))
           t
           (λ (i : nat),
              @coe.{1 1} nnreal ennreal
                (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
                (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (d i) (c i))))),
b : real,
cv :
  @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
    (@set.Union.{0 1} real nat
       (λ (i : nat),
          @set.Union.{0 0} real
            (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
               (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                  (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                  s))
            (λ
             (H :
               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                 (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                    (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                    s)), @set.Ioo.{0} real real.preorder (c i) (d i)))),
ab :
  @has_le.le.{0} real
    (@preorder.to_has_le.{0} real
       (@partial_order.to_preorder.{0} real (@linear_order.to_partial_order.{0} real real.linear_order)))
    a
    b
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
    (@finset.sum.{0 0} nat ennreal
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       s
       (λ (i : nat),
          @coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
            (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (d i) (c i)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a : real,
c d : nat → real,
s s : finset.{0} nat,
IH :
  ∀ (t : finset.{0} nat),
    @has_ssubset.ssubset.{0} (finset.{0} nat) (@finset.has_ssubset.{0} nat) t s →
    ∀ (b : real),
      @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
        (@set.Union.{0 1} real nat
           (λ (i : nat),
              @set.Union.{0 0} real
                (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                   (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                      (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                      t))
                (λ
                 (H :
                   @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                     (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                        (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                        t)), @set.Ioo.{0} real real.preorder (c i) (d i)))) →
      @has_le.le.{0} ennreal
        (@preorder.to_has_le.{0} ennreal
           (@partial_order.to_preorder.{0} ennreal
              (@ordered_comm_monoid.to_partial_order.{0} ennreal
                 (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                    (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                       ennreal.canonically_ordered_comm_semiring_1)))))
        (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
           (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
        (@finset.sum.{0 0} nat ennreal
           (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
              (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                 (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                    ennreal.canonically_ordered_comm_semiring_1)))
           t
           (λ (i : nat),
              @coe.{1 1} nnreal ennreal
                (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
                (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (d i) (c i))))),
b : real,
cv :
  @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
    (@set.Union.{0 1} real nat
       (λ (i : nat),
          @set.Union.{0 0} real
            (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
               (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                  (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                  s))
            (λ
             (H :
               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                 (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                    (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                    s)), @set.Ioo.{0} real real.preorder (c i) (d i)))),
ab :
  @has_le.le.{0} real
    (@preorder.to_has_le.{0} real
       (@partial_order.to_preorder.{0} real (@linear_order.to_partial_order.{0} real real.linear_order)))
    a
    b,
this :
  @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) b
    (@set.Union.{0 1} real nat
       (λ (i : nat),
          @set.Union.{0 0} real
            (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
               (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                  (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                  s))
            (λ
             (H :
               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                 (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                    (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                    s)), @set.Ioo.{0} real real.preorder (c i) (d i))))
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
    (@finset.sum.{0 0} nat ennreal
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       s
       (λ (i : nat),
          @coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
            (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (d i) (c i)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a : real,
c d : nat → real,
s s : finset.{0} nat,
IH :
  ∀ (t : finset.{0} nat),
    @has_ssubset.ssubset.{0} (finset.{0} nat) (@finset.has_ssubset.{0} nat) t s →
    ∀ (b : real),
      @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
        (@set.Union.{0 1} real nat
           (λ (i : nat),
              @set.Union.{0 0} real
                (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                   (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                      (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                      t))
                (λ
                 (H :
                   @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                     (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                        (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                        t)), @set.Ioo.{0} real real.preorder (c i) (d i)))) →
      @has_le.le.{0} ennreal
        (@preorder.to_has_le.{0} ennreal
           (@partial_order.to_preorder.{0} ennreal
              (@ordered_comm_monoid.to_partial_order.{0} ennreal
                 (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                    (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                       ennreal.canonically_ordered_comm_semiring_1)))))
        (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
           (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
        (@finset.sum.{0 0} nat ennreal
           (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
              (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                 (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                    ennreal.canonically_ordered_comm_semiring_1)))
           t
           (λ (i : nat),
              @coe.{1 1} nnreal ennreal
                (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
                (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (d i) (c i))))),
b : real,
cv :
  @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
    (@set.Union.{0 1} real nat
       (λ (i : nat),
          @set.Union.{0 0} real
            (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
               (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                  (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                  s))
            (λ
             (H :
               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                 (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                    (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                    s)), @set.Ioo.{0} real real.preorder (c i) (d i)))),
ab :
  @has_le.le.{0} real
    (@preorder.to_has_le.{0} real
       (@partial_order.to_preorder.{0} real (@linear_order.to_partial_order.{0} real real.linear_order)))
    a
    b,
this :
  @Exists.{1} nat
    (λ (i : nat),
       and (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i s)
         (and (@has_lt.lt.{0} real (@preorder.to_has_lt.{0} real real.preorder) (c i) b)
            (@has_lt.lt.{0} real (@preorder.to_has_lt.{0} real real.preorder) b (d i))))
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
    (@finset.sum.{0 0} nat ennreal
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       s
       (λ (i : nat),
          @coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
            (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (d i) (c i)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>112    rcases this with ⟨i, is, cb, bd⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@Exists.{1} nat (λ (i : nat), and (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i s) (and (@has_lt.lt.{0} real (@preorder.to_has_lt.{0} real real.preorder) (c i) b) (@has_lt.lt.{0} real (@preorder.to_has_lt.{0} real real.preorder) b (d i))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a : real,
c d : nat → real,
s s : finset.{0} nat,
IH :
  ∀ (t : finset.{0} nat),
    @has_ssubset.ssubset.{0} (finset.{0} nat) (@finset.has_ssubset.{0} nat) t s →
    ∀ (b : real),
      @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
        (@set.Union.{0 1} real nat
           (λ (i : nat),
              @set.Union.{0 0} real
                (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                   (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                      (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                      t))
                (λ
                 (H :
                   @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                     (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                        (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                        t)), @set.Ioo.{0} real real.preorder (c i) (d i)))) →
      @has_le.le.{0} ennreal
        (@preorder.to_has_le.{0} ennreal
           (@partial_order.to_preorder.{0} ennreal
              (@ordered_comm_monoid.to_partial_order.{0} ennreal
                 (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                    (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                       ennreal.canonically_ordered_comm_semiring_1)))))
        (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
           (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
        (@finset.sum.{0 0} nat ennreal
           (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
              (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                 (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                    ennreal.canonically_ordered_comm_semiring_1)))
           t
           (λ (i : nat),
              @coe.{1 1} nnreal ennreal
                (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
                (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (d i) (c i))))),
b : real,
cv :
  @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
    (@set.Union.{0 1} real nat
       (λ (i : nat),
          @set.Union.{0 0} real
            (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
               (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                  (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                  s))
            (λ
             (H :
               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                 (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                    (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                    s)), @set.Ioo.{0} real real.preorder (c i) (d i)))),
ab :
  @has_le.le.{0} real
    (@preorder.to_has_le.{0} real
       (@partial_order.to_preorder.{0} real (@linear_order.to_partial_order.{0} real real.linear_order)))
    a
    b,
this :
  @Exists.{1} nat
    (λ (i : nat),
       and (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i s)
         (and (@has_lt.lt.{0} real (@preorder.to_has_lt.{0} real real.preorder) (c i) b)
            (@has_lt.lt.{0} real (@preorder.to_has_lt.{0} real real.preorder) b (d i))))
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
    (@finset.sum.{0 0} nat ennreal
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       s
       (λ (i : nat),
          @coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
            (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (d i) (c i)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a : real,
c d : nat → real,
s s : finset.{0} nat,
IH :
  ∀ (t : finset.{0} nat),
    @has_ssubset.ssubset.{0} (finset.{0} nat) (@finset.has_ssubset.{0} nat) t s →
    ∀ (b : real),
      @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
        (@set.Union.{0 1} real nat
           (λ (i : nat),
              @set.Union.{0 0} real
                (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                   (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                      (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                      t))
                (λ
                 (H :
                   @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                     (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                        (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                        t)), @set.Ioo.{0} real real.preorder (c i) (d i)))) →
      @has_le.le.{0} ennreal
        (@preorder.to_has_le.{0} ennreal
           (@partial_order.to_preorder.{0} ennreal
              (@ordered_comm_monoid.to_partial_order.{0} ennreal
                 (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                    (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                       ennreal.canonically_ordered_comm_semiring_1)))))
        (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
           (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
        (@finset.sum.{0 0} nat ennreal
           (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
              (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                 (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                    ennreal.canonically_ordered_comm_semiring_1)))
           t
           (λ (i : nat),
              @coe.{1 1} nnreal ennreal
                (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
                (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (d i) (c i))))),
b : real,
cv :
  @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
    (@set.Union.{0 1} real nat
       (λ (i : nat),
          @set.Union.{0 0} real
            (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
               (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                  (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                  s))
            (λ
             (H :
               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                 (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                    (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                    s)), @set.Ioo.{0} real real.preorder (c i) (d i)))),
ab :
  @has_le.le.{0} real
    (@preorder.to_has_le.{0} real
       (@partial_order.to_preorder.{0} real (@linear_order.to_partial_order.{0} real real.linear_order)))
    a
    b,
i : nat,
is : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i s,
cb : @has_lt.lt.{0} real (@preorder.to_has_lt.{0} real real.preorder) (c i) b,
bd : @has_lt.lt.{0} real (@preorder.to_has_lt.{0} real real.preorder) b (d i)
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
    (@finset.sum.{0 0} nat ennreal
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       s
       (λ (i : nat),
          @coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
            (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (d i) (c i)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>113    rw [← finset.insert_erase is] at cv ⊢,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='finset.insert_erase'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='is'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/finset.lean&#x27;, &#x27;line&#x27;: 523, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : decidable_eq.{1} α] {a : α} {s : finset.{0} α}, @has_mem.mem.{0 0} α (finset.{0} α) (@finset.has_mem.{0} α) a s → @eq.{1} (finset.{0} α) (@insert.{0 0} α (finset.{0} α) (@finset.has_insert.{0} α (λ (a b : α), _inst_1 a b)) a (@finset.erase.{0} α (λ (a b : α), _inst_1 a b) s a)) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a : real,
c d : nat → real,
s s : finset.{0} nat,
IH :
  ∀ (t : finset.{0} nat),
    @has_ssubset.ssubset.{0} (finset.{0} nat) (@finset.has_ssubset.{0} nat) t s →
    ∀ (b : real),
      @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
        (@set.Union.{0 1} real nat
           (λ (i : nat),
              @set.Union.{0 0} real
                (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                   (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                      (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                      t))
                (λ
                 (H :
                   @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                     (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                        (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                        t)), @set.Ioo.{0} real real.preorder (c i) (d i)))) →
      @has_le.le.{0} ennreal
        (@preorder.to_has_le.{0} ennreal
           (@partial_order.to_preorder.{0} ennreal
              (@ordered_comm_monoid.to_partial_order.{0} ennreal
                 (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                    (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                       ennreal.canonically_ordered_comm_semiring_1)))))
        (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
           (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
        (@finset.sum.{0 0} nat ennreal
           (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
              (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                 (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                    ennreal.canonically_ordered_comm_semiring_1)))
           t
           (λ (i : nat),
              @coe.{1 1} nnreal ennreal
                (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
                (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (d i) (c i))))),
b : real,
cv :
  @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
    (@set.Union.{0 1} real nat
       (λ (i : nat),
          @set.Union.{0 0} real
            (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
               (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                  (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                  s))
            (λ
             (H :
               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                 (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                    (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                    s)), @set.Ioo.{0} real real.preorder (c i) (d i)))),
ab :
  @has_le.le.{0} real
    (@preorder.to_has_le.{0} real
       (@partial_order.to_preorder.{0} real (@linear_order.to_partial_order.{0} real real.linear_order)))
    a
    b,
i : nat,
is : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i s,
cb : @has_lt.lt.{0} real (@preorder.to_has_lt.{0} real real.preorder) (c i) b,
bd : @has_lt.lt.{0} real (@preorder.to_has_lt.{0} real real.preorder) b (d i)
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
    (@finset.sum.{0 0} nat ennreal
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       s
       (λ (i : nat),
          @coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
            (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (d i) (c i)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a : real,
c d : nat → real,
s s : finset.{0} nat,
IH :
  ∀ (t : finset.{0} nat),
    @has_ssubset.ssubset.{0} (finset.{0} nat) (@finset.has_ssubset.{0} nat) t s →
    ∀ (b : real),
      @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
        (@set.Union.{0 1} real nat
           (λ (i : nat),
              @set.Union.{0 0} real
                (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                   (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                      (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                      t))
                (λ
                 (H :
                   @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                     (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                        (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                        t)), @set.Ioo.{0} real real.preorder (c i) (d i)))) →
      @has_le.le.{0} ennreal
        (@preorder.to_has_le.{0} ennreal
           (@partial_order.to_preorder.{0} ennreal
              (@ordered_comm_monoid.to_partial_order.{0} ennreal
                 (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                    (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                       ennreal.canonically_ordered_comm_semiring_1)))))
        (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
           (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
        (@finset.sum.{0 0} nat ennreal
           (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
              (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                 (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                    ennreal.canonically_ordered_comm_semiring_1)))
           t
           (λ (i : nat),
              @coe.{1 1} nnreal ennreal
                (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
                (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (d i) (c i))))),
b : real,
ab :
  @has_le.le.{0} real
    (@preorder.to_has_le.{0} real
       (@partial_order.to_preorder.{0} real (@linear_order.to_partial_order.{0} real real.linear_order)))
    a
    b,
i : nat,
is : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i s,
cb : @has_lt.lt.{0} real (@preorder.to_has_lt.{0} real real.preorder) (c i) b,
bd : @has_lt.lt.{0} real (@preorder.to_has_lt.{0} real real.preorder) b (d i),
cv :
  @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
    (@set.Union.{0 1} real nat
       (λ (i_1 : nat),
          @set.Union.{0 0} real
            (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i_1
               (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                  (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                  (@insert.{0 0} nat (finset.{0} nat)
                     (@finset.has_insert.{0} nat (λ (a b : nat), (λ (a b : nat), nat.decidable_eq a b) a b))
                     i
                     (@finset.erase.{0} nat (λ (a b : nat), (λ (a b : nat), nat.decidable_eq a b) a b) s i))))
            (λ
             (H :
               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i_1
                 (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                    (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                    (@insert.{0 0} nat (finset.{0} nat)
                       (@finset.has_insert.{0} nat (λ (a b : nat), (λ (a b : nat), nat.decidable_eq a b) a b))
                       i
                       (@finset.erase.{0} nat (λ (a b : nat), (λ (a b : nat), nat.decidable_eq a b) a b) s i)))),
               @set.Ioo.{0} real real.preorder (c i_1) (d i_1))))
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
    (@finset.sum.{0 0} nat ennreal
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       (@insert.{0 0} nat (finset.{0} nat)
          (@finset.has_insert.{0} nat (λ (a b : nat), (λ (a b : nat), nat.decidable_eq a b) a b))
          i
          (@finset.erase.{0} nat (λ (a b : nat), (λ (a b : nat), nat.decidable_eq a b) a b) s i))
       (λ (i : nat),
          @coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
            (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (d i) (c i)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a : real,
c d : nat → real,
s s : finset.{0} nat,
IH :
  ∀ (t : finset.{0} nat),
    @has_ssubset.ssubset.{0} (finset.{0} nat) (@finset.has_ssubset.{0} nat) t s →
    ∀ (b : real),
      @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
        (@set.Union.{0 1} real nat
           (λ (i : nat),
              @set.Union.{0 0} real
                (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                   (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                      (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                      t))
                (λ
                 (H :
                   @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                     (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                        (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                        t)), @set.Ioo.{0} real real.preorder (c i) (d i)))) →
      @has_le.le.{0} ennreal
        (@preorder.to_has_le.{0} ennreal
           (@partial_order.to_preorder.{0} ennreal
              (@ordered_comm_monoid.to_partial_order.{0} ennreal
                 (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                    (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                       ennreal.canonically_ordered_comm_semiring_1)))))
        (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
           (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
        (@finset.sum.{0 0} nat ennreal
           (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
              (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                 (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                    ennreal.canonically_ordered_comm_semiring_1)))
           t
           (λ (i : nat),
              @coe.{1 1} nnreal ennreal
                (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
                (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (d i) (c i))))),
b : real,
cv :
  @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
    (@set.Union.{0 1} real nat
       (λ (i : nat),
          @set.Union.{0 0} real
            (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
               (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                  (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                  s))
            (λ
             (H :
               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                 (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                    (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                    s)), @set.Ioo.{0} real real.preorder (c i) (d i)))),
ab :
  @has_le.le.{0} real
    (@preorder.to_has_le.{0} real
       (@partial_order.to_preorder.{0} real (@linear_order.to_partial_order.{0} real real.linear_order)))
    a
    b,
i : nat,
is : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i s,
cb : @has_lt.lt.{0} real (@preorder.to_has_lt.{0} real real.preorder) (c i) b,
bd : @has_lt.lt.{0} real (@preorder.to_has_lt.{0} real real.preorder) b (d i)
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
    (@finset.sum.{0 0} nat ennreal
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       s
       (λ (i : nat),
          @coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
            (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (d i) (c i)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a : real,
c d : nat → real,
s s : finset.{0} nat,
IH :
  ∀ (t : finset.{0} nat),
    @has_ssubset.ssubset.{0} (finset.{0} nat) (@finset.has_ssubset.{0} nat) t s →
    ∀ (b : real),
      @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
        (@set.Union.{0 1} real nat
           (λ (i : nat),
              @set.Union.{0 0} real
                (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                   (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                      (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                      t))
                (λ
                 (H :
                   @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                     (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                        (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                        t)), @set.Ioo.{0} real real.preorder (c i) (d i)))) →
      @has_le.le.{0} ennreal
        (@preorder.to_has_le.{0} ennreal
           (@partial_order.to_preorder.{0} ennreal
              (@ordered_comm_monoid.to_partial_order.{0} ennreal
                 (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                    (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                       ennreal.canonically_ordered_comm_semiring_1)))))
        (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
           (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
        (@finset.sum.{0 0} nat ennreal
           (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
              (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                 (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                    ennreal.canonically_ordered_comm_semiring_1)))
           t
           (λ (i : nat),
              @coe.{1 1} nnreal ennreal
                (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
                (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (d i) (c i))))),
b : real,
ab :
  @has_le.le.{0} real
    (@preorder.to_has_le.{0} real
       (@partial_order.to_preorder.{0} real (@linear_order.to_partial_order.{0} real real.linear_order)))
    a
    b,
i : nat,
is : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i s,
cb : @has_lt.lt.{0} real (@preorder.to_has_lt.{0} real real.preorder) (c i) b,
bd : @has_lt.lt.{0} real (@preorder.to_has_lt.{0} real real.preorder) b (d i),
cv :
  @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
    (@set.Union.{0 1} real nat
       (λ (i_1 : nat),
          @set.Union.{0 0} real
            (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i_1
               (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                  (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                  (@insert.{0 0} nat (finset.{0} nat)
                     (@finset.has_insert.{0} nat (λ (a b : nat), (λ (a b : nat), nat.decidable_eq a b) a b))
                     i
                     (@finset.erase.{0} nat (λ (a b : nat), (λ (a b : nat), nat.decidable_eq a b) a b) s i))))
            (λ
             (H :
               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i_1
                 (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                    (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                    (@insert.{0 0} nat (finset.{0} nat)
                       (@finset.has_insert.{0} nat (λ (a b : nat), (λ (a b : nat), nat.decidable_eq a b) a b))
                       i
                       (@finset.erase.{0} nat (λ (a b : nat), (λ (a b : nat), nat.decidable_eq a b) a b) s i)))),
               @set.Ioo.{0} real real.preorder (c i_1) (d i_1))))
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
    (@finset.sum.{0 0} nat ennreal
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       (@insert.{0 0} nat (finset.{0} nat)
          (@finset.has_insert.{0} nat (λ (a b : nat), (λ (a b : nat), nat.decidable_eq a b) a b))
          i
          (@finset.erase.{0} nat (λ (a b : nat), (λ (a b : nat), nat.decidable_eq a b) a b) s i))
       (λ (i : nat),
          @coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
            (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (d i) (c i)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>114    rw [finset.coe_insert, bUnion_insert] at cv,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='finset.coe_insert'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.bUnion_insert'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/finset.lean&#x27;, &#x27;line&#x27;: 227, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/lattice.lean&#x27;, &#x27;line&#x27;: 298, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : decidable_eq.{1} α] (a : α) (s : finset.{0} α), @eq.{1} (set.{0} α) (@coe.{1 1} (finset.{0} α) (set.{0} α) (@lift_base.{1 1} (finset.{0} α) (set.{0} α) (@finset.has_lift.{0} α)) (@insert.{0 0} α (finset.{0} α) (@finset.has_insert.{0} α (λ (a b : α), _inst_1 a b)) a s)) (@insert.{0 0} α (set.{0} α) (@set.has_insert.{0} α) a (@coe.{1 1} (finset.{0} α) (set.{0} α) (@lift_base.{1 1} (finset.{0} α) (set.{0} α) (@finset.has_lift.{0} α)) s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type} (a : α) (s : set.{0} α) (t : α → set.{0} β), @eq.{1} (set.{0} β) (@set.Union.{0 1} β α (λ (x : α), @set.Union.{0 0} β (@has_mem.mem.{0 0} α (set.{0} α) (@set.has_mem.{0} α) x (@insert.{0 0} α (set.{0} α) (@set.has_insert.{0} α) a s)) (λ (H : @has_mem.mem.{0 0} α (set.{0} α) (@set.has_mem.{0} α) x (@insert.{0 0} α (set.{0} α) (@set.has_insert.{0} α) a s)), t x))) (@has_union.union.{0} (set.{0} β) (@set.has_union.{0} β) (t a) (@set.Union.{0 1} β α (λ (x : α), @set.Union.{0 0} β (@has_mem.mem.{0 0} α (set.{0} α) (@set.has_mem.{0} α) x s) (λ (H : @has_mem.mem.{0 0} α (set.{0} α) (@set.has_mem.{0} α) x s), t x))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a : real,
c d : nat → real,
s s : finset.{0} nat,
IH :
  ∀ (t : finset.{0} nat),
    @has_ssubset.ssubset.{0} (finset.{0} nat) (@finset.has_ssubset.{0} nat) t s →
    ∀ (b : real),
      @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
        (@set.Union.{0 1} real nat
           (λ (i : nat),
              @set.Union.{0 0} real
                (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                   (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                      (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                      t))
                (λ
                 (H :
                   @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                     (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                        (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                        t)), @set.Ioo.{0} real real.preorder (c i) (d i)))) →
      @has_le.le.{0} ennreal
        (@preorder.to_has_le.{0} ennreal
           (@partial_order.to_preorder.{0} ennreal
              (@ordered_comm_monoid.to_partial_order.{0} ennreal
                 (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                    (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                       ennreal.canonically_ordered_comm_semiring_1)))))
        (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
           (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
        (@finset.sum.{0 0} nat ennreal
           (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
              (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                 (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                    ennreal.canonically_ordered_comm_semiring_1)))
           t
           (λ (i : nat),
              @coe.{1 1} nnreal ennreal
                (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
                (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (d i) (c i))))),
b : real,
ab :
  @has_le.le.{0} real
    (@preorder.to_has_le.{0} real
       (@partial_order.to_preorder.{0} real (@linear_order.to_partial_order.{0} real real.linear_order)))
    a
    b,
i : nat,
is : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i s,
cb : @has_lt.lt.{0} real (@preorder.to_has_lt.{0} real real.preorder) (c i) b,
bd : @has_lt.lt.{0} real (@preorder.to_has_lt.{0} real real.preorder) b (d i),
cv :
  @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
    (@set.Union.{0 1} real nat
       (λ (i_1 : nat),
          @set.Union.{0 0} real
            (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i_1
               (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                  (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                  (@insert.{0 0} nat (finset.{0} nat)
                     (@finset.has_insert.{0} nat (λ (a b : nat), (λ (a b : nat), nat.decidable_eq a b) a b))
                     i
                     (@finset.erase.{0} nat (λ (a b : nat), (λ (a b : nat), nat.decidable_eq a b) a b) s i))))
            (λ
             (H :
               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i_1
                 (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                    (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                    (@insert.{0 0} nat (finset.{0} nat)
                       (@finset.has_insert.{0} nat (λ (a b : nat), (λ (a b : nat), nat.decidable_eq a b) a b))
                       i
                       (@finset.erase.{0} nat (λ (a b : nat), (λ (a b : nat), nat.decidable_eq a b) a b) s i)))),
               @set.Ioo.{0} real real.preorder (c i_1) (d i_1))))
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
    (@finset.sum.{0 0} nat ennreal
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       (@insert.{0 0} nat (finset.{0} nat)
          (@finset.has_insert.{0} nat (λ (a b : nat), (λ (a b : nat), nat.decidable_eq a b) a b))
          i
          (@finset.erase.{0} nat (λ (a b : nat), (λ (a b : nat), nat.decidable_eq a b) a b) s i))
       (λ (i : nat),
          @coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
            (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (d i) (c i)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a : real,
c d : nat → real,
s s : finset.{0} nat,
IH :
  ∀ (t : finset.{0} nat),
    @has_ssubset.ssubset.{0} (finset.{0} nat) (@finset.has_ssubset.{0} nat) t s →
    ∀ (b : real),
      @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
        (@set.Union.{0 1} real nat
           (λ (i : nat),
              @set.Union.{0 0} real
                (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                   (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                      (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                      t))
                (λ
                 (H :
                   @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                     (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                        (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                        t)), @set.Ioo.{0} real real.preorder (c i) (d i)))) →
      @has_le.le.{0} ennreal
        (@preorder.to_has_le.{0} ennreal
           (@partial_order.to_preorder.{0} ennreal
              (@ordered_comm_monoid.to_partial_order.{0} ennreal
                 (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                    (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                       ennreal.canonically_ordered_comm_semiring_1)))))
        (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
           (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
        (@finset.sum.{0 0} nat ennreal
           (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
              (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                 (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                    ennreal.canonically_ordered_comm_semiring_1)))
           t
           (λ (i : nat),
              @coe.{1 1} nnreal ennreal
                (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
                (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (d i) (c i))))),
b : real,
ab :
  @has_le.le.{0} real
    (@preorder.to_has_le.{0} real
       (@partial_order.to_preorder.{0} real (@linear_order.to_partial_order.{0} real real.linear_order)))
    a
    b,
i : nat,
is : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i s,
cb : @has_lt.lt.{0} real (@preorder.to_has_lt.{0} real real.preorder) (c i) b,
bd : @has_lt.lt.{0} real (@preorder.to_has_lt.{0} real real.preorder) b (d i),
cv :
  @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
    (@set.Union.{0 1} real nat
       (λ (i_1 : nat),
          @set.Union.{0 0} real
            (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i_1
               (@insert.{0 0} nat (set.{0} nat) (@set.has_insert.{0} nat) i
                  (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                     (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                     (@finset.erase.{0} nat (λ (a b : nat), (λ (a b : nat), nat.decidable_eq a b) a b) s i))))
            (λ
             (H :
               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i_1
                 (@insert.{0 0} nat (set.{0} nat) (@set.has_insert.{0} nat) i
                    (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                       (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                       (@finset.erase.{0} nat (λ (a b : nat), (λ (a b : nat), nat.decidable_eq a b) a b) s i)))),
               @set.Ioo.{0} real real.preorder (c i_1) (d i_1))))
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
    (@finset.sum.{0 0} nat ennreal
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       (@insert.{0 0} nat (finset.{0} nat)
          (@finset.has_insert.{0} nat (λ (a b : nat), (λ (a b : nat), nat.decidable_eq a b) a b))
          i
          (@finset.erase.{0} nat (λ (a b : nat), (λ (a b : nat), nat.decidable_eq a b) a b) s i))
       (λ (i : nat),
          @coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
            (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (d i) (c i)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a : real,
c d : nat → real,
s s : finset.{0} nat,
IH :
  ∀ (t : finset.{0} nat),
    @has_ssubset.ssubset.{0} (finset.{0} nat) (@finset.has_ssubset.{0} nat) t s →
    ∀ (b : real),
      @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
        (@set.Union.{0 1} real nat
           (λ (i : nat),
              @set.Union.{0 0} real
                (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                   (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                      (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                      t))
                (λ
                 (H :
                   @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                     (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                        (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                        t)), @set.Ioo.{0} real real.preorder (c i) (d i)))) →
      @has_le.le.{0} ennreal
        (@preorder.to_has_le.{0} ennreal
           (@partial_order.to_preorder.{0} ennreal
              (@ordered_comm_monoid.to_partial_order.{0} ennreal
                 (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                    (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                       ennreal.canonically_ordered_comm_semiring_1)))))
        (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
           (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
        (@finset.sum.{0 0} nat ennreal
           (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
              (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                 (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                    ennreal.canonically_ordered_comm_semiring_1)))
           t
           (λ (i : nat),
              @coe.{1 1} nnreal ennreal
                (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
                (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (d i) (c i))))),
b : real,
ab :
  @has_le.le.{0} real
    (@preorder.to_has_le.{0} real
       (@partial_order.to_preorder.{0} real (@linear_order.to_partial_order.{0} real real.linear_order)))
    a
    b,
i : nat,
is : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i s,
cb : @has_lt.lt.{0} real (@preorder.to_has_lt.{0} real real.preorder) (c i) b,
bd : @has_lt.lt.{0} real (@preorder.to_has_lt.{0} real real.preorder) b (d i),
cv :
  @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
    (@has_union.union.{0} (set.{0} real) (@set.has_union.{0} real) (@set.Ioo.{0} real real.preorder (c i) (d i))
       (@set.Union.{0 1} real nat
          (λ (x : nat),
             @set.Union.{0 0} real
               (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x
                  (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                     (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                     (@finset.erase.{0} nat (λ (a b : nat), (λ (a b : nat), nat.decidable_eq a b) a b) s i)))
               (λ
                (H :
                  @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x
                    (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                       (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                       (@finset.erase.{0} nat (λ (a b : nat), (λ (a b : nat), nat.decidable_eq a b) a b) s i))),
                  @set.Ioo.{0} real real.preorder (c x) (d x)))))
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
    (@finset.sum.{0 0} nat ennreal
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       (@insert.{0 0} nat (finset.{0} nat)
          (@finset.has_insert.{0} nat (λ (a b : nat), (λ (a b : nat), nat.decidable_eq a b) a b))
          i
          (@finset.erase.{0} nat (λ (a b : nat), (λ (a b : nat), nat.decidable_eq a b) a b) s i))
       (λ (i : nat),
          @coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
            (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (d i) (c i)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a : real,
c d : nat → real,
s s : finset.{0} nat,
IH :
  ∀ (t : finset.{0} nat),
    @has_ssubset.ssubset.{0} (finset.{0} nat) (@finset.has_ssubset.{0} nat) t s →
    ∀ (b : real),
      @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
        (@set.Union.{0 1} real nat
           (λ (i : nat),
              @set.Union.{0 0} real
                (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                   (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                      (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                      t))
                (λ
                 (H :
                   @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                     (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                        (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                        t)), @set.Ioo.{0} real real.preorder (c i) (d i)))) →
      @has_le.le.{0} ennreal
        (@preorder.to_has_le.{0} ennreal
           (@partial_order.to_preorder.{0} ennreal
              (@ordered_comm_monoid.to_partial_order.{0} ennreal
                 (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                    (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                       ennreal.canonically_ordered_comm_semiring_1)))))
        (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
           (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
        (@finset.sum.{0 0} nat ennreal
           (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
              (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                 (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                    ennreal.canonically_ordered_comm_semiring_1)))
           t
           (λ (i : nat),
              @coe.{1 1} nnreal ennreal
                (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
                (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (d i) (c i))))),
b : real,
ab :
  @has_le.le.{0} real
    (@preorder.to_has_le.{0} real
       (@partial_order.to_preorder.{0} real (@linear_order.to_partial_order.{0} real real.linear_order)))
    a
    b,
i : nat,
is : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i s,
cb : @has_lt.lt.{0} real (@preorder.to_has_lt.{0} real real.preorder) (c i) b,
bd : @has_lt.lt.{0} real (@preorder.to_has_lt.{0} real real.preorder) b (d i),
cv :
  @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
    (@set.Union.{0 1} real nat
       (λ (i_1 : nat),
          @set.Union.{0 0} real
            (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i_1
               (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                  (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                  (@insert.{0 0} nat (finset.{0} nat)
                     (@finset.has_insert.{0} nat (λ (a b : nat), (λ (a b : nat), nat.decidable_eq a b) a b))
                     i
                     (@finset.erase.{0} nat (λ (a b : nat), (λ (a b : nat), nat.decidable_eq a b) a b) s i))))
            (λ
             (H :
               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i_1
                 (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                    (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                    (@insert.{0 0} nat (finset.{0} nat)
                       (@finset.has_insert.{0} nat (λ (a b : nat), (λ (a b : nat), nat.decidable_eq a b) a b))
                       i
                       (@finset.erase.{0} nat (λ (a b : nat), (λ (a b : nat), nat.decidable_eq a b) a b) s i)))),
               @set.Ioo.{0} real real.preorder (c i_1) (d i_1))))
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
    (@finset.sum.{0 0} nat ennreal
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       (@insert.{0 0} nat (finset.{0} nat)
          (@finset.has_insert.{0} nat (λ (a b : nat), (λ (a b : nat), nat.decidable_eq a b) a b))
          i
          (@finset.erase.{0} nat (λ (a b : nat), (λ (a b : nat), nat.decidable_eq a b) a b) s i))
       (λ (i : nat),
          @coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
            (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (d i) (c i)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a : real,
c d : nat → real,
s s : finset.{0} nat,
IH :
  ∀ (t : finset.{0} nat),
    @has_ssubset.ssubset.{0} (finset.{0} nat) (@finset.has_ssubset.{0} nat) t s →
    ∀ (b : real),
      @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
        (@set.Union.{0 1} real nat
           (λ (i : nat),
              @set.Union.{0 0} real
                (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                   (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                      (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                      t))
                (λ
                 (H :
                   @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                     (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                        (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                        t)), @set.Ioo.{0} real real.preorder (c i) (d i)))) →
      @has_le.le.{0} ennreal
        (@preorder.to_has_le.{0} ennreal
           (@partial_order.to_preorder.{0} ennreal
              (@ordered_comm_monoid.to_partial_order.{0} ennreal
                 (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                    (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                       ennreal.canonically_ordered_comm_semiring_1)))))
        (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
           (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
        (@finset.sum.{0 0} nat ennreal
           (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
              (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                 (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                    ennreal.canonically_ordered_comm_semiring_1)))
           t
           (λ (i : nat),
              @coe.{1 1} nnreal ennreal
                (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
                (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (d i) (c i))))),
b : real,
ab :
  @has_le.le.{0} real
    (@preorder.to_has_le.{0} real
       (@partial_order.to_preorder.{0} real (@linear_order.to_partial_order.{0} real real.linear_order)))
    a
    b,
i : nat,
is : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i s,
cb : @has_lt.lt.{0} real (@preorder.to_has_lt.{0} real real.preorder) (c i) b,
bd : @has_lt.lt.{0} real (@preorder.to_has_lt.{0} real real.preorder) b (d i),
cv :
  @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
    (@has_union.union.{0} (set.{0} real) (@set.has_union.{0} real) (@set.Ioo.{0} real real.preorder (c i) (d i))
       (@set.Union.{0 1} real nat
          (λ (x : nat),
             @set.Union.{0 0} real
               (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x
                  (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                     (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                     (@finset.erase.{0} nat (λ (a b : nat), (λ (a b : nat), nat.decidable_eq a b) a b) s i)))
               (λ
                (H :
                  @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x
                    (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                       (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                       (@finset.erase.{0} nat (λ (a b : nat), (λ (a b : nat), nat.decidable_eq a b) a b) s i))),
                  @set.Ioo.{0} real real.preorder (c x) (d x)))))
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
    (@finset.sum.{0 0} nat ennreal
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       (@insert.{0 0} nat (finset.{0} nat)
          (@finset.has_insert.{0} nat (λ (a b : nat), (λ (a b : nat), nat.decidable_eq a b) a b))
          i
          (@finset.erase.{0} nat (λ (a b : nat), (λ (a b : nat), nat.decidable_eq a b) a b) s i))
       (λ (i : nat),
          @coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
            (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (d i) (c i)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>115    rw [finset.sum_insert (finset.not_mem_erase _ _)],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='finset.sum_insert'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='finset.not_mem_erase'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/big_operators.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/finset.lean&#x27;, &#x27;line&#x27;: 507, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type} {s : finset.{0} α} {a : α} {f : α → β} [_inst_1 : add_comm_monoid.{0} β] [_inst_2 : decidable_eq.{1} α], not (@has_mem.mem.{0 0} α (finset.{0} α) (@finset.has_mem.{0} α) a s) → @eq.{1} β (@finset.sum.{0 0} α β _inst_1 (@insert.{0 0} α (finset.{0} α) (@finset.has_insert.{0} α (λ (a b : α), _inst_2 a b)) a s) f) (@has_add.add.{0} β (@add_semigroup.to_has_add.{0} β (@add_monoid.to_add_semigroup.{0} β (@add_comm_monoid.to_add_monoid.{0} β _inst_1))) (f a) (@finset.sum.{0 0} α β _inst_1 s f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type} [_inst_1 : decidable_eq.{1} α] (a : α) (s : finset.{0} α), not (@has_mem.mem.{0 0} α (finset.{0} α) (@finset.has_mem.{0} α) a (@finset.erase.{0} α (λ (a b : α), _inst_1 a b) s a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a : real,
c d : nat → real,
s s : finset.{0} nat,
IH :
  ∀ (t : finset.{0} nat),
    @has_ssubset.ssubset.{0} (finset.{0} nat) (@finset.has_ssubset.{0} nat) t s →
    ∀ (b : real),
      @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
        (@set.Union.{0 1} real nat
           (λ (i : nat),
              @set.Union.{0 0} real
                (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                   (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                      (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                      t))
                (λ
                 (H :
                   @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                     (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                        (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                        t)), @set.Ioo.{0} real real.preorder (c i) (d i)))) →
      @has_le.le.{0} ennreal
        (@preorder.to_has_le.{0} ennreal
           (@partial_order.to_preorder.{0} ennreal
              (@ordered_comm_monoid.to_partial_order.{0} ennreal
                 (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                    (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                       ennreal.canonically_ordered_comm_semiring_1)))))
        (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
           (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
        (@finset.sum.{0 0} nat ennreal
           (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
              (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                 (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                    ennreal.canonically_ordered_comm_semiring_1)))
           t
           (λ (i : nat),
              @coe.{1 1} nnreal ennreal
                (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
                (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (d i) (c i))))),
b : real,
ab :
  @has_le.le.{0} real
    (@preorder.to_has_le.{0} real
       (@partial_order.to_preorder.{0} real (@linear_order.to_partial_order.{0} real real.linear_order)))
    a
    b,
i : nat,
is : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i s,
cb : @has_lt.lt.{0} real (@preorder.to_has_lt.{0} real real.preorder) (c i) b,
bd : @has_lt.lt.{0} real (@preorder.to_has_lt.{0} real real.preorder) b (d i),
cv :
  @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
    (@has_union.union.{0} (set.{0} real) (@set.has_union.{0} real) (@set.Ioo.{0} real real.preorder (c i) (d i))
       (@set.Union.{0 1} real nat
          (λ (x : nat),
             @set.Union.{0 0} real
               (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x
                  (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                     (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                     (@finset.erase.{0} nat (λ (a b : nat), (λ (a b : nat), nat.decidable_eq a b) a b) s i)))
               (λ
                (H :
                  @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x
                    (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                       (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                       (@finset.erase.{0} nat (λ (a b : nat), (λ (a b : nat), nat.decidable_eq a b) a b) s i))),
                  @set.Ioo.{0} real real.preorder (c x) (d x)))))
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
    (@finset.sum.{0 0} nat ennreal
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       (@insert.{0 0} nat (finset.{0} nat)
          (@finset.has_insert.{0} nat (λ (a b : nat), (λ (a b : nat), nat.decidable_eq a b) a b))
          i
          (@finset.erase.{0} nat (λ (a b : nat), (λ (a b : nat), nat.decidable_eq a b) a b) s i))
       (λ (i : nat),
          @coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
            (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (d i) (c i)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a : real,
c d : nat → real,
s s : finset.{0} nat,
IH :
  ∀ (t : finset.{0} nat),
    @has_ssubset.ssubset.{0} (finset.{0} nat) (@finset.has_ssubset.{0} nat) t s →
    ∀ (b : real),
      @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
        (@set.Union.{0 1} real nat
           (λ (i : nat),
              @set.Union.{0 0} real
                (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                   (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                      (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                      t))
                (λ
                 (H :
                   @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                     (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                        (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                        t)), @set.Ioo.{0} real real.preorder (c i) (d i)))) →
      @has_le.le.{0} ennreal
        (@preorder.to_has_le.{0} ennreal
           (@partial_order.to_preorder.{0} ennreal
              (@ordered_comm_monoid.to_partial_order.{0} ennreal
                 (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                    (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                       ennreal.canonically_ordered_comm_semiring_1)))))
        (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
           (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
        (@finset.sum.{0 0} nat ennreal
           (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
              (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                 (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                    ennreal.canonically_ordered_comm_semiring_1)))
           t
           (λ (i : nat),
              @coe.{1 1} nnreal ennreal
                (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
                (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (d i) (c i))))),
b : real,
ab :
  @has_le.le.{0} real
    (@preorder.to_has_le.{0} real
       (@partial_order.to_preorder.{0} real (@linear_order.to_partial_order.{0} real real.linear_order)))
    a
    b,
i : nat,
is : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i s,
cb : @has_lt.lt.{0} real (@preorder.to_has_lt.{0} real real.preorder) (c i) b,
bd : @has_lt.lt.{0} real (@preorder.to_has_lt.{0} real real.preorder) b (d i),
cv :
  @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
    (@has_union.union.{0} (set.{0} real) (@set.has_union.{0} real) (@set.Ioo.{0} real real.preorder (c i) (d i))
       (@set.Union.{0 1} real nat
          (λ (x : nat),
             @set.Union.{0 0} real
               (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x
                  (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                     (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                     (@finset.erase.{0} nat (λ (a b : nat), (λ (a b : nat), nat.decidable_eq a b) a b) s i)))
               (λ
                (H :
                  @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x
                    (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                       (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                       (@finset.erase.{0} nat (λ (a b : nat), (λ (a b : nat), nat.decidable_eq a b) a b) s i))),
                  @set.Ioo.{0} real real.preorder (c x) (d x)))))
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
    (@has_add.add.{0} ennreal
       (@add_semigroup.to_has_add.{0} ennreal
          (@add_monoid.to_add_semigroup.{0} ennreal
             (@add_comm_monoid.to_add_monoid.{0} ennreal
                (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
                   (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                      (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                         ennreal.canonically_ordered_comm_semiring_1))))))
       (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
          (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (d i) (c i))))
       (@finset.sum.{0 0} nat ennreal
          (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))
          (@finset.erase.{0} nat (λ (a b : nat), (λ (a b : nat), nat.decidable_eq a b) a b) s i)
          (λ (i : nat),
             @coe.{1 1} nnreal ennreal
               (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
               (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (d i) (c i))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>116    refine le_trans _ (add_le_add_left&#x27; (IH _ (finset.erase_ssubset is) (c i) _)),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='le_trans'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='add_le_add_left&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='IH'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='finset.erase_ssubset'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='is'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 33, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/ordered_group.lean&#x27;, &#x27;line&#x27;: 37, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/finset.lean&#x27;, &#x27;line&#x27;: 535, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : preorder.{0} α] {a b c : α}, @has_le.le.{0} α (@preorder.to_has_le.{0} α _inst_1) a b → @has_le.le.{0} α (@preorder.to_has_le.{0} α _inst_1) b c → @has_le.le.{0} α (@preorder.to_has_le.{0} α _inst_1) a c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type} [_inst_1 : ordered_comm_monoid.{0} α] {a b c : α}, @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@ordered_comm_monoid.to_partial_order.{0} α _inst_1))) a b → @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@ordered_comm_monoid.to_partial_order.{0} α _inst_1))) (@has_add.add.{0} α (@add_semigroup.to_has_add.{0} α (@add_monoid.to_add_semigroup.{0} α (@add_comm_monoid.to_add_monoid.{0} α (@ordered_comm_monoid.to_add_comm_monoid.{0} α _inst_1)))) c a) (@has_add.add.{0} α (@add_semigroup.to_has_add.{0} α (@add_monoid.to_add_semigroup.{0} α (@add_comm_monoid.to_add_monoid.{0} α (@ordered_comm_monoid.to_add_comm_monoid.{0} α _inst_1)))) c b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ (t : finset.{0} nat), @has_ssubset.ssubset.{0} (finset.{0} nat) (@finset.has_ssubset.{0} nat) t s → ∀ (b : real), @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b) (@set.Union.{0 1} real nat (λ (i : nat), @set.Union.{0 0} real (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i (@coe.{1 1} (finset.{0} nat) (set.{0} nat) (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat)) t)) (λ (H : @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i (@coe.{1 1} (finset.{0} nat) (set.{0} nat) (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat)) t)), @set.Ioo.{0} real real.preorder (c i) (d i)))) → @has_le.le.{0} ennreal (@preorder.to_has_le.{0} ennreal (@partial_order.to_preorder.{0} ennreal (@ordered_comm_monoid.to_partial_order.{0} ennreal (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal ennreal.canonically_ordered_comm_semiring_1))))) (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe)) (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a))) (@finset.sum.{0 0} nat ennreal (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal ennreal.canonically_ordered_comm_semiring_1))) t (λ (i : nat), @coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe)) (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (d i) (c i)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type} [_inst_1 : decidable_eq.{1} α] {a : α} {s : finset.{0} α}, @has_mem.mem.{0 0} α (finset.{0} α) (@finset.has_mem.{0} α) a s → @has_ssubset.ssubset.{0} (finset.{0} α) (@finset.has_ssubset.{0} α) (@finset.erase.{0} α (λ (a b : α), _inst_1 a b) s a) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a : real,
c d : nat → real,
s s : finset.{0} nat,
IH :
  ∀ (t : finset.{0} nat),
    @has_ssubset.ssubset.{0} (finset.{0} nat) (@finset.has_ssubset.{0} nat) t s →
    ∀ (b : real),
      @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
        (@set.Union.{0 1} real nat
           (λ (i : nat),
              @set.Union.{0 0} real
                (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                   (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                      (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                      t))
                (λ
                 (H :
                   @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                     (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                        (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                        t)), @set.Ioo.{0} real real.preorder (c i) (d i)))) →
      @has_le.le.{0} ennreal
        (@preorder.to_has_le.{0} ennreal
           (@partial_order.to_preorder.{0} ennreal
              (@ordered_comm_monoid.to_partial_order.{0} ennreal
                 (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                    (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                       ennreal.canonically_ordered_comm_semiring_1)))))
        (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
           (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
        (@finset.sum.{0 0} nat ennreal
           (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
              (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                 (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                    ennreal.canonically_ordered_comm_semiring_1)))
           t
           (λ (i : nat),
              @coe.{1 1} nnreal ennreal
                (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
                (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (d i) (c i))))),
b : real,
ab :
  @has_le.le.{0} real
    (@preorder.to_has_le.{0} real
       (@partial_order.to_preorder.{0} real (@linear_order.to_partial_order.{0} real real.linear_order)))
    a
    b,
i : nat,
is : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i s,
cb : @has_lt.lt.{0} real (@preorder.to_has_lt.{0} real real.preorder) (c i) b,
bd : @has_lt.lt.{0} real (@preorder.to_has_lt.{0} real real.preorder) b (d i),
cv :
  @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
    (@has_union.union.{0} (set.{0} real) (@set.has_union.{0} real) (@set.Ioo.{0} real real.preorder (c i) (d i))
       (@set.Union.{0 1} real nat
          (λ (x : nat),
             @set.Union.{0 0} real
               (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x
                  (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                     (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                     (@finset.erase.{0} nat (λ (a b : nat), (λ (a b : nat), nat.decidable_eq a b) a b) s i)))
               (λ
                (H :
                  @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x
                    (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                       (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                       (@finset.erase.{0} nat (λ (a b : nat), (λ (a b : nat), nat.decidable_eq a b) a b) s i))),
                  @set.Ioo.{0} real real.preorder (c x) (d x)))))
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
    (@has_add.add.{0} ennreal
       (@add_semigroup.to_has_add.{0} ennreal
          (@add_monoid.to_add_semigroup.{0} ennreal
             (@add_comm_monoid.to_add_monoid.{0} ennreal
                (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
                   (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                      (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                         ennreal.canonically_ordered_comm_semiring_1))))))
       (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
          (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (d i) (c i))))
       (@finset.sum.{0 0} nat ennreal
          (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))
          (@finset.erase.{0} nat (λ (a b : nat), (λ (a b : nat), nat.decidable_eq a b) a b) s i)
          (λ (i : nat),
             @coe.{1 1} nnreal ennreal
               (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
               (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (d i) (c i))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
a : real,
c d : nat → real,
s s : finset.{0} nat,
IH :
  ∀ (t : finset.{0} nat),
    @has_ssubset.ssubset.{0} (finset.{0} nat) (@finset.has_ssubset.{0} nat) t s →
    ∀ (b : real),
      @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
        (@set.Union.{0 1} real nat
           (λ (i : nat),
              @set.Union.{0 0} real
                (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                   (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                      (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                      t))
                (λ
                 (H :
                   @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                     (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                        (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                        t)), @set.Ioo.{0} real real.preorder (c i) (d i)))) →
      @has_le.le.{0} ennreal
        (@preorder.to_has_le.{0} ennreal
           (@partial_order.to_preorder.{0} ennreal
              (@ordered_comm_monoid.to_partial_order.{0} ennreal
                 (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                    (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                       ennreal.canonically_ordered_comm_semiring_1)))))
        (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
           (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
        (@finset.sum.{0 0} nat ennreal
           (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
              (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                 (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                    ennreal.canonically_ordered_comm_semiring_1)))
           t
           (λ (i : nat),
              @coe.{1 1} nnreal ennreal
                (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
                (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (d i) (c i))))),
b : real,
ab :
  @has_le.le.{0} real
    (@preorder.to_has_le.{0} real
       (@partial_order.to_preorder.{0} real (@linear_order.to_partial_order.{0} real real.linear_order)))
    a
    b,
i : nat,
is : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i s,
cb : @has_lt.lt.{0} real (@preorder.to_has_lt.{0} real real.preorder) (c i) b,
bd : @has_lt.lt.{0} real (@preorder.to_has_lt.{0} real real.preorder) b (d i),
cv :
  @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
    (@has_union.union.{0} (set.{0} real) (@set.has_union.{0} real) (@set.Ioo.{0} real real.preorder (c i) (d i))
       (@set.Union.{0 1} real nat
          (λ (x : nat),
             @set.Union.{0 0} real
               (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x
                  (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                     (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                     (@finset.erase.{0} nat (λ (a b : nat), (λ (a b : nat), nat.decidable_eq a b) a b) s i)))
               (λ
                (H :
                  @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x
                    (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                       (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                       (@finset.erase.{0} nat (λ (a b : nat), (λ (a b : nat), nat.decidable_eq a b) a b) s i))),
                  @set.Ioo.{0} real real.preorder (c x) (d x)))))
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
    (@has_add.add.{0} ennreal
       (@add_semigroup.to_has_add.{0} ennreal
          (@add_monoid.to_add_semigroup.{0} ennreal
             (@add_comm_monoid.to_add_monoid.{0} ennreal
                (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
                   (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                      (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                         ennreal.canonically_ordered_comm_semiring_1))))))
       (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
          (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (d i) (c i))))
       (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
          (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (c i) a))))

a : real,
c d : nat → real,
s s : finset.{0} nat,
IH :
  ∀ (t : finset.{0} nat),
    @has_ssubset.ssubset.{0} (finset.{0} nat) (@finset.has_ssubset.{0} nat) t s →
    ∀ (b : real),
      @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
        (@set.Union.{0 1} real nat
           (λ (i : nat),
              @set.Union.{0 0} real
                (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                   (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                      (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                      t))
                (λ
                 (H :
                   @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                     (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                        (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                        t)), @set.Ioo.{0} real real.preorder (c i) (d i)))) →
      @has_le.le.{0} ennreal
        (@preorder.to_has_le.{0} ennreal
           (@partial_order.to_preorder.{0} ennreal
              (@ordered_comm_monoid.to_partial_order.{0} ennreal
                 (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                    (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                       ennreal.canonically_ordered_comm_semiring_1)))))
        (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
           (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
        (@finset.sum.{0 0} nat ennreal
           (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
              (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                 (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                    ennreal.canonically_ordered_comm_semiring_1)))
           t
           (λ (i : nat),
              @coe.{1 1} nnreal ennreal
                (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
                (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (d i) (c i))))),
b : real,
ab :
  @has_le.le.{0} real
    (@preorder.to_has_le.{0} real
       (@partial_order.to_preorder.{0} real (@linear_order.to_partial_order.{0} real real.linear_order)))
    a
    b,
i : nat,
is : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i s,
cb : @has_lt.lt.{0} real (@preorder.to_has_lt.{0} real real.preorder) (c i) b,
bd : @has_lt.lt.{0} real (@preorder.to_has_lt.{0} real real.preorder) b (d i),
cv :
  @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
    (@has_union.union.{0} (set.{0} real) (@set.has_union.{0} real) (@set.Ioo.{0} real real.preorder (c i) (d i))
       (@set.Union.{0 1} real nat
          (λ (x : nat),
             @set.Union.{0 0} real
               (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x
                  (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                     (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                     (@finset.erase.{0} nat (λ (a b : nat), (λ (a b : nat), nat.decidable_eq a b) a b) s i)))
               (λ
                (H :
                  @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x
                    (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                       (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                       (@finset.erase.{0} nat (λ (a b : nat), (λ (a b : nat), nat.decidable_eq a b) a b) s i))),
                  @set.Ioo.{0} real real.preorder (c x) (d x)))))
⊢ @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a (c i))
    (@set.Union.{0 1} real nat
       (λ (i_1 : nat),
          @set.Union.{0 0} real
            (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i_1
               (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                  (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                  (@finset.erase.{0} nat (λ (a b : nat), nat.decidable_eq a b) s i)))
            (λ
             (H :
               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i_1
                 (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                    (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                    (@finset.erase.{0} nat (λ (a b : nat), nat.decidable_eq a b) s i))),
               @set.Ioo.{0} real real.preorder (c i_1) (d i_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>117    { rw [← ennreal.coe_add, ennreal.coe_le_coe],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='ennreal.coe_add'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ennreal.coe_le_coe'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/ennreal.lean&#x27;, &#x27;line&#x27;: 128, &#x27;column&#x27;: 25}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/ennreal.lean&#x27;, &#x27;line&#x27;: 117, &#x27;column&#x27;: 25}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {r p : nnreal}, @eq.{1} ennreal (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe)) (@has_add.add.{0} nnreal nnreal.has_add r p)) (@has_add.add.{0} ennreal (@distrib.to_has_add.{0} ennreal (@semiring.to_distrib.{0} ennreal (@comm_semiring.to_semiring.{0} ennreal (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal ennreal.canonically_ordered_comm_semiring_1)))) (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe)) r) (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe)) p))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {r q : nnreal}, iff (@has_le.le.{0} ennreal (@preorder.to_has_le.{0} ennreal (@partial_order.to_preorder.{0} ennreal (@ordered_comm_monoid.to_partial_order.{0} ennreal (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal ennreal.canonically_ordered_comm_semiring_1))))) (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe)) r) (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe)) q)) (@has_le.le.{0} nnreal nnreal.has_le r q)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
a : real,
c d : nat → real,
s s : finset.{0} nat,
IH :
  ∀ (t : finset.{0} nat),
    @has_ssubset.ssubset.{0} (finset.{0} nat) (@finset.has_ssubset.{0} nat) t s →
    ∀ (b : real),
      @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
        (@set.Union.{0 1} real nat
           (λ (i : nat),
              @set.Union.{0 0} real
                (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                   (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                      (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                      t))
                (λ
                 (H :
                   @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                     (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                        (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                        t)), @set.Ioo.{0} real real.preorder (c i) (d i)))) →
      @has_le.le.{0} ennreal
        (@preorder.to_has_le.{0} ennreal
           (@partial_order.to_preorder.{0} ennreal
              (@ordered_comm_monoid.to_partial_order.{0} ennreal
                 (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                    (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                       ennreal.canonically_ordered_comm_semiring_1)))))
        (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
           (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
        (@finset.sum.{0 0} nat ennreal
           (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
              (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                 (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                    ennreal.canonically_ordered_comm_semiring_1)))
           t
           (λ (i : nat),
              @coe.{1 1} nnreal ennreal
                (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
                (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (d i) (c i))))),
b : real,
ab :
  @has_le.le.{0} real
    (@preorder.to_has_le.{0} real
       (@partial_order.to_preorder.{0} real (@linear_order.to_partial_order.{0} real real.linear_order)))
    a
    b,
i : nat,
is : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i s,
cb : @has_lt.lt.{0} real (@preorder.to_has_lt.{0} real real.preorder) (c i) b,
bd : @has_lt.lt.{0} real (@preorder.to_has_lt.{0} real real.preorder) b (d i),
cv :
  @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
    (@has_union.union.{0} (set.{0} real) (@set.has_union.{0} real) (@set.Ioo.{0} real real.preorder (c i) (d i))
       (@set.Union.{0 1} real nat
          (λ (x : nat),
             @set.Union.{0 0} real
               (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x
                  (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                     (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                     (@finset.erase.{0} nat (λ (a b : nat), (λ (a b : nat), nat.decidable_eq a b) a b) s i)))
               (λ
                (H :
                  @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x
                    (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                       (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                       (@finset.erase.{0} nat (λ (a b : nat), (λ (a b : nat), nat.decidable_eq a b) a b) s i))),
                  @set.Ioo.{0} real real.preorder (c x) (d x)))))
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
    (@has_add.add.{0} ennreal
       (@add_semigroup.to_has_add.{0} ennreal
          (@add_monoid.to_add_semigroup.{0} ennreal
             (@add_comm_monoid.to_add_monoid.{0} ennreal
                (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
                   (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                      (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                         ennreal.canonically_ordered_comm_semiring_1))))))
       (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
          (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (d i) (c i))))
       (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
          (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (c i) a))))

a : real,
c d : nat → real,
s s : finset.{0} nat,
IH :
  ∀ (t : finset.{0} nat),
    @has_ssubset.ssubset.{0} (finset.{0} nat) (@finset.has_ssubset.{0} nat) t s →
    ∀ (b : real),
      @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
        (@set.Union.{0 1} real nat
           (λ (i : nat),
              @set.Union.{0 0} real
                (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                   (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                      (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                      t))
                (λ
                 (H :
                   @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                     (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                        (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                        t)), @set.Ioo.{0} real real.preorder (c i) (d i)))) →
      @has_le.le.{0} ennreal
        (@preorder.to_has_le.{0} ennreal
           (@partial_order.to_preorder.{0} ennreal
              (@ordered_comm_monoid.to_partial_order.{0} ennreal
                 (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                    (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                       ennreal.canonically_ordered_comm_semiring_1)))))
        (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
           (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
        (@finset.sum.{0 0} nat ennreal
           (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
              (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                 (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                    ennreal.canonically_ordered_comm_semiring_1)))
           t
           (λ (i : nat),
              @coe.{1 1} nnreal ennreal
                (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
                (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (d i) (c i))))),
b : real,
ab :
  @has_le.le.{0} real
    (@preorder.to_has_le.{0} real
       (@partial_order.to_preorder.{0} real (@linear_order.to_partial_order.{0} real real.linear_order)))
    a
    b,
i : nat,
is : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i s,
cb : @has_lt.lt.{0} real (@preorder.to_has_lt.{0} real real.preorder) (c i) b,
bd : @has_lt.lt.{0} real (@preorder.to_has_lt.{0} real real.preorder) b (d i),
cv :
  @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
    (@has_union.union.{0} (set.{0} real) (@set.has_union.{0} real) (@set.Ioo.{0} real real.preorder (c i) (d i))
       (@set.Union.{0 1} real nat
          (λ (x : nat),
             @set.Union.{0 0} real
               (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x
                  (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                     (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                     (@finset.erase.{0} nat (λ (a b : nat), (λ (a b : nat), nat.decidable_eq a b) a b) s i)))
               (λ
                (H :
                  @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x
                    (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                       (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                       (@finset.erase.{0} nat (λ (a b : nat), (λ (a b : nat), nat.decidable_eq a b) a b) s i))),
                  @set.Ioo.{0} real real.preorder (c x) (d x)))))
⊢ @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a (c i))
    (@set.Union.{0 1} real nat
       (λ (i_1 : nat),
          @set.Union.{0 0} real
            (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i_1
               (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                  (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                  (@finset.erase.{0} nat (λ (a b : nat), nat.decidable_eq a b) s i)))
            (λ
             (H :
               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i_1
                 (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                    (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                    (@finset.erase.{0} nat (λ (a b : nat), nat.decidable_eq a b) s i))),
               @set.Ioo.{0} real real.preorder (c i_1) (d i_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a : real,
c d : nat → real,
s s : finset.{0} nat,
IH :
  ∀ (t : finset.{0} nat),
    @has_ssubset.ssubset.{0} (finset.{0} nat) (@finset.has_ssubset.{0} nat) t s →
    ∀ (b : real),
      @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
        (@set.Union.{0 1} real nat
           (λ (i : nat),
              @set.Union.{0 0} real
                (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                   (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                      (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                      t))
                (λ
                 (H :
                   @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                     (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                        (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                        t)), @set.Ioo.{0} real real.preorder (c i) (d i)))) →
      @has_le.le.{0} ennreal
        (@preorder.to_has_le.{0} ennreal
           (@partial_order.to_preorder.{0} ennreal
              (@ordered_comm_monoid.to_partial_order.{0} ennreal
                 (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                    (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                       ennreal.canonically_ordered_comm_semiring_1)))))
        (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
           (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
        (@finset.sum.{0 0} nat ennreal
           (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
              (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                 (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                    ennreal.canonically_ordered_comm_semiring_1)))
           t
           (λ (i : nat),
              @coe.{1 1} nnreal ennreal
                (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
                (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (d i) (c i))))),
b : real,
ab :
  @has_le.le.{0} real
    (@preorder.to_has_le.{0} real
       (@partial_order.to_preorder.{0} real (@linear_order.to_partial_order.{0} real real.linear_order)))
    a
    b,
i : nat,
is : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i s,
cb : @has_lt.lt.{0} real (@preorder.to_has_lt.{0} real real.preorder) (c i) b,
bd : @has_lt.lt.{0} real (@preorder.to_has_lt.{0} real real.preorder) b (d i),
cv :
  @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
    (@has_union.union.{0} (set.{0} real) (@set.has_union.{0} real) (@set.Ioo.{0} real real.preorder (c i) (d i))
       (@set.Union.{0 1} real nat
          (λ (x : nat),
             @set.Union.{0 0} real
               (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x
                  (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                     (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                     (@finset.erase.{0} nat (λ (a b : nat), (λ (a b : nat), nat.decidable_eq a b) a b) s i)))
               (λ
                (H :
                  @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x
                    (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                       (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                       (@finset.erase.{0} nat (λ (a b : nat), (λ (a b : nat), nat.decidable_eq a b) a b) s i))),
                  @set.Ioo.{0} real real.preorder (c x) (d x)))))
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
    (@has_add.add.{0} ennreal
       (@add_semigroup.to_has_add.{0} ennreal
          (@add_monoid.to_add_semigroup.{0} ennreal
             (@add_comm_monoid.to_add_monoid.{0} ennreal
                (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
                   (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                      (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                         ennreal.canonically_ordered_comm_semiring_1))))))
       (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
          (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (d i) (c i))))
       (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
          (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (c i) a))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a : real,
c d : nat → real,
s s : finset.{0} nat,
IH :
  ∀ (t : finset.{0} nat),
    @has_ssubset.ssubset.{0} (finset.{0} nat) (@finset.has_ssubset.{0} nat) t s →
    ∀ (b : real),
      @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
        (@set.Union.{0 1} real nat
           (λ (i : nat),
              @set.Union.{0 0} real
                (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                   (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                      (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                      t))
                (λ
                 (H :
                   @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                     (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                        (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                        t)), @set.Ioo.{0} real real.preorder (c i) (d i)))) →
      @has_le.le.{0} ennreal
        (@preorder.to_has_le.{0} ennreal
           (@partial_order.to_preorder.{0} ennreal
              (@ordered_comm_monoid.to_partial_order.{0} ennreal
                 (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                    (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                       ennreal.canonically_ordered_comm_semiring_1)))))
        (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
           (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
        (@finset.sum.{0 0} nat ennreal
           (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
              (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                 (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                    ennreal.canonically_ordered_comm_semiring_1)))
           t
           (λ (i : nat),
              @coe.{1 1} nnreal ennreal
                (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
                (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (d i) (c i))))),
b : real,
ab :
  @has_le.le.{0} real
    (@preorder.to_has_le.{0} real
       (@partial_order.to_preorder.{0} real (@linear_order.to_partial_order.{0} real real.linear_order)))
    a
    b,
i : nat,
is : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i s,
cb : @has_lt.lt.{0} real (@preorder.to_has_lt.{0} real real.preorder) (c i) b,
bd : @has_lt.lt.{0} real (@preorder.to_has_lt.{0} real real.preorder) b (d i),
cv :
  @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
    (@has_union.union.{0} (set.{0} real) (@set.has_union.{0} real) (@set.Ioo.{0} real real.preorder (c i) (d i))
       (@set.Union.{0 1} real nat
          (λ (x : nat),
             @set.Union.{0 0} real
               (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x
                  (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                     (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                     (@finset.erase.{0} nat (λ (a b : nat), (λ (a b : nat), nat.decidable_eq a b) a b) s i)))
               (λ
                (H :
                  @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x
                    (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                       (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                       (@finset.erase.{0} nat (λ (a b : nat), (λ (a b : nat), nat.decidable_eq a b) a b) s i))),
                  @set.Ioo.{0} real real.preorder (c x) (d x)))))
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (@has_add.add.{0} nnreal nnreal.has_add
          (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (d i) (c i)))
          (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (c i) a))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a : real,
c d : nat → real,
s s : finset.{0} nat,
IH :
  ∀ (t : finset.{0} nat),
    @has_ssubset.ssubset.{0} (finset.{0} nat) (@finset.has_ssubset.{0} nat) t s →
    ∀ (b : real),
      @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
        (@set.Union.{0 1} real nat
           (λ (i : nat),
              @set.Union.{0 0} real
                (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                   (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                      (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                      t))
                (λ
                 (H :
                   @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                     (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                        (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                        t)), @set.Ioo.{0} real real.preorder (c i) (d i)))) →
      @has_le.le.{0} ennreal
        (@preorder.to_has_le.{0} ennreal
           (@partial_order.to_preorder.{0} ennreal
              (@ordered_comm_monoid.to_partial_order.{0} ennreal
                 (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                    (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                       ennreal.canonically_ordered_comm_semiring_1)))))
        (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
           (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
        (@finset.sum.{0 0} nat ennreal
           (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
              (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                 (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                    ennreal.canonically_ordered_comm_semiring_1)))
           t
           (λ (i : nat),
              @coe.{1 1} nnreal ennreal
                (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
                (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (d i) (c i))))),
b : real,
ab :
  @has_le.le.{0} real
    (@preorder.to_has_le.{0} real
       (@partial_order.to_preorder.{0} real (@linear_order.to_partial_order.{0} real real.linear_order)))
    a
    b,
i : nat,
is : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i s,
cb : @has_lt.lt.{0} real (@preorder.to_has_lt.{0} real real.preorder) (c i) b,
bd : @has_lt.lt.{0} real (@preorder.to_has_lt.{0} real real.preorder) b (d i),
cv :
  @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
    (@has_union.union.{0} (set.{0} real) (@set.has_union.{0} real) (@set.Ioo.{0} real real.preorder (c i) (d i))
       (@set.Union.{0 1} real nat
          (λ (x : nat),
             @set.Union.{0 0} real
               (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x
                  (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                     (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                     (@finset.erase.{0} nat (λ (a b : nat), (λ (a b : nat), nat.decidable_eq a b) a b) s i)))
               (λ
                (H :
                  @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x
                    (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                       (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                       (@finset.erase.{0} nat (λ (a b : nat), (λ (a b : nat), nat.decidable_eq a b) a b) s i))),
                  @set.Ioo.{0} real real.preorder (c x) (d x)))))
⊢ @has_le.le.{0} nnreal nnreal.has_le
    (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a))
    (@has_add.add.{0} nnreal nnreal.has_add
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (d i) (c i)))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (c i) a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>118      refine le_trans (nnreal.of_real_le_of_real _) nnreal.of_real_add_le,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='le_trans'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='nnreal.of_real_le_of_real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='nnreal.of_real_add_le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 33, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/nnreal.lean&#x27;, &#x27;line&#x27;: 309, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/nnreal.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : preorder.{0} α] {a b c : α}, @has_le.le.{0} α (@preorder.to_has_le.{0} α _inst_1) a b → @has_le.le.{0} α (@preorder.to_has_le.{0} α _inst_1) b c → @has_le.le.{0} α (@preorder.to_has_le.{0} α _inst_1) a c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {r p : real}, @has_le.le.{0} real real.has_le r p → @has_le.le.{0} nnreal nnreal.has_le (nnreal.of_real r) (nnreal.of_real p)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {r p : real}, @has_le.le.{0} nnreal nnreal.has_le (nnreal.of_real (@has_add.add.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring)) r p)) (@has_add.add.{0} nnreal nnreal.has_add (nnreal.of_real r) (nnreal.of_real p))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a : real,
c d : nat → real,
s s : finset.{0} nat,
IH :
  ∀ (t : finset.{0} nat),
    @has_ssubset.ssubset.{0} (finset.{0} nat) (@finset.has_ssubset.{0} nat) t s →
    ∀ (b : real),
      @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
        (@set.Union.{0 1} real nat
           (λ (i : nat),
              @set.Union.{0 0} real
                (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                   (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                      (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                      t))
                (λ
                 (H :
                   @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                     (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                        (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                        t)), @set.Ioo.{0} real real.preorder (c i) (d i)))) →
      @has_le.le.{0} ennreal
        (@preorder.to_has_le.{0} ennreal
           (@partial_order.to_preorder.{0} ennreal
              (@ordered_comm_monoid.to_partial_order.{0} ennreal
                 (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                    (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                       ennreal.canonically_ordered_comm_semiring_1)))))
        (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
           (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
        (@finset.sum.{0 0} nat ennreal
           (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
              (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                 (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                    ennreal.canonically_ordered_comm_semiring_1)))
           t
           (λ (i : nat),
              @coe.{1 1} nnreal ennreal
                (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
                (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (d i) (c i))))),
b : real,
ab :
  @has_le.le.{0} real
    (@preorder.to_has_le.{0} real
       (@partial_order.to_preorder.{0} real (@linear_order.to_partial_order.{0} real real.linear_order)))
    a
    b,
i : nat,
is : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i s,
cb : @has_lt.lt.{0} real (@preorder.to_has_lt.{0} real real.preorder) (c i) b,
bd : @has_lt.lt.{0} real (@preorder.to_has_lt.{0} real real.preorder) b (d i),
cv :
  @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
    (@has_union.union.{0} (set.{0} real) (@set.has_union.{0} real) (@set.Ioo.{0} real real.preorder (c i) (d i))
       (@set.Union.{0 1} real nat
          (λ (x : nat),
             @set.Union.{0 0} real
               (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x
                  (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                     (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                     (@finset.erase.{0} nat (λ (a b : nat), (λ (a b : nat), nat.decidable_eq a b) a b) s i)))
               (λ
                (H :
                  @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x
                    (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                       (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                       (@finset.erase.{0} nat (λ (a b : nat), (λ (a b : nat), nat.decidable_eq a b) a b) s i))),
                  @set.Ioo.{0} real real.preorder (c x) (d x)))))
⊢ @has_le.le.{0} nnreal nnreal.has_le
    (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a))
    (@has_add.add.{0} nnreal nnreal.has_add
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (d i) (c i)))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (c i) a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a : real,
c d : nat → real,
s s : finset.{0} nat,
IH :
  ∀ (t : finset.{0} nat),
    @has_ssubset.ssubset.{0} (finset.{0} nat) (@finset.has_ssubset.{0} nat) t s →
    ∀ (b : real),
      @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
        (@set.Union.{0 1} real nat
           (λ (i : nat),
              @set.Union.{0 0} real
                (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                   (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                      (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                      t))
                (λ
                 (H :
                   @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                     (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                        (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                        t)), @set.Ioo.{0} real real.preorder (c i) (d i)))) →
      @has_le.le.{0} ennreal
        (@preorder.to_has_le.{0} ennreal
           (@partial_order.to_preorder.{0} ennreal
              (@ordered_comm_monoid.to_partial_order.{0} ennreal
                 (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                    (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                       ennreal.canonically_ordered_comm_semiring_1)))))
        (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
           (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
        (@finset.sum.{0 0} nat ennreal
           (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
              (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                 (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                    ennreal.canonically_ordered_comm_semiring_1)))
           t
           (λ (i : nat),
              @coe.{1 1} nnreal ennreal
                (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
                (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (d i) (c i))))),
b : real,
ab :
  @has_le.le.{0} real
    (@preorder.to_has_le.{0} real
       (@partial_order.to_preorder.{0} real (@linear_order.to_partial_order.{0} real real.linear_order)))
    a
    b,
i : nat,
is : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i s,
cb : @has_lt.lt.{0} real (@preorder.to_has_lt.{0} real real.preorder) (c i) b,
bd : @has_lt.lt.{0} real (@preorder.to_has_lt.{0} real real.preorder) b (d i),
cv :
  @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
    (@has_union.union.{0} (set.{0} real) (@set.has_union.{0} real) (@set.Ioo.{0} real real.preorder (c i) (d i))
       (@set.Union.{0 1} real nat
          (λ (x : nat),
             @set.Union.{0 0} real
               (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x
                  (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                     (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                     (@finset.erase.{0} nat (λ (a b : nat), (λ (a b : nat), nat.decidable_eq a b) a b) s i)))
               (λ
                (H :
                  @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x
                    (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                       (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                       (@finset.erase.{0} nat (λ (a b : nat), (λ (a b : nat), nat.decidable_eq a b) a b) s i))),
                  @set.Ioo.{0} real real.preorder (c x) (d x)))))
⊢ @has_le.le.{0} real real.has_le (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)
    (@has_add.add.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
       (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (d i) (c i))
       (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (c i) a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>119      rw sub_add_sub_cancel,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='sub_add_sub_cancel'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/group/basic.lean&#x27;, &#x27;line&#x27;: 161, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : add_group.{0} α] (a b c : α), @eq.{1} α (@has_add.add.{0} α (@add_semigroup.to_has_add.{0} α (@add_monoid.to_add_semigroup.{0} α (@add_group.to_add_monoid.{0} α _inst_1))) (@has_sub.sub.{0} α (@add_group_has_sub.{0} α _inst_1) a b) (@has_sub.sub.{0} α (@add_group_has_sub.{0} α _inst_1) b c)) (@has_sub.sub.{0} α (@add_group_has_sub.{0} α _inst_1) a c)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a : real,
c d : nat → real,
s s : finset.{0} nat,
IH :
  ∀ (t : finset.{0} nat),
    @has_ssubset.ssubset.{0} (finset.{0} nat) (@finset.has_ssubset.{0} nat) t s →
    ∀ (b : real),
      @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
        (@set.Union.{0 1} real nat
           (λ (i : nat),
              @set.Union.{0 0} real
                (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                   (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                      (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                      t))
                (λ
                 (H :
                   @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                     (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                        (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                        t)), @set.Ioo.{0} real real.preorder (c i) (d i)))) →
      @has_le.le.{0} ennreal
        (@preorder.to_has_le.{0} ennreal
           (@partial_order.to_preorder.{0} ennreal
              (@ordered_comm_monoid.to_partial_order.{0} ennreal
                 (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                    (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                       ennreal.canonically_ordered_comm_semiring_1)))))
        (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
           (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
        (@finset.sum.{0 0} nat ennreal
           (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
              (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                 (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                    ennreal.canonically_ordered_comm_semiring_1)))
           t
           (λ (i : nat),
              @coe.{1 1} nnreal ennreal
                (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
                (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (d i) (c i))))),
b : real,
ab :
  @has_le.le.{0} real
    (@preorder.to_has_le.{0} real
       (@partial_order.to_preorder.{0} real (@linear_order.to_partial_order.{0} real real.linear_order)))
    a
    b,
i : nat,
is : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i s,
cb : @has_lt.lt.{0} real (@preorder.to_has_lt.{0} real real.preorder) (c i) b,
bd : @has_lt.lt.{0} real (@preorder.to_has_lt.{0} real real.preorder) b (d i),
cv :
  @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
    (@has_union.union.{0} (set.{0} real) (@set.has_union.{0} real) (@set.Ioo.{0} real real.preorder (c i) (d i))
       (@set.Union.{0 1} real nat
          (λ (x : nat),
             @set.Union.{0 0} real
               (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x
                  (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                     (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                     (@finset.erase.{0} nat (λ (a b : nat), (λ (a b : nat), nat.decidable_eq a b) a b) s i)))
               (λ
                (H :
                  @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x
                    (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                       (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                       (@finset.erase.{0} nat (λ (a b : nat), (λ (a b : nat), nat.decidable_eq a b) a b) s i))),
                  @set.Ioo.{0} real real.preorder (c x) (d x)))))
⊢ @has_le.le.{0} real real.has_le (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)
    (@has_add.add.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
       (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (d i) (c i))
       (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (c i) a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a : real,
c d : nat → real,
s s : finset.{0} nat,
IH :
  ∀ (t : finset.{0} nat),
    @has_ssubset.ssubset.{0} (finset.{0} nat) (@finset.has_ssubset.{0} nat) t s →
    ∀ (b : real),
      @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
        (@set.Union.{0 1} real nat
           (λ (i : nat),
              @set.Union.{0 0} real
                (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                   (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                      (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                      t))
                (λ
                 (H :
                   @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                     (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                        (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                        t)), @set.Ioo.{0} real real.preorder (c i) (d i)))) →
      @has_le.le.{0} ennreal
        (@preorder.to_has_le.{0} ennreal
           (@partial_order.to_preorder.{0} ennreal
              (@ordered_comm_monoid.to_partial_order.{0} ennreal
                 (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                    (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                       ennreal.canonically_ordered_comm_semiring_1)))))
        (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
           (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
        (@finset.sum.{0 0} nat ennreal
           (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
              (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                 (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                    ennreal.canonically_ordered_comm_semiring_1)))
           t
           (λ (i : nat),
              @coe.{1 1} nnreal ennreal
                (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
                (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (d i) (c i))))),
b : real,
ab :
  @has_le.le.{0} real
    (@preorder.to_has_le.{0} real
       (@partial_order.to_preorder.{0} real (@linear_order.to_partial_order.{0} real real.linear_order)))
    a
    b,
i : nat,
is : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i s,
cb : @has_lt.lt.{0} real (@preorder.to_has_lt.{0} real real.preorder) (c i) b,
bd : @has_lt.lt.{0} real (@preorder.to_has_lt.{0} real real.preorder) b (d i),
cv :
  @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
    (@has_union.union.{0} (set.{0} real) (@set.has_union.{0} real) (@set.Ioo.{0} real real.preorder (c i) (d i))
       (@set.Union.{0 1} real nat
          (λ (x : nat),
             @set.Union.{0 0} real
               (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x
                  (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                     (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                     (@finset.erase.{0} nat (λ (a b : nat), (λ (a b : nat), nat.decidable_eq a b) a b) s i)))
               (λ
                (H :
                  @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x
                    (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                       (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                       (@finset.erase.{0} nat (λ (a b : nat), (λ (a b : nat), nat.decidable_eq a b) a b) s i))),
                  @set.Ioo.{0} real real.preorder (c x) (d x)))))
⊢ @has_le.le.{0} real real.has_le (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)
    (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (d i) a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>120      exact sub_le_sub_right (le_of_lt bd) _ },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='sub_le_sub_right'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='le_of_lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='bd'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/ordered_group.lean&#x27;, &#x27;line&#x27;: 451, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 99, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : ordered_comm_group.{0} α] {a b : α}, @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@ordered_comm_group.to_partial_order.{0} α _inst_1))) a b → ∀ (c : α), @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@ordered_comm_group.to_partial_order.{0} α _inst_1))) (@has_sub.sub.{0} α (@add_group_has_sub.{0} α (@add_comm_group.to_add_group.{0} α (@ordered_comm_group.to_add_comm_group.{0} α _inst_1))) a c) (@has_sub.sub.{0} α (@add_group_has_sub.{0} α (@add_comm_group.to_add_group.{0} α (@ordered_comm_group.to_add_comm_group.{0} α _inst_1))) b c)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type} [_inst_1 : preorder.{0} α] {a b : α}, @has_lt.lt.{0} α (@preorder.to_has_lt.{0} α _inst_1) a b → @has_le.le.{0} α (@preorder.to_has_le.{0} α _inst_1) a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_lt.lt.{0} real (@preorder.to_has_lt.{0} real real.preorder) b (d i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a : real,
c d : nat → real,
s s : finset.{0} nat,
IH :
  ∀ (t : finset.{0} nat),
    @has_ssubset.ssubset.{0} (finset.{0} nat) (@finset.has_ssubset.{0} nat) t s →
    ∀ (b : real),
      @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
        (@set.Union.{0 1} real nat
           (λ (i : nat),
              @set.Union.{0 0} real
                (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                   (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                      (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                      t))
                (λ
                 (H :
                   @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                     (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                        (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                        t)), @set.Ioo.{0} real real.preorder (c i) (d i)))) →
      @has_le.le.{0} ennreal
        (@preorder.to_has_le.{0} ennreal
           (@partial_order.to_preorder.{0} ennreal
              (@ordered_comm_monoid.to_partial_order.{0} ennreal
                 (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                    (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                       ennreal.canonically_ordered_comm_semiring_1)))))
        (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
           (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
        (@finset.sum.{0 0} nat ennreal
           (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
              (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                 (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                    ennreal.canonically_ordered_comm_semiring_1)))
           t
           (λ (i : nat),
              @coe.{1 1} nnreal ennreal
                (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
                (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (d i) (c i))))),
b : real,
ab :
  @has_le.le.{0} real
    (@preorder.to_has_le.{0} real
       (@partial_order.to_preorder.{0} real (@linear_order.to_partial_order.{0} real real.linear_order)))
    a
    b,
i : nat,
is : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i s,
cb : @has_lt.lt.{0} real (@preorder.to_has_lt.{0} real real.preorder) (c i) b,
bd : @has_lt.lt.{0} real (@preorder.to_has_lt.{0} real real.preorder) b (d i),
cv :
  @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
    (@has_union.union.{0} (set.{0} real) (@set.has_union.{0} real) (@set.Ioo.{0} real real.preorder (c i) (d i))
       (@set.Union.{0 1} real nat
          (λ (x : nat),
             @set.Union.{0 0} real
               (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x
                  (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                     (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                     (@finset.erase.{0} nat (λ (a b : nat), (λ (a b : nat), nat.decidable_eq a b) a b) s i)))
               (λ
                (H :
                  @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x
                    (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                       (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                       (@finset.erase.{0} nat (λ (a b : nat), (λ (a b : nat), nat.decidable_eq a b) a b) s i))),
                  @set.Ioo.{0} real real.preorder (c x) (d x)))))
⊢ @has_le.le.{0} real real.has_le (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)
    (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (d i) a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a : real,
c d : nat → real,
s s : finset.{0} nat,
IH :
  ∀ (t : finset.{0} nat),
    @has_ssubset.ssubset.{0} (finset.{0} nat) (@finset.has_ssubset.{0} nat) t s →
    ∀ (b : real),
      @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
        (@set.Union.{0 1} real nat
           (λ (i : nat),
              @set.Union.{0 0} real
                (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                   (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                      (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                      t))
                (λ
                 (H :
                   @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                     (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                        (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                        t)), @set.Ioo.{0} real real.preorder (c i) (d i)))) →
      @has_le.le.{0} ennreal
        (@preorder.to_has_le.{0} ennreal
           (@partial_order.to_preorder.{0} ennreal
              (@ordered_comm_monoid.to_partial_order.{0} ennreal
                 (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                    (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                       ennreal.canonically_ordered_comm_semiring_1)))))
        (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
           (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
        (@finset.sum.{0 0} nat ennreal
           (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
              (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                 (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                    ennreal.canonically_ordered_comm_semiring_1)))
           t
           (λ (i : nat),
              @coe.{1 1} nnreal ennreal
                (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
                (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (d i) (c i))))),
b : real,
ab :
  @has_le.le.{0} real
    (@preorder.to_has_le.{0} real
       (@partial_order.to_preorder.{0} real (@linear_order.to_partial_order.{0} real real.linear_order)))
    a
    b,
i : nat,
is : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i s,
cb : @has_lt.lt.{0} real (@preorder.to_has_lt.{0} real real.preorder) (c i) b,
bd : @has_lt.lt.{0} real (@preorder.to_has_lt.{0} real real.preorder) b (d i),
cv :
  @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
    (@has_union.union.{0} (set.{0} real) (@set.has_union.{0} real) (@set.Ioo.{0} real real.preorder (c i) (d i))
       (@set.Union.{0 1} real nat
          (λ (x : nat),
             @set.Union.{0 0} real
               (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x
                  (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                     (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                     (@finset.erase.{0} nat (λ (a b : nat), (λ (a b : nat), nat.decidable_eq a b) a b) s i)))
               (λ
                (H :
                  @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x
                    (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                       (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                       (@finset.erase.{0} nat (λ (a b : nat), (λ (a b : nat), nat.decidable_eq a b) a b) s i))),
                  @set.Ioo.{0} real real.preorder (c x) (d x)))))
⊢ @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a (c i))
    (@set.Union.{0 1} real nat
       (λ (i_1 : nat),
          @set.Union.{0 0} real
            (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i_1
               (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                  (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                  (@finset.erase.{0} nat (λ (a b : nat), nat.decidable_eq a b) s i)))
            (λ
             (H :
               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i_1
                 (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                    (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                    (@finset.erase.{0} nat (λ (a b : nat), nat.decidable_eq a b) s i))),
               @set.Ioo.{0} real real.preorder (c i_1) (d i_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>121    { rintro x ⟨h₁, h₂⟩,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 441, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat) (λ (a : sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat), @sum.has_reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) nat (λ (a : nat), nat.reflect a) `(tactic.list_Pi.{0} tactic.rcases_patt) `(nat) a) tactic.rintro_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `rintro` tactic is a combination of the `intros` tactic with `rcases` to
allow for destructuring patterns while introducing variables. See `rcases` for
a description of supported patterns. For example, `rintro (a | ⟨b, c⟩) ⟨d, e⟩`
will introduce two variables, and then do case splits on both of them producing
two subgoals, one with variables `a d e` and the other with `b c d e`.

`rintro?` will introduce and case split on variables in the same way as
`rintro`, but will also print the `rintro` invocation that would have the same
result. Like `rcases?`, `rintro? : n` allows for modifying the
depth of splitting; the default is 5.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rintro'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; (: n)?) | patt_list&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a : real,
c d : nat → real,
s s : finset.{0} nat,
IH :
  ∀ (t : finset.{0} nat),
    @has_ssubset.ssubset.{0} (finset.{0} nat) (@finset.has_ssubset.{0} nat) t s →
    ∀ (b : real),
      @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
        (@set.Union.{0 1} real nat
           (λ (i : nat),
              @set.Union.{0 0} real
                (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                   (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                      (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                      t))
                (λ
                 (H :
                   @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                     (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                        (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                        t)), @set.Ioo.{0} real real.preorder (c i) (d i)))) →
      @has_le.le.{0} ennreal
        (@preorder.to_has_le.{0} ennreal
           (@partial_order.to_preorder.{0} ennreal
              (@ordered_comm_monoid.to_partial_order.{0} ennreal
                 (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                    (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                       ennreal.canonically_ordered_comm_semiring_1)))))
        (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
           (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
        (@finset.sum.{0 0} nat ennreal
           (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
              (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                 (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                    ennreal.canonically_ordered_comm_semiring_1)))
           t
           (λ (i : nat),
              @coe.{1 1} nnreal ennreal
                (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
                (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (d i) (c i))))),
b : real,
ab :
  @has_le.le.{0} real
    (@preorder.to_has_le.{0} real
       (@partial_order.to_preorder.{0} real (@linear_order.to_partial_order.{0} real real.linear_order)))
    a
    b,
i : nat,
is : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i s,
cb : @has_lt.lt.{0} real (@preorder.to_has_lt.{0} real real.preorder) (c i) b,
bd : @has_lt.lt.{0} real (@preorder.to_has_lt.{0} real real.preorder) b (d i),
cv :
  @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
    (@has_union.union.{0} (set.{0} real) (@set.has_union.{0} real) (@set.Ioo.{0} real real.preorder (c i) (d i))
       (@set.Union.{0 1} real nat
          (λ (x : nat),
             @set.Union.{0 0} real
               (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x
                  (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                     (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                     (@finset.erase.{0} nat (λ (a b : nat), (λ (a b : nat), nat.decidable_eq a b) a b) s i)))
               (λ
                (H :
                  @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x
                    (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                       (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                       (@finset.erase.{0} nat (λ (a b : nat), (λ (a b : nat), nat.decidable_eq a b) a b) s i))),
                  @set.Ioo.{0} real real.preorder (c x) (d x)))))
⊢ @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a (c i))
    (@set.Union.{0 1} real nat
       (λ (i_1 : nat),
          @set.Union.{0 0} real
            (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i_1
               (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                  (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                  (@finset.erase.{0} nat (λ (a b : nat), nat.decidable_eq a b) s i)))
            (λ
             (H :
               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i_1
                 (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                    (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                    (@finset.erase.{0} nat (λ (a b : nat), nat.decidable_eq a b) s i))),
               @set.Ioo.{0} real real.preorder (c i_1) (d i_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a : real,
c d : nat → real,
s s : finset.{0} nat,
IH :
  ∀ (t : finset.{0} nat),
    @has_ssubset.ssubset.{0} (finset.{0} nat) (@finset.has_ssubset.{0} nat) t s →
    ∀ (b : real),
      @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
        (@set.Union.{0 1} real nat
           (λ (i : nat),
              @set.Union.{0 0} real
                (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                   (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                      (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                      t))
                (λ
                 (H :
                   @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                     (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                        (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                        t)), @set.Ioo.{0} real real.preorder (c i) (d i)))) →
      @has_le.le.{0} ennreal
        (@preorder.to_has_le.{0} ennreal
           (@partial_order.to_preorder.{0} ennreal
              (@ordered_comm_monoid.to_partial_order.{0} ennreal
                 (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                    (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                       ennreal.canonically_ordered_comm_semiring_1)))))
        (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
           (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
        (@finset.sum.{0 0} nat ennreal
           (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
              (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                 (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                    ennreal.canonically_ordered_comm_semiring_1)))
           t
           (λ (i : nat),
              @coe.{1 1} nnreal ennreal
                (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
                (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (d i) (c i))))),
b : real,
ab :
  @has_le.le.{0} real
    (@preorder.to_has_le.{0} real
       (@partial_order.to_preorder.{0} real (@linear_order.to_partial_order.{0} real real.linear_order)))
    a
    b,
i : nat,
is : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i s,
cb : @has_lt.lt.{0} real (@preorder.to_has_lt.{0} real real.preorder) (c i) b,
bd : @has_lt.lt.{0} real (@preorder.to_has_lt.{0} real real.preorder) b (d i),
cv :
  @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
    (@has_union.union.{0} (set.{0} real) (@set.has_union.{0} real) (@set.Ioo.{0} real real.preorder (c i) (d i))
       (@set.Union.{0 1} real nat
          (λ (x : nat),
             @set.Union.{0 0} real
               (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x
                  (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                     (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                     (@finset.erase.{0} nat (λ (a b : nat), (λ (a b : nat), nat.decidable_eq a b) a b) s i)))
               (λ
                (H :
                  @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x
                    (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                       (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                       (@finset.erase.{0} nat (λ (a b : nat), (λ (a b : nat), nat.decidable_eq a b) a b) s i))),
                  @set.Ioo.{0} real real.preorder (c x) (d x))))),
x : real,
h₁ : @has_le.le.{0} real (@preorder.to_has_le.{0} real real.preorder) a x,
h₂ : @has_le.le.{0} real (@preorder.to_has_le.{0} real real.preorder) x (c i)
⊢ @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x
    (@set.Union.{0 1} real nat
       (λ (i_1 : nat),
          @set.Union.{0 0} real
            (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i_1
               (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                  (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                  (@finset.erase.{0} nat (λ (a b : nat), nat.decidable_eq a b) s i)))
            (λ
             (H :
               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i_1
                 (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                    (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                    (@finset.erase.{0} nat (λ (a b : nat), nat.decidable_eq a b) s i))),
               @set.Ioo.{0} real real.preorder (c i_1) (d i_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>122      refine (cv ⟨h₁, le_trans h₂ (le_of_lt cb)⟩).resolve_left</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='cv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='h₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='le_trans'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='le_of_lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='cb'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 33, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 99, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b) (@has_union.union.{0} (set.{0} real) (@set.has_union.{0} real) (@set.Ioo.{0} real real.preorder (c i) (d i)) (@set.Union.{0 1} real nat (λ (x : nat), @set.Union.{0 0} real (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x (@coe.{1 1} (finset.{0} nat) (set.{0} nat) (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat)) (@finset.erase.{0} nat (λ (a b : nat), (λ (a b : nat), nat.decidable_eq a b) a b) s i))) (λ (H : @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x (@coe.{1 1} (finset.{0} nat) (set.{0} nat) (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat)) (@finset.erase.{0} nat (λ (a b : nat), (λ (a b : nat), nat.decidable_eq a b) a b) s i))), @set.Ioo.{0} real real.preorder (c x) (d x)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_le.le.{0} real (@preorder.to_has_le.{0} real real.preorder) a x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : preorder.{0} α] {a b c : α}, @has_le.le.{0} α (@preorder.to_has_le.{0} α _inst_1) a b → @has_le.le.{0} α (@preorder.to_has_le.{0} α _inst_1) b c → @has_le.le.{0} α (@preorder.to_has_le.{0} α _inst_1) a c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type} [_inst_1 : preorder.{0} α] {a b : α}, @has_lt.lt.{0} α (@preorder.to_has_lt.{0} α _inst_1) a b → @has_le.le.{0} α (@preorder.to_has_le.{0} α _inst_1) a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_lt.lt.{0} real (@preorder.to_has_lt.{0} real real.preorder) (c i) b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a : real,
c d : nat → real,
s s : finset.{0} nat,
IH :
  ∀ (t : finset.{0} nat),
    @has_ssubset.ssubset.{0} (finset.{0} nat) (@finset.has_ssubset.{0} nat) t s →
    ∀ (b : real),
      @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
        (@set.Union.{0 1} real nat
           (λ (i : nat),
              @set.Union.{0 0} real
                (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                   (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                      (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                      t))
                (λ
                 (H :
                   @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                     (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                        (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                        t)), @set.Ioo.{0} real real.preorder (c i) (d i)))) →
      @has_le.le.{0} ennreal
        (@preorder.to_has_le.{0} ennreal
           (@partial_order.to_preorder.{0} ennreal
              (@ordered_comm_monoid.to_partial_order.{0} ennreal
                 (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                    (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                       ennreal.canonically_ordered_comm_semiring_1)))))
        (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
           (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
        (@finset.sum.{0 0} nat ennreal
           (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
              (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                 (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                    ennreal.canonically_ordered_comm_semiring_1)))
           t
           (λ (i : nat),
              @coe.{1 1} nnreal ennreal
                (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
                (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (d i) (c i))))),
b : real,
ab :
  @has_le.le.{0} real
    (@preorder.to_has_le.{0} real
       (@partial_order.to_preorder.{0} real (@linear_order.to_partial_order.{0} real real.linear_order)))
    a
    b,
i : nat,
is : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i s,
cb : @has_lt.lt.{0} real (@preorder.to_has_lt.{0} real real.preorder) (c i) b,
bd : @has_lt.lt.{0} real (@preorder.to_has_lt.{0} real real.preorder) b (d i),
cv :
  @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
    (@has_union.union.{0} (set.{0} real) (@set.has_union.{0} real) (@set.Ioo.{0} real real.preorder (c i) (d i))
       (@set.Union.{0 1} real nat
          (λ (x : nat),
             @set.Union.{0 0} real
               (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x
                  (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                     (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                     (@finset.erase.{0} nat (λ (a b : nat), (λ (a b : nat), nat.decidable_eq a b) a b) s i)))
               (λ
                (H :
                  @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x
                    (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                       (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                       (@finset.erase.{0} nat (λ (a b : nat), (λ (a b : nat), nat.decidable_eq a b) a b) s i))),
                  @set.Ioo.{0} real real.preorder (c x) (d x))))),
x : real,
h₁ : @has_le.le.{0} real (@preorder.to_has_le.{0} real real.preorder) a x,
h₂ : @has_le.le.{0} real (@preorder.to_has_le.{0} real real.preorder) x (c i)
⊢ @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x
    (@set.Union.{0 1} real nat
       (λ (i_1 : nat),
          @set.Union.{0 0} real
            (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i_1
               (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                  (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                  (@finset.erase.{0} nat (λ (a b : nat), nat.decidable_eq a b) s i)))
            (λ
             (H :
               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i_1
                 (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                    (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                    (@finset.erase.{0} nat (λ (a b : nat), nat.decidable_eq a b) s i))),
               @set.Ioo.{0} real real.preorder (c i_1) (d i_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>123        (mt and.left (not_lt_of_le h₂)) }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='mt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='and.left'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='not_lt_of_le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 34, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/order.lean&#x27;, &#x27;line&#x27;: 16, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {a b : Prop}, (a → b) → not b → not a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, and a b → a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type} [_inst_1 : preorder.{0} α] {a b : α}, @has_le.le.{0} α (@preorder.to_has_le.{0} α _inst_1) a b → not (@has_lt.lt.{0} α (@preorder.to_has_lt.{0} α _inst_1) b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_le.le.{0} real (@preorder.to_has_le.{0} real real.preorder) x (c i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a : real,
c d : nat → real,
s s : finset.{0} nat,
IH :
  ∀ (t : finset.{0} nat),
    @has_ssubset.ssubset.{0} (finset.{0} nat) (@finset.has_ssubset.{0} nat) t s →
    ∀ (b : real),
      @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
        (@set.Union.{0 1} real nat
           (λ (i : nat),
              @set.Union.{0 0} real
                (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                   (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                      (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                      t))
                (λ
                 (H :
                   @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i
                     (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                        (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                        t)), @set.Ioo.{0} real real.preorder (c i) (d i)))) →
      @has_le.le.{0} ennreal
        (@preorder.to_has_le.{0} ennreal
           (@partial_order.to_preorder.{0} ennreal
              (@ordered_comm_monoid.to_partial_order.{0} ennreal
                 (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                    (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                       ennreal.canonically_ordered_comm_semiring_1)))))
        (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
           (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
        (@finset.sum.{0 0} nat ennreal
           (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
              (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                 (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                    ennreal.canonically_ordered_comm_semiring_1)))
           t
           (λ (i : nat),
              @coe.{1 1} nnreal ennreal
                (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
                (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (d i) (c i))))),
b : real,
ab :
  @has_le.le.{0} real
    (@preorder.to_has_le.{0} real
       (@partial_order.to_preorder.{0} real (@linear_order.to_partial_order.{0} real real.linear_order)))
    a
    b,
i : nat,
is : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i s,
cb : @has_lt.lt.{0} real (@preorder.to_has_lt.{0} real real.preorder) (c i) b,
bd : @has_lt.lt.{0} real (@preorder.to_has_lt.{0} real real.preorder) b (d i),
cv :
  @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
    (@has_union.union.{0} (set.{0} real) (@set.has_union.{0} real) (@set.Ioo.{0} real real.preorder (c i) (d i))
       (@set.Union.{0 1} real nat
          (λ (x : nat),
             @set.Union.{0 0} real
               (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x
                  (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                     (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                     (@finset.erase.{0} nat (λ (a b : nat), (λ (a b : nat), nat.decidable_eq a b) a b) s i)))
               (λ
                (H :
                  @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x
                    (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                       (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                       (@finset.erase.{0} nat (λ (a b : nat), (λ (a b : nat), nat.decidable_eq a b) a b) s i))),
                  @set.Ioo.{0} real real.preorder (c x) (d x))))),
x : real,
h₁ : @has_le.le.{0} real (@preorder.to_has_le.{0} real real.preorder) a x,
h₂ : @has_le.le.{0} real (@preorder.to_has_le.{0} real real.preorder) x (c i)
⊢ @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x
    (@set.Union.{0 1} real nat
       (λ (i_1 : nat),
          @set.Union.{0 0} real
            (@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i_1
               (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                  (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                  (@finset.erase.{0} nat (λ (a b : nat), nat.decidable_eq a b) s i)))
            (λ
             (H :
               @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) i_1
                 (@coe.{1 1} (finset.{0} nat) (set.{0} nat)
                    (@lift_base.{1 1} (finset.{0} nat) (set.{0} nat) (@finset.has_lift.{0} nat))
                    (@finset.erase.{0} nat (λ (a b : nat), nat.decidable_eq a b) s i))),
               @set.Ioo.{0} real real.preorder (c i_1) (d i_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>124  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>125  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>126  @[simp] lemma lebesgue_outer_Icc (a b : ℝ) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='blue'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/basic.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>127    lebesgue_outer (Icc a b) = of_real (b - a) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='measure_theory.lebesgue_outer'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.Icc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='nnreal.of_real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_sub.sub'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 87, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/intervals/basic.lean&#x27;, &#x27;line&#x27;: 49, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/nnreal.lean&#x27;, &#x27;line&#x27;: 32, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 315, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='measure_theory.outer_measure.{0} real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [_inst_1 : preorder.{u} α], α → α → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='prod.{0 0} real real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real → nnreal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_sub.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The Lebesgue outer measure, as an outer measure of ℝ.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Left-closed right-closed interval'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>128  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a b : real
⊢ @eq.{1} ennreal
    (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real) (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
       measure_theory.lebesgue_outer
       (@set.Icc.{0} real real.preorder a b))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>129    refine le_antisymm (by rw ← lebesgue_length_Icc; apply lebesgue_outer_le_length)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='le_antisymm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='measure_theory.lebesgue_length_Icc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='measure_theory.lebesgue_outer_le_length'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 45, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 77, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 90, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : partial_order.{0} α] {a b : α}, @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α _inst_1)) a b → @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α _inst_1)) b a → @eq.{1} α a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (a b : real), @eq.{1} ennreal (measure_theory.lebesgue_length (@set.Icc.{0} real real.preorder a b)) (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe)) (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (s : set.{0} real), @has_le.le.{0} ennreal (@preorder.to_has_le.{0} ennreal (@partial_order.to_preorder.{0} ennreal (@ordered_comm_monoid.to_partial_order.{0} ennreal (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal ennreal.canonically_ordered_comm_semiring_1))))) (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real) (@measure_theory.outer_measure.has_coe_to_fun.{0} real) measure_theory.lebesgue_outer s) (measure_theory.lebesgue_length s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a b : real
⊢ @eq.{1} ennreal
    (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real) (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
       measure_theory.lebesgue_outer
       (@set.Icc.{0} real real.preorder a b))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a b : real
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real) (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
       measure_theory.lebesgue_outer
       (@set.Icc.{0} real real.preorder a b))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a b : real
⊢ @eq.{1} ennreal
    (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real) (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
       measure_theory.lebesgue_outer
       (@set.Icc.{0} real real.preorder a b))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>130      (le_infi $ λ f, le_infi $ λ hf,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='blue'><a title='lattice.le_infi'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/complete_lattice.lean&#x27;, &#x27;line&#x27;: 300, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α ι : Type} [_inst_1 : lattice.complete_lattice.{0} α] {s : ι → α} {a : α}, (∀ (i : ι), @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@lattice.order_bot.to_partial_order.{0} α (@lattice.bounded_lattice.to_order_bot.{0} α (@lattice.complete_lattice.to_bounded_lattice.{0} α _inst_1))))) a (s i)) → @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@lattice.order_bot.to_partial_order.{0} α (@lattice.bounded_lattice.to_order_bot.{0} α (@lattice.complete_lattice.to_bounded_lattice.{0} α _inst_1))))) a (@lattice.infi.{0 1} α ι (@lattice.complete_lattice.to_has_Inf.{0} α _inst_1) s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a b : real
⊢ @eq.{1} ennreal
    (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real) (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
       measure_theory.lebesgue_outer
       (@set.Icc.{0} real real.preorder a b))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>131      ennreal.le_of_forall_epsilon_le $ λ ε ε0 h, _),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='ennreal.le_of_forall_epsilon_le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/ennreal.lean&#x27;, &#x27;line&#x27;: 259, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : ennreal}, (∀ (ε : nnreal), @has_lt.lt.{0} nnreal (@preorder.to_has_lt.{0} nnreal (@partial_order.to_preorder.{0} nnreal (@ordered_comm_monoid.to_partial_order.{0} nnreal (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring)))))) (@has_zero.zero.{0} nnreal nnreal.has_zero) ε → @has_lt.lt.{0} ennreal (@preorder.to_has_lt.{0} ennreal (@partial_order.to_preorder.{0} ennreal (@ordered_comm_monoid.to_partial_order.{0} ennreal (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal ennreal.canonically_ordered_comm_semiring_1))))) b (@lattice.has_top.top.{0} ennreal (@lattice.order_top.to_has_top.{0} ennreal (@lattice.bounded_lattice.to_order_top.{0} ennreal (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))))) → @has_le.le.{0} ennreal (@preorder.to_has_le.{0} ennreal (@partial_order.to_preorder.{0} ennreal (@ordered_comm_monoid.to_partial_order.{0} ennreal (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal ennreal.canonically_ordered_comm_semiring_1))))) a (@has_add.add.{0} ennreal (@distrib.to_has_add.{0} ennreal (@semiring.to_distrib.{0} ennreal (@comm_semiring.to_semiring.{0} ennreal (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal ennreal.canonically_ordered_comm_semiring_1)))) b (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe)) ε))) → @has_le.le.{0} ennreal (@preorder.to_has_le.{0} ennreal (@partial_order.to_preorder.{0} ennreal (@ordered_comm_monoid.to_partial_order.{0} ennreal (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal ennreal.canonically_ordered_comm_semiring_1))))) a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a b : real
⊢ @eq.{1} ennreal
    (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real) (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
       measure_theory.lebesgue_outer
       (@set.Icc.{0} real real.preorder a b))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a b : real,
f : nat → set.{0} real,
hf :
  @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
    (@set.Union.{0 1} real nat (λ (i : nat), f i)),
ε : nnreal,
ε0 :
  @has_lt.lt.{0} nnreal
    (@preorder.to_has_lt.{0} nnreal
       (@partial_order.to_preorder.{0} nnreal
          (@ordered_comm_monoid.to_partial_order.{0} nnreal
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                   (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
    (@has_zero.zero.{0} nnreal nnreal.has_zero)
    ε,
h :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat), measure_theory.lebesgue_length (f i)))
    (@lattice.has_top.top.{0} ennreal
       (@lattice.order_top.to_has_top.{0} ennreal
          (@lattice.bounded_lattice.to_order_top.{0} ennreal
             (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))))
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
    (@has_add.add.{0} ennreal
       (@distrib.to_has_add.{0} ennreal
          (@semiring.to_distrib.{0} ennreal
             (@comm_semiring.to_semiring.{0} ennreal
                (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1))))
       (@tsum.{0 0} ennreal nat
          (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))
          ennreal.topological_space
          (λ (i : nat), measure_theory.lebesgue_length (f i)))
       (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
          ε))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>132    rcases ennreal.exists_pos_sum_of_encodable</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='ennreal.exists_pos_sum_of_encodable'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/specific_limits.lean&#x27;, &#x27;line&#x27;: 440, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {ε : ennreal}, @has_lt.lt.{0} ennreal (@preorder.to_has_lt.{0} ennreal (@partial_order.to_preorder.{0} ennreal (@ordered_comm_monoid.to_partial_order.{0} ennreal (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal ennreal.canonically_ordered_comm_semiring_1))))) (@has_zero.zero.{0} ennreal (@zero_ne_one_class.to_has_zero.{0} ennreal (@canonically_ordered_comm_semiring.to_zero_ne_one_class.{0} ennreal ennreal.canonically_ordered_comm_semiring_1))) ε → ∀ (ι : Type) [_inst_1 : encodable.{0} ι], @Exists.{1} (ι → nnreal) (λ (ε&#x27; : ι → nnreal), and (∀ (i : ι), @has_lt.lt.{0} nnreal (@preorder.to_has_lt.{0} nnreal (@partial_order.to_preorder.{0} nnreal (@ordered_comm_monoid.to_partial_order.{0} nnreal (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring)))))) (@has_zero.zero.{0} nnreal nnreal.has_zero) (ε&#x27; i)) (@has_lt.lt.{0} ennreal (@preorder.to_has_lt.{0} ennreal (@partial_order.to_preorder.{0} ennreal (@ordered_comm_monoid.to_partial_order.{0} ennreal (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal ennreal.canonically_ordered_comm_semiring_1))))) (@tsum.{0 0} ennreal ι (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal ennreal.canonically_ordered_comm_semiring_1))) ennreal.topological_space (λ (i : ι), @coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe)) (ε&#x27; i))) ε))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a b : real,
f : nat → set.{0} real,
hf :
  @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
    (@set.Union.{0 1} real nat (λ (i : nat), f i)),
ε : nnreal,
ε0 :
  @has_lt.lt.{0} nnreal
    (@preorder.to_has_lt.{0} nnreal
       (@partial_order.to_preorder.{0} nnreal
          (@ordered_comm_monoid.to_partial_order.{0} nnreal
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                   (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
    (@has_zero.zero.{0} nnreal nnreal.has_zero)
    ε,
h :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat), measure_theory.lebesgue_length (f i)))
    (@lattice.has_top.top.{0} ennreal
       (@lattice.order_top.to_has_top.{0} ennreal
          (@lattice.bounded_lattice.to_order_top.{0} ennreal
             (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))))
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
    (@has_add.add.{0} ennreal
       (@distrib.to_has_add.{0} ennreal
          (@semiring.to_distrib.{0} ennreal
             (@comm_semiring.to_semiring.{0} ennreal
                (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1))))
       (@tsum.{0 0} ennreal nat
          (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))
          ennreal.topological_space
          (λ (i : nat), measure_theory.lebesgue_length (f i)))
       (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
          ε))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>133      (ennreal.zero_lt_coe_iff.2 ε0) ℕ with ⟨ε&#x27;, ε&#x27;0, hε⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='ennreal.zero_lt_coe_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='ε0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/ennreal.lean&#x27;, &#x27;line&#x27;: 218, &#x27;column&#x27;: 25}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {p : nnreal}, iff (@has_lt.lt.{0} ennreal (@preorder.to_has_lt.{0} ennreal (@partial_order.to_preorder.{0} ennreal (@ordered_comm_monoid.to_partial_order.{0} ennreal (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal ennreal.canonically_ordered_comm_semiring_1))))) (@has_zero.zero.{0} ennreal (@zero_ne_one_class.to_has_zero.{0} ennreal (@canonically_ordered_comm_semiring.to_zero_ne_one_class.{0} ennreal ennreal.canonically_ordered_comm_semiring_1))) (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe)) p)) (@has_lt.lt.{0} nnreal (@preorder.to_has_lt.{0} nnreal (@partial_order.to_preorder.{0} nnreal (@ordered_comm_monoid.to_partial_order.{0} nnreal (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring)))))) (@has_zero.zero.{0} nnreal nnreal.has_zero) p)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_lt.lt.{0} nnreal (@preorder.to_has_lt.{0} nnreal (@partial_order.to_preorder.{0} nnreal (@ordered_comm_monoid.to_partial_order.{0} nnreal (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring)))))) (@has_zero.zero.{0} nnreal nnreal.has_zero) ε'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a b : real,
f : nat → set.{0} real,
hf :
  @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
    (@set.Union.{0 1} real nat (λ (i : nat), f i)),
ε : nnreal,
ε0 :
  @has_lt.lt.{0} nnreal
    (@preorder.to_has_lt.{0} nnreal
       (@partial_order.to_preorder.{0} nnreal
          (@ordered_comm_monoid.to_partial_order.{0} nnreal
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                   (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
    (@has_zero.zero.{0} nnreal nnreal.has_zero)
    ε,
h :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat), measure_theory.lebesgue_length (f i)))
    (@lattice.has_top.top.{0} ennreal
       (@lattice.order_top.to_has_top.{0} ennreal
          (@lattice.bounded_lattice.to_order_top.{0} ennreal
             (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))))
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
    (@has_add.add.{0} ennreal
       (@distrib.to_has_add.{0} ennreal
          (@semiring.to_distrib.{0} ennreal
             (@comm_semiring.to_semiring.{0} ennreal
                (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1))))
       (@tsum.{0 0} ennreal nat
          (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))
          ennreal.topological_space
          (λ (i : nat), measure_theory.lebesgue_length (f i)))
       (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
          ε))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a b : real,
f : nat → set.{0} real,
hf :
  @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
    (@set.Union.{0 1} real nat (λ (i : nat), f i)),
ε : nnreal,
ε0 :
  @has_lt.lt.{0} nnreal
    (@preorder.to_has_lt.{0} nnreal
       (@partial_order.to_preorder.{0} nnreal
          (@ordered_comm_monoid.to_partial_order.{0} nnreal
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                   (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
    (@has_zero.zero.{0} nnreal nnreal.has_zero)
    ε,
h :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat), measure_theory.lebesgue_length (f i)))
    (@lattice.has_top.top.{0} ennreal
       (@lattice.order_top.to_has_top.{0} ennreal
          (@lattice.bounded_lattice.to_order_top.{0} ennreal
             (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))))),
ε&#x27; : nat → nnreal,
ε&#x27;0 :
  ∀ (i : nat),
    @has_lt.lt.{0} nnreal
      (@preorder.to_has_lt.{0} nnreal
         (@partial_order.to_preorder.{0} nnreal
            (@ordered_comm_monoid.to_partial_order.{0} nnreal
               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                     (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
      (@has_zero.zero.{0} nnreal nnreal.has_zero)
      (ε&#x27; i),
hε :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat),
          @coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
            (ε&#x27; i)))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe)) ε)
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
    (@has_add.add.{0} ennreal
       (@distrib.to_has_add.{0} ennreal
          (@semiring.to_distrib.{0} ennreal
             (@comm_semiring.to_semiring.{0} ennreal
                (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1))))
       (@tsum.{0 0} ennreal nat
          (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))
          ennreal.topological_space
          (λ (i : nat), measure_theory.lebesgue_length (f i)))
       (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
          ε))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>134    refine le_trans _ (add_le_add_left&#x27; (le_of_lt hε)),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='le_trans'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='add_le_add_left&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='le_of_lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hε'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 33, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/ordered_group.lean&#x27;, &#x27;line&#x27;: 37, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 99, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : preorder.{0} α] {a b c : α}, @has_le.le.{0} α (@preorder.to_has_le.{0} α _inst_1) a b → @has_le.le.{0} α (@preorder.to_has_le.{0} α _inst_1) b c → @has_le.le.{0} α (@preorder.to_has_le.{0} α _inst_1) a c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type} [_inst_1 : ordered_comm_monoid.{0} α] {a b c : α}, @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@ordered_comm_monoid.to_partial_order.{0} α _inst_1))) a b → @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@ordered_comm_monoid.to_partial_order.{0} α _inst_1))) (@has_add.add.{0} α (@add_semigroup.to_has_add.{0} α (@add_monoid.to_add_semigroup.{0} α (@add_comm_monoid.to_add_monoid.{0} α (@ordered_comm_monoid.to_add_comm_monoid.{0} α _inst_1)))) c a) (@has_add.add.{0} α (@add_semigroup.to_has_add.{0} α (@add_monoid.to_add_semigroup.{0} α (@add_comm_monoid.to_add_monoid.{0} α (@ordered_comm_monoid.to_add_comm_monoid.{0} α _inst_1)))) c b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type} [_inst_1 : preorder.{0} α] {a b : α}, @has_lt.lt.{0} α (@preorder.to_has_lt.{0} α _inst_1) a b → @has_le.le.{0} α (@preorder.to_has_le.{0} α _inst_1) a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_lt.lt.{0} ennreal (@preorder.to_has_lt.{0} ennreal (@partial_order.to_preorder.{0} ennreal (@ordered_comm_monoid.to_partial_order.{0} ennreal (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal ennreal.canonically_ordered_comm_semiring_1))))) (@tsum.{0 0} ennreal nat (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal ennreal.canonically_ordered_comm_semiring_1))) ennreal.topological_space (λ (i : nat), @coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe)) (ε&#x27; i))) (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe)) ε)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a b : real,
f : nat → set.{0} real,
hf :
  @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
    (@set.Union.{0 1} real nat (λ (i : nat), f i)),
ε : nnreal,
ε0 :
  @has_lt.lt.{0} nnreal
    (@preorder.to_has_lt.{0} nnreal
       (@partial_order.to_preorder.{0} nnreal
          (@ordered_comm_monoid.to_partial_order.{0} nnreal
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                   (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
    (@has_zero.zero.{0} nnreal nnreal.has_zero)
    ε,
h :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat), measure_theory.lebesgue_length (f i)))
    (@lattice.has_top.top.{0} ennreal
       (@lattice.order_top.to_has_top.{0} ennreal
          (@lattice.bounded_lattice.to_order_top.{0} ennreal
             (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))))),
ε&#x27; : nat → nnreal,
ε&#x27;0 :
  ∀ (i : nat),
    @has_lt.lt.{0} nnreal
      (@preorder.to_has_lt.{0} nnreal
         (@partial_order.to_preorder.{0} nnreal
            (@ordered_comm_monoid.to_partial_order.{0} nnreal
               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                     (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
      (@has_zero.zero.{0} nnreal nnreal.has_zero)
      (ε&#x27; i),
hε :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat),
          @coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
            (ε&#x27; i)))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe)) ε)
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
    (@has_add.add.{0} ennreal
       (@distrib.to_has_add.{0} ennreal
          (@semiring.to_distrib.{0} ennreal
             (@comm_semiring.to_semiring.{0} ennreal
                (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1))))
       (@tsum.{0 0} ennreal nat
          (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))
          ennreal.topological_space
          (λ (i : nat), measure_theory.lebesgue_length (f i)))
       (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
          ε))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a b : real,
f : nat → set.{0} real,
hf :
  @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
    (@set.Union.{0 1} real nat (λ (i : nat), f i)),
ε : nnreal,
ε0 :
  @has_lt.lt.{0} nnreal
    (@preorder.to_has_lt.{0} nnreal
       (@partial_order.to_preorder.{0} nnreal
          (@ordered_comm_monoid.to_partial_order.{0} nnreal
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                   (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
    (@has_zero.zero.{0} nnreal nnreal.has_zero)
    ε,
h :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat), measure_theory.lebesgue_length (f i)))
    (@lattice.has_top.top.{0} ennreal
       (@lattice.order_top.to_has_top.{0} ennreal
          (@lattice.bounded_lattice.to_order_top.{0} ennreal
             (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))))),
ε&#x27; : nat → nnreal,
ε&#x27;0 :
  ∀ (i : nat),
    @has_lt.lt.{0} nnreal
      (@preorder.to_has_lt.{0} nnreal
         (@partial_order.to_preorder.{0} nnreal
            (@ordered_comm_monoid.to_partial_order.{0} nnreal
               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                     (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
      (@has_zero.zero.{0} nnreal nnreal.has_zero)
      (ε&#x27; i),
hε :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat),
          @coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
            (ε&#x27; i)))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe)) ε)
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
    (@has_add.add.{0} ennreal
       (@add_semigroup.to_has_add.{0} ennreal
          (@add_monoid.to_add_semigroup.{0} ennreal
             (@add_comm_monoid.to_add_monoid.{0} ennreal
                (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
                   (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                      (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                         ennreal.canonically_ordered_comm_semiring_1))))))
       (@tsum.{0 0} ennreal nat
          (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))
          ennreal.topological_space
          (λ (i : nat), measure_theory.lebesgue_length (f i)))
       (@tsum.{0 0} ennreal nat
          (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))
          ennreal.topological_space
          (λ (i : nat),
             @coe.{1 1} nnreal ennreal
               (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
               (ε&#x27; i))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>135    rw ← ennreal.tsum_add,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='ennreal.tsum_add'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/instances/ennreal.lean&#x27;, &#x27;line&#x27;: 470, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} {f g : α → ennreal}, @eq.{1} ennreal (@tsum.{0 0} ennreal α (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal ennreal.canonically_ordered_comm_semiring_1))) ennreal.topological_space (λ (a : α), @has_add.add.{0} ennreal (@distrib.to_has_add.{0} ennreal (@semiring.to_distrib.{0} ennreal (@comm_semiring.to_semiring.{0} ennreal (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal ennreal.canonically_ordered_comm_semiring_1)))) (f a) (g a))) (@has_add.add.{0} ennreal (@distrib.to_has_add.{0} ennreal (@semiring.to_distrib.{0} ennreal (@comm_semiring.to_semiring.{0} ennreal (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal ennreal.canonically_ordered_comm_semiring_1)))) (@tsum.{0 0} ennreal α (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal ennreal.canonically_ordered_comm_semiring_1))) ennreal.topological_space (λ (a : α), f a)) (@tsum.{0 0} ennreal α (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal ennreal.canonically_ordered_comm_semiring_1))) ennreal.topological_space (λ (a : α), g a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a b : real,
f : nat → set.{0} real,
hf :
  @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
    (@set.Union.{0 1} real nat (λ (i : nat), f i)),
ε : nnreal,
ε0 :
  @has_lt.lt.{0} nnreal
    (@preorder.to_has_lt.{0} nnreal
       (@partial_order.to_preorder.{0} nnreal
          (@ordered_comm_monoid.to_partial_order.{0} nnreal
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                   (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
    (@has_zero.zero.{0} nnreal nnreal.has_zero)
    ε,
h :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat), measure_theory.lebesgue_length (f i)))
    (@lattice.has_top.top.{0} ennreal
       (@lattice.order_top.to_has_top.{0} ennreal
          (@lattice.bounded_lattice.to_order_top.{0} ennreal
             (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))))),
ε&#x27; : nat → nnreal,
ε&#x27;0 :
  ∀ (i : nat),
    @has_lt.lt.{0} nnreal
      (@preorder.to_has_lt.{0} nnreal
         (@partial_order.to_preorder.{0} nnreal
            (@ordered_comm_monoid.to_partial_order.{0} nnreal
               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                     (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
      (@has_zero.zero.{0} nnreal nnreal.has_zero)
      (ε&#x27; i),
hε :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat),
          @coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
            (ε&#x27; i)))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe)) ε)
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
    (@has_add.add.{0} ennreal
       (@add_semigroup.to_has_add.{0} ennreal
          (@add_monoid.to_add_semigroup.{0} ennreal
             (@add_comm_monoid.to_add_monoid.{0} ennreal
                (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
                   (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                      (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                         ennreal.canonically_ordered_comm_semiring_1))))))
       (@tsum.{0 0} ennreal nat
          (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))
          ennreal.topological_space
          (λ (i : nat), measure_theory.lebesgue_length (f i)))
       (@tsum.{0 0} ennreal nat
          (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))
          ennreal.topological_space
          (λ (i : nat),
             @coe.{1 1} nnreal ennreal
               (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
               (ε&#x27; i))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a b : real,
f : nat → set.{0} real,
hf :
  @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
    (@set.Union.{0 1} real nat (λ (i : nat), f i)),
ε : nnreal,
ε0 :
  @has_lt.lt.{0} nnreal
    (@preorder.to_has_lt.{0} nnreal
       (@partial_order.to_preorder.{0} nnreal
          (@ordered_comm_monoid.to_partial_order.{0} nnreal
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                   (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
    (@has_zero.zero.{0} nnreal nnreal.has_zero)
    ε,
h :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat), measure_theory.lebesgue_length (f i)))
    (@lattice.has_top.top.{0} ennreal
       (@lattice.order_top.to_has_top.{0} ennreal
          (@lattice.bounded_lattice.to_order_top.{0} ennreal
             (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))))),
ε&#x27; : nat → nnreal,
ε&#x27;0 :
  ∀ (i : nat),
    @has_lt.lt.{0} nnreal
      (@preorder.to_has_lt.{0} nnreal
         (@partial_order.to_preorder.{0} nnreal
            (@ordered_comm_monoid.to_partial_order.{0} nnreal
               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                     (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
      (@has_zero.zero.{0} nnreal nnreal.has_zero)
      (ε&#x27; i),
hε :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat),
          @coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
            (ε&#x27; i)))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe)) ε)
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (a : nat),
          @has_add.add.{0} ennreal
            (@distrib.to_has_add.{0} ennreal
               (@semiring.to_distrib.{0} ennreal
                  (@comm_semiring.to_semiring.{0} ennreal
                     (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                        ennreal.canonically_ordered_comm_semiring_1))))
            (measure_theory.lebesgue_length (f a))
            (@coe.{1 1} nnreal ennreal
               (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
               (ε&#x27; a))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>136    choose g hg using show</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 511, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 511, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse name (λ (a : name), name.reflect a) lean.parser.ident → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse name (λ (a : name), name.reflect a) lean.parser.ident → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title=' `choose a b h using hyp` takes an hypothesis `hyp` of the form
`∀ (x : X) (y : Y), ∃ (a : A) (b : B), P x y a b` for some `P : X → Y → A → B → Prop` and outputs
into context a function `a : X → Y → A`, `b : X → Y → B` and a proposition `h` stating
`∀ (x : X) (y : Y), P x y (a x y) (b x y)`. It presumably also works with dependent versions.

Example:

```lean
example (h : ∀n m : ℕ, ∃i j, m = n + i ∨ m + j = n) : true :=
begin
  choose i j h using h,
  guard_hyp i := ℕ → ℕ → ℕ,
  guard_hyp j := ℕ → ℕ → ℕ,
  guard_hyp h := ∀ (n m : ℕ), m = n + i n m ∨ m + j n m = n,
  trivial
end
```'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title=' `choose a b h using hyp` takes an hypothesis `hyp` of the form
`∀ (x : X) (y : Y), ∃ (a : A) (b : B), P x y a b` for some `P : X → Y → A → B → Prop` and outputs
into context a function `a : X → Y → A`, `b : X → Y → B` and a proposition `h` stating
`∀ (x : X) (y : Y), P x y (a x y) (b x y)`. It presumably also works with dependent versions.

Example:

```lean
example (h : ∀n m : ℕ, ∃i j, m = n + i ∨ m + j = n) : true :=
begin
  choose i j h using h,
  guard_hyp i := ℕ → ℕ → ℕ,
  guard_hyp j := ℕ → ℕ → ℕ,
  guard_hyp h := ∀ (n m : ℕ), m = n + i n m ∨ m + j n m = n,
  trivial
end
```'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='choose'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='choose'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id&#x27;, &#x27;id*&#x27;, &#x27;(using expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id&#x27;, &#x27;id*&#x27;, &#x27;(using expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a b : real,
f : nat → set.{0} real,
hf :
  @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
    (@set.Union.{0 1} real nat (λ (i : nat), f i)),
ε : nnreal,
ε0 :
  @has_lt.lt.{0} nnreal
    (@preorder.to_has_lt.{0} nnreal
       (@partial_order.to_preorder.{0} nnreal
          (@ordered_comm_monoid.to_partial_order.{0} nnreal
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                   (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
    (@has_zero.zero.{0} nnreal nnreal.has_zero)
    ε,
h :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat), measure_theory.lebesgue_length (f i)))
    (@lattice.has_top.top.{0} ennreal
       (@lattice.order_top.to_has_top.{0} ennreal
          (@lattice.bounded_lattice.to_order_top.{0} ennreal
             (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))))),
ε&#x27; : nat → nnreal,
ε&#x27;0 :
  ∀ (i : nat),
    @has_lt.lt.{0} nnreal
      (@preorder.to_has_lt.{0} nnreal
         (@partial_order.to_preorder.{0} nnreal
            (@ordered_comm_monoid.to_partial_order.{0} nnreal
               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                     (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
      (@has_zero.zero.{0} nnreal nnreal.has_zero)
      (ε&#x27; i),
hε :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat),
          @coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
            (ε&#x27; i)))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe)) ε)
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (a : nat),
          @has_add.add.{0} ennreal
            (@distrib.to_has_add.{0} ennreal
               (@semiring.to_distrib.{0} ennreal
                  (@comm_semiring.to_semiring.{0} ennreal
                     (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                        ennreal.canonically_ordered_comm_semiring_1))))
            (measure_theory.lebesgue_length (f a))
            (@coe.{1 1} nnreal ennreal
               (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
               (ε&#x27; a))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>137      ∀ i, ∃ p:ℝ×ℝ, f i ⊆ Ioo p.1 p.2 ∧ (of_real (p.2 - p.1) : ennreal) &lt; lebesgue_length (f i) + ε&#x27; i,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='has_subset.subset'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.Ioo'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='nnreal.of_real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='has_sub.sub'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='ennreal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_lt.lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='measure_theory.lebesgue_length'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ε&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 511, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 511, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 511, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 511, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 511, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 511, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 511, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 327, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 511, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/intervals/basic.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 511, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 511, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 511, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 511, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/nnreal.lean&#x27;, &#x27;line&#x27;: 32, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 511, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 511, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 315, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 511, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 511, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/ennreal.lean&#x27;, &#x27;line&#x27;: 18, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 511, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 320, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 511, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 17, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 511, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 511, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 511, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 511, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 511, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 511, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse name (λ (a : name), name.reflect a) lean.parser.ident → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse name (λ (a : name), name.reflect a) lean.parser.ident → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse name (λ (a : name), name.reflect a) lean.parser.ident → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse name (λ (a : name), name.reflect a) lean.parser.ident → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type → Type → Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse name (λ (a : name), name.reflect a) lean.parser.ident → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse name (λ (a : name), name.reflect a) lean.parser.ident → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse name (λ (a : name), name.reflect a) lean.parser.ident → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} [c : has_subset.{0} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse name (λ (a : name), name.reflect a) lean.parser.ident → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} [_inst_1 : preorder.{0} α], α → α → set.{0} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse name (λ (a : name), name.reflect a) lean.parser.ident → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse name (λ (a : name), name.reflect a) lean.parser.ident → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse name (λ (a : name), name.reflect a) lean.parser.ident → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse name (λ (a : name), name.reflect a) lean.parser.ident → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real → nnreal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse name (λ (a : name), name.reflect a) lean.parser.ident → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse name (λ (a : name), name.reflect a) lean.parser.ident → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} [c : has_sub.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse name (λ (a : name), name.reflect a) lean.parser.ident → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse name (λ (a : name), name.reflect a) lean.parser.ident → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse name (λ (a : name), name.reflect a) lean.parser.ident → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} [c : has_lt.{0} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse name (λ (a : name), name.reflect a) lean.parser.ident → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{0} real → ennreal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse name (λ (a : name), name.reflect a) lean.parser.ident → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat → set.{0} real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse name (λ (a : name), name.reflect a) lean.parser.ident → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse name (λ (a : name), name.reflect a) lean.parser.ident → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} [c : has_add.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse name (λ (a : name), name.reflect a) lean.parser.ident → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat → nnreal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse name (λ (a : name), name.reflect a) lean.parser.ident → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse name (λ (a : name), name.reflect a) lean.parser.ident → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title=' `choose a b h using hyp` takes an hypothesis `hyp` of the form
`∀ (x : X) (y : Y), ∃ (a : A) (b : B), P x y a b` for some `P : X → Y → A → B → Prop` and outputs
into context a function `a : X → Y → A`, `b : X → Y → B` and a proposition `h` stating
`∀ (x : X) (y : Y), P x y (a x y) (b x y)`. It presumably also works with dependent versions.

Example:

```lean
example (h : ∀n m : ℕ, ∃i j, m = n + i ∨ m + j = n) : true :=
begin
  choose i j h using h,
  guard_hyp i := ℕ → ℕ → ℕ,
  guard_hyp j := ℕ → ℕ → ℕ,
  guard_hyp h := ∀ (n m : ℕ), m = n + i n m ∨ m + j n m = n,
  trivial
end
```'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title=' `choose a b h using hyp` takes an hypothesis `hyp` of the form
`∀ (x : X) (y : Y), ∃ (a : A) (b : B), P x y a b` for some `P : X → Y → A → B → Prop` and outputs
into context a function `a : X → Y → A`, `b : X → Y → B` and a proposition `h` stating
`∀ (x : X) (y : Y), P x y (a x y) (b x y)`. It presumably also works with dependent versions.

Example:

```lean
example (h : ∀n m : ℕ, ∃i j, m = n + i ∨ m + j = n) : true :=
begin
  choose i j h using h,
  guard_hyp i := ℕ → ℕ → ℕ,
  guard_hyp j := ℕ → ℕ → ℕ,
  guard_hyp h := ∀ (n m : ℕ), m = n + i n m ∨ m + j n m = n,
  trivial
end
```'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title=' `choose a b h using hyp` takes an hypothesis `hyp` of the form
`∀ (x : X) (y : Y), ∃ (a : A) (b : B), P x y a b` for some `P : X → Y → A → B → Prop` and outputs
into context a function `a : X → Y → A`, `b : X → Y → B` and a proposition `h` stating
`∀ (x : X) (y : Y), P x y (a x y) (b x y)`. It presumably also works with dependent versions.

Example:

```lean
example (h : ∀n m : ℕ, ∃i j, m = n + i ∨ m + j = n) : true :=
begin
  choose i j h using h,
  guard_hyp i := ℕ → ℕ → ℕ,
  guard_hyp j := ℕ → ℕ → ℕ,
  guard_hyp h := ∀ (n m : ℕ), m = n + i n m ∨ m + j n m = n,
  trivial
end
```'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title=' `choose a b h using hyp` takes an hypothesis `hyp` of the form
`∀ (x : X) (y : Y), ∃ (a : A) (b : B), P x y a b` for some `P : X → Y → A → B → Prop` and outputs
into context a function `a : X → Y → A`, `b : X → Y → B` and a proposition `h` stating
`∀ (x : X) (y : Y), P x y (a x y) (b x y)`. It presumably also works with dependent versions.

Example:

```lean
example (h : ∀n m : ℕ, ∃i j, m = n + i ∨ m + j = n) : true :=
begin
  choose i j h using h,
  guard_hyp i := ℕ → ℕ → ℕ,
  guard_hyp j := ℕ → ℕ → ℕ,
  guard_hyp h := ∀ (n m : ℕ), m = n + i n m ∨ m + j n m = n,
  trivial
end
```'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title=' `choose a b h using hyp` takes an hypothesis `hyp` of the form
`∀ (x : X) (y : Y), ∃ (a : A) (b : B), P x y a b` for some `P : X → Y → A → B → Prop` and outputs
into context a function `a : X → Y → A`, `b : X → Y → B` and a proposition `h` stating
`∀ (x : X) (y : Y), P x y (a x y) (b x y)`. It presumably also works with dependent versions.

Example:

```lean
example (h : ∀n m : ℕ, ∃i j, m = n + i ∨ m + j = n) : true :=
begin
  choose i j h using h,
  guard_hyp i := ℕ → ℕ → ℕ,
  guard_hyp j := ℕ → ℕ → ℕ,
  guard_hyp h := ∀ (n m : ℕ), m = n + i n m ∨ m + j n m = n,
  trivial
end
```'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title=' `choose a b h using hyp` takes an hypothesis `hyp` of the form
`∀ (x : X) (y : Y), ∃ (a : A) (b : B), P x y a b` for some `P : X → Y → A → B → Prop` and outputs
into context a function `a : X → Y → A`, `b : X → Y → B` and a proposition `h` stating
`∀ (x : X) (y : Y), P x y (a x y) (b x y)`. It presumably also works with dependent versions.

Example:

```lean
example (h : ∀n m : ℕ, ∃i j, m = n + i ∨ m + j = n) : true :=
begin
  choose i j h using h,
  guard_hyp i := ℕ → ℕ → ℕ,
  guard_hyp j := ℕ → ℕ → ℕ,
  guard_hyp h := ∀ (n m : ℕ), m = n + i n m ∨ m + j n m = n,
  trivial
end
```'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title=' `choose a b h using hyp` takes an hypothesis `hyp` of the form
`∀ (x : X) (y : Y), ∃ (a : A) (b : B), P x y a b` for some `P : X → Y → A → B → Prop` and outputs
into context a function `a : X → Y → A`, `b : X → Y → B` and a proposition `h` stating
`∀ (x : X) (y : Y), P x y (a x y) (b x y)`. It presumably also works with dependent versions.

Example:

```lean
example (h : ∀n m : ℕ, ∃i j, m = n + i ∨ m + j = n) : true :=
begin
  choose i j h using h,
  guard_hyp i := ℕ → ℕ → ℕ,
  guard_hyp j := ℕ → ℕ → ℕ,
  guard_hyp h := ∀ (n m : ℕ), m = n + i n m ∨ m + j n m = n,
  trivial
end
```'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title=' `choose a b h using hyp` takes an hypothesis `hyp` of the form
`∀ (x : X) (y : Y), ∃ (a : A) (b : B), P x y a b` for some `P : X → Y → A → B → Prop` and outputs
into context a function `a : X → Y → A`, `b : X → Y → B` and a proposition `h` stating
`∀ (x : X) (y : Y), P x y (a x y) (b x y)`. It presumably also works with dependent versions.

Example:

```lean
example (h : ∀n m : ℕ, ∃i j, m = n + i ∨ m + j = n) : true :=
begin
  choose i j h using h,
  guard_hyp i := ℕ → ℕ → ℕ,
  guard_hyp j := ℕ → ℕ → ℕ,
  guard_hyp h := ∀ (n m : ℕ), m = n + i n m ∨ m + j n m = n,
  trivial
end
```'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Left-open right-open interval'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title=' `choose a b h using hyp` takes an hypothesis `hyp` of the form
`∀ (x : X) (y : Y), ∃ (a : A) (b : B), P x y a b` for some `P : X → Y → A → B → Prop` and outputs
into context a function `a : X → Y → A`, `b : X → Y → B` and a proposition `h` stating
`∀ (x : X) (y : Y), P x y (a x y) (b x y)`. It presumably also works with dependent versions.

Example:

```lean
example (h : ∀n m : ℕ, ∃i j, m = n + i ∨ m + j = n) : true :=
begin
  choose i j h using h,
  guard_hyp i := ℕ → ℕ → ℕ,
  guard_hyp j := ℕ → ℕ → ℕ,
  guard_hyp h := ∀ (n m : ℕ), m = n + i n m ∨ m + j n m = n,
  trivial
end
```'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title=' `choose a b h using hyp` takes an hypothesis `hyp` of the form
`∀ (x : X) (y : Y), ∃ (a : A) (b : B), P x y a b` for some `P : X → Y → A → B → Prop` and outputs
into context a function `a : X → Y → A`, `b : X → Y → B` and a proposition `h` stating
`∀ (x : X) (y : Y), P x y (a x y) (b x y)`. It presumably also works with dependent versions.

Example:

```lean
example (h : ∀n m : ℕ, ∃i j, m = n + i ∨ m + j = n) : true :=
begin
  choose i j h using h,
  guard_hyp i := ℕ → ℕ → ℕ,
  guard_hyp j := ℕ → ℕ → ℕ,
  guard_hyp h := ∀ (n m : ℕ), m = n + i n m ∨ m + j n m = n,
  trivial
end
```'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title=' `choose a b h using hyp` takes an hypothesis `hyp` of the form
`∀ (x : X) (y : Y), ∃ (a : A) (b : B), P x y a b` for some `P : X → Y → A → B → Prop` and outputs
into context a function `a : X → Y → A`, `b : X → Y → B` and a proposition `h` stating
`∀ (x : X) (y : Y), P x y (a x y) (b x y)`. It presumably also works with dependent versions.

Example:

```lean
example (h : ∀n m : ℕ, ∃i j, m = n + i ∨ m + j = n) : true :=
begin
  choose i j h using h,
  guard_hyp i := ℕ → ℕ → ℕ,
  guard_hyp j := ℕ → ℕ → ℕ,
  guard_hyp h := ∀ (n m : ℕ), m = n + i n m ∨ m + j n m = n,
  trivial
end
```'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title=' `choose a b h using hyp` takes an hypothesis `hyp` of the form
`∀ (x : X) (y : Y), ∃ (a : A) (b : B), P x y a b` for some `P : X → Y → A → B → Prop` and outputs
into context a function `a : X → Y → A`, `b : X → Y → B` and a proposition `h` stating
`∀ (x : X) (y : Y), P x y (a x y) (b x y)`. It presumably also works with dependent versions.

Example:

```lean
example (h : ∀n m : ℕ, ∃i j, m = n + i ∨ m + j = n) : true :=
begin
  choose i j h using h,
  guard_hyp i := ℕ → ℕ → ℕ,
  guard_hyp j := ℕ → ℕ → ℕ,
  guard_hyp h := ∀ (n m : ℕ), m = n + i n m ∨ m + j n m = n,
  trivial
end
```'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title=' `choose a b h using hyp` takes an hypothesis `hyp` of the form
`∀ (x : X) (y : Y), ∃ (a : A) (b : B), P x y a b` for some `P : X → Y → A → B → Prop` and outputs
into context a function `a : X → Y → A`, `b : X → Y → B` and a proposition `h` stating
`∀ (x : X) (y : Y), P x y (a x y) (b x y)`. It presumably also works with dependent versions.

Example:

```lean
example (h : ∀n m : ℕ, ∃i j, m = n + i ∨ m + j = n) : true :=
begin
  choose i j h using h,
  guard_hyp i := ℕ → ℕ → ℕ,
  guard_hyp j := ℕ → ℕ → ℕ,
  guard_hyp h := ∀ (n m : ℕ), m = n + i n m ∨ m + j n m = n,
  trivial
end
```'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title=' `choose a b h using hyp` takes an hypothesis `hyp` of the form
`∀ (x : X) (y : Y), ∃ (a : A) (b : B), P x y a b` for some `P : X → Y → A → B → Prop` and outputs
into context a function `a : X → Y → A`, `b : X → Y → B` and a proposition `h` stating
`∀ (x : X) (y : Y), P x y (a x y) (b x y)`. It presumably also works with dependent versions.

Example:

```lean
example (h : ∀n m : ℕ, ∃i j, m = n + i ∨ m + j = n) : true :=
begin
  choose i j h using h,
  guard_hyp i := ℕ → ℕ → ℕ,
  guard_hyp j := ℕ → ℕ → ℕ,
  guard_hyp h := ∀ (n m : ℕ), m = n + i n m ∨ m + j n m = n,
  trivial
end
```'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title=' `choose a b h using hyp` takes an hypothesis `hyp` of the form
`∀ (x : X) (y : Y), ∃ (a : A) (b : B), P x y a b` for some `P : X → Y → A → B → Prop` and outputs
into context a function `a : X → Y → A`, `b : X → Y → B` and a proposition `h` stating
`∀ (x : X) (y : Y), P x y (a x y) (b x y)`. It presumably also works with dependent versions.

Example:

```lean
example (h : ∀n m : ℕ, ∃i j, m = n + i ∨ m + j = n) : true :=
begin
  choose i j h using h,
  guard_hyp i := ℕ → ℕ → ℕ,
  guard_hyp j := ℕ → ℕ → ℕ,
  guard_hyp h := ∀ (n m : ℕ), m = n + i n m ∨ m + j n m = n,
  trivial
end
```'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title=' `choose a b h using hyp` takes an hypothesis `hyp` of the form
`∀ (x : X) (y : Y), ∃ (a : A) (b : B), P x y a b` for some `P : X → Y → A → B → Prop` and outputs
into context a function `a : X → Y → A`, `b : X → Y → B` and a proposition `h` stating
`∀ (x : X) (y : Y), P x y (a x y) (b x y)`. It presumably also works with dependent versions.

Example:

```lean
example (h : ∀n m : ℕ, ∃i j, m = n + i ∨ m + j = n) : true :=
begin
  choose i j h using h,
  guard_hyp i := ℕ → ℕ → ℕ,
  guard_hyp j := ℕ → ℕ → ℕ,
  guard_hyp h := ∀ (n m : ℕ), m = n + i n m ∨ m + j n m = n,
  trivial
end
```'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The extended nonnegative real numbers. This is usually denoted [0, ∞],
 and is relevant as the codomain of a measure.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title=' `choose a b h using hyp` takes an hypothesis `hyp` of the form
`∀ (x : X) (y : Y), ∃ (a : A) (b : B), P x y a b` for some `P : X → Y → A → B → Prop` and outputs
into context a function `a : X → Y → A`, `b : X → Y → B` and a proposition `h` stating
`∀ (x : X) (y : Y), P x y (a x y) (b x y)`. It presumably also works with dependent versions.

Example:

```lean
example (h : ∀n m : ℕ, ∃i j, m = n + i ∨ m + j = n) : true :=
begin
  choose i j h using h,
  guard_hyp i := ℕ → ℕ → ℕ,
  guard_hyp j := ℕ → ℕ → ℕ,
  guard_hyp h := ∀ (n m : ℕ), m = n + i n m ∨ m + j n m = n,
  trivial
end
```'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title=' `choose a b h using hyp` takes an hypothesis `hyp` of the form
`∀ (x : X) (y : Y), ∃ (a : A) (b : B), P x y a b` for some `P : X → Y → A → B → Prop` and outputs
into context a function `a : X → Y → A`, `b : X → Y → B` and a proposition `h` stating
`∀ (x : X) (y : Y), P x y (a x y) (b x y)`. It presumably also works with dependent versions.

Example:

```lean
example (h : ∀n m : ℕ, ∃i j, m = n + i ∨ m + j = n) : true :=
begin
  choose i j h using h,
  guard_hyp i := ℕ → ℕ → ℕ,
  guard_hyp j := ℕ → ℕ → ℕ,
  guard_hyp h := ∀ (n m : ℕ), m = n + i n m ∨ m + j n m = n,
  trivial
end
```'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Length of an interval. This is the largest monotonic function which correctly
 measures all intervals.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title=' `choose a b h using hyp` takes an hypothesis `hyp` of the form
`∀ (x : X) (y : Y), ∃ (a : A) (b : B), P x y a b` for some `P : X → Y → A → B → Prop` and outputs
into context a function `a : X → Y → A`, `b : X → Y → B` and a proposition `h` stating
`∀ (x : X) (y : Y), P x y (a x y) (b x y)`. It presumably also works with dependent versions.

Example:

```lean
example (h : ∀n m : ℕ, ∃i j, m = n + i ∨ m + j = n) : true :=
begin
  choose i j h using h,
  guard_hyp i := ℕ → ℕ → ℕ,
  guard_hyp j := ℕ → ℕ → ℕ,
  guard_hyp h := ∀ (n m : ℕ), m = n + i n m ∨ m + j n m = n,
  trivial
end
```'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title=' `choose a b h using hyp` takes an hypothesis `hyp` of the form
`∀ (x : X) (y : Y), ∃ (a : A) (b : B), P x y a b` for some `P : X → Y → A → B → Prop` and outputs
into context a function `a : X → Y → A`, `b : X → Y → B` and a proposition `h` stating
`∀ (x : X) (y : Y), P x y (a x y) (b x y)`. It presumably also works with dependent versions.

Example:

```lean
example (h : ∀n m : ℕ, ∃i j, m = n + i ∨ m + j = n) : true :=
begin
  choose i j h using h,
  guard_hyp i := ℕ → ℕ → ℕ,
  guard_hyp j := ℕ → ℕ → ℕ,
  guard_hyp h := ∀ (n m : ℕ), m = n + i n m ∨ m + j n m = n,
  trivial
end
```'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title=' `choose a b h using hyp` takes an hypothesis `hyp` of the form
`∀ (x : X) (y : Y), ∃ (a : A) (b : B), P x y a b` for some `P : X → Y → A → B → Prop` and outputs
into context a function `a : X → Y → A`, `b : X → Y → B` and a proposition `h` stating
`∀ (x : X) (y : Y), P x y (a x y) (b x y)`. It presumably also works with dependent versions.

Example:

```lean
example (h : ∀n m : ℕ, ∃i j, m = n + i ∨ m + j = n) : true :=
begin
  choose i j h using h,
  guard_hyp i := ℕ → ℕ → ℕ,
  guard_hyp j := ℕ → ℕ → ℕ,
  guard_hyp h := ∀ (n m : ℕ), m = n + i n m ∨ m + j n m = n,
  trivial
end
```'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title=' `choose a b h using hyp` takes an hypothesis `hyp` of the form
`∀ (x : X) (y : Y), ∃ (a : A) (b : B), P x y a b` for some `P : X → Y → A → B → Prop` and outputs
into context a function `a : X → Y → A`, `b : X → Y → B` and a proposition `h` stating
`∀ (x : X) (y : Y), P x y (a x y) (b x y)`. It presumably also works with dependent versions.

Example:

```lean
example (h : ∀n m : ℕ, ∃i j, m = n + i ∨ m + j = n) : true :=
begin
  choose i j h using h,
  guard_hyp i := ℕ → ℕ → ℕ,
  guard_hyp j := ℕ → ℕ → ℕ,
  guard_hyp h := ∀ (n m : ℕ), m = n + i n m ∨ m + j n m = n,
  trivial
end
```'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title=' `choose a b h using hyp` takes an hypothesis `hyp` of the form
`∀ (x : X) (y : Y), ∃ (a : A) (b : B), P x y a b` for some `P : X → Y → A → B → Prop` and outputs
into context a function `a : X → Y → A`, `b : X → Y → B` and a proposition `h` stating
`∀ (x : X) (y : Y), P x y (a x y) (b x y)`. It presumably also works with dependent versions.

Example:

```lean
example (h : ∀n m : ℕ, ∃i j, m = n + i ∨ m + j = n) : true :=
begin
  choose i j h using h,
  guard_hyp i := ℕ → ℕ → ℕ,
  guard_hyp j := ℕ → ℕ → ℕ,
  guard_hyp h := ∀ (n m : ℕ), m = n + i n m ∨ m + j n m = n,
  trivial
end
```'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title=' `choose a b h using hyp` takes an hypothesis `hyp` of the form
`∀ (x : X) (y : Y), ∃ (a : A) (b : B), P x y a b` for some `P : X → Y → A → B → Prop` and outputs
into context a function `a : X → Y → A`, `b : X → Y → B` and a proposition `h` stating
`∀ (x : X) (y : Y), P x y (a x y) (b x y)`. It presumably also works with dependent versions.

Example:

```lean
example (h : ∀n m : ℕ, ∃i j, m = n + i ∨ m + j = n) : true :=
begin
  choose i j h using h,
  guard_hyp i := ℕ → ℕ → ℕ,
  guard_hyp j := ℕ → ℕ → ℕ,
  guard_hyp h := ∀ (n m : ℕ), m = n + i n m ∨ m + j n m = n,
  trivial
end
```'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='choose'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='choose'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='choose'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='choose'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='choose'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='choose'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='choose'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='choose'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='choose'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='choose'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='choose'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='choose'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='choose'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='choose'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='choose'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='choose'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='choose'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='choose'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='choose'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='choose'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='choose'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='choose'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='choose'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='choose'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id&#x27;, &#x27;id*&#x27;, &#x27;(using expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id&#x27;, &#x27;id*&#x27;, &#x27;(using expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id&#x27;, &#x27;id*&#x27;, &#x27;(using expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id&#x27;, &#x27;id*&#x27;, &#x27;(using expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id&#x27;, &#x27;id*&#x27;, &#x27;(using expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id&#x27;, &#x27;id*&#x27;, &#x27;(using expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id&#x27;, &#x27;id*&#x27;, &#x27;(using expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id&#x27;, &#x27;id*&#x27;, &#x27;(using expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;id&#x27;, &#x27;id*&#x27;, &#x27;(using expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id&#x27;, &#x27;id*&#x27;, &#x27;(using expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id&#x27;, &#x27;id*&#x27;, &#x27;(using expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id&#x27;, &#x27;id*&#x27;, &#x27;(using expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;id&#x27;, &#x27;id*&#x27;, &#x27;(using expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id&#x27;, &#x27;id*&#x27;, &#x27;(using expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id&#x27;, &#x27;id*&#x27;, &#x27;(using expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id&#x27;, &#x27;id*&#x27;, &#x27;(using expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;id&#x27;, &#x27;id*&#x27;, &#x27;(using expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id&#x27;, &#x27;id*&#x27;, &#x27;(using expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;id&#x27;, &#x27;id*&#x27;, &#x27;(using expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id&#x27;, &#x27;id*&#x27;, &#x27;(using expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id&#x27;, &#x27;id*&#x27;, &#x27;(using expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id&#x27;, &#x27;id*&#x27;, &#x27;(using expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id&#x27;, &#x27;id*&#x27;, &#x27;(using expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id&#x27;, &#x27;id*&#x27;, &#x27;(using expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a b : real,
f : nat → set.{0} real,
hf :
  @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
    (@set.Union.{0 1} real nat (λ (i : nat), f i)),
ε : nnreal,
ε0 :
  @has_lt.lt.{0} nnreal
    (@preorder.to_has_lt.{0} nnreal
       (@partial_order.to_preorder.{0} nnreal
          (@ordered_comm_monoid.to_partial_order.{0} nnreal
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                   (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
    (@has_zero.zero.{0} nnreal nnreal.has_zero)
    ε,
h :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat), measure_theory.lebesgue_length (f i)))
    (@lattice.has_top.top.{0} ennreal
       (@lattice.order_top.to_has_top.{0} ennreal
          (@lattice.bounded_lattice.to_order_top.{0} ennreal
             (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))))),
ε&#x27; : nat → nnreal,
ε&#x27;0 :
  ∀ (i : nat),
    @has_lt.lt.{0} nnreal
      (@preorder.to_has_lt.{0} nnreal
         (@partial_order.to_preorder.{0} nnreal
            (@ordered_comm_monoid.to_partial_order.{0} nnreal
               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                     (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
      (@has_zero.zero.{0} nnreal nnreal.has_zero)
      (ε&#x27; i),
hε :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat),
          @coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
            (ε&#x27; i)))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe)) ε)
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (a : nat),
          @has_add.add.{0} ennreal
            (@distrib.to_has_add.{0} ennreal
               (@semiring.to_distrib.{0} ennreal
                  (@comm_semiring.to_semiring.{0} ennreal
                     (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                        ennreal.canonically_ordered_comm_semiring_1))))
            (measure_theory.lebesgue_length (f a))
            (@coe.{1 1} nnreal ennreal
               (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
               (ε&#x27; a))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>138    { intro i,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 511, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 122, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 511, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse name (λ (a : name), name.reflect a) lean.parser.ident → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse name (λ (a : name), name.reflect a) lean.parser.ident → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title=' `choose a b h using hyp` takes an hypothesis `hyp` of the form
`∀ (x : X) (y : Y), ∃ (a : A) (b : B), P x y a b` for some `P : X → Y → A → B → Prop` and outputs
into context a function `a : X → Y → A`, `b : X → Y → B` and a proposition `h` stating
`∀ (x : X) (y : Y), P x y (a x y) (b x y)`. It presumably also works with dependent versions.

Example:

```lean
example (h : ∀n m : ℕ, ∃i j, m = n + i ∨ m + j = n) : true :=
begin
  choose i j h using h,
  guard_hyp i := ℕ → ℕ → ℕ,
  guard_hyp j := ℕ → ℕ → ℕ,
  guard_hyp h := ∀ (n m : ℕ), m = n + i n m ∨ m + j n m = n,
  trivial
end
```'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='If the current goal is a Pi/forall `∀ x : t, u` (resp. `let x := t in u`) then `intro` puts `x : t` (resp. `x := t`) in the local context. The new subgoal target is `u`.

If the goal is an arrow `t → u`, then it puts `h : t` in the local context and the new goal target is `u`.

If the goal is neither a Pi/forall nor begins with a let binder, the tactic `intro` applies the tactic `whnf` until an introduction can be applied or the goal is not head reducible. In the latter case, the tactic fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title=' `choose a b h using hyp` takes an hypothesis `hyp` of the form
`∀ (x : X) (y : Y), ∃ (a : A) (b : B), P x y a b` for some `P : X → Y → A → B → Prop` and outputs
into context a function `a : X → Y → A`, `b : X → Y → B` and a proposition `h` stating
`∀ (x : X) (y : Y), P x y (a x y) (b x y)`. It presumably also works with dependent versions.

Example:

```lean
example (h : ∀n m : ℕ, ∃i j, m = n + i ∨ m + j = n) : true :=
begin
  choose i j h using h,
  guard_hyp i := ℕ → ℕ → ℕ,
  guard_hyp j := ℕ → ℕ → ℕ,
  guard_hyp h := ∀ (n m : ℕ), m = n + i n m ∨ m + j n m = n,
  trivial
end
```'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='choose'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='intro'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='choose'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id&#x27;, &#x27;id*&#x27;, &#x27;(using expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id&#x27;, &#x27;id*&#x27;, &#x27;(using expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a b : real,
f : nat → set.{0} real,
hf :
  @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
    (@set.Union.{0 1} real nat (λ (i : nat), f i)),
ε : nnreal,
ε0 :
  @has_lt.lt.{0} nnreal
    (@preorder.to_has_lt.{0} nnreal
       (@partial_order.to_preorder.{0} nnreal
          (@ordered_comm_monoid.to_partial_order.{0} nnreal
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                   (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
    (@has_zero.zero.{0} nnreal nnreal.has_zero)
    ε,
h :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat), measure_theory.lebesgue_length (f i)))
    (@lattice.has_top.top.{0} ennreal
       (@lattice.order_top.to_has_top.{0} ennreal
          (@lattice.bounded_lattice.to_order_top.{0} ennreal
             (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))))),
ε&#x27; : nat → nnreal,
ε&#x27;0 :
  ∀ (i : nat),
    @has_lt.lt.{0} nnreal
      (@preorder.to_has_lt.{0} nnreal
         (@partial_order.to_preorder.{0} nnreal
            (@ordered_comm_monoid.to_partial_order.{0} nnreal
               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                     (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
      (@has_zero.zero.{0} nnreal nnreal.has_zero)
      (ε&#x27; i),
hε :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat),
          @coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
            (ε&#x27; i)))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe)) ε)
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (a : nat),
          @has_add.add.{0} ennreal
            (@distrib.to_has_add.{0} ennreal
               (@semiring.to_distrib.{0} ennreal
                  (@comm_semiring.to_semiring.{0} ennreal
                     (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                        ennreal.canonically_ordered_comm_semiring_1))))
            (measure_theory.lebesgue_length (f a))
            (@coe.{1 1} nnreal ennreal
               (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
               (ε&#x27; a))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a b : real,
f : nat → set.{0} real,
hf :
  @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
    (@set.Union.{0 1} real nat (λ (i : nat), f i)),
ε : nnreal,
ε0 :
  @has_lt.lt.{0} nnreal
    (@preorder.to_has_lt.{0} nnreal
       (@partial_order.to_preorder.{0} nnreal
          (@ordered_comm_monoid.to_partial_order.{0} nnreal
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                   (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
    (@has_zero.zero.{0} nnreal nnreal.has_zero)
    ε,
h :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat), measure_theory.lebesgue_length (f i)))
    (@lattice.has_top.top.{0} ennreal
       (@lattice.order_top.to_has_top.{0} ennreal
          (@lattice.bounded_lattice.to_order_top.{0} ennreal
             (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))))),
ε&#x27; : nat → nnreal,
ε&#x27;0 :
  ∀ (i : nat),
    @has_lt.lt.{0} nnreal
      (@preorder.to_has_lt.{0} nnreal
         (@partial_order.to_preorder.{0} nnreal
            (@ordered_comm_monoid.to_partial_order.{0} nnreal
               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                     (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
      (@has_zero.zero.{0} nnreal nnreal.has_zero)
      (ε&#x27; i),
hε :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat),
          @coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
            (ε&#x27; i)))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe)) ε)
⊢ ∀ (i : nat),
    @Exists.{1} (prod.{0 0} real real)
      (λ (p : prod.{0 0} real real),
         and
           (@has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (f i)
              (@set.Ioo.{0} real real.preorder (@prod.fst.{0 0} real real p) (@prod.snd.{0 0} real real p)))
           (@has_lt.lt.{0} ennreal
              (@preorder.to_has_lt.{0} ennreal
                 (@partial_order.to_preorder.{0} ennreal
                    (@ordered_comm_monoid.to_partial_order.{0} ennreal
                       (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                          (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                             ennreal.canonically_ordered_comm_semiring_1)))))
              (@coe.{1 1} nnreal ennreal
                 (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
                 (nnreal.of_real
                    (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (@prod.snd.{0 0} real real p)
                       (@prod.fst.{0 0} real real p))))
              (@has_add.add.{0} ennreal
                 (@distrib.to_has_add.{0} ennreal
                    (@semiring.to_distrib.{0} ennreal
                       (@comm_semiring.to_semiring.{0} ennreal
                          (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                             ennreal.canonically_ordered_comm_semiring_1))))
                 (measure_theory.lebesgue_length (f i))
                 (@coe.{1 1} nnreal ennreal
                    (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
                    (ε&#x27; i)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a b : real,
f : nat → set.{0} real,
hf :
  @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
    (@set.Union.{0 1} real nat (λ (i : nat), f i)),
ε : nnreal,
ε0 :
  @has_lt.lt.{0} nnreal
    (@preorder.to_has_lt.{0} nnreal
       (@partial_order.to_preorder.{0} nnreal
          (@ordered_comm_monoid.to_partial_order.{0} nnreal
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                   (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
    (@has_zero.zero.{0} nnreal nnreal.has_zero)
    ε,
h :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat), measure_theory.lebesgue_length (f i)))
    (@lattice.has_top.top.{0} ennreal
       (@lattice.order_top.to_has_top.{0} ennreal
          (@lattice.bounded_lattice.to_order_top.{0} ennreal
             (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))))),
ε&#x27; : nat → nnreal,
ε&#x27;0 :
  ∀ (i : nat),
    @has_lt.lt.{0} nnreal
      (@preorder.to_has_lt.{0} nnreal
         (@partial_order.to_preorder.{0} nnreal
            (@ordered_comm_monoid.to_partial_order.{0} nnreal
               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                     (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
      (@has_zero.zero.{0} nnreal nnreal.has_zero)
      (ε&#x27; i),
hε :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat),
          @coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
            (ε&#x27; i)))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe)) ε),
i : nat
⊢ @Exists.{1} (prod.{0 0} real real)
    (λ (p : prod.{0 0} real real),
       and
         (@has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (f i)
            (@set.Ioo.{0} real real.preorder (@prod.fst.{0 0} real real p) (@prod.snd.{0 0} real real p)))
         (@has_lt.lt.{0} ennreal
            (@preorder.to_has_lt.{0} ennreal
               (@partial_order.to_preorder.{0} ennreal
                  (@ordered_comm_monoid.to_partial_order.{0} ennreal
                     (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                        (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                           ennreal.canonically_ordered_comm_semiring_1)))))
            (@coe.{1 1} nnreal ennreal
               (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
               (nnreal.of_real
                  (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (@prod.snd.{0 0} real real p)
                     (@prod.fst.{0 0} real real p))))
            (@has_add.add.{0} ennreal
               (@distrib.to_has_add.{0} ennreal
                  (@semiring.to_distrib.{0} ennreal
                     (@comm_semiring.to_semiring.{0} ennreal
                        (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                           ennreal.canonically_ordered_comm_semiring_1))))
               (measure_theory.lebesgue_length (f i))
               (@coe.{1 1} nnreal ennreal
                  (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
                  (ε&#x27; i)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>139      have := (ennreal.lt_add_right (lt_of_le_of_lt (ennreal.le_tsum i) h)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='ennreal.lt_add_right'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='lt_of_le_of_lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ennreal.le_tsum'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 511, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/ennreal.lean&#x27;, &#x27;line&#x27;: 256, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 107, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/instances/ennreal.lean&#x27;, &#x27;line&#x27;: 485, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse name (λ (a : name), name.reflect a) lean.parser.ident → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {a b : ennreal}, @has_lt.lt.{0} ennreal (@preorder.to_has_lt.{0} ennreal (@partial_order.to_preorder.{0} ennreal (@ordered_comm_monoid.to_partial_order.{0} ennreal (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal ennreal.canonically_ordered_comm_semiring_1))))) a (@lattice.has_top.top.{0} ennreal (@lattice.order_top.to_has_top.{0} ennreal (@lattice.bounded_lattice.to_order_top.{0} ennreal (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))))) → @has_lt.lt.{0} ennreal (@preorder.to_has_lt.{0} ennreal (@partial_order.to_preorder.{0} ennreal (@ordered_comm_monoid.to_partial_order.{0} ennreal (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal ennreal.canonically_ordered_comm_semiring_1))))) (@has_zero.zero.{0} ennreal (@zero_ne_one_class.to_has_zero.{0} ennreal (@canonically_ordered_comm_semiring.to_zero_ne_one_class.{0} ennreal ennreal.canonically_ordered_comm_semiring_1))) b → @has_lt.lt.{0} ennreal (@preorder.to_has_lt.{0} ennreal (@partial_order.to_preorder.{0} ennreal (@ordered_comm_monoid.to_partial_order.{0} ennreal (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal ennreal.canonically_ordered_comm_semiring_1))))) a (@has_add.add.{0} ennreal (@distrib.to_has_add.{0} ennreal (@semiring.to_distrib.{0} ennreal (@comm_semiring.to_semiring.{0} ennreal (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal ennreal.canonically_ordered_comm_semiring_1)))) a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type} [_inst_1 : preorder.{0} α] {a b c : α}, @has_le.le.{0} α (@preorder.to_has_le.{0} α _inst_1) a b → @has_lt.lt.{0} α (@preorder.to_has_lt.{0} α _inst_1) b c → @has_lt.lt.{0} α (@preorder.to_has_lt.{0} α _inst_1) a c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type} {f : α → ennreal} (a : α), @has_le.le.{0} ennreal (@preorder.to_has_le.{0} ennreal (@partial_order.to_preorder.{0} ennreal (@ordered_comm_monoid.to_partial_order.{0} ennreal (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal ennreal.canonically_ordered_comm_semiring_1))))) (f a) (@tsum.{0 0} ennreal α (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal ennreal.canonically_ordered_comm_semiring_1))) ennreal.topological_space (λ (a : α), f a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_lt.lt.{0} ennreal (@preorder.to_has_lt.{0} ennreal (@partial_order.to_preorder.{0} ennreal (@ordered_comm_monoid.to_partial_order.{0} ennreal (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal ennreal.canonically_ordered_comm_semiring_1))))) (@tsum.{0 0} ennreal nat (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal ennreal.canonically_ordered_comm_semiring_1))) ennreal.topological_space (λ (i : nat), measure_theory.lebesgue_length (f i))) (@lattice.has_top.top.{0} ennreal (@lattice.order_top.to_has_top.{0} ennreal (@lattice.bounded_lattice.to_order_top.{0} ennreal (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title=' `choose a b h using hyp` takes an hypothesis `hyp` of the form
`∀ (x : X) (y : Y), ∃ (a : A) (b : B), P x y a b` for some `P : X → Y → A → B → Prop` and outputs
into context a function `a : X → Y → A`, `b : X → Y → B` and a proposition `h` stating
`∀ (x : X) (y : Y), P x y (a x y) (b x y)`. It presumably also works with dependent versions.

Example:

```lean
example (h : ∀n m : ℕ, ∃i j, m = n + i ∨ m + j = n) : true :=
begin
  choose i j h using h,
  guard_hyp i := ℕ → ℕ → ℕ,
  guard_hyp j := ℕ → ℕ → ℕ,
  guard_hyp h := ∀ (n m : ℕ), m = n + i n m ∨ m + j n m = n,
  trivial
end
```'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='choose'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id&#x27;, &#x27;id*&#x27;, &#x27;(using expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a b : real,
f : nat → set.{0} real,
hf :
  @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
    (@set.Union.{0 1} real nat (λ (i : nat), f i)),
ε : nnreal,
ε0 :
  @has_lt.lt.{0} nnreal
    (@preorder.to_has_lt.{0} nnreal
       (@partial_order.to_preorder.{0} nnreal
          (@ordered_comm_monoid.to_partial_order.{0} nnreal
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                   (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
    (@has_zero.zero.{0} nnreal nnreal.has_zero)
    ε,
h :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat), measure_theory.lebesgue_length (f i)))
    (@lattice.has_top.top.{0} ennreal
       (@lattice.order_top.to_has_top.{0} ennreal
          (@lattice.bounded_lattice.to_order_top.{0} ennreal
             (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))))),
ε&#x27; : nat → nnreal,
ε&#x27;0 :
  ∀ (i : nat),
    @has_lt.lt.{0} nnreal
      (@preorder.to_has_lt.{0} nnreal
         (@partial_order.to_preorder.{0} nnreal
            (@ordered_comm_monoid.to_partial_order.{0} nnreal
               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                     (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
      (@has_zero.zero.{0} nnreal nnreal.has_zero)
      (ε&#x27; i),
hε :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat),
          @coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
            (ε&#x27; i)))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe)) ε),
i : nat
⊢ @Exists.{1} (prod.{0 0} real real)
    (λ (p : prod.{0 0} real real),
       and
         (@has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (f i)
            (@set.Ioo.{0} real real.preorder (@prod.fst.{0 0} real real p) (@prod.snd.{0 0} real real p)))
         (@has_lt.lt.{0} ennreal
            (@preorder.to_has_lt.{0} ennreal
               (@partial_order.to_preorder.{0} ennreal
                  (@ordered_comm_monoid.to_partial_order.{0} ennreal
                     (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                        (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                           ennreal.canonically_ordered_comm_semiring_1)))))
            (@coe.{1 1} nnreal ennreal
               (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
               (nnreal.of_real
                  (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (@prod.snd.{0 0} real real p)
                     (@prod.fst.{0 0} real real p))))
            (@has_add.add.{0} ennreal
               (@distrib.to_has_add.{0} ennreal
                  (@semiring.to_distrib.{0} ennreal
                     (@comm_semiring.to_semiring.{0} ennreal
                        (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                           ennreal.canonically_ordered_comm_semiring_1))))
               (measure_theory.lebesgue_length (f i))
               (@coe.{1 1} nnreal ennreal
                  (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
                  (ε&#x27; i)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>140          (ennreal.zero_lt_coe_iff.2 (ε&#x27;0 i))),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='ennreal.zero_lt_coe_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='ε&#x27;0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/ennreal.lean&#x27;, &#x27;line&#x27;: 218, &#x27;column&#x27;: 25}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 511, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {p : nnreal}, iff (@has_lt.lt.{0} ennreal (@preorder.to_has_lt.{0} ennreal (@partial_order.to_preorder.{0} ennreal (@ordered_comm_monoid.to_partial_order.{0} ennreal (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal ennreal.canonically_ordered_comm_semiring_1))))) (@has_zero.zero.{0} ennreal (@zero_ne_one_class.to_has_zero.{0} ennreal (@canonically_ordered_comm_semiring.to_zero_ne_one_class.{0} ennreal ennreal.canonically_ordered_comm_semiring_1))) (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe)) p)) (@has_lt.lt.{0} nnreal (@preorder.to_has_lt.{0} nnreal (@partial_order.to_preorder.{0} nnreal (@ordered_comm_monoid.to_partial_order.{0} nnreal (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring)))))) (@has_zero.zero.{0} nnreal nnreal.has_zero) p)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ (i : nat), @has_lt.lt.{0} nnreal (@preorder.to_has_lt.{0} nnreal (@partial_order.to_preorder.{0} nnreal (@ordered_comm_monoid.to_partial_order.{0} nnreal (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring)))))) (@has_zero.zero.{0} nnreal nnreal.has_zero) (ε&#x27; i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse name (λ (a : name), name.reflect a) lean.parser.ident → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title=' `choose a b h using hyp` takes an hypothesis `hyp` of the form
`∀ (x : X) (y : Y), ∃ (a : A) (b : B), P x y a b` for some `P : X → Y → A → B → Prop` and outputs
into context a function `a : X → Y → A`, `b : X → Y → B` and a proposition `h` stating
`∀ (x : X) (y : Y), P x y (a x y) (b x y)`. It presumably also works with dependent versions.

Example:

```lean
example (h : ∀n m : ℕ, ∃i j, m = n + i ∨ m + j = n) : true :=
begin
  choose i j h using h,
  guard_hyp i := ℕ → ℕ → ℕ,
  guard_hyp j := ℕ → ℕ → ℕ,
  guard_hyp h := ∀ (n m : ℕ), m = n + i n m ∨ m + j n m = n,
  trivial
end
```'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='choose'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id&#x27;, &#x27;id*&#x27;, &#x27;(using expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a b : real,
f : nat → set.{0} real,
hf :
  @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
    (@set.Union.{0 1} real nat (λ (i : nat), f i)),
ε : nnreal,
ε0 :
  @has_lt.lt.{0} nnreal
    (@preorder.to_has_lt.{0} nnreal
       (@partial_order.to_preorder.{0} nnreal
          (@ordered_comm_monoid.to_partial_order.{0} nnreal
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                   (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
    (@has_zero.zero.{0} nnreal nnreal.has_zero)
    ε,
h :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat), measure_theory.lebesgue_length (f i)))
    (@lattice.has_top.top.{0} ennreal
       (@lattice.order_top.to_has_top.{0} ennreal
          (@lattice.bounded_lattice.to_order_top.{0} ennreal
             (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))))),
ε&#x27; : nat → nnreal,
ε&#x27;0 :
  ∀ (i : nat),
    @has_lt.lt.{0} nnreal
      (@preorder.to_has_lt.{0} nnreal
         (@partial_order.to_preorder.{0} nnreal
            (@ordered_comm_monoid.to_partial_order.{0} nnreal
               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                     (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
      (@has_zero.zero.{0} nnreal nnreal.has_zero)
      (ε&#x27; i),
hε :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat),
          @coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
            (ε&#x27; i)))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe)) ε),
i : nat
⊢ @Exists.{1} (prod.{0 0} real real)
    (λ (p : prod.{0 0} real real),
       and
         (@has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (f i)
            (@set.Ioo.{0} real real.preorder (@prod.fst.{0 0} real real p) (@prod.snd.{0 0} real real p)))
         (@has_lt.lt.{0} ennreal
            (@preorder.to_has_lt.{0} ennreal
               (@partial_order.to_preorder.{0} ennreal
                  (@ordered_comm_monoid.to_partial_order.{0} ennreal
                     (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                        (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                           ennreal.canonically_ordered_comm_semiring_1)))))
            (@coe.{1 1} nnreal ennreal
               (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
               (nnreal.of_real
                  (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (@prod.snd.{0 0} real real p)
                     (@prod.fst.{0 0} real real p))))
            (@has_add.add.{0} ennreal
               (@distrib.to_has_add.{0} ennreal
                  (@semiring.to_distrib.{0} ennreal
                     (@comm_semiring.to_semiring.{0} ennreal
                        (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                           ennreal.canonically_ordered_comm_semiring_1))))
               (measure_theory.lebesgue_length (f i))
               (@coe.{1 1} nnreal ennreal
                  (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
                  (ε&#x27; i)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a b : real,
f : nat → set.{0} real,
hf :
  @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
    (@set.Union.{0 1} real nat (λ (i : nat), f i)),
ε : nnreal,
ε0 :
  @has_lt.lt.{0} nnreal
    (@preorder.to_has_lt.{0} nnreal
       (@partial_order.to_preorder.{0} nnreal
          (@ordered_comm_monoid.to_partial_order.{0} nnreal
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                   (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
    (@has_zero.zero.{0} nnreal nnreal.has_zero)
    ε,
h :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat), measure_theory.lebesgue_length (f i)))
    (@lattice.has_top.top.{0} ennreal
       (@lattice.order_top.to_has_top.{0} ennreal
          (@lattice.bounded_lattice.to_order_top.{0} ennreal
             (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))))),
ε&#x27; : nat → nnreal,
ε&#x27;0 :
  ∀ (i : nat),
    @has_lt.lt.{0} nnreal
      (@preorder.to_has_lt.{0} nnreal
         (@partial_order.to_preorder.{0} nnreal
            (@ordered_comm_monoid.to_partial_order.{0} nnreal
               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                     (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
      (@has_zero.zero.{0} nnreal nnreal.has_zero)
      (ε&#x27; i),
hε :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat),
          @coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
            (ε&#x27; i)))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe)) ε),
i : nat,
this :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (measure_theory.lebesgue_length (f i))
    (@has_add.add.{0} ennreal
       (@distrib.to_has_add.{0} ennreal
          (@semiring.to_distrib.{0} ennreal
             (@comm_semiring.to_semiring.{0} ennreal
                (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1))))
       (measure_theory.lebesgue_length (f i))
       (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
          (ε&#x27; i)))
⊢ @Exists.{1} (prod.{0 0} real real)
    (λ (p : prod.{0 0} real real),
       and
         (@has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (f i)
            (@set.Ioo.{0} real real.preorder (@prod.fst.{0 0} real real p) (@prod.snd.{0 0} real real p)))
         (@has_lt.lt.{0} ennreal
            (@preorder.to_has_lt.{0} ennreal
               (@partial_order.to_preorder.{0} ennreal
                  (@ordered_comm_monoid.to_partial_order.{0} ennreal
                     (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                        (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                           ennreal.canonically_ordered_comm_semiring_1)))))
            (@coe.{1 1} nnreal ennreal
               (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
               (nnreal.of_real
                  (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (@prod.snd.{0 0} real real p)
                     (@prod.fst.{0 0} real real p))))
            (@has_add.add.{0} ennreal
               (@distrib.to_has_add.{0} ennreal
                  (@semiring.to_distrib.{0} ennreal
                     (@comm_semiring.to_semiring.{0} ennreal
                        (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                           ennreal.canonically_ordered_comm_semiring_1))))
               (measure_theory.lebesgue_length (f i))
               (@coe.{1 1} nnreal ennreal
                  (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
                  (ε&#x27; i)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>141      conv at this {to_lhs, rw lebesgue_length_eq_infi_Ioo},</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='blue'><a title='measure_theory.lebesgue_length_eq_infi_Ioo'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 511, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 65, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 36, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 511, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse name (λ (a : name), name.reflect a) lean.parser.ident → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit name (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.ident)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) (lean.parser.pexpr std.prec.max))) → conv.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit name (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.ident)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) (lean.parser.pexpr std.prec.max))) → conv.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (s : set.{0} real), @eq.{1} ennreal (measure_theory.lebesgue_length s) (@lattice.infi.{0 1} ennreal real (@lattice.conditionally_complete_lattice.to_has_Inf.{0} ennreal (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))) (λ (a : real), @lattice.infi.{0 1} ennreal real (@lattice.conditionally_complete_lattice.to_has_Inf.{0} ennreal (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))) (λ (b : real), @lattice.infi.{0 0} ennreal (@has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) s (@set.Ioo.{0} real real.preorder a b)) (@lattice.conditionally_complete_lattice.to_has_Inf.{0} ennreal (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))) (λ (h : @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) s (@set.Ioo.{0} real real.preorder a b)), @coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe)) (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit name (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.ident)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) (lean.parser.pexpr std.prec.max))) → conv.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse name (λ (a : name), name.reflect a) lean.parser.ident → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title=' `choose a b h using hyp` takes an hypothesis `hyp` of the form
`∀ (x : X) (y : Y), ∃ (a : A) (b : B), P x y a b` for some `P : X → Y → A → B → Prop` and outputs
into context a function `a : X → Y → A`, `b : X → Y → B` and a proposition `h` stating
`∀ (x : X) (y : Y), P x y (a x y) (b x y)`. It presumably also works with dependent versions.

Example:

```lean
example (h : ∀n m : ℕ, ∃i j, m = n + i ∨ m + j = n) : true :=
begin
  choose i j h using h,
  guard_hyp i := ℕ → ℕ → ℕ,
  guard_hyp j := ℕ → ℕ → ℕ,
  guard_hyp h := ∀ (n m : ℕ), m = n + i n m ∨ m + j n m = n,
  trivial
end
```'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                     </code><font color='orange'><a title=' `choose a b h using hyp` takes an hypothesis `hyp` of the form
`∀ (x : X) (y : Y), ∃ (a : A) (b : B), P x y a b` for some `P : X → Y → A → B → Prop` and outputs
into context a function `a : X → Y → A`, `b : X → Y → B` and a proposition `h` stating
`∀ (x : X) (y : Y), P x y (a x y) (b x y)`. It presumably also works with dependent versions.

Example:

```lean
example (h : ∀n m : ℕ, ∃i j, m = n + i ∨ m + j = n) : true :=
begin
  choose i j h using h,
  guard_hyp i := ℕ → ℕ → ℕ,
  guard_hyp j := ℕ → ℕ → ℕ,
  guard_hyp h := ∀ (n m : ℕ), m = n + i n m ∨ m + j n m = n,
  trivial
end
```'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='choose'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='conv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='to_lhs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='conv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='teal'><a title='conv'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='choose'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id&#x27;, &#x27;id*&#x27;, &#x27;(using expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;(at id)?&#x27;, &#x27;(in expr)?&#x27;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;(at id)?&#x27;, &#x27;(in expr)?&#x27;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='grey'><a title='[&#x27;(at id)?&#x27;, &#x27;(in expr)?&#x27;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id&#x27;, &#x27;id*&#x27;, &#x27;(using expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a b : real,
f : nat → set.{0} real,
hf :
  @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
    (@set.Union.{0 1} real nat (λ (i : nat), f i)),
ε : nnreal,
ε0 :
  @has_lt.lt.{0} nnreal
    (@preorder.to_has_lt.{0} nnreal
       (@partial_order.to_preorder.{0} nnreal
          (@ordered_comm_monoid.to_partial_order.{0} nnreal
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                   (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
    (@has_zero.zero.{0} nnreal nnreal.has_zero)
    ε,
h :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat), measure_theory.lebesgue_length (f i)))
    (@lattice.has_top.top.{0} ennreal
       (@lattice.order_top.to_has_top.{0} ennreal
          (@lattice.bounded_lattice.to_order_top.{0} ennreal
             (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))))),
ε&#x27; : nat → nnreal,
ε&#x27;0 :
  ∀ (i : nat),
    @has_lt.lt.{0} nnreal
      (@preorder.to_has_lt.{0} nnreal
         (@partial_order.to_preorder.{0} nnreal
            (@ordered_comm_monoid.to_partial_order.{0} nnreal
               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                     (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
      (@has_zero.zero.{0} nnreal nnreal.has_zero)
      (ε&#x27; i),
hε :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat),
          @coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
            (ε&#x27; i)))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe)) ε),
i : nat,
this :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (measure_theory.lebesgue_length (f i))
    (@has_add.add.{0} ennreal
       (@distrib.to_has_add.{0} ennreal
          (@semiring.to_distrib.{0} ennreal
             (@comm_semiring.to_semiring.{0} ennreal
                (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1))))
       (measure_theory.lebesgue_length (f i))
       (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
          (ε&#x27; i)))
⊢ @Exists.{1} (prod.{0 0} real real)
    (λ (p : prod.{0 0} real real),
       and
         (@has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (f i)
            (@set.Ioo.{0} real real.preorder (@prod.fst.{0 0} real real p) (@prod.snd.{0 0} real real p)))
         (@has_lt.lt.{0} ennreal
            (@preorder.to_has_lt.{0} ennreal
               (@partial_order.to_preorder.{0} ennreal
                  (@ordered_comm_monoid.to_partial_order.{0} ennreal
                     (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                        (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                           ennreal.canonically_ordered_comm_semiring_1)))))
            (@coe.{1 1} nnreal ennreal
               (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
               (nnreal.of_real
                  (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (@prod.snd.{0 0} real real p)
                     (@prod.fst.{0 0} real real p))))
            (@has_add.add.{0} ennreal
               (@distrib.to_has_add.{0} ennreal
                  (@semiring.to_distrib.{0} ennreal
                     (@comm_semiring.to_semiring.{0} ennreal
                        (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                           ennreal.canonically_ordered_comm_semiring_1))))
               (measure_theory.lebesgue_length (f i))
               (@coe.{1 1} nnreal ennreal
                  (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
                  (ε&#x27; i)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a b : real,
f : nat → set.{0} real,
hf :
  @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
    (@set.Union.{0 1} real nat (λ (i : nat), f i)),
ε : nnreal,
ε0 :
  @has_lt.lt.{0} nnreal
    (@preorder.to_has_lt.{0} nnreal
       (@partial_order.to_preorder.{0} nnreal
          (@ordered_comm_monoid.to_partial_order.{0} nnreal
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                   (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
    (@has_zero.zero.{0} nnreal nnreal.has_zero)
    ε,
h :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat), measure_theory.lebesgue_length (f i)))
    (@lattice.has_top.top.{0} ennreal
       (@lattice.order_top.to_has_top.{0} ennreal
          (@lattice.bounded_lattice.to_order_top.{0} ennreal
             (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))))),
ε&#x27; : nat → nnreal,
ε&#x27;0 :
  ∀ (i : nat),
    @has_lt.lt.{0} nnreal
      (@preorder.to_has_lt.{0} nnreal
         (@partial_order.to_preorder.{0} nnreal
            (@ordered_comm_monoid.to_partial_order.{0} nnreal
               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                     (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
      (@has_zero.zero.{0} nnreal nnreal.has_zero)
      (ε&#x27; i),
hε :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat),
          @coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
            (ε&#x27; i)))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe)) ε),
i : nat,
this :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (measure_theory.lebesgue_length (f i))
    (@has_add.add.{0} ennreal
       (@distrib.to_has_add.{0} ennreal
          (@semiring.to_distrib.{0} ennreal
             (@comm_semiring.to_semiring.{0} ennreal
                (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1))))
       (measure_theory.lebesgue_length (f i))
       (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
          (ε&#x27; i)))
| @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (measure_theory.lebesgue_length (f i))
    (@has_add.add.{0} ennreal
       (@distrib.to_has_add.{0} ennreal
          (@semiring.to_distrib.{0} ennreal
             (@comm_semiring.to_semiring.{0} ennreal
                (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1))))
       (measure_theory.lebesgue_length (f i))
       (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
          (ε&#x27; i)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a b : real,
f : nat → set.{0} real,
hf :
  @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
    (@set.Union.{0 1} real nat (λ (i : nat), f i)),
ε : nnreal,
ε0 :
  @has_lt.lt.{0} nnreal
    (@preorder.to_has_lt.{0} nnreal
       (@partial_order.to_preorder.{0} nnreal
          (@ordered_comm_monoid.to_partial_order.{0} nnreal
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                   (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
    (@has_zero.zero.{0} nnreal nnreal.has_zero)
    ε,
h :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat), measure_theory.lebesgue_length (f i)))
    (@lattice.has_top.top.{0} ennreal
       (@lattice.order_top.to_has_top.{0} ennreal
          (@lattice.bounded_lattice.to_order_top.{0} ennreal
             (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))))),
ε&#x27; : nat → nnreal,
ε&#x27;0 :
  ∀ (i : nat),
    @has_lt.lt.{0} nnreal
      (@preorder.to_has_lt.{0} nnreal
         (@partial_order.to_preorder.{0} nnreal
            (@ordered_comm_monoid.to_partial_order.{0} nnreal
               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                     (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
      (@has_zero.zero.{0} nnreal nnreal.has_zero)
      (ε&#x27; i),
hε :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat),
          @coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
            (ε&#x27; i)))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe)) ε),
i : nat,
this :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (measure_theory.lebesgue_length (f i))
    (@has_add.add.{0} ennreal
       (@distrib.to_has_add.{0} ennreal
          (@semiring.to_distrib.{0} ennreal
             (@comm_semiring.to_semiring.{0} ennreal
                (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1))))
       (measure_theory.lebesgue_length (f i))
       (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
          (ε&#x27; i)))
| measure_theory.lebesgue_length (f i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a b : real,
f : nat → set.{0} real,
hf :
  @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
    (@set.Union.{0 1} real nat (λ (i : nat), f i)),
ε : nnreal,
ε0 :
  @has_lt.lt.{0} nnreal
    (@preorder.to_has_lt.{0} nnreal
       (@partial_order.to_preorder.{0} nnreal
          (@ordered_comm_monoid.to_partial_order.{0} nnreal
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                   (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
    (@has_zero.zero.{0} nnreal nnreal.has_zero)
    ε,
h :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat), measure_theory.lebesgue_length (f i)))
    (@lattice.has_top.top.{0} ennreal
       (@lattice.order_top.to_has_top.{0} ennreal
          (@lattice.bounded_lattice.to_order_top.{0} ennreal
             (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))))),
ε&#x27; : nat → nnreal,
ε&#x27;0 :
  ∀ (i : nat),
    @has_lt.lt.{0} nnreal
      (@preorder.to_has_lt.{0} nnreal
         (@partial_order.to_preorder.{0} nnreal
            (@ordered_comm_monoid.to_partial_order.{0} nnreal
               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                     (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
      (@has_zero.zero.{0} nnreal nnreal.has_zero)
      (ε&#x27; i),
hε :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat),
          @coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
            (ε&#x27; i)))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe)) ε),
i : nat,
this :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (measure_theory.lebesgue_length (f i))
    (@has_add.add.{0} ennreal
       (@distrib.to_has_add.{0} ennreal
          (@semiring.to_distrib.{0} ennreal
             (@comm_semiring.to_semiring.{0} ennreal
                (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1))))
       (measure_theory.lebesgue_length (f i))
       (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
          (ε&#x27; i)))
| @lattice.infi.{0 1} ennreal real
    (@lattice.conditionally_complete_lattice.to_has_Inf.{0} ennreal
       (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
          (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
    (λ (a : real),
       @lattice.infi.{0 1} ennreal real
         (@lattice.conditionally_complete_lattice.to_has_Inf.{0} ennreal
            (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
               (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
         (λ (b : real),
            @lattice.infi.{0 0} ennreal
              (@has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (f i)
                 (@set.Ioo.{0} real real.preorder a b))
              (@lattice.conditionally_complete_lattice.to_has_Inf.{0} ennreal
                 (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
                    (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
              (λ
               (h :
                 @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (f i)
                   (@set.Ioo.{0} real real.preorder a b)),
                 @coe.{1 1} nnreal ennreal
                   (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
                   (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a b : real,
f : nat → set.{0} real,
hf :
  @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
    (@set.Union.{0 1} real nat (λ (i : nat), f i)),
ε : nnreal,
ε0 :
  @has_lt.lt.{0} nnreal
    (@preorder.to_has_lt.{0} nnreal
       (@partial_order.to_preorder.{0} nnreal
          (@ordered_comm_monoid.to_partial_order.{0} nnreal
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                   (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
    (@has_zero.zero.{0} nnreal nnreal.has_zero)
    ε,
h :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat), measure_theory.lebesgue_length (f i)))
    (@lattice.has_top.top.{0} ennreal
       (@lattice.order_top.to_has_top.{0} ennreal
          (@lattice.bounded_lattice.to_order_top.{0} ennreal
             (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))))),
ε&#x27; : nat → nnreal,
ε&#x27;0 :
  ∀ (i : nat),
    @has_lt.lt.{0} nnreal
      (@preorder.to_has_lt.{0} nnreal
         (@partial_order.to_preorder.{0} nnreal
            (@ordered_comm_monoid.to_partial_order.{0} nnreal
               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                     (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
      (@has_zero.zero.{0} nnreal nnreal.has_zero)
      (ε&#x27; i),
hε :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat),
          @coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
            (ε&#x27; i)))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe)) ε),
i : nat,
this :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@lattice.infi.{0 1} ennreal real
       (@lattice.conditionally_complete_lattice.to_has_Inf.{0} ennreal
          (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
             (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
       (λ (a : real),
          @lattice.infi.{0 1} ennreal real
            (@lattice.conditionally_complete_lattice.to_has_Inf.{0} ennreal
               (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
                  (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
            (λ (b : real),
               @lattice.infi.{0 0} ennreal
                 (@has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (f i)
                    (@set.Ioo.{0} real real.preorder a b))
                 (@lattice.conditionally_complete_lattice.to_has_Inf.{0} ennreal
                    (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
                       (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal
                          ennreal.complete_linear_order_1)))
                 (λ
                  (h :
                    @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (f i)
                      (@set.Ioo.{0} real real.preorder a b)),
                    @coe.{1 1} nnreal ennreal
                      (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
                      (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a))))))
    (@has_add.add.{0} ennreal
       (@distrib.to_has_add.{0} ennreal
          (@semiring.to_distrib.{0} ennreal
             (@comm_semiring.to_semiring.{0} ennreal
                (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1))))
       (measure_theory.lebesgue_length (f i))
       (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
          (ε&#x27; i)))
⊢ @Exists.{1} (prod.{0 0} real real)
    (λ (p : prod.{0 0} real real),
       and
         (@has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (f i)
            (@set.Ioo.{0} real real.preorder (@prod.fst.{0 0} real real p) (@prod.snd.{0 0} real real p)))
         (@has_lt.lt.{0} ennreal
            (@preorder.to_has_lt.{0} ennreal
               (@partial_order.to_preorder.{0} ennreal
                  (@ordered_comm_monoid.to_partial_order.{0} ennreal
                     (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                        (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                           ennreal.canonically_ordered_comm_semiring_1)))))
            (@coe.{1 1} nnreal ennreal
               (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
               (nnreal.of_real
                  (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (@prod.snd.{0 0} real real p)
                     (@prod.fst.{0 0} real real p))))
            (@has_add.add.{0} ennreal
               (@distrib.to_has_add.{0} ennreal
                  (@semiring.to_distrib.{0} ennreal
                     (@comm_semiring.to_semiring.{0} ennreal
                        (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                           ennreal.canonically_ordered_comm_semiring_1))))
               (measure_theory.lebesgue_length (f i))
               (@coe.{1 1} nnreal ennreal
                  (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
                  (ε&#x27; i)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>142      simpa [infi_lt_iff] },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='lattice.infi_lt_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 511, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/complete_lattice.lean&#x27;, &#x27;line&#x27;: 217, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 511, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse name (λ (a : name), name.reflect a) lean.parser.ident → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} [_inst_1 : lattice.complete_linear_order.{?l_1} α] {a : α} {ι : Sort ?l_2} {f : ι → α}, iff (@has_lt.lt.{?l_1} α (@preorder.to_has_lt.{?l_1} α (@partial_order.to_preorder.{?l_1} α (@lattice.order_bot.to_partial_order.{?l_1} α (@lattice.bounded_lattice.to_order_bot.{?l_1} α (@lattice.complete_lattice.to_bounded_lattice.{?l_1} α (@lattice.complete_linear_order.to_complete_lattice.{?l_1} α _inst_1)))))) (@lattice.infi.{?l_1 ?l_2} α ι (@lattice.complete_lattice.to_has_Inf.{?l_1} α (@lattice.complete_linear_order.to_complete_lattice.{?l_1} α _inst_1)) f) a) (@Exists.{?l_2} ι (λ (i : ι), @has_lt.lt.{?l_1} α (@preorder.to_has_lt.{?l_1} α (@partial_order.to_preorder.{?l_1} α (@lattice.order_bot.to_partial_order.{?l_1} α (@lattice.bounded_lattice.to_order_bot.{?l_1} α (@lattice.complete_lattice.to_bounded_lattice.{?l_1} α (@lattice.complete_linear_order.to_complete_lattice.{?l_1} α _inst_1)))))) (f i) a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse name (λ (a : name), name.reflect a) lean.parser.ident → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title=' `choose a b h using hyp` takes an hypothesis `hyp` of the form
`∀ (x : X) (y : Y), ∃ (a : A) (b : B), P x y a b` for some `P : X → Y → A → B → Prop` and outputs
into context a function `a : X → Y → A`, `b : X → Y → B` and a proposition `h` stating
`∀ (x : X) (y : Y), P x y (a x y) (b x y)`. It presumably also works with dependent versions.

Example:

```lean
example (h : ∀n m : ℕ, ∃i j, m = n + i ∨ m + j = n) : true :=
begin
  choose i j h using h,
  guard_hyp i := ℕ → ℕ → ℕ,
  guard_hyp j := ℕ → ℕ → ℕ,
  guard_hyp h := ∀ (n m : ℕ), m = n + i n m ∨ m + j n m = n,
  trivial
end
```'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title=' `choose a b h using hyp` takes an hypothesis `hyp` of the form
`∀ (x : X) (y : Y), ∃ (a : A) (b : B), P x y a b` for some `P : X → Y → A → B → Prop` and outputs
into context a function `a : X → Y → A`, `b : X → Y → B` and a proposition `h` stating
`∀ (x : X) (y : Y), P x y (a x y) (b x y)`. It presumably also works with dependent versions.

Example:

```lean
example (h : ∀n m : ℕ, ∃i j, m = n + i ∨ m + j = n) : true :=
begin
  choose i j h using h,
  guard_hyp i := ℕ → ℕ → ℕ,
  guard_hyp j := ℕ → ℕ → ℕ,
  guard_hyp h := ∀ (n m : ℕ), m = n + i n m ∨ m + j n m = n,
  trivial
end
```'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='choose'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='choose'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id&#x27;, &#x27;id*&#x27;, &#x27;(using expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id&#x27;, &#x27;id*&#x27;, &#x27;(using expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a b : real,
f : nat → set.{0} real,
hf :
  @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
    (@set.Union.{0 1} real nat (λ (i : nat), f i)),
ε : nnreal,
ε0 :
  @has_lt.lt.{0} nnreal
    (@preorder.to_has_lt.{0} nnreal
       (@partial_order.to_preorder.{0} nnreal
          (@ordered_comm_monoid.to_partial_order.{0} nnreal
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                   (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
    (@has_zero.zero.{0} nnreal nnreal.has_zero)
    ε,
h :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat), measure_theory.lebesgue_length (f i)))
    (@lattice.has_top.top.{0} ennreal
       (@lattice.order_top.to_has_top.{0} ennreal
          (@lattice.bounded_lattice.to_order_top.{0} ennreal
             (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))))),
ε&#x27; : nat → nnreal,
ε&#x27;0 :
  ∀ (i : nat),
    @has_lt.lt.{0} nnreal
      (@preorder.to_has_lt.{0} nnreal
         (@partial_order.to_preorder.{0} nnreal
            (@ordered_comm_monoid.to_partial_order.{0} nnreal
               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                     (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
      (@has_zero.zero.{0} nnreal nnreal.has_zero)
      (ε&#x27; i),
hε :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat),
          @coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
            (ε&#x27; i)))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe)) ε),
i : nat,
this :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@lattice.infi.{0 1} ennreal real
       (@lattice.conditionally_complete_lattice.to_has_Inf.{0} ennreal
          (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
             (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
       (λ (a : real),
          @lattice.infi.{0 1} ennreal real
            (@lattice.conditionally_complete_lattice.to_has_Inf.{0} ennreal
               (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
                  (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
            (λ (b : real),
               @lattice.infi.{0 0} ennreal
                 (@has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (f i)
                    (@set.Ioo.{0} real real.preorder a b))
                 (@lattice.conditionally_complete_lattice.to_has_Inf.{0} ennreal
                    (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
                       (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal
                          ennreal.complete_linear_order_1)))
                 (λ
                  (h :
                    @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (f i)
                      (@set.Ioo.{0} real real.preorder a b)),
                    @coe.{1 1} nnreal ennreal
                      (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
                      (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a))))))
    (@has_add.add.{0} ennreal
       (@distrib.to_has_add.{0} ennreal
          (@semiring.to_distrib.{0} ennreal
             (@comm_semiring.to_semiring.{0} ennreal
                (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1))))
       (measure_theory.lebesgue_length (f i))
       (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
          (ε&#x27; i)))
⊢ @Exists.{1} (prod.{0 0} real real)
    (λ (p : prod.{0 0} real real),
       and
         (@has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (f i)
            (@set.Ioo.{0} real real.preorder (@prod.fst.{0 0} real real p) (@prod.snd.{0 0} real real p)))
         (@has_lt.lt.{0} ennreal
            (@preorder.to_has_lt.{0} ennreal
               (@partial_order.to_preorder.{0} ennreal
                  (@ordered_comm_monoid.to_partial_order.{0} ennreal
                     (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                        (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                           ennreal.canonically_ordered_comm_semiring_1)))))
            (@coe.{1 1} nnreal ennreal
               (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
               (nnreal.of_real
                  (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (@prod.snd.{0 0} real real p)
                     (@prod.fst.{0 0} real real p))))
            (@has_add.add.{0} ennreal
               (@distrib.to_has_add.{0} ennreal
                  (@semiring.to_distrib.{0} ennreal
                     (@comm_semiring.to_semiring.{0} ennreal
                        (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                           ennreal.canonically_ordered_comm_semiring_1))))
               (measure_theory.lebesgue_length (f i))
               (@coe.{1 1} nnreal ennreal
                  (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
                  (ε&#x27; i)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a b : real,
f : nat → set.{0} real,
hf :
  @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
    (@set.Union.{0 1} real nat (λ (i : nat), f i)),
ε : nnreal,
ε0 :
  @has_lt.lt.{0} nnreal
    (@preorder.to_has_lt.{0} nnreal
       (@partial_order.to_preorder.{0} nnreal
          (@ordered_comm_monoid.to_partial_order.{0} nnreal
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                   (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
    (@has_zero.zero.{0} nnreal nnreal.has_zero)
    ε,
h :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat), measure_theory.lebesgue_length (f i)))
    (@lattice.has_top.top.{0} ennreal
       (@lattice.order_top.to_has_top.{0} ennreal
          (@lattice.bounded_lattice.to_order_top.{0} ennreal
             (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))))),
ε&#x27; : nat → nnreal,
ε&#x27;0 :
  ∀ (i : nat),
    @has_lt.lt.{0} nnreal
      (@preorder.to_has_lt.{0} nnreal
         (@partial_order.to_preorder.{0} nnreal
            (@ordered_comm_monoid.to_partial_order.{0} nnreal
               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                     (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
      (@has_zero.zero.{0} nnreal nnreal.has_zero)
      (ε&#x27; i),
hε :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat),
          @coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
            (ε&#x27; i)))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe)) ε),
g : nat → prod.{0 0} real real,
hg :
  ∀ (i : nat),
    and
      (@has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (f i)
         (@set.Ioo.{0} real real.preorder (@prod.fst.{0 0} real real (g i)) (@prod.snd.{0 0} real real (g i))))
      (@has_lt.lt.{0} ennreal
         (@preorder.to_has_lt.{0} ennreal
            (@partial_order.to_preorder.{0} ennreal
               (@ordered_comm_monoid.to_partial_order.{0} ennreal
                  (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                     (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                        ennreal.canonically_ordered_comm_semiring_1)))))
         (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
            (nnreal.of_real
               (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (@prod.snd.{0 0} real real (g i))
                  (@prod.fst.{0 0} real real (g i)))))
         (@has_add.add.{0} ennreal
            (@distrib.to_has_add.{0} ennreal
               (@semiring.to_distrib.{0} ennreal
                  (@comm_semiring.to_semiring.{0} ennreal
                     (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                        ennreal.canonically_ordered_comm_semiring_1))))
            (measure_theory.lebesgue_length (f i))
            (@coe.{1 1} nnreal ennreal
               (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
               (ε&#x27; i))))
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (a : nat),
          @has_add.add.{0} ennreal
            (@distrib.to_has_add.{0} ennreal
               (@semiring.to_distrib.{0} ennreal
                  (@comm_semiring.to_semiring.{0} ennreal
                     (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                        ennreal.canonically_ordered_comm_semiring_1))))
            (measure_theory.lebesgue_length (f a))
            (@coe.{1 1} nnreal ennreal
               (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
               (ε&#x27; a))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>143    refine le_trans _ (ennreal.tsum_le_tsum $ λ i, le_of_lt (hg i).2),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='le_trans'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='ennreal.tsum_le_tsum'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='le_of_lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 33, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/instances/ennreal.lean&#x27;, &#x27;line&#x27;: 473, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 99, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : preorder.{0} α] {a b c : α}, @has_le.le.{0} α (@preorder.to_has_le.{0} α _inst_1) a b → @has_le.le.{0} α (@preorder.to_has_le.{0} α _inst_1) b c → @has_le.le.{0} α (@preorder.to_has_le.{0} α _inst_1) a c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type} {f g : α → ennreal}, (∀ (a : α), @has_le.le.{0} ennreal (@preorder.to_has_le.{0} ennreal (@partial_order.to_preorder.{0} ennreal (@ordered_comm_monoid.to_partial_order.{0} ennreal (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal ennreal.canonically_ordered_comm_semiring_1))))) (f a) (g a)) → @has_le.le.{0} ennreal (@preorder.to_has_le.{0} ennreal (@partial_order.to_preorder.{0} ennreal (@ordered_comm_monoid.to_partial_order.{0} ennreal (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal ennreal.canonically_ordered_comm_semiring_1))))) (@tsum.{0 0} ennreal α (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal ennreal.canonically_ordered_comm_semiring_1))) ennreal.topological_space (λ (a : α), f a)) (@tsum.{0 0} ennreal α (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal ennreal.canonically_ordered_comm_semiring_1))) ennreal.topological_space (λ (a : α), g a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : preorder.{0} α] {a b : α}, @has_lt.lt.{0} α (@preorder.to_has_lt.{0} α _inst_1) a b → @has_le.le.{0} α (@preorder.to_has_le.{0} α _inst_1) a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ (i : nat), and (@has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (f i) (@set.Ioo.{0} real real.preorder (@prod.fst.{0 0} real real (g i)) (@prod.snd.{0 0} real real (g i)))) (@has_lt.lt.{0} ennreal (@preorder.to_has_lt.{0} ennreal (@partial_order.to_preorder.{0} ennreal (@ordered_comm_monoid.to_partial_order.{0} ennreal (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal ennreal.canonically_ordered_comm_semiring_1))))) (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe)) (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (@prod.snd.{0 0} real real (g i)) (@prod.fst.{0 0} real real (g i))))) (@has_add.add.{0} ennreal (@distrib.to_has_add.{0} ennreal (@semiring.to_distrib.{0} ennreal (@comm_semiring.to_semiring.{0} ennreal (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal ennreal.canonically_ordered_comm_semiring_1)))) (measure_theory.lebesgue_length (f i)) (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe)) (ε&#x27; i))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a b : real,
f : nat → set.{0} real,
hf :
  @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
    (@set.Union.{0 1} real nat (λ (i : nat), f i)),
ε : nnreal,
ε0 :
  @has_lt.lt.{0} nnreal
    (@preorder.to_has_lt.{0} nnreal
       (@partial_order.to_preorder.{0} nnreal
          (@ordered_comm_monoid.to_partial_order.{0} nnreal
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                   (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
    (@has_zero.zero.{0} nnreal nnreal.has_zero)
    ε,
h :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat), measure_theory.lebesgue_length (f i)))
    (@lattice.has_top.top.{0} ennreal
       (@lattice.order_top.to_has_top.{0} ennreal
          (@lattice.bounded_lattice.to_order_top.{0} ennreal
             (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))))),
ε&#x27; : nat → nnreal,
ε&#x27;0 :
  ∀ (i : nat),
    @has_lt.lt.{0} nnreal
      (@preorder.to_has_lt.{0} nnreal
         (@partial_order.to_preorder.{0} nnreal
            (@ordered_comm_monoid.to_partial_order.{0} nnreal
               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                     (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
      (@has_zero.zero.{0} nnreal nnreal.has_zero)
      (ε&#x27; i),
hε :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat),
          @coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
            (ε&#x27; i)))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe)) ε),
g : nat → prod.{0 0} real real,
hg :
  ∀ (i : nat),
    and
      (@has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (f i)
         (@set.Ioo.{0} real real.preorder (@prod.fst.{0 0} real real (g i)) (@prod.snd.{0 0} real real (g i))))
      (@has_lt.lt.{0} ennreal
         (@preorder.to_has_lt.{0} ennreal
            (@partial_order.to_preorder.{0} ennreal
               (@ordered_comm_monoid.to_partial_order.{0} ennreal
                  (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                     (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                        ennreal.canonically_ordered_comm_semiring_1)))))
         (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
            (nnreal.of_real
               (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (@prod.snd.{0 0} real real (g i))
                  (@prod.fst.{0 0} real real (g i)))))
         (@has_add.add.{0} ennreal
            (@distrib.to_has_add.{0} ennreal
               (@semiring.to_distrib.{0} ennreal
                  (@comm_semiring.to_semiring.{0} ennreal
                     (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                        ennreal.canonically_ordered_comm_semiring_1))))
            (measure_theory.lebesgue_length (f i))
            (@coe.{1 1} nnreal ennreal
               (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
               (ε&#x27; i))))
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (a : nat),
          @has_add.add.{0} ennreal
            (@distrib.to_has_add.{0} ennreal
               (@semiring.to_distrib.{0} ennreal
                  (@comm_semiring.to_semiring.{0} ennreal
                     (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                        ennreal.canonically_ordered_comm_semiring_1))))
            (measure_theory.lebesgue_length (f a))
            (@coe.{1 1} nnreal ennreal
               (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
               (ε&#x27; a))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a b : real,
f : nat → set.{0} real,
hf :
  @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
    (@set.Union.{0 1} real nat (λ (i : nat), f i)),
ε : nnreal,
ε0 :
  @has_lt.lt.{0} nnreal
    (@preorder.to_has_lt.{0} nnreal
       (@partial_order.to_preorder.{0} nnreal
          (@ordered_comm_monoid.to_partial_order.{0} nnreal
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                   (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
    (@has_zero.zero.{0} nnreal nnreal.has_zero)
    ε,
h :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat), measure_theory.lebesgue_length (f i)))
    (@lattice.has_top.top.{0} ennreal
       (@lattice.order_top.to_has_top.{0} ennreal
          (@lattice.bounded_lattice.to_order_top.{0} ennreal
             (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))))),
ε&#x27; : nat → nnreal,
ε&#x27;0 :
  ∀ (i : nat),
    @has_lt.lt.{0} nnreal
      (@preorder.to_has_lt.{0} nnreal
         (@partial_order.to_preorder.{0} nnreal
            (@ordered_comm_monoid.to_partial_order.{0} nnreal
               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                     (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
      (@has_zero.zero.{0} nnreal nnreal.has_zero)
      (ε&#x27; i),
hε :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat),
          @coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
            (ε&#x27; i)))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe)) ε),
g : nat → prod.{0 0} real real,
hg :
  ∀ (i : nat),
    and
      (@has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (f i)
         (@set.Ioo.{0} real real.preorder (@prod.fst.{0 0} real real (g i)) (@prod.snd.{0 0} real real (g i))))
      (@has_lt.lt.{0} ennreal
         (@preorder.to_has_lt.{0} ennreal
            (@partial_order.to_preorder.{0} ennreal
               (@ordered_comm_monoid.to_partial_order.{0} ennreal
                  (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                     (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                        ennreal.canonically_ordered_comm_semiring_1)))))
         (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
            (nnreal.of_real
               (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (@prod.snd.{0 0} real real (g i))
                  (@prod.fst.{0 0} real real (g i)))))
         (@has_add.add.{0} ennreal
            (@distrib.to_has_add.{0} ennreal
               (@semiring.to_distrib.{0} ennreal
                  (@comm_semiring.to_semiring.{0} ennreal
                     (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                        ennreal.canonically_ordered_comm_semiring_1))))
            (measure_theory.lebesgue_length (f i))
            (@coe.{1 1} nnreal ennreal
               (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
               (ε&#x27; i))))
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (a : nat),
          @coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
            (nnreal.of_real
               (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (@prod.snd.{0 0} real real (g a))
                  (@prod.fst.{0 0} real real (g a))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>144    exact lebesgue_length_subadditive (subset.trans hf $</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='measure_theory.lebesgue_length_subadditive'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.subset.trans'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 93, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 94, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : real} {c d : nat → real}, @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b) (@set.Union.{0 1} real nat (λ (i : nat), @set.Ioo.{0} real real.preorder (c i) (d i))) → @has_le.le.{0} ennreal (@preorder.to_has_le.{0} ennreal (@partial_order.to_preorder.{0} ennreal (@ordered_comm_monoid.to_partial_order.{0} ennreal (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal ennreal.canonically_ordered_comm_semiring_1))))) (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe)) (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a))) (@tsum.{0 0} ennreal nat (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal ennreal.canonically_ordered_comm_semiring_1))) ennreal.topological_space (λ (i : nat), @coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe)) (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (d i) (c i)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type} {a b c : set.{0} α}, @has_subset.subset.{0} (set.{0} α) (@set.has_subset.{0} α) a b → @has_subset.subset.{0} (set.{0} α) (@set.has_subset.{0} α) b c → @has_subset.subset.{0} (set.{0} α) (@set.has_subset.{0} α) a c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b) (@set.Union.{0 1} real nat (λ (i : nat), f i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a b : real,
f : nat → set.{0} real,
hf :
  @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
    (@set.Union.{0 1} real nat (λ (i : nat), f i)),
ε : nnreal,
ε0 :
  @has_lt.lt.{0} nnreal
    (@preorder.to_has_lt.{0} nnreal
       (@partial_order.to_preorder.{0} nnreal
          (@ordered_comm_monoid.to_partial_order.{0} nnreal
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                   (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
    (@has_zero.zero.{0} nnreal nnreal.has_zero)
    ε,
h :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat), measure_theory.lebesgue_length (f i)))
    (@lattice.has_top.top.{0} ennreal
       (@lattice.order_top.to_has_top.{0} ennreal
          (@lattice.bounded_lattice.to_order_top.{0} ennreal
             (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))))),
ε&#x27; : nat → nnreal,
ε&#x27;0 :
  ∀ (i : nat),
    @has_lt.lt.{0} nnreal
      (@preorder.to_has_lt.{0} nnreal
         (@partial_order.to_preorder.{0} nnreal
            (@ordered_comm_monoid.to_partial_order.{0} nnreal
               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                     (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
      (@has_zero.zero.{0} nnreal nnreal.has_zero)
      (ε&#x27; i),
hε :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat),
          @coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
            (ε&#x27; i)))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe)) ε),
g : nat → prod.{0 0} real real,
hg :
  ∀ (i : nat),
    and
      (@has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (f i)
         (@set.Ioo.{0} real real.preorder (@prod.fst.{0 0} real real (g i)) (@prod.snd.{0 0} real real (g i))))
      (@has_lt.lt.{0} ennreal
         (@preorder.to_has_lt.{0} ennreal
            (@partial_order.to_preorder.{0} ennreal
               (@ordered_comm_monoid.to_partial_order.{0} ennreal
                  (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                     (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                        ennreal.canonically_ordered_comm_semiring_1)))))
         (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
            (nnreal.of_real
               (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (@prod.snd.{0 0} real real (g i))
                  (@prod.fst.{0 0} real real (g i)))))
         (@has_add.add.{0} ennreal
            (@distrib.to_has_add.{0} ennreal
               (@semiring.to_distrib.{0} ennreal
                  (@comm_semiring.to_semiring.{0} ennreal
                     (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                        ennreal.canonically_ordered_comm_semiring_1))))
            (measure_theory.lebesgue_length (f i))
            (@coe.{1 1} nnreal ennreal
               (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
               (ε&#x27; i))))
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (a : nat),
          @coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
            (nnreal.of_real
               (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (@prod.snd.{0 0} real real (g a))
                  (@prod.fst.{0 0} real real (g a))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>145      Union_subset_Union $ λ i, (hg i).1)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='set.Union_subset_Union'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='hg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/lattice.lean&#x27;, &#x27;line&#x27;: 455, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α ι : Type} {s t : ι → set.{0} α}, (∀ (i : ι), @has_subset.subset.{0} (set.{0} α) (@set.has_subset.{0} α) (s i) (t i)) → @has_subset.subset.{0} (set.{0} α) (@set.has_subset.{0} α) (@set.Union.{0 1} α ι (λ (i : ι), s i)) (@set.Union.{0 1} α ι (λ (i : ι), t i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ (i : nat), and (@has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (f i) (@set.Ioo.{0} real real.preorder (@prod.fst.{0 0} real real (g i)) (@prod.snd.{0 0} real real (g i)))) (@has_lt.lt.{0} ennreal (@preorder.to_has_lt.{0} ennreal (@partial_order.to_preorder.{0} ennreal (@ordered_comm_monoid.to_partial_order.{0} ennreal (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal ennreal.canonically_ordered_comm_semiring_1))))) (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe)) (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (@prod.snd.{0 0} real real (g i)) (@prod.fst.{0 0} real real (g i))))) (@has_add.add.{0} ennreal (@distrib.to_has_add.{0} ennreal (@semiring.to_distrib.{0} ennreal (@comm_semiring.to_semiring.{0} ennreal (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal ennreal.canonically_ordered_comm_semiring_1)))) (measure_theory.lebesgue_length (f i)) (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe)) (ε&#x27; i))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a b : real,
f : nat → set.{0} real,
hf :
  @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (@set.Icc.{0} real real.preorder a b)
    (@set.Union.{0 1} real nat (λ (i : nat), f i)),
ε : nnreal,
ε0 :
  @has_lt.lt.{0} nnreal
    (@preorder.to_has_lt.{0} nnreal
       (@partial_order.to_preorder.{0} nnreal
          (@ordered_comm_monoid.to_partial_order.{0} nnreal
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                   (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
    (@has_zero.zero.{0} nnreal nnreal.has_zero)
    ε,
h :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat), measure_theory.lebesgue_length (f i)))
    (@lattice.has_top.top.{0} ennreal
       (@lattice.order_top.to_has_top.{0} ennreal
          (@lattice.bounded_lattice.to_order_top.{0} ennreal
             (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))))),
ε&#x27; : nat → nnreal,
ε&#x27;0 :
  ∀ (i : nat),
    @has_lt.lt.{0} nnreal
      (@preorder.to_has_lt.{0} nnreal
         (@partial_order.to_preorder.{0} nnreal
            (@ordered_comm_monoid.to_partial_order.{0} nnreal
               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                     (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
      (@has_zero.zero.{0} nnreal nnreal.has_zero)
      (ε&#x27; i),
hε :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat),
          @coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
            (ε&#x27; i)))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe)) ε),
g : nat → prod.{0 0} real real,
hg :
  ∀ (i : nat),
    and
      (@has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (f i)
         (@set.Ioo.{0} real real.preorder (@prod.fst.{0 0} real real (g i)) (@prod.snd.{0 0} real real (g i))))
      (@has_lt.lt.{0} ennreal
         (@preorder.to_has_lt.{0} ennreal
            (@partial_order.to_preorder.{0} ennreal
               (@ordered_comm_monoid.to_partial_order.{0} ennreal
                  (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                     (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                        ennreal.canonically_ordered_comm_semiring_1)))))
         (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
            (nnreal.of_real
               (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (@prod.snd.{0 0} real real (g i))
                  (@prod.fst.{0 0} real real (g i)))))
         (@has_add.add.{0} ennreal
            (@distrib.to_has_add.{0} ennreal
               (@semiring.to_distrib.{0} ennreal
                  (@comm_semiring.to_semiring.{0} ennreal
                     (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                        ennreal.canonically_ordered_comm_semiring_1))))
            (measure_theory.lebesgue_length (f i))
            (@coe.{1 1} nnreal ennreal
               (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
               (ε&#x27; i))))
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (a : nat),
          @coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
            (nnreal.of_real
               (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (@prod.snd.{0 0} real real (g a))
                  (@prod.fst.{0 0} real real (g a))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>146  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>147  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>148  @[simp] lemma lebesgue_outer_singleton (a : ℝ) : lebesgue_outer {a} = 0 :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                            </code><font color='blue'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='measure_theory.lebesgue_outer'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='singleton'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/basic.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 87, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 393, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                            </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='measure_theory.outer_measure.{0} real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type} [_inst_1 : has_emptyc.{0} γ] [_inst_2 : has_insert.{0 0} α γ], α → γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                           </code><font color='orange'><a title='The Lebesgue outer measure, as an outer measure of ℝ.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>149  by simpa using lebesgue_outer_Icc a a</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='measure_theory.lebesgue_outer_Icc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 126, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (a b : real), @eq.{1} ennreal (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real) (@measure_theory.outer_measure.has_coe_to_fun.{0} real) measure_theory.lebesgue_outer (@set.Icc.{0} real real.preorder a b)) (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe)) (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='5'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='a : real
⊢ @eq.{1} ennreal
    (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real) (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
       measure_theory.lebesgue_outer
       (@singleton.{0 0} real (set.{0} real) (@set.has_emptyc.{0} real) (@set.has_insert.{0} real) a))
    (@has_zero.zero.{0} ennreal
       (@zero_ne_one_class.to_has_zero.{0} ennreal
          (@canonically_ordered_comm_semiring.to_zero_ne_one_class.{0} ennreal
             ennreal.canonically_ordered_comm_semiring_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>150  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='5'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a : real
⊢ @eq.{1} ennreal
    (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real) (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
       measure_theory.lebesgue_outer
       (@singleton.{0 0} real (set.{0} real) (@set.has_emptyc.{0} real) (@set.has_insert.{0} real) a))
    (@has_zero.zero.{0} ennreal
       (@zero_ne_one_class.to_has_zero.{0} ennreal
          (@canonically_ordered_comm_semiring.to_zero_ne_one_class.{0} ennreal
             ennreal.canonically_ordered_comm_semiring_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>151  @[simp] lemma lebesgue_outer_Ico (a b : ℝ) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='blue'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/basic.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>152    lebesgue_outer (Ico a b) = of_real (b - a) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='measure_theory.lebesgue_outer'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.Ico'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='nnreal.of_real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_sub.sub'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 87, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/intervals/basic.lean&#x27;, &#x27;line&#x27;: 43, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/nnreal.lean&#x27;, &#x27;line&#x27;: 32, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 315, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='measure_theory.outer_measure.{0} real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [_inst_1 : preorder.{u} α], α → α → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real → nnreal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_sub.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The Lebesgue outer measure, as an outer measure of ℝ.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Left-closed right-open interval'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>153  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a b : real
⊢ @eq.{1} ennreal
    (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real) (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
       measure_theory.lebesgue_outer
       (@set.Ico.{0} real real.preorder a b))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>154    refine le_antisymm (by rw ← lebesgue_length_Ico; apply lebesgue_outer_le_length)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='le_antisymm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='measure_theory.lebesgue_length_Ico'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='measure_theory.lebesgue_outer_le_length'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 45, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 22, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 90, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : partial_order.{0} α] {a b : α}, @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α _inst_1)) a b → @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α _inst_1)) b a → @eq.{1} α a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (a b : real), @eq.{1} ennreal (measure_theory.lebesgue_length (@set.Ico.{0} real real.preorder a b)) (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe)) (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (s : set.{0} real), @has_le.le.{0} ennreal (@preorder.to_has_le.{0} ennreal (@partial_order.to_preorder.{0} ennreal (@ordered_comm_monoid.to_partial_order.{0} ennreal (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal ennreal.canonically_ordered_comm_semiring_1))))) (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real) (@measure_theory.outer_measure.has_coe_to_fun.{0} real) measure_theory.lebesgue_outer s) (measure_theory.lebesgue_length s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a b : real
⊢ @eq.{1} ennreal
    (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real) (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
       measure_theory.lebesgue_outer
       (@set.Ico.{0} real real.preorder a b))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a b : real
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real) (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
       measure_theory.lebesgue_outer
       (@set.Ico.{0} real real.preorder a b))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a b : real
⊢ @eq.{1} ennreal
    (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real) (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
       measure_theory.lebesgue_outer
       (@set.Ico.{0} real real.preorder a b))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>155      (ennreal.le_of_forall_epsilon_le $ λ ε ε0 h, _),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='ennreal.le_of_forall_epsilon_le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/ennreal.lean&#x27;, &#x27;line&#x27;: 259, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {a b : ennreal}, (∀ (ε : nnreal), @has_lt.lt.{0} nnreal (@preorder.to_has_lt.{0} nnreal (@partial_order.to_preorder.{0} nnreal (@ordered_comm_monoid.to_partial_order.{0} nnreal (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring)))))) (@has_zero.zero.{0} nnreal nnreal.has_zero) ε → @has_lt.lt.{0} ennreal (@preorder.to_has_lt.{0} ennreal (@partial_order.to_preorder.{0} ennreal (@ordered_comm_monoid.to_partial_order.{0} ennreal (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal ennreal.canonically_ordered_comm_semiring_1))))) b (@lattice.has_top.top.{0} ennreal (@lattice.order_top.to_has_top.{0} ennreal (@lattice.bounded_lattice.to_order_top.{0} ennreal (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))))) → @has_le.le.{0} ennreal (@preorder.to_has_le.{0} ennreal (@partial_order.to_preorder.{0} ennreal (@ordered_comm_monoid.to_partial_order.{0} ennreal (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal ennreal.canonically_ordered_comm_semiring_1))))) a (@has_add.add.{0} ennreal (@distrib.to_has_add.{0} ennreal (@semiring.to_distrib.{0} ennreal (@comm_semiring.to_semiring.{0} ennreal (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal ennreal.canonically_ordered_comm_semiring_1)))) b (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe)) ε))) → @has_le.le.{0} ennreal (@preorder.to_has_le.{0} ennreal (@partial_order.to_preorder.{0} ennreal (@ordered_comm_monoid.to_partial_order.{0} ennreal (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal ennreal.canonically_ordered_comm_semiring_1))))) a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a b : real
⊢ @eq.{1} ennreal
    (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real) (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
       measure_theory.lebesgue_outer
       (@set.Ico.{0} real real.preorder a b))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a b : real,
ε : nnreal,
ε0 :
  @has_lt.lt.{0} nnreal
    (@preorder.to_has_lt.{0} nnreal
       (@partial_order.to_preorder.{0} nnreal
          (@ordered_comm_monoid.to_partial_order.{0} nnreal
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                   (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
    (@has_zero.zero.{0} nnreal nnreal.has_zero)
    ε,
h :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real) (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
       measure_theory.lebesgue_outer
       (@set.Ico.{0} real real.preorder a b))
    (@lattice.has_top.top.{0} ennreal
       (@lattice.order_top.to_has_top.{0} ennreal
          (@lattice.bounded_lattice.to_order_top.{0} ennreal
             (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))))
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
    (@has_add.add.{0} ennreal
       (@distrib.to_has_add.{0} ennreal
          (@semiring.to_distrib.{0} ennreal
             (@comm_semiring.to_semiring.{0} ennreal
                (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1))))
       (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real) (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
          measure_theory.lebesgue_outer
          (@set.Ico.{0} real real.preorder a b))
       (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
          ε))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>156    have := @nnreal.of_real_add_le (b - a - ε) ε,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='nnreal.of_real_add_le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_sub.sub'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='ε'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/nnreal.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 315, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {r p : real}, @has_le.le.{0} nnreal nnreal.has_le (nnreal.of_real (@has_add.add.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring)) r p)) (@has_add.add.{0} nnreal nnreal.has_add (nnreal.of_real r) (nnreal.of_real p))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} [c : has_sub.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nnreal'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a b : real,
ε : nnreal,
ε0 :
  @has_lt.lt.{0} nnreal
    (@preorder.to_has_lt.{0} nnreal
       (@partial_order.to_preorder.{0} nnreal
          (@ordered_comm_monoid.to_partial_order.{0} nnreal
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                   (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
    (@has_zero.zero.{0} nnreal nnreal.has_zero)
    ε,
h :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real) (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
       measure_theory.lebesgue_outer
       (@set.Ico.{0} real real.preorder a b))
    (@lattice.has_top.top.{0} ennreal
       (@lattice.order_top.to_has_top.{0} ennreal
          (@lattice.bounded_lattice.to_order_top.{0} ennreal
             (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))))
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
    (@has_add.add.{0} ennreal
       (@distrib.to_has_add.{0} ennreal
          (@semiring.to_distrib.{0} ennreal
             (@comm_semiring.to_semiring.{0} ennreal
                (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1))))
       (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real) (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
          measure_theory.lebesgue_outer
          (@set.Ico.{0} real real.preorder a b))
       (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
          ε))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a b : real,
ε : nnreal,
ε0 :
  @has_lt.lt.{0} nnreal
    (@preorder.to_has_lt.{0} nnreal
       (@partial_order.to_preorder.{0} nnreal
          (@ordered_comm_monoid.to_partial_order.{0} nnreal
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                   (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
    (@has_zero.zero.{0} nnreal nnreal.has_zero)
    ε,
h :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real) (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
       measure_theory.lebesgue_outer
       (@set.Ico.{0} real real.preorder a b))
    (@lattice.has_top.top.{0} ennreal
       (@lattice.order_top.to_has_top.{0} ennreal
          (@lattice.bounded_lattice.to_order_top.{0} ennreal
             (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))))),
this :
  @has_le.le.{0} nnreal nnreal.has_le
    (nnreal.of_real
       (@has_add.add.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
          (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group)
             (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)
             (@coe.{1 1} nnreal real (@coe_to_lift.{1 1} nnreal real (@coe_base.{1 1} nnreal real nnreal.has_coe)) ε))
          (@coe.{1 1} nnreal real (@coe_to_lift.{1 1} nnreal real (@coe_base.{1 1} nnreal real nnreal.has_coe)) ε)))
    (@has_add.add.{0} nnreal nnreal.has_add
       (nnreal.of_real
          (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group)
             (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)
             (@coe.{1 1} nnreal real (@coe_to_lift.{1 1} nnreal real (@coe_base.{1 1} nnreal real nnreal.has_coe)) ε)))
       (nnreal.of_real
          (@coe.{1 1} nnreal real (@coe_to_lift.{1 1} nnreal real (@coe_base.{1 1} nnreal real nnreal.has_coe)) ε)))
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
    (@has_add.add.{0} ennreal
       (@distrib.to_has_add.{0} ennreal
          (@semiring.to_distrib.{0} ennreal
             (@comm_semiring.to_semiring.{0} ennreal
                (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1))))
       (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real) (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
          measure_theory.lebesgue_outer
          (@set.Ico.{0} real real.preorder a b))
       (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
          ε))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>157    rw [← ennreal.coe_le_coe, ennreal.coe_add, sub_add_cancel, sub_right_comm,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='ennreal.coe_le_coe'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ennreal.coe_add'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='sub_add_cancel'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='sub_right_comm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/ennreal.lean&#x27;, &#x27;line&#x27;: 117, &#x27;column&#x27;: 25}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/ennreal.lean&#x27;, &#x27;line&#x27;: 128, &#x27;column&#x27;: 25}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 330, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/group/basic.lean&#x27;, &#x27;line&#x27;: 227, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {r q : nnreal}, iff (@has_le.le.{0} ennreal (@preorder.to_has_le.{0} ennreal (@partial_order.to_preorder.{0} ennreal (@ordered_comm_monoid.to_partial_order.{0} ennreal (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal ennreal.canonically_ordered_comm_semiring_1))))) (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe)) r) (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe)) q)) (@has_le.le.{0} nnreal nnreal.has_le r q)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {r p : nnreal}, @eq.{1} ennreal (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe)) (@has_add.add.{0} nnreal nnreal.has_add r p)) (@has_add.add.{0} ennreal (@distrib.to_has_add.{0} ennreal (@semiring.to_distrib.{0} ennreal (@comm_semiring.to_semiring.{0} ennreal (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal ennreal.canonically_ordered_comm_semiring_1)))) (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe)) r) (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe)) p))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : add_group.{0} α] (a b : α), @eq.{1} α (@has_add.add.{0} α (@add_semigroup.to_has_add.{0} α (@add_monoid.to_add_semigroup.{0} α (@add_group.to_add_monoid.{0} α _inst_1))) (@has_sub.sub.{0} α (@add_group_has_sub.{0} α _inst_1) a b) b) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : add_comm_group.{0} α] (a b c : α), @eq.{1} α (@has_sub.sub.{0} α (@add_group_has_sub.{0} α (@add_comm_group.to_add_group.{0} α _inst_1)) (@has_sub.sub.{0} α (@add_group_has_sub.{0} α (@add_comm_group.to_add_group.{0} α _inst_1)) a b) c) (@has_sub.sub.{0} α (@add_group_has_sub.{0} α (@add_comm_group.to_add_group.{0} α _inst_1)) (@has_sub.sub.{0} α (@add_group_has_sub.{0} α (@add_comm_group.to_add_group.{0} α _inst_1)) a c) b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a b : real,
ε : nnreal,
ε0 :
  @has_lt.lt.{0} nnreal
    (@preorder.to_has_lt.{0} nnreal
       (@partial_order.to_preorder.{0} nnreal
          (@ordered_comm_monoid.to_partial_order.{0} nnreal
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                   (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
    (@has_zero.zero.{0} nnreal nnreal.has_zero)
    ε,
h :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real) (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
       measure_theory.lebesgue_outer
       (@set.Ico.{0} real real.preorder a b))
    (@lattice.has_top.top.{0} ennreal
       (@lattice.order_top.to_has_top.{0} ennreal
          (@lattice.bounded_lattice.to_order_top.{0} ennreal
             (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))))),
this :
  @has_le.le.{0} nnreal nnreal.has_le
    (nnreal.of_real
       (@has_add.add.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
          (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group)
             (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)
             (@coe.{1 1} nnreal real (@coe_to_lift.{1 1} nnreal real (@coe_base.{1 1} nnreal real nnreal.has_coe)) ε))
          (@coe.{1 1} nnreal real (@coe_to_lift.{1 1} nnreal real (@coe_base.{1 1} nnreal real nnreal.has_coe)) ε)))
    (@has_add.add.{0} nnreal nnreal.has_add
       (nnreal.of_real
          (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group)
             (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)
             (@coe.{1 1} nnreal real (@coe_to_lift.{1 1} nnreal real (@coe_base.{1 1} nnreal real nnreal.has_coe)) ε)))
       (nnreal.of_real
          (@coe.{1 1} nnreal real (@coe_to_lift.{1 1} nnreal real (@coe_base.{1 1} nnreal real nnreal.has_coe)) ε)))
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
    (@has_add.add.{0} ennreal
       (@distrib.to_has_add.{0} ennreal
          (@semiring.to_distrib.{0} ennreal
             (@comm_semiring.to_semiring.{0} ennreal
                (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1))))
       (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real) (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
          measure_theory.lebesgue_outer
          (@set.Ico.{0} real real.preorder a b))
       (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
          ε))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a b : real,
ε : nnreal,
ε0 :
  @has_lt.lt.{0} nnreal
    (@preorder.to_has_lt.{0} nnreal
       (@partial_order.to_preorder.{0} nnreal
          (@ordered_comm_monoid.to_partial_order.{0} nnreal
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                   (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
    (@has_zero.zero.{0} nnreal nnreal.has_zero)
    ε,
h :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real) (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
       measure_theory.lebesgue_outer
       (@set.Ico.{0} real real.preorder a b))
    (@lattice.has_top.top.{0} ennreal
       (@lattice.order_top.to_has_top.{0} ennreal
          (@lattice.bounded_lattice.to_order_top.{0} ennreal
             (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))))),
this :
  @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real
          (@has_add.add.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
             (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group)
                (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)
                (@coe.{1 1} nnreal real (@coe_to_lift.{1 1} nnreal real (@coe_base.{1 1} nnreal real nnreal.has_coe))
                   ε))
             (@coe.{1 1} nnreal real (@coe_to_lift.{1 1} nnreal real (@coe_base.{1 1} nnreal real nnreal.has_coe))
                ε))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (@has_add.add.{0} nnreal nnreal.has_add
          (nnreal.of_real
             (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group)
                (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)
                (@coe.{1 1} nnreal real (@coe_to_lift.{1 1} nnreal real (@coe_base.{1 1} nnreal real nnreal.has_coe))
                   ε)))
          (nnreal.of_real
             (@coe.{1 1} nnreal real (@coe_to_lift.{1 1} nnreal real (@coe_base.{1 1} nnreal real nnreal.has_coe))
                ε))))
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
    (@has_add.add.{0} ennreal
       (@distrib.to_has_add.{0} ennreal
          (@semiring.to_distrib.{0} ennreal
             (@comm_semiring.to_semiring.{0} ennreal
                (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1))))
       (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real) (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
          measure_theory.lebesgue_outer
          (@set.Ico.{0} real real.preorder a b))
       (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
          ε))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a b : real,
ε : nnreal,
ε0 :
  @has_lt.lt.{0} nnreal
    (@preorder.to_has_lt.{0} nnreal
       (@partial_order.to_preorder.{0} nnreal
          (@ordered_comm_monoid.to_partial_order.{0} nnreal
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                   (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
    (@has_zero.zero.{0} nnreal nnreal.has_zero)
    ε,
h :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real) (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
       measure_theory.lebesgue_outer
       (@set.Ico.{0} real real.preorder a b))
    (@lattice.has_top.top.{0} ennreal
       (@lattice.order_top.to_has_top.{0} ennreal
          (@lattice.bounded_lattice.to_order_top.{0} ennreal
             (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))))),
this :
  @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real
          (@has_add.add.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
             (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group)
                (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)
                (@coe.{1 1} nnreal real (@coe_to_lift.{1 1} nnreal real (@coe_base.{1 1} nnreal real nnreal.has_coe))
                   ε))
             (@coe.{1 1} nnreal real (@coe_to_lift.{1 1} nnreal real (@coe_base.{1 1} nnreal real nnreal.has_coe))
                ε))))
    (@has_add.add.{0} ennreal
       (@distrib.to_has_add.{0} ennreal
          (@semiring.to_distrib.{0} ennreal
             (@comm_semiring.to_semiring.{0} ennreal
                (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1))))
       (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
          (nnreal.of_real
             (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group)
                (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)
                (@coe.{1 1} nnreal real (@coe_to_lift.{1 1} nnreal real (@coe_base.{1 1} nnreal real nnreal.has_coe))
                   ε))))
       (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
          (nnreal.of_real
             (@coe.{1 1} nnreal real (@coe_to_lift.{1 1} nnreal real (@coe_base.{1 1} nnreal real nnreal.has_coe))
                ε))))
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
    (@has_add.add.{0} ennreal
       (@distrib.to_has_add.{0} ennreal
          (@semiring.to_distrib.{0} ennreal
             (@comm_semiring.to_semiring.{0} ennreal
                (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1))))
       (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real) (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
          measure_theory.lebesgue_outer
          (@set.Ico.{0} real real.preorder a b))
       (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
          ε))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a b : real,
ε : nnreal,
ε0 :
  @has_lt.lt.{0} nnreal
    (@preorder.to_has_lt.{0} nnreal
       (@partial_order.to_preorder.{0} nnreal
          (@ordered_comm_monoid.to_partial_order.{0} nnreal
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                   (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
    (@has_zero.zero.{0} nnreal nnreal.has_zero)
    ε,
h :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real) (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
       measure_theory.lebesgue_outer
       (@set.Ico.{0} real real.preorder a b))
    (@lattice.has_top.top.{0} ennreal
       (@lattice.order_top.to_has_top.{0} ennreal
          (@lattice.bounded_lattice.to_order_top.{0} ennreal
             (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))))),
this :
  @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
    (@has_add.add.{0} ennreal
       (@distrib.to_has_add.{0} ennreal
          (@semiring.to_distrib.{0} ennreal
             (@comm_semiring.to_semiring.{0} ennreal
                (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1))))
       (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
          (nnreal.of_real
             (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group)
                (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)
                (@coe.{1 1} nnreal real (@coe_to_lift.{1 1} nnreal real (@coe_base.{1 1} nnreal real nnreal.has_coe))
                   ε))))
       (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
          (nnreal.of_real
             (@coe.{1 1} nnreal real (@coe_to_lift.{1 1} nnreal real (@coe_base.{1 1} nnreal real nnreal.has_coe))
                ε))))
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
    (@has_add.add.{0} ennreal
       (@distrib.to_has_add.{0} ennreal
          (@semiring.to_distrib.{0} ennreal
             (@comm_semiring.to_semiring.{0} ennreal
                (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1))))
       (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real) (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
          measure_theory.lebesgue_outer
          (@set.Ico.{0} real real.preorder a b))
       (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
          ε))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a b : real,
ε : nnreal,
ε0 :
  @has_lt.lt.{0} nnreal
    (@preorder.to_has_lt.{0} nnreal
       (@partial_order.to_preorder.{0} nnreal
          (@ordered_comm_monoid.to_partial_order.{0} nnreal
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                   (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
    (@has_zero.zero.{0} nnreal nnreal.has_zero)
    ε,
h :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real) (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
       measure_theory.lebesgue_outer
       (@set.Ico.{0} real real.preorder a b))
    (@lattice.has_top.top.{0} ennreal
       (@lattice.order_top.to_has_top.{0} ennreal
          (@lattice.bounded_lattice.to_order_top.{0} ennreal
             (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))))),
this :
  @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
    (@has_add.add.{0} ennreal
       (@distrib.to_has_add.{0} ennreal
          (@semiring.to_distrib.{0} ennreal
             (@comm_semiring.to_semiring.{0} ennreal
                (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1))))
       (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
          (nnreal.of_real
             (@has_sub.sub.{0} real
                (@add_group_has_sub.{0} real (@add_comm_group.to_add_group.{0} real real.add_comm_group))
                (@has_sub.sub.{0} real
                   (@add_group_has_sub.{0} real (@add_comm_group.to_add_group.{0} real real.add_comm_group))
                   b
                   (@coe.{1 1} nnreal real (@coe_to_lift.{1 1} nnreal real (@coe_base.{1 1} nnreal real nnreal.has_coe))
                      ε))
                a)))
       (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
          (nnreal.of_real
             (@coe.{1 1} nnreal real (@coe_to_lift.{1 1} nnreal real (@coe_base.{1 1} nnreal real nnreal.has_coe))
                ε))))
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
    (@has_add.add.{0} ennreal
       (@distrib.to_has_add.{0} ennreal
          (@semiring.to_distrib.{0} ennreal
             (@comm_semiring.to_semiring.{0} ennreal
                (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1))))
       (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real) (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
          measure_theory.lebesgue_outer
          (@set.Ico.{0} real real.preorder a b))
       (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
          ε))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>158      ← lebesgue_outer_Icc a (b-ε), nnreal.of_real_coe] at this,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='measure_theory.lebesgue_outer_Icc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ε'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='nnreal.of_real_coe'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 126, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/nnreal.lean&#x27;, &#x27;line&#x27;: 124, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (a b : real), @eq.{1} ennreal (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real) (@measure_theory.outer_measure.has_coe_to_fun.{0} real) measure_theory.lebesgue_outer (@set.Icc.{0} real real.preorder a b)) (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe)) (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nnreal'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {r : nnreal}, @eq.{1} nnreal (nnreal.of_real (@coe.{1 1} nnreal real (@coe_to_lift.{1 1} nnreal real (@coe_base.{1 1} nnreal real nnreal.has_coe)) r)) r'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a b : real,
ε : nnreal,
ε0 :
  @has_lt.lt.{0} nnreal
    (@preorder.to_has_lt.{0} nnreal
       (@partial_order.to_preorder.{0} nnreal
          (@ordered_comm_monoid.to_partial_order.{0} nnreal
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                   (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
    (@has_zero.zero.{0} nnreal nnreal.has_zero)
    ε,
h :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real) (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
       measure_theory.lebesgue_outer
       (@set.Ico.{0} real real.preorder a b))
    (@lattice.has_top.top.{0} ennreal
       (@lattice.order_top.to_has_top.{0} ennreal
          (@lattice.bounded_lattice.to_order_top.{0} ennreal
             (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))))),
this :
  @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
    (@has_add.add.{0} ennreal
       (@distrib.to_has_add.{0} ennreal
          (@semiring.to_distrib.{0} ennreal
             (@comm_semiring.to_semiring.{0} ennreal
                (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1))))
       (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
          (nnreal.of_real
             (@has_sub.sub.{0} real
                (@add_group_has_sub.{0} real (@add_comm_group.to_add_group.{0} real real.add_comm_group))
                (@has_sub.sub.{0} real
                   (@add_group_has_sub.{0} real (@add_comm_group.to_add_group.{0} real real.add_comm_group))
                   b
                   (@coe.{1 1} nnreal real (@coe_to_lift.{1 1} nnreal real (@coe_base.{1 1} nnreal real nnreal.has_coe))
                      ε))
                a)))
       (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
          (nnreal.of_real
             (@coe.{1 1} nnreal real (@coe_to_lift.{1 1} nnreal real (@coe_base.{1 1} nnreal real nnreal.has_coe))
                ε))))
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
    (@has_add.add.{0} ennreal
       (@distrib.to_has_add.{0} ennreal
          (@semiring.to_distrib.{0} ennreal
             (@comm_semiring.to_semiring.{0} ennreal
                (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1))))
       (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real) (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
          measure_theory.lebesgue_outer
          (@set.Ico.{0} real real.preorder a b))
       (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
          ε))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a b : real,
ε : nnreal,
ε0 :
  @has_lt.lt.{0} nnreal
    (@preorder.to_has_lt.{0} nnreal
       (@partial_order.to_preorder.{0} nnreal
          (@ordered_comm_monoid.to_partial_order.{0} nnreal
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                   (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
    (@has_zero.zero.{0} nnreal nnreal.has_zero)
    ε,
h :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real) (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
       measure_theory.lebesgue_outer
       (@set.Ico.{0} real real.preorder a b))
    (@lattice.has_top.top.{0} ennreal
       (@lattice.order_top.to_has_top.{0} ennreal
          (@lattice.bounded_lattice.to_order_top.{0} ennreal
             (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))))),
this :
  @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
    (@has_add.add.{0} ennreal
       (@distrib.to_has_add.{0} ennreal
          (@semiring.to_distrib.{0} ennreal
             (@comm_semiring.to_semiring.{0} ennreal
                (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1))))
       (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real) (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
          measure_theory.lebesgue_outer
          (@set.Icc.{0} real real.preorder a
             (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b
                (@coe.{1 1} nnreal real (@coe_to_lift.{1 1} nnreal real (@coe_base.{1 1} nnreal real nnreal.has_coe))
                   ε))))
       (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
          (nnreal.of_real
             (@coe.{1 1} nnreal real (@coe_to_lift.{1 1} nnreal real (@coe_base.{1 1} nnreal real nnreal.has_coe))
                ε))))
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
    (@has_add.add.{0} ennreal
       (@distrib.to_has_add.{0} ennreal
          (@semiring.to_distrib.{0} ennreal
             (@comm_semiring.to_semiring.{0} ennreal
                (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1))))
       (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real) (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
          measure_theory.lebesgue_outer
          (@set.Ico.{0} real real.preorder a b))
       (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
          ε))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a b : real,
ε : nnreal,
ε0 :
  @has_lt.lt.{0} nnreal
    (@preorder.to_has_lt.{0} nnreal
       (@partial_order.to_preorder.{0} nnreal
          (@ordered_comm_monoid.to_partial_order.{0} nnreal
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                   (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
    (@has_zero.zero.{0} nnreal nnreal.has_zero)
    ε,
h :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real) (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
       measure_theory.lebesgue_outer
       (@set.Ico.{0} real real.preorder a b))
    (@lattice.has_top.top.{0} ennreal
       (@lattice.order_top.to_has_top.{0} ennreal
          (@lattice.bounded_lattice.to_order_top.{0} ennreal
             (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))))),
this :
  @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
    (@has_add.add.{0} ennreal
       (@distrib.to_has_add.{0} ennreal
          (@semiring.to_distrib.{0} ennreal
             (@comm_semiring.to_semiring.{0} ennreal
                (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1))))
       (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real) (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
          measure_theory.lebesgue_outer
          (@set.Icc.{0} real real.preorder a
             (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b
                (@coe.{1 1} nnreal real (@coe_to_lift.{1 1} nnreal real (@coe_base.{1 1} nnreal real nnreal.has_coe))
                   ε))))
       (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
          ε))
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
    (@has_add.add.{0} ennreal
       (@distrib.to_has_add.{0} ennreal
          (@semiring.to_distrib.{0} ennreal
             (@comm_semiring.to_semiring.{0} ennreal
                (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1))))
       (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real) (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
          measure_theory.lebesgue_outer
          (@set.Ico.{0} real real.preorder a b))
       (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
          ε))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a b : real,
ε : nnreal,
ε0 :
  @has_lt.lt.{0} nnreal
    (@preorder.to_has_lt.{0} nnreal
       (@partial_order.to_preorder.{0} nnreal
          (@ordered_comm_monoid.to_partial_order.{0} nnreal
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                   (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
    (@has_zero.zero.{0} nnreal nnreal.has_zero)
    ε,
h :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real) (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
       measure_theory.lebesgue_outer
       (@set.Ico.{0} real real.preorder a b))
    (@lattice.has_top.top.{0} ennreal
       (@lattice.order_top.to_has_top.{0} ennreal
          (@lattice.bounded_lattice.to_order_top.{0} ennreal
             (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))))),
this :
  @has_le.le.{0} nnreal nnreal.has_le
    (nnreal.of_real
       (@has_add.add.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
          (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group)
             (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)
             (@coe.{1 1} nnreal real (@coe_to_lift.{1 1} nnreal real (@coe_base.{1 1} nnreal real nnreal.has_coe)) ε))
          (@coe.{1 1} nnreal real (@coe_to_lift.{1 1} nnreal real (@coe_base.{1 1} nnreal real nnreal.has_coe)) ε)))
    (@has_add.add.{0} nnreal nnreal.has_add
       (nnreal.of_real
          (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group)
             (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)
             (@coe.{1 1} nnreal real (@coe_to_lift.{1 1} nnreal real (@coe_base.{1 1} nnreal real nnreal.has_coe)) ε)))
       (nnreal.of_real
          (@coe.{1 1} nnreal real (@coe_to_lift.{1 1} nnreal real (@coe_base.{1 1} nnreal real nnreal.has_coe)) ε)))
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
    (@has_add.add.{0} ennreal
       (@distrib.to_has_add.{0} ennreal
          (@semiring.to_distrib.{0} ennreal
             (@comm_semiring.to_semiring.{0} ennreal
                (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1))))
       (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real) (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
          measure_theory.lebesgue_outer
          (@set.Ico.{0} real real.preorder a b))
       (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
          ε))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a b : real,
ε : nnreal,
ε0 :
  @has_lt.lt.{0} nnreal
    (@preorder.to_has_lt.{0} nnreal
       (@partial_order.to_preorder.{0} nnreal
          (@ordered_comm_monoid.to_partial_order.{0} nnreal
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                   (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
    (@has_zero.zero.{0} nnreal nnreal.has_zero)
    ε,
h :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real) (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
       measure_theory.lebesgue_outer
       (@set.Ico.{0} real real.preorder a b))
    (@lattice.has_top.top.{0} ennreal
       (@lattice.order_top.to_has_top.{0} ennreal
          (@lattice.bounded_lattice.to_order_top.{0} ennreal
             (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))))),
this :
  @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
    (@has_add.add.{0} ennreal
       (@distrib.to_has_add.{0} ennreal
          (@semiring.to_distrib.{0} ennreal
             (@comm_semiring.to_semiring.{0} ennreal
                (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1))))
       (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real) (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
          measure_theory.lebesgue_outer
          (@set.Icc.{0} real real.preorder a
             (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b
                (@coe.{1 1} nnreal real (@coe_to_lift.{1 1} nnreal real (@coe_base.{1 1} nnreal real nnreal.has_coe))
                   ε))))
       (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
          ε))
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
    (@has_add.add.{0} ennreal
       (@distrib.to_has_add.{0} ennreal
          (@semiring.to_distrib.{0} ennreal
             (@comm_semiring.to_semiring.{0} ennreal
                (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1))))
       (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real) (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
          measure_theory.lebesgue_outer
          (@set.Ico.{0} real real.preorder a b))
       (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
          ε))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>159    exact le_trans this (add_le_add_right&#x27; $ lebesgue_outer.mono $</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='le_trans'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='add_le_add_right&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='measure_theory.lebesgue_outer'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 33, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/ordered_group.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/outer_measure.lean&#x27;, &#x27;line&#x27;: 87, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : preorder.{0} α] {a b c : α}, @has_le.le.{0} α (@preorder.to_has_le.{0} α _inst_1) a b → @has_le.le.{0} α (@preorder.to_has_le.{0} α _inst_1) b c → @has_le.le.{0} α (@preorder.to_has_le.{0} α _inst_1) a c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_le.le.{0} ennreal (@preorder.to_has_le.{0} ennreal (@partial_order.to_preorder.{0} ennreal (@ordered_comm_monoid.to_partial_order.{0} ennreal (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal ennreal.canonically_ordered_comm_semiring_1))))) (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe)) (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a))) (@has_add.add.{0} ennreal (@distrib.to_has_add.{0} ennreal (@semiring.to_distrib.{0} ennreal (@comm_semiring.to_semiring.{0} ennreal (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal ennreal.canonically_ordered_comm_semiring_1)))) (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real) (@measure_theory.outer_measure.has_coe_to_fun.{0} real) measure_theory.lebesgue_outer (@set.Icc.{0} real real.preorder a (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b (@coe.{1 1} nnreal real (@coe_to_lift.{1 1} nnreal real (@coe_base.{1 1} nnreal real nnreal.has_coe)) ε)))) (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe)) ε))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type} [_inst_1 : ordered_comm_monoid.{0} α] {a b c : α}, @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@ordered_comm_monoid.to_partial_order.{0} α _inst_1))) a b → @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@ordered_comm_monoid.to_partial_order.{0} α _inst_1))) (@has_add.add.{0} α (@add_semigroup.to_has_add.{0} α (@add_monoid.to_add_semigroup.{0} α (@add_comm_monoid.to_add_monoid.{0} α (@ordered_comm_monoid.to_add_comm_monoid.{0} α _inst_1)))) a c) (@has_add.add.{0} α (@add_semigroup.to_has_add.{0} α (@add_monoid.to_add_semigroup.{0} α (@add_comm_monoid.to_add_monoid.{0} α (@ordered_comm_monoid.to_add_comm_monoid.{0} α _inst_1)))) b c)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='measure_theory.outer_measure.{0} real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The Lebesgue outer measure, as an outer measure of ℝ.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a b : real,
ε : nnreal,
ε0 :
  @has_lt.lt.{0} nnreal
    (@preorder.to_has_lt.{0} nnreal
       (@partial_order.to_preorder.{0} nnreal
          (@ordered_comm_monoid.to_partial_order.{0} nnreal
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                   (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
    (@has_zero.zero.{0} nnreal nnreal.has_zero)
    ε,
h :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real) (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
       measure_theory.lebesgue_outer
       (@set.Ico.{0} real real.preorder a b))
    (@lattice.has_top.top.{0} ennreal
       (@lattice.order_top.to_has_top.{0} ennreal
          (@lattice.bounded_lattice.to_order_top.{0} ennreal
             (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))))),
this :
  @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
    (@has_add.add.{0} ennreal
       (@distrib.to_has_add.{0} ennreal
          (@semiring.to_distrib.{0} ennreal
             (@comm_semiring.to_semiring.{0} ennreal
                (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1))))
       (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real) (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
          measure_theory.lebesgue_outer
          (@set.Icc.{0} real real.preorder a
             (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b
                (@coe.{1 1} nnreal real (@coe_to_lift.{1 1} nnreal real (@coe_base.{1 1} nnreal real nnreal.has_coe))
                   ε))))
       (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
          ε))
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
    (@has_add.add.{0} ennreal
       (@distrib.to_has_add.{0} ennreal
          (@semiring.to_distrib.{0} ennreal
             (@comm_semiring.to_semiring.{0} ennreal
                (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1))))
       (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real) (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
          measure_theory.lebesgue_outer
          (@set.Ico.{0} real real.preorder a b))
       (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
          ε))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>160      Icc_subset_Ico_right $ (sub_lt_self_iff _).2 ε0)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='set.Icc_subset_Ico_right'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='sub_lt_self_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='ε0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/intervals/basic.lean&#x27;, &#x27;line&#x27;: 181, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/ordered_group.lean&#x27;, &#x27;line&#x27;: 661, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : preorder.{0} α] {a b₁ b₂ : α}, @has_lt.lt.{0} α (@preorder.to_has_lt.{0} α _inst_1) b₁ b₂ → @has_subset.subset.{0} (set.{0} α) (@set.has_subset.{0} α) (@set.Icc.{0} α _inst_1 a b₁) (@set.Ico.{0} α _inst_1 a b₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type} [_inst_1 : ordered_comm_group.{0} α] (a : α) {b : α}, iff (@has_lt.lt.{0} α (@preorder.to_has_lt.{0} α (@partial_order.to_preorder.{0} α (@ordered_comm_monoid.to_partial_order.{0} α (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} α (@ordered_comm_group.to_ordered_cancel_comm_monoid.{0} α _inst_1))))) (@has_sub.sub.{0} α (@add_group_has_sub.{0} α (@add_comm_group.to_add_group.{0} α (@ordered_comm_group.to_add_comm_group.{0} α _inst_1))) a b) a) (@has_lt.lt.{0} α (@preorder.to_has_lt.{0} α (@partial_order.to_preorder.{0} α (@ordered_comm_monoid.to_partial_order.{0} α (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} α (@ordered_comm_group.to_ordered_cancel_comm_monoid.{0} α _inst_1))))) (@has_zero.zero.{0} α (@add_monoid.to_has_zero.{0} α (@add_group.to_add_monoid.{0} α (@add_comm_group.to_add_group.{0} α (@ordered_comm_group.to_add_comm_group.{0} α _inst_1))))) b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_lt.lt.{0} nnreal (@preorder.to_has_lt.{0} nnreal (@partial_order.to_preorder.{0} nnreal (@ordered_comm_monoid.to_partial_order.{0} nnreal (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring)))))) (@has_zero.zero.{0} nnreal nnreal.has_zero) ε'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a b : real,
ε : nnreal,
ε0 :
  @has_lt.lt.{0} nnreal
    (@preorder.to_has_lt.{0} nnreal
       (@partial_order.to_preorder.{0} nnreal
          (@ordered_comm_monoid.to_partial_order.{0} nnreal
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                   (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
    (@has_zero.zero.{0} nnreal nnreal.has_zero)
    ε,
h :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real) (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
       measure_theory.lebesgue_outer
       (@set.Ico.{0} real real.preorder a b))
    (@lattice.has_top.top.{0} ennreal
       (@lattice.order_top.to_has_top.{0} ennreal
          (@lattice.bounded_lattice.to_order_top.{0} ennreal
             (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))))),
this :
  @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
    (@has_add.add.{0} ennreal
       (@distrib.to_has_add.{0} ennreal
          (@semiring.to_distrib.{0} ennreal
             (@comm_semiring.to_semiring.{0} ennreal
                (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1))))
       (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real) (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
          measure_theory.lebesgue_outer
          (@set.Icc.{0} real real.preorder a
             (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b
                (@coe.{1 1} nnreal real (@coe_to_lift.{1 1} nnreal real (@coe_base.{1 1} nnreal real nnreal.has_coe))
                   ε))))
       (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
          ε))
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
    (@has_add.add.{0} ennreal
       (@distrib.to_has_add.{0} ennreal
          (@semiring.to_distrib.{0} ennreal
             (@comm_semiring.to_semiring.{0} ennreal
                (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1))))
       (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real) (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
          measure_theory.lebesgue_outer
          (@set.Ico.{0} real real.preorder a b))
       (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
          ε))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>161  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>162  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>163  @[simp] lemma lebesgue_outer_Ioo (a b : ℝ) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='blue'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/basic.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>164    lebesgue_outer (Ioo a b) = of_real (b - a) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='measure_theory.lebesgue_outer'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.Ioo'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='nnreal.of_real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_sub.sub'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 87, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/intervals/basic.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/nnreal.lean&#x27;, &#x27;line&#x27;: 32, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 315, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='measure_theory.outer_measure.{0} real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [_inst_1 : preorder.{u} α], α → α → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real → nnreal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_sub.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The Lebesgue outer measure, as an outer measure of ℝ.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Left-open right-open interval'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>165  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a b : real
⊢ @eq.{1} ennreal
    (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real) (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
       measure_theory.lebesgue_outer
       (@set.Ioo.{0} real real.preorder a b))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>166    refine le_antisymm (by rw ← lebesgue_length_Ioo; apply lebesgue_outer_le_length)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='le_antisymm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='measure_theory.lebesgue_length_Ioo'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='measure_theory.lebesgue_outer_le_length'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 45, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 50, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 90, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : partial_order.{0} α] {a b : α}, @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α _inst_1)) a b → @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α _inst_1)) b a → @eq.{1} α a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (a b : real), @eq.{1} ennreal (measure_theory.lebesgue_length (@set.Ioo.{0} real real.preorder a b)) (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe)) (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (s : set.{0} real), @has_le.le.{0} ennreal (@preorder.to_has_le.{0} ennreal (@partial_order.to_preorder.{0} ennreal (@ordered_comm_monoid.to_partial_order.{0} ennreal (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal ennreal.canonically_ordered_comm_semiring_1))))) (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real) (@measure_theory.outer_measure.has_coe_to_fun.{0} real) measure_theory.lebesgue_outer s) (measure_theory.lebesgue_length s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a b : real
⊢ @eq.{1} ennreal
    (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real) (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
       measure_theory.lebesgue_outer
       (@set.Ioo.{0} real real.preorder a b))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a b : real
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real) (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
       measure_theory.lebesgue_outer
       (@set.Ioo.{0} real real.preorder a b))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a b : real
⊢ @eq.{1} ennreal
    (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real) (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
       measure_theory.lebesgue_outer
       (@set.Ioo.{0} real real.preorder a b))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>167      (ennreal.le_of_forall_epsilon_le $ λ ε ε0 h, _),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='ennreal.le_of_forall_epsilon_le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/ennreal.lean&#x27;, &#x27;line&#x27;: 259, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {a b : ennreal}, (∀ (ε : nnreal), @has_lt.lt.{0} nnreal (@preorder.to_has_lt.{0} nnreal (@partial_order.to_preorder.{0} nnreal (@ordered_comm_monoid.to_partial_order.{0} nnreal (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring)))))) (@has_zero.zero.{0} nnreal nnreal.has_zero) ε → @has_lt.lt.{0} ennreal (@preorder.to_has_lt.{0} ennreal (@partial_order.to_preorder.{0} ennreal (@ordered_comm_monoid.to_partial_order.{0} ennreal (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal ennreal.canonically_ordered_comm_semiring_1))))) b (@lattice.has_top.top.{0} ennreal (@lattice.order_top.to_has_top.{0} ennreal (@lattice.bounded_lattice.to_order_top.{0} ennreal (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))))) → @has_le.le.{0} ennreal (@preorder.to_has_le.{0} ennreal (@partial_order.to_preorder.{0} ennreal (@ordered_comm_monoid.to_partial_order.{0} ennreal (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal ennreal.canonically_ordered_comm_semiring_1))))) a (@has_add.add.{0} ennreal (@distrib.to_has_add.{0} ennreal (@semiring.to_distrib.{0} ennreal (@comm_semiring.to_semiring.{0} ennreal (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal ennreal.canonically_ordered_comm_semiring_1)))) b (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe)) ε))) → @has_le.le.{0} ennreal (@preorder.to_has_le.{0} ennreal (@partial_order.to_preorder.{0} ennreal (@ordered_comm_monoid.to_partial_order.{0} ennreal (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal ennreal.canonically_ordered_comm_semiring_1))))) a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a b : real
⊢ @eq.{1} ennreal
    (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real) (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
       measure_theory.lebesgue_outer
       (@set.Ioo.{0} real real.preorder a b))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a b : real,
ε : nnreal,
ε0 :
  @has_lt.lt.{0} nnreal
    (@preorder.to_has_lt.{0} nnreal
       (@partial_order.to_preorder.{0} nnreal
          (@ordered_comm_monoid.to_partial_order.{0} nnreal
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                   (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
    (@has_zero.zero.{0} nnreal nnreal.has_zero)
    ε,
h :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real) (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
       measure_theory.lebesgue_outer
       (@set.Ioo.{0} real real.preorder a b))
    (@lattice.has_top.top.{0} ennreal
       (@lattice.order_top.to_has_top.{0} ennreal
          (@lattice.bounded_lattice.to_order_top.{0} ennreal
             (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))))
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
    (@has_add.add.{0} ennreal
       (@distrib.to_has_add.{0} ennreal
          (@semiring.to_distrib.{0} ennreal
             (@comm_semiring.to_semiring.{0} ennreal
                (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1))))
       (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real) (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
          measure_theory.lebesgue_outer
          (@set.Ioo.{0} real real.preorder a b))
       (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
          ε))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>168    have := @nnreal.of_real_add_le (b - a - ε) ε,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='nnreal.of_real_add_le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_sub.sub'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='ε'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/nnreal.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 315, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {r p : real}, @has_le.le.{0} nnreal nnreal.has_le (nnreal.of_real (@has_add.add.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring)) r p)) (@has_add.add.{0} nnreal nnreal.has_add (nnreal.of_real r) (nnreal.of_real p))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} [c : has_sub.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nnreal'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a b : real,
ε : nnreal,
ε0 :
  @has_lt.lt.{0} nnreal
    (@preorder.to_has_lt.{0} nnreal
       (@partial_order.to_preorder.{0} nnreal
          (@ordered_comm_monoid.to_partial_order.{0} nnreal
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                   (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
    (@has_zero.zero.{0} nnreal nnreal.has_zero)
    ε,
h :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real) (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
       measure_theory.lebesgue_outer
       (@set.Ioo.{0} real real.preorder a b))
    (@lattice.has_top.top.{0} ennreal
       (@lattice.order_top.to_has_top.{0} ennreal
          (@lattice.bounded_lattice.to_order_top.{0} ennreal
             (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))))
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
    (@has_add.add.{0} ennreal
       (@distrib.to_has_add.{0} ennreal
          (@semiring.to_distrib.{0} ennreal
             (@comm_semiring.to_semiring.{0} ennreal
                (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1))))
       (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real) (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
          measure_theory.lebesgue_outer
          (@set.Ioo.{0} real real.preorder a b))
       (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
          ε))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a b : real,
ε : nnreal,
ε0 :
  @has_lt.lt.{0} nnreal
    (@preorder.to_has_lt.{0} nnreal
       (@partial_order.to_preorder.{0} nnreal
          (@ordered_comm_monoid.to_partial_order.{0} nnreal
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                   (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
    (@has_zero.zero.{0} nnreal nnreal.has_zero)
    ε,
h :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real) (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
       measure_theory.lebesgue_outer
       (@set.Ioo.{0} real real.preorder a b))
    (@lattice.has_top.top.{0} ennreal
       (@lattice.order_top.to_has_top.{0} ennreal
          (@lattice.bounded_lattice.to_order_top.{0} ennreal
             (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))))),
this :
  @has_le.le.{0} nnreal nnreal.has_le
    (nnreal.of_real
       (@has_add.add.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
          (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group)
             (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)
             (@coe.{1 1} nnreal real (@coe_to_lift.{1 1} nnreal real (@coe_base.{1 1} nnreal real nnreal.has_coe)) ε))
          (@coe.{1 1} nnreal real (@coe_to_lift.{1 1} nnreal real (@coe_base.{1 1} nnreal real nnreal.has_coe)) ε)))
    (@has_add.add.{0} nnreal nnreal.has_add
       (nnreal.of_real
          (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group)
             (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)
             (@coe.{1 1} nnreal real (@coe_to_lift.{1 1} nnreal real (@coe_base.{1 1} nnreal real nnreal.has_coe)) ε)))
       (nnreal.of_real
          (@coe.{1 1} nnreal real (@coe_to_lift.{1 1} nnreal real (@coe_base.{1 1} nnreal real nnreal.has_coe)) ε)))
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
    (@has_add.add.{0} ennreal
       (@distrib.to_has_add.{0} ennreal
          (@semiring.to_distrib.{0} ennreal
             (@comm_semiring.to_semiring.{0} ennreal
                (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1))))
       (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real) (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
          measure_theory.lebesgue_outer
          (@set.Ioo.{0} real real.preorder a b))
       (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
          ε))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>169    rw [← ennreal.coe_le_coe, ennreal.coe_add, sub_add_cancel, sub_sub,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='ennreal.coe_le_coe'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ennreal.coe_add'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='sub_add_cancel'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='sub_sub'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/ennreal.lean&#x27;, &#x27;line&#x27;: 117, &#x27;column&#x27;: 25}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/ennreal.lean&#x27;, &#x27;line&#x27;: 128, &#x27;column&#x27;: 25}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 330, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 399, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {r q : nnreal}, iff (@has_le.le.{0} ennreal (@preorder.to_has_le.{0} ennreal (@partial_order.to_preorder.{0} ennreal (@ordered_comm_monoid.to_partial_order.{0} ennreal (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal ennreal.canonically_ordered_comm_semiring_1))))) (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe)) r) (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe)) q)) (@has_le.le.{0} nnreal nnreal.has_le r q)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {r p : nnreal}, @eq.{1} ennreal (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe)) (@has_add.add.{0} nnreal nnreal.has_add r p)) (@has_add.add.{0} ennreal (@distrib.to_has_add.{0} ennreal (@semiring.to_distrib.{0} ennreal (@comm_semiring.to_semiring.{0} ennreal (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal ennreal.canonically_ordered_comm_semiring_1)))) (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe)) r) (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe)) p))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : add_group.{0} α] (a b : α), @eq.{1} α (@has_add.add.{0} α (@add_semigroup.to_has_add.{0} α (@add_monoid.to_add_semigroup.{0} α (@add_group.to_add_monoid.{0} α _inst_1))) (@has_sub.sub.{0} α (@add_group_has_sub.{0} α _inst_1) a b) b) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : add_comm_group.{0} α] (a b c : α), @eq.{1} α (@has_sub.sub.{0} α (@add_group_has_sub.{0} α (@add_comm_group.to_add_group.{0} α _inst_1)) (@has_sub.sub.{0} α (@add_group_has_sub.{0} α (@add_comm_group.to_add_group.{0} α _inst_1)) a b) c) (@has_sub.sub.{0} α (@add_group_has_sub.{0} α (@add_comm_group.to_add_group.{0} α _inst_1)) a (@has_add.add.{0} α (@add_semigroup.to_has_add.{0} α (@add_monoid.to_add_semigroup.{0} α (@add_group.to_add_monoid.{0} α (@add_comm_group.to_add_group.{0} α _inst_1)))) b c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a b : real,
ε : nnreal,
ε0 :
  @has_lt.lt.{0} nnreal
    (@preorder.to_has_lt.{0} nnreal
       (@partial_order.to_preorder.{0} nnreal
          (@ordered_comm_monoid.to_partial_order.{0} nnreal
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                   (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
    (@has_zero.zero.{0} nnreal nnreal.has_zero)
    ε,
h :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real) (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
       measure_theory.lebesgue_outer
       (@set.Ioo.{0} real real.preorder a b))
    (@lattice.has_top.top.{0} ennreal
       (@lattice.order_top.to_has_top.{0} ennreal
          (@lattice.bounded_lattice.to_order_top.{0} ennreal
             (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))))),
this :
  @has_le.le.{0} nnreal nnreal.has_le
    (nnreal.of_real
       (@has_add.add.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
          (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group)
             (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)
             (@coe.{1 1} nnreal real (@coe_to_lift.{1 1} nnreal real (@coe_base.{1 1} nnreal real nnreal.has_coe)) ε))
          (@coe.{1 1} nnreal real (@coe_to_lift.{1 1} nnreal real (@coe_base.{1 1} nnreal real nnreal.has_coe)) ε)))
    (@has_add.add.{0} nnreal nnreal.has_add
       (nnreal.of_real
          (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group)
             (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)
             (@coe.{1 1} nnreal real (@coe_to_lift.{1 1} nnreal real (@coe_base.{1 1} nnreal real nnreal.has_coe)) ε)))
       (nnreal.of_real
          (@coe.{1 1} nnreal real (@coe_to_lift.{1 1} nnreal real (@coe_base.{1 1} nnreal real nnreal.has_coe)) ε)))
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
    (@has_add.add.{0} ennreal
       (@distrib.to_has_add.{0} ennreal
          (@semiring.to_distrib.{0} ennreal
             (@comm_semiring.to_semiring.{0} ennreal
                (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1))))
       (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real) (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
          measure_theory.lebesgue_outer
          (@set.Ioo.{0} real real.preorder a b))
       (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
          ε))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a b : real,
ε : nnreal,
ε0 :
  @has_lt.lt.{0} nnreal
    (@preorder.to_has_lt.{0} nnreal
       (@partial_order.to_preorder.{0} nnreal
          (@ordered_comm_monoid.to_partial_order.{0} nnreal
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                   (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
    (@has_zero.zero.{0} nnreal nnreal.has_zero)
    ε,
h :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real) (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
       measure_theory.lebesgue_outer
       (@set.Ioo.{0} real real.preorder a b))
    (@lattice.has_top.top.{0} ennreal
       (@lattice.order_top.to_has_top.{0} ennreal
          (@lattice.bounded_lattice.to_order_top.{0} ennreal
             (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))))),
this :
  @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real
          (@has_add.add.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
             (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group)
                (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)
                (@coe.{1 1} nnreal real (@coe_to_lift.{1 1} nnreal real (@coe_base.{1 1} nnreal real nnreal.has_coe))
                   ε))
             (@coe.{1 1} nnreal real (@coe_to_lift.{1 1} nnreal real (@coe_base.{1 1} nnreal real nnreal.has_coe))
                ε))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (@has_add.add.{0} nnreal nnreal.has_add
          (nnreal.of_real
             (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group)
                (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)
                (@coe.{1 1} nnreal real (@coe_to_lift.{1 1} nnreal real (@coe_base.{1 1} nnreal real nnreal.has_coe))
                   ε)))
          (nnreal.of_real
             (@coe.{1 1} nnreal real (@coe_to_lift.{1 1} nnreal real (@coe_base.{1 1} nnreal real nnreal.has_coe))
                ε))))
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
    (@has_add.add.{0} ennreal
       (@distrib.to_has_add.{0} ennreal
          (@semiring.to_distrib.{0} ennreal
             (@comm_semiring.to_semiring.{0} ennreal
                (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1))))
       (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real) (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
          measure_theory.lebesgue_outer
          (@set.Ioo.{0} real real.preorder a b))
       (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
          ε))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a b : real,
ε : nnreal,
ε0 :
  @has_lt.lt.{0} nnreal
    (@preorder.to_has_lt.{0} nnreal
       (@partial_order.to_preorder.{0} nnreal
          (@ordered_comm_monoid.to_partial_order.{0} nnreal
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                   (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
    (@has_zero.zero.{0} nnreal nnreal.has_zero)
    ε,
h :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real) (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
       measure_theory.lebesgue_outer
       (@set.Ioo.{0} real real.preorder a b))
    (@lattice.has_top.top.{0} ennreal
       (@lattice.order_top.to_has_top.{0} ennreal
          (@lattice.bounded_lattice.to_order_top.{0} ennreal
             (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))))),
this :
  @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real
          (@has_add.add.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
             (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group)
                (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)
                (@coe.{1 1} nnreal real (@coe_to_lift.{1 1} nnreal real (@coe_base.{1 1} nnreal real nnreal.has_coe))
                   ε))
             (@coe.{1 1} nnreal real (@coe_to_lift.{1 1} nnreal real (@coe_base.{1 1} nnreal real nnreal.has_coe))
                ε))))
    (@has_add.add.{0} ennreal
       (@distrib.to_has_add.{0} ennreal
          (@semiring.to_distrib.{0} ennreal
             (@comm_semiring.to_semiring.{0} ennreal
                (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1))))
       (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
          (nnreal.of_real
             (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group)
                (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)
                (@coe.{1 1} nnreal real (@coe_to_lift.{1 1} nnreal real (@coe_base.{1 1} nnreal real nnreal.has_coe))
                   ε))))
       (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
          (nnreal.of_real
             (@coe.{1 1} nnreal real (@coe_to_lift.{1 1} nnreal real (@coe_base.{1 1} nnreal real nnreal.has_coe))
                ε))))
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
    (@has_add.add.{0} ennreal
       (@distrib.to_has_add.{0} ennreal
          (@semiring.to_distrib.{0} ennreal
             (@comm_semiring.to_semiring.{0} ennreal
                (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1))))
       (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real) (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
          measure_theory.lebesgue_outer
          (@set.Ioo.{0} real real.preorder a b))
       (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
          ε))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a b : real,
ε : nnreal,
ε0 :
  @has_lt.lt.{0} nnreal
    (@preorder.to_has_lt.{0} nnreal
       (@partial_order.to_preorder.{0} nnreal
          (@ordered_comm_monoid.to_partial_order.{0} nnreal
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                   (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
    (@has_zero.zero.{0} nnreal nnreal.has_zero)
    ε,
h :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real) (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
       measure_theory.lebesgue_outer
       (@set.Ioo.{0} real real.preorder a b))
    (@lattice.has_top.top.{0} ennreal
       (@lattice.order_top.to_has_top.{0} ennreal
          (@lattice.bounded_lattice.to_order_top.{0} ennreal
             (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))))),
this :
  @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
    (@has_add.add.{0} ennreal
       (@distrib.to_has_add.{0} ennreal
          (@semiring.to_distrib.{0} ennreal
             (@comm_semiring.to_semiring.{0} ennreal
                (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1))))
       (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
          (nnreal.of_real
             (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group)
                (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)
                (@coe.{1 1} nnreal real (@coe_to_lift.{1 1} nnreal real (@coe_base.{1 1} nnreal real nnreal.has_coe))
                   ε))))
       (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
          (nnreal.of_real
             (@coe.{1 1} nnreal real (@coe_to_lift.{1 1} nnreal real (@coe_base.{1 1} nnreal real nnreal.has_coe))
                ε))))
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
    (@has_add.add.{0} ennreal
       (@distrib.to_has_add.{0} ennreal
          (@semiring.to_distrib.{0} ennreal
             (@comm_semiring.to_semiring.{0} ennreal
                (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1))))
       (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real) (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
          measure_theory.lebesgue_outer
          (@set.Ioo.{0} real real.preorder a b))
       (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
          ε))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a b : real,
ε : nnreal,
ε0 :
  @has_lt.lt.{0} nnreal
    (@preorder.to_has_lt.{0} nnreal
       (@partial_order.to_preorder.{0} nnreal
          (@ordered_comm_monoid.to_partial_order.{0} nnreal
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                   (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
    (@has_zero.zero.{0} nnreal nnreal.has_zero)
    ε,
h :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real) (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
       measure_theory.lebesgue_outer
       (@set.Ioo.{0} real real.preorder a b))
    (@lattice.has_top.top.{0} ennreal
       (@lattice.order_top.to_has_top.{0} ennreal
          (@lattice.bounded_lattice.to_order_top.{0} ennreal
             (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))))),
this :
  @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
    (@has_add.add.{0} ennreal
       (@distrib.to_has_add.{0} ennreal
          (@semiring.to_distrib.{0} ennreal
             (@comm_semiring.to_semiring.{0} ennreal
                (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1))))
       (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
          (nnreal.of_real
             (@has_sub.sub.{0} real
                (@add_group_has_sub.{0} real (@add_comm_group.to_add_group.{0} real real.add_comm_group))
                b
                (@has_add.add.{0} real
                   (@add_semigroup.to_has_add.{0} real
                      (@add_monoid.to_add_semigroup.{0} real
                         (@add_group.to_add_monoid.{0} real
                            (@add_comm_group.to_add_group.{0} real real.add_comm_group))))
                   a
                   (@coe.{1 1} nnreal real (@coe_to_lift.{1 1} nnreal real (@coe_base.{1 1} nnreal real nnreal.has_coe))
                      ε)))))
       (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
          (nnreal.of_real
             (@coe.{1 1} nnreal real (@coe_to_lift.{1 1} nnreal real (@coe_base.{1 1} nnreal real nnreal.has_coe))
                ε))))
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
    (@has_add.add.{0} ennreal
       (@distrib.to_has_add.{0} ennreal
          (@semiring.to_distrib.{0} ennreal
             (@comm_semiring.to_semiring.{0} ennreal
                (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1))))
       (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real) (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
          measure_theory.lebesgue_outer
          (@set.Ioo.{0} real real.preorder a b))
       (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
          ε))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>170      ← lebesgue_outer_Ico (a+ε) b, nnreal.of_real_coe] at this,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='measure_theory.lebesgue_outer_Ico'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='ε'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='nnreal.of_real_coe'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 151, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/nnreal.lean&#x27;, &#x27;line&#x27;: 124, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (a b : real), @eq.{1} ennreal (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real) (@measure_theory.outer_measure.has_coe_to_fun.{0} real) measure_theory.lebesgue_outer (@set.Ico.{0} real real.preorder a b)) (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe)) (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} [c : has_add.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nnreal'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {r : nnreal}, @eq.{1} nnreal (nnreal.of_real (@coe.{1 1} nnreal real (@coe_to_lift.{1 1} nnreal real (@coe_base.{1 1} nnreal real nnreal.has_coe)) r)) r'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a b : real,
ε : nnreal,
ε0 :
  @has_lt.lt.{0} nnreal
    (@preorder.to_has_lt.{0} nnreal
       (@partial_order.to_preorder.{0} nnreal
          (@ordered_comm_monoid.to_partial_order.{0} nnreal
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                   (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
    (@has_zero.zero.{0} nnreal nnreal.has_zero)
    ε,
h :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real) (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
       measure_theory.lebesgue_outer
       (@set.Ioo.{0} real real.preorder a b))
    (@lattice.has_top.top.{0} ennreal
       (@lattice.order_top.to_has_top.{0} ennreal
          (@lattice.bounded_lattice.to_order_top.{0} ennreal
             (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))))),
this :
  @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
    (@has_add.add.{0} ennreal
       (@distrib.to_has_add.{0} ennreal
          (@semiring.to_distrib.{0} ennreal
             (@comm_semiring.to_semiring.{0} ennreal
                (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1))))
       (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
          (nnreal.of_real
             (@has_sub.sub.{0} real
                (@add_group_has_sub.{0} real (@add_comm_group.to_add_group.{0} real real.add_comm_group))
                b
                (@has_add.add.{0} real
                   (@add_semigroup.to_has_add.{0} real
                      (@add_monoid.to_add_semigroup.{0} real
                         (@add_group.to_add_monoid.{0} real
                            (@add_comm_group.to_add_group.{0} real real.add_comm_group))))
                   a
                   (@coe.{1 1} nnreal real (@coe_to_lift.{1 1} nnreal real (@coe_base.{1 1} nnreal real nnreal.has_coe))
                      ε)))))
       (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
          (nnreal.of_real
             (@coe.{1 1} nnreal real (@coe_to_lift.{1 1} nnreal real (@coe_base.{1 1} nnreal real nnreal.has_coe))
                ε))))
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
    (@has_add.add.{0} ennreal
       (@distrib.to_has_add.{0} ennreal
          (@semiring.to_distrib.{0} ennreal
             (@comm_semiring.to_semiring.{0} ennreal
                (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1))))
       (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real) (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
          measure_theory.lebesgue_outer
          (@set.Ioo.{0} real real.preorder a b))
       (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
          ε))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a b : real,
ε : nnreal,
ε0 :
  @has_lt.lt.{0} nnreal
    (@preorder.to_has_lt.{0} nnreal
       (@partial_order.to_preorder.{0} nnreal
          (@ordered_comm_monoid.to_partial_order.{0} nnreal
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                   (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
    (@has_zero.zero.{0} nnreal nnreal.has_zero)
    ε,
h :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real) (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
       measure_theory.lebesgue_outer
       (@set.Ioo.{0} real real.preorder a b))
    (@lattice.has_top.top.{0} ennreal
       (@lattice.order_top.to_has_top.{0} ennreal
          (@lattice.bounded_lattice.to_order_top.{0} ennreal
             (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))))),
this :
  @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
    (@has_add.add.{0} ennreal
       (@distrib.to_has_add.{0} ennreal
          (@semiring.to_distrib.{0} ennreal
             (@comm_semiring.to_semiring.{0} ennreal
                (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1))))
       (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real) (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
          measure_theory.lebesgue_outer
          (@set.Ico.{0} real real.preorder
             (@has_add.add.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring)) a
                (@coe.{1 1} nnreal real (@coe_to_lift.{1 1} nnreal real (@coe_base.{1 1} nnreal real nnreal.has_coe))
                   ε))
             b))
       (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
          (nnreal.of_real
             (@coe.{1 1} nnreal real (@coe_to_lift.{1 1} nnreal real (@coe_base.{1 1} nnreal real nnreal.has_coe))
                ε))))
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
    (@has_add.add.{0} ennreal
       (@distrib.to_has_add.{0} ennreal
          (@semiring.to_distrib.{0} ennreal
             (@comm_semiring.to_semiring.{0} ennreal
                (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1))))
       (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real) (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
          measure_theory.lebesgue_outer
          (@set.Ioo.{0} real real.preorder a b))
       (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
          ε))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a b : real,
ε : nnreal,
ε0 :
  @has_lt.lt.{0} nnreal
    (@preorder.to_has_lt.{0} nnreal
       (@partial_order.to_preorder.{0} nnreal
          (@ordered_comm_monoid.to_partial_order.{0} nnreal
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                   (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
    (@has_zero.zero.{0} nnreal nnreal.has_zero)
    ε,
h :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real) (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
       measure_theory.lebesgue_outer
       (@set.Ioo.{0} real real.preorder a b))
    (@lattice.has_top.top.{0} ennreal
       (@lattice.order_top.to_has_top.{0} ennreal
          (@lattice.bounded_lattice.to_order_top.{0} ennreal
             (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))))),
this :
  @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
    (@has_add.add.{0} ennreal
       (@distrib.to_has_add.{0} ennreal
          (@semiring.to_distrib.{0} ennreal
             (@comm_semiring.to_semiring.{0} ennreal
                (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1))))
       (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real) (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
          measure_theory.lebesgue_outer
          (@set.Ico.{0} real real.preorder
             (@has_add.add.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring)) a
                (@coe.{1 1} nnreal real (@coe_to_lift.{1 1} nnreal real (@coe_base.{1 1} nnreal real nnreal.has_coe))
                   ε))
             b))
       (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
          ε))
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
    (@has_add.add.{0} ennreal
       (@distrib.to_has_add.{0} ennreal
          (@semiring.to_distrib.{0} ennreal
             (@comm_semiring.to_semiring.{0} ennreal
                (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1))))
       (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real) (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
          measure_theory.lebesgue_outer
          (@set.Ioo.{0} real real.preorder a b))
       (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
          ε))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a b : real,
ε : nnreal,
ε0 :
  @has_lt.lt.{0} nnreal
    (@preorder.to_has_lt.{0} nnreal
       (@partial_order.to_preorder.{0} nnreal
          (@ordered_comm_monoid.to_partial_order.{0} nnreal
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                   (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
    (@has_zero.zero.{0} nnreal nnreal.has_zero)
    ε,
h :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real) (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
       measure_theory.lebesgue_outer
       (@set.Ioo.{0} real real.preorder a b))
    (@lattice.has_top.top.{0} ennreal
       (@lattice.order_top.to_has_top.{0} ennreal
          (@lattice.bounded_lattice.to_order_top.{0} ennreal
             (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))))),
this :
  @has_le.le.{0} nnreal nnreal.has_le
    (nnreal.of_real
       (@has_add.add.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
          (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group)
             (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)
             (@coe.{1 1} nnreal real (@coe_to_lift.{1 1} nnreal real (@coe_base.{1 1} nnreal real nnreal.has_coe)) ε))
          (@coe.{1 1} nnreal real (@coe_to_lift.{1 1} nnreal real (@coe_base.{1 1} nnreal real nnreal.has_coe)) ε)))
    (@has_add.add.{0} nnreal nnreal.has_add
       (nnreal.of_real
          (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group)
             (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)
             (@coe.{1 1} nnreal real (@coe_to_lift.{1 1} nnreal real (@coe_base.{1 1} nnreal real nnreal.has_coe)) ε)))
       (nnreal.of_real
          (@coe.{1 1} nnreal real (@coe_to_lift.{1 1} nnreal real (@coe_base.{1 1} nnreal real nnreal.has_coe)) ε)))
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
    (@has_add.add.{0} ennreal
       (@distrib.to_has_add.{0} ennreal
          (@semiring.to_distrib.{0} ennreal
             (@comm_semiring.to_semiring.{0} ennreal
                (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1))))
       (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real) (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
          measure_theory.lebesgue_outer
          (@set.Ioo.{0} real real.preorder a b))
       (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
          ε))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a b : real,
ε : nnreal,
ε0 :
  @has_lt.lt.{0} nnreal
    (@preorder.to_has_lt.{0} nnreal
       (@partial_order.to_preorder.{0} nnreal
          (@ordered_comm_monoid.to_partial_order.{0} nnreal
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                   (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
    (@has_zero.zero.{0} nnreal nnreal.has_zero)
    ε,
h :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real) (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
       measure_theory.lebesgue_outer
       (@set.Ioo.{0} real real.preorder a b))
    (@lattice.has_top.top.{0} ennreal
       (@lattice.order_top.to_has_top.{0} ennreal
          (@lattice.bounded_lattice.to_order_top.{0} ennreal
             (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))))),
this :
  @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
    (@has_add.add.{0} ennreal
       (@distrib.to_has_add.{0} ennreal
          (@semiring.to_distrib.{0} ennreal
             (@comm_semiring.to_semiring.{0} ennreal
                (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1))))
       (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real) (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
          measure_theory.lebesgue_outer
          (@set.Ico.{0} real real.preorder
             (@has_add.add.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring)) a
                (@coe.{1 1} nnreal real (@coe_to_lift.{1 1} nnreal real (@coe_base.{1 1} nnreal real nnreal.has_coe))
                   ε))
             b))
       (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
          ε))
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
    (@has_add.add.{0} ennreal
       (@distrib.to_has_add.{0} ennreal
          (@semiring.to_distrib.{0} ennreal
             (@comm_semiring.to_semiring.{0} ennreal
                (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1))))
       (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real) (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
          measure_theory.lebesgue_outer
          (@set.Ioo.{0} real real.preorder a b))
       (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
          ε))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>171    exact le_trans this (add_le_add_right&#x27; $ lebesgue_outer.mono $</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='le_trans'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='add_le_add_right&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='measure_theory.lebesgue_outer'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 33, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/ordered_group.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/outer_measure.lean&#x27;, &#x27;line&#x27;: 87, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : preorder.{0} α] {a b c : α}, @has_le.le.{0} α (@preorder.to_has_le.{0} α _inst_1) a b → @has_le.le.{0} α (@preorder.to_has_le.{0} α _inst_1) b c → @has_le.le.{0} α (@preorder.to_has_le.{0} α _inst_1) a c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_le.le.{0} ennreal (@preorder.to_has_le.{0} ennreal (@partial_order.to_preorder.{0} ennreal (@ordered_comm_monoid.to_partial_order.{0} ennreal (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal ennreal.canonically_ordered_comm_semiring_1))))) (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe)) (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a))) (@has_add.add.{0} ennreal (@distrib.to_has_add.{0} ennreal (@semiring.to_distrib.{0} ennreal (@comm_semiring.to_semiring.{0} ennreal (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal ennreal.canonically_ordered_comm_semiring_1)))) (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real) (@measure_theory.outer_measure.has_coe_to_fun.{0} real) measure_theory.lebesgue_outer (@set.Ico.{0} real real.preorder (@has_add.add.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring)) a (@coe.{1 1} nnreal real (@coe_to_lift.{1 1} nnreal real (@coe_base.{1 1} nnreal real nnreal.has_coe)) ε)) b)) (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe)) ε))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type} [_inst_1 : ordered_comm_monoid.{0} α] {a b c : α}, @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@ordered_comm_monoid.to_partial_order.{0} α _inst_1))) a b → @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@ordered_comm_monoid.to_partial_order.{0} α _inst_1))) (@has_add.add.{0} α (@add_semigroup.to_has_add.{0} α (@add_monoid.to_add_semigroup.{0} α (@add_comm_monoid.to_add_monoid.{0} α (@ordered_comm_monoid.to_add_comm_monoid.{0} α _inst_1)))) a c) (@has_add.add.{0} α (@add_semigroup.to_has_add.{0} α (@add_monoid.to_add_semigroup.{0} α (@add_comm_monoid.to_add_monoid.{0} α (@ordered_comm_monoid.to_add_comm_monoid.{0} α _inst_1)))) b c)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='measure_theory.outer_measure.{0} real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The Lebesgue outer measure, as an outer measure of ℝ.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a b : real,
ε : nnreal,
ε0 :
  @has_lt.lt.{0} nnreal
    (@preorder.to_has_lt.{0} nnreal
       (@partial_order.to_preorder.{0} nnreal
          (@ordered_comm_monoid.to_partial_order.{0} nnreal
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                   (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
    (@has_zero.zero.{0} nnreal nnreal.has_zero)
    ε,
h :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real) (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
       measure_theory.lebesgue_outer
       (@set.Ioo.{0} real real.preorder a b))
    (@lattice.has_top.top.{0} ennreal
       (@lattice.order_top.to_has_top.{0} ennreal
          (@lattice.bounded_lattice.to_order_top.{0} ennreal
             (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))))),
this :
  @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
    (@has_add.add.{0} ennreal
       (@distrib.to_has_add.{0} ennreal
          (@semiring.to_distrib.{0} ennreal
             (@comm_semiring.to_semiring.{0} ennreal
                (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1))))
       (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real) (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
          measure_theory.lebesgue_outer
          (@set.Ico.{0} real real.preorder
             (@has_add.add.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring)) a
                (@coe.{1 1} nnreal real (@coe_to_lift.{1 1} nnreal real (@coe_base.{1 1} nnreal real nnreal.has_coe))
                   ε))
             b))
       (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
          ε))
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
    (@has_add.add.{0} ennreal
       (@distrib.to_has_add.{0} ennreal
          (@semiring.to_distrib.{0} ennreal
             (@comm_semiring.to_semiring.{0} ennreal
                (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1))))
       (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real) (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
          measure_theory.lebesgue_outer
          (@set.Ioo.{0} real real.preorder a b))
       (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
          ε))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>172      Ico_subset_Ioo_left $ (lt_add_iff_pos_right _).2 ε0)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='set.Ico_subset_Ioo_left'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='lt_add_iff_pos_right'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='ε0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/intervals/basic.lean&#x27;, &#x27;line&#x27;: 178, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/ordered_group.lean&#x27;, &#x27;line&#x27;: 428, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : preorder.{0} α] {a₁ a₂ b : α}, @has_lt.lt.{0} α (@preorder.to_has_lt.{0} α _inst_1) a₁ a₂ → @has_subset.subset.{0} (set.{0} α) (@set.has_subset.{0} α) (@set.Ico.{0} α _inst_1 a₂ b) (@set.Ioo.{0} α _inst_1 a₁ b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type} [_inst_1 : ordered_cancel_comm_monoid.{0} α] (a : α) {b : α}, iff (@has_lt.lt.{0} α (@preorder.to_has_lt.{0} α (@partial_order.to_preorder.{0} α (@ordered_comm_monoid.to_partial_order.{0} α (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} α _inst_1)))) a (@has_add.add.{0} α (@add_semigroup.to_has_add.{0} α (@add_monoid.to_add_semigroup.{0} α (@add_comm_monoid.to_add_monoid.{0} α (@ordered_comm_monoid.to_add_comm_monoid.{0} α (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} α _inst_1))))) a b)) (@has_lt.lt.{0} α (@preorder.to_has_lt.{0} α (@partial_order.to_preorder.{0} α (@ordered_comm_monoid.to_partial_order.{0} α (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} α _inst_1)))) (@has_zero.zero.{0} α (@add_monoid.to_has_zero.{0} α (@add_comm_monoid.to_add_monoid.{0} α (@ordered_comm_monoid.to_add_comm_monoid.{0} α (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} α _inst_1))))) b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_lt.lt.{0} nnreal (@preorder.to_has_lt.{0} nnreal (@partial_order.to_preorder.{0} nnreal (@ordered_comm_monoid.to_partial_order.{0} nnreal (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring)))))) (@has_zero.zero.{0} nnreal nnreal.has_zero) ε'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a b : real,
ε : nnreal,
ε0 :
  @has_lt.lt.{0} nnreal
    (@preorder.to_has_lt.{0} nnreal
       (@partial_order.to_preorder.{0} nnreal
          (@ordered_comm_monoid.to_partial_order.{0} nnreal
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                   (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
    (@has_zero.zero.{0} nnreal nnreal.has_zero)
    ε,
h :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real) (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
       measure_theory.lebesgue_outer
       (@set.Ioo.{0} real real.preorder a b))
    (@lattice.has_top.top.{0} ennreal
       (@lattice.order_top.to_has_top.{0} ennreal
          (@lattice.bounded_lattice.to_order_top.{0} ennreal
             (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))))),
this :
  @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
    (@has_add.add.{0} ennreal
       (@distrib.to_has_add.{0} ennreal
          (@semiring.to_distrib.{0} ennreal
             (@comm_semiring.to_semiring.{0} ennreal
                (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1))))
       (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real) (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
          measure_theory.lebesgue_outer
          (@set.Ico.{0} real real.preorder
             (@has_add.add.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring)) a
                (@coe.{1 1} nnreal real (@coe_to_lift.{1 1} nnreal real (@coe_base.{1 1} nnreal real nnreal.has_coe))
                   ε))
             b))
       (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
          ε))
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
    (@has_add.add.{0} ennreal
       (@distrib.to_has_add.{0} ennreal
          (@semiring.to_distrib.{0} ennreal
             (@comm_semiring.to_semiring.{0} ennreal
                (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1))))
       (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real) (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
          measure_theory.lebesgue_outer
          (@set.Ioo.{0} real real.preorder a b))
       (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
          ε))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>173  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>174  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>175  lemma is_lebesgue_measurable_Iio {c : ℝ} :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='blue'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/basic.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>176    lebesgue_outer.caratheodory.is_measurable (Iio c) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='measure_theory.lebesgue_outer'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='measure_theory.outer_measure.caratheodory'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='measurable_space.is_measurable'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.Iio'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 87, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/outer_measure.lean&#x27;, &#x27;line&#x27;: 404, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measurable_space.lean&#x27;, &#x27;line&#x27;: 67, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/intervals/basic.lean&#x27;, &#x27;line&#x27;: 46, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='measure_theory.outer_measure.{0} real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type}, measure_theory.outer_measure.{0} α → measurable_space.{0} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type}, measurable_space.{0} α → set.{0} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [_inst_1 : preorder.{u} α], α → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The Lebesgue outer measure, as an outer measure of ℝ.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Given an outer measure `μ`, the Caratheodory measurable space is
 defined such that `s` is measurable if `∀t, μ t = μ (t ∩ s) + μ (t \ s)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='Left-infinite right-open interval'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>177  outer_measure.caratheodory_is_measurable $ λ t,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='measure_theory.outer_measure.caratheodory_is_measurable'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/outer_measure.lean&#x27;, &#x27;line&#x27;: 424, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} {m : set.{0} α → ennreal} {s : set.{0} α} {h₀ : @eq.{1} ennreal (m (@has_emptyc.emptyc.{0} (set.{0} α) (@set.has_emptyc.{0} α))) (@has_zero.zero.{0} ennreal (@zero_ne_one_class.to_has_zero.{0} ennreal (@canonically_ordered_comm_semiring.to_zero_ne_one_class.{0} ennreal ennreal.canonically_ordered_comm_semiring_1)))}, (∀ (t : set.{0} α), @has_le.le.{0} ennreal (@preorder.to_has_le.{0} ennreal (@partial_order.to_preorder.{0} ennreal (@ordered_comm_monoid.to_partial_order.{0} ennreal (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal ennreal.canonically_ordered_comm_semiring_1))))) (@has_add.add.{0} ennreal (@distrib.to_has_add.{0} ennreal (@semiring.to_distrib.{0} ennreal (@comm_semiring.to_semiring.{0} ennreal (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal ennreal.canonically_ordered_comm_semiring_1)))) (m (@has_inter.inter.{0} (set.{0} α) (@set.has_inter.{0} α) t s)) (m (@has_sdiff.sdiff.{0} (set.{0} α) (@set.has_sdiff.{0} α) t s))) (m t)) → @measurable_space.is_measurable.{0} α (@measure_theory.outer_measure.caratheodory.{0} α (@measure_theory.outer_measure.of_function.{0} α m h₀)) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='set.{0} real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>178  le_infi $ λ a, le_infi $ λ b, le_infi $ λ h, begin</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='lattice.le_infi'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='lattice.le_infi'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='lattice.le_infi'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/complete_lattice.lean&#x27;, &#x27;line&#x27;: 300, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/complete_lattice.lean&#x27;, &#x27;line&#x27;: 300, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/complete_lattice.lean&#x27;, &#x27;line&#x27;: 300, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α ι : Type} [_inst_1 : lattice.complete_lattice.{0} α] {s : ι → α} {a : α}, (∀ (i : ι), @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@lattice.order_bot.to_partial_order.{0} α (@lattice.bounded_lattice.to_order_bot.{0} α (@lattice.complete_lattice.to_bounded_lattice.{0} α _inst_1))))) a (s i)) → @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@lattice.order_bot.to_partial_order.{0} α (@lattice.bounded_lattice.to_order_bot.{0} α (@lattice.complete_lattice.to_bounded_lattice.{0} α _inst_1))))) a (@lattice.infi.{0 1} α ι (@lattice.complete_lattice.to_has_Inf.{0} α _inst_1) s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α ι : Type} [_inst_1 : lattice.complete_lattice.{0} α] {s : ι → α} {a : α}, (∀ (i : ι), @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@lattice.order_bot.to_partial_order.{0} α (@lattice.bounded_lattice.to_order_bot.{0} α (@lattice.complete_lattice.to_bounded_lattice.{0} α _inst_1))))) a (s i)) → @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@lattice.order_bot.to_partial_order.{0} α (@lattice.bounded_lattice.to_order_bot.{0} α (@lattice.complete_lattice.to_bounded_lattice.{0} α _inst_1))))) a (@lattice.infi.{0 1} α ι (@lattice.complete_lattice.to_has_Inf.{0} α _inst_1) s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type} {ι : Prop} [_inst_1 : lattice.complete_lattice.{0} α] {s : ι → α} {a : α}, (∀ (i : ι), @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@lattice.order_bot.to_partial_order.{0} α (@lattice.bounded_lattice.to_order_bot.{0} α (@lattice.complete_lattice.to_bounded_lattice.{0} α _inst_1))))) a (s i)) → @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@lattice.order_bot.to_partial_order.{0} α (@lattice.bounded_lattice.to_order_bot.{0} α (@lattice.complete_lattice.to_bounded_lattice.{0} α _inst_1))))) a (@lattice.infi.{0 0} α ι (@lattice.complete_lattice.to_has_Inf.{0} α _inst_1) s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) t (@set.Ico.{0} real real.preorder a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                             </code><font color='lime'><a title='c : real,
t : set.{0} real,
a b : real,
h : @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) t (@set.Ico.{0} real real.preorder a b)
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@lattice.order_bot.to_partial_order.{0} ennreal
             (@lattice.bounded_lattice.to_order_bot.{0} ennreal
                (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                   (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))))))
    (@has_add.add.{0} ennreal
       (@distrib.to_has_add.{0} ennreal
          (@semiring.to_distrib.{0} ennreal
             (@comm_semiring.to_semiring.{0} ennreal
                (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1))))
       (measure_theory.lebesgue_length
          (@has_inter.inter.{0} (set.{0} real) (@set.has_inter.{0} real) t (@set.Iio.{0} real real.preorder c)))
       (measure_theory.lebesgue_length
          (@has_sdiff.sdiff.{0} (set.{0} real) (@set.has_sdiff.{0} real) t (@set.Iio.{0} real real.preorder c))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>179    refine le_trans (add_le_add&#x27;</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='le_trans'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='add_le_add&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 33, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/ordered_group.lean&#x27;, &#x27;line&#x27;: 46, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : preorder.{0} α] {a b c : α}, @has_le.le.{0} α (@preorder.to_has_le.{0} α _inst_1) a b → @has_le.le.{0} α (@preorder.to_has_le.{0} α _inst_1) b c → @has_le.le.{0} α (@preorder.to_has_le.{0} α _inst_1) a c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type} [_inst_1 : ordered_comm_monoid.{0} α] {a b c d : α}, @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@ordered_comm_monoid.to_partial_order.{0} α _inst_1))) a b → @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@ordered_comm_monoid.to_partial_order.{0} α _inst_1))) c d → @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@ordered_comm_monoid.to_partial_order.{0} α _inst_1))) (@has_add.add.{0} α (@add_semigroup.to_has_add.{0} α (@add_monoid.to_add_semigroup.{0} α (@add_comm_monoid.to_add_monoid.{0} α (@ordered_comm_monoid.to_add_comm_monoid.{0} α _inst_1)))) a c) (@has_add.add.{0} α (@add_semigroup.to_has_add.{0} α (@add_monoid.to_add_semigroup.{0} α (@add_comm_monoid.to_add_monoid.{0} α (@ordered_comm_monoid.to_add_comm_monoid.{0} α _inst_1)))) b d)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='c : real,
t : set.{0} real,
a b : real,
h : @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) t (@set.Ico.{0} real real.preorder a b)
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@lattice.order_bot.to_partial_order.{0} ennreal
             (@lattice.bounded_lattice.to_order_bot.{0} ennreal
                (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                   (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))))))
    (@has_add.add.{0} ennreal
       (@distrib.to_has_add.{0} ennreal
          (@semiring.to_distrib.{0} ennreal
             (@comm_semiring.to_semiring.{0} ennreal
                (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1))))
       (measure_theory.lebesgue_length
          (@has_inter.inter.{0} (set.{0} real) (@set.has_inter.{0} real) t (@set.Iio.{0} real real.preorder c)))
       (measure_theory.lebesgue_length
          (@has_sdiff.sdiff.{0} (set.{0} real) (@set.has_sdiff.{0} real) t (@set.Iio.{0} real real.preorder c))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>180      (lebesgue_length_mono $ inter_subset_inter_left _ h)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='blue'><a title='set.inter_subset_inter_left'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 402, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} {s t : set.{0} α} (u : set.{0} α), @has_subset.subset.{0} (set.{0} α) (@set.has_subset.{0} α) s t → @has_subset.subset.{0} (set.{0} α) (@set.has_subset.{0} α) (@has_inter.inter.{0} (set.{0} α) (@set.has_inter.{0} α) s u) (@has_inter.inter.{0} (set.{0} α) (@set.has_inter.{0} α) t u)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='c : real,
t : set.{0} real,
a b : real,
h : @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) t (@set.Ico.{0} real real.preorder a b)
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@lattice.order_bot.to_partial_order.{0} ennreal
             (@lattice.bounded_lattice.to_order_bot.{0} ennreal
                (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                   (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))))))
    (@has_add.add.{0} ennreal
       (@distrib.to_has_add.{0} ennreal
          (@semiring.to_distrib.{0} ennreal
             (@comm_semiring.to_semiring.{0} ennreal
                (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1))))
       (measure_theory.lebesgue_length
          (@has_inter.inter.{0} (set.{0} real) (@set.has_inter.{0} real) t (@set.Iio.{0} real real.preorder c)))
       (measure_theory.lebesgue_length
          (@has_sdiff.sdiff.{0} (set.{0} real) (@set.has_sdiff.{0} real) t (@set.Iio.{0} real real.preorder c))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>181      (lebesgue_length_mono $ diff_subset_diff_left h)) _,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='measure_theory.lebesgue_length_mono'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='set.diff_subset_diff_left'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 33, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 735, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {s₁ s₂ : set.{0} real}, @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) s₁ s₂ → @has_le.le.{0} ennreal (@preorder.to_has_le.{0} ennreal (@partial_order.to_preorder.{0} ennreal (@ordered_comm_monoid.to_partial_order.{0} ennreal (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal ennreal.canonically_ordered_comm_semiring_1))))) (measure_theory.lebesgue_length s₁) (measure_theory.lebesgue_length s₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} {s₁ s₂ t : set.{0} α}, @has_subset.subset.{0} (set.{0} α) (@set.has_subset.{0} α) s₁ s₂ → @has_subset.subset.{0} (set.{0} α) (@set.has_subset.{0} α) (@has_sdiff.sdiff.{0} (set.{0} α) (@set.has_sdiff.{0} α) s₁ t) (@has_sdiff.sdiff.{0} (set.{0} α) (@set.has_sdiff.{0} α) s₂ t)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) t (@set.Ico.{0} real real.preorder a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='c : real,
t : set.{0} real,
a b : real,
h : @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) t (@set.Ico.{0} real real.preorder a b)
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@lattice.order_bot.to_partial_order.{0} ennreal
             (@lattice.bounded_lattice.to_order_bot.{0} ennreal
                (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                   (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))))))
    (@has_add.add.{0} ennreal
       (@distrib.to_has_add.{0} ennreal
          (@semiring.to_distrib.{0} ennreal
             (@comm_semiring.to_semiring.{0} ennreal
                (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1))))
       (measure_theory.lebesgue_length
          (@has_inter.inter.{0} (set.{0} real) (@set.has_inter.{0} real) t (@set.Iio.{0} real real.preorder c)))
       (measure_theory.lebesgue_length
          (@has_sdiff.sdiff.{0} (set.{0} real) (@set.has_sdiff.{0} real) t (@set.Iio.{0} real real.preorder c))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='c : real,
t : set.{0} real,
a b : real,
h : @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) t (@set.Ico.{0} real real.preorder a b)
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@has_add.add.{0} ennreal
       (@add_semigroup.to_has_add.{0} ennreal
          (@add_monoid.to_add_semigroup.{0} ennreal
             (@add_comm_monoid.to_add_monoid.{0} ennreal
                (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
                   (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                      (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                         ennreal.canonically_ordered_comm_semiring_1))))))
       (measure_theory.lebesgue_length
          (@has_inter.inter.{0} (set.{0} real) (@set.has_inter.{0} real) (@set.Ico.{0} real real.preorder a b)
             (@set.Iio.{0} real real.preorder c)))
       (measure_theory.lebesgue_length
          (@has_sdiff.sdiff.{0} (set.{0} real) (@set.has_sdiff.{0} real) (@set.Ico.{0} real real.preorder a b)
             (@set.Iio.{0} real real.preorder c))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>182    cases le_total a c with hac hca; cases le_total b c with hbc hcb;</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='le_total'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='blue'><a title='le_total'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 57, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 57, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : linear_order.{0} α] (a b : α), or (@has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@linear_order.to_partial_order.{0} α _inst_1))) a b) (@has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@linear_order.to_partial_order.{0} α _inst_1))) b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : linear_order.{0} α] (a b : α), or (@has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@linear_order.to_partial_order.{0} α _inst_1))) a b) (@has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@linear_order.to_partial_order.{0} α _inst_1))) b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='c : real,
t : set.{0} real,
a b : real,
h : @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) t (@set.Ico.{0} real real.preorder a b)
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@has_add.add.{0} ennreal
       (@add_semigroup.to_has_add.{0} ennreal
          (@add_monoid.to_add_semigroup.{0} ennreal
             (@add_comm_monoid.to_add_monoid.{0} ennreal
                (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
                   (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                      (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                         ennreal.canonically_ordered_comm_semiring_1))))))
       (measure_theory.lebesgue_length
          (@has_inter.inter.{0} (set.{0} real) (@set.has_inter.{0} real) (@set.Ico.{0} real real.preorder a b)
             (@set.Iio.{0} real real.preorder c)))
       (measure_theory.lebesgue_length
          (@has_sdiff.sdiff.{0} (set.{0} real) (@set.has_sdiff.{0} real) (@set.Ico.{0} real real.preorder a b)
             (@set.Iio.{0} real real.preorder c))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>183      simp [*, -sub_eq_add_neg, sub_add_sub_cancel&#x27;];</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='blue'><a title='sub_add_sub_cancel&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/group/basic.lean&#x27;, &#x27;line&#x27;: 236, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} [_inst_1 : add_comm_group.{?l_1} α] (a b c : α), @eq.{?l_1+1} α (@has_add.add.{?l_1} α (@add_semigroup.to_has_add.{?l_1} α (@add_monoid.to_add_semigroup.{?l_1} α (@add_group.to_add_monoid.{?l_1} α (@add_comm_group.to_add_group.{?l_1} α _inst_1)))) (@has_sub.sub.{?l_1} α (@add_group_has_sub.{?l_1} α (@add_comm_group.to_add_group.{?l_1} α _inst_1)) a b) (@has_sub.sub.{?l_1} α (@add_group_has_sub.{?l_1} α (@add_comm_group.to_add_group.{?l_1} α _inst_1)) c a)) (@has_sub.sub.{?l_1} α (@add_group_has_sub.{?l_1} α (@add_comm_group.to_add_group.{?l_1} α _inst_1)) c b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='c : real,
t : set.{0} real,
a b : real,
h : @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) t (@set.Ico.{0} real real.preorder a b)
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@has_add.add.{0} ennreal
       (@add_semigroup.to_has_add.{0} ennreal
          (@add_monoid.to_add_semigroup.{0} ennreal
             (@add_comm_monoid.to_add_monoid.{0} ennreal
                (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
                   (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                      (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                         ennreal.canonically_ordered_comm_semiring_1))))))
       (measure_theory.lebesgue_length
          (@has_inter.inter.{0} (set.{0} real) (@set.has_inter.{0} real) (@set.Ico.{0} real real.preorder a b)
             (@set.Iio.{0} real real.preorder c)))
       (measure_theory.lebesgue_length
          (@has_sdiff.sdiff.{0} (set.{0} real) (@set.has_sdiff.{0} real) (@set.Ico.{0} real real.preorder a b)
             (@set.Iio.{0} real real.preorder c))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>184      rw [← ennreal.coe_add, ennreal.coe_le_coe],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='ennreal.coe_add'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ennreal.coe_le_coe'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/ennreal.lean&#x27;, &#x27;line&#x27;: 128, &#x27;column&#x27;: 25}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/ennreal.lean&#x27;, &#x27;line&#x27;: 117, &#x27;column&#x27;: 25}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {r p : nnreal}, @eq.{1} ennreal (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe)) (@has_add.add.{0} nnreal nnreal.has_add r p)) (@has_add.add.{0} ennreal (@distrib.to_has_add.{0} ennreal (@semiring.to_distrib.{0} ennreal (@comm_semiring.to_semiring.{0} ennreal (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal ennreal.canonically_ordered_comm_semiring_1)))) (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe)) r) (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe)) p))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {r q : nnreal}, iff (@has_le.le.{0} ennreal (@preorder.to_has_le.{0} ennreal (@partial_order.to_preorder.{0} ennreal (@ordered_comm_monoid.to_partial_order.{0} ennreal (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal ennreal.canonically_ordered_comm_semiring_1))))) (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe)) r) (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe)) q)) (@has_le.le.{0} nnreal nnreal.has_le r q)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='c : real,
t : set.{0} real,
a b : real,
h : @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) t (@set.Ico.{0} real real.preorder a b)
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@has_add.add.{0} ennreal
       (@add_semigroup.to_has_add.{0} ennreal
          (@add_monoid.to_add_semigroup.{0} ennreal
             (@add_comm_monoid.to_add_monoid.{0} ennreal
                (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
                   (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                      (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                         ennreal.canonically_ordered_comm_semiring_1))))))
       (measure_theory.lebesgue_length
          (@has_inter.inter.{0} (set.{0} real) (@set.has_inter.{0} real) (@set.Ico.{0} real real.preorder a b)
             (@set.Iio.{0} real real.preorder c)))
       (measure_theory.lebesgue_length
          (@has_sdiff.sdiff.{0} (set.{0} real) (@set.has_sdiff.{0} real) (@set.Ico.{0} real real.preorder a b)
             (@set.Iio.{0} real real.preorder c))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case or.inr
c : real,
t : set.{0} real,
a b : real,
h : @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) t (@set.Ico.{0} real real.preorder a b),
hac :
  @has_le.le.{0} real
    (@preorder.to_has_le.{0} real
       (@partial_order.to_preorder.{0} real (@linear_order.to_partial_order.{0} real real.linear_order)))
    a
    c,
hcb :
  @has_le.le.{0} real
    (@preorder.to_has_le.{0} real
       (@partial_order.to_preorder.{0} real (@linear_order.to_partial_order.{0} real real.linear_order)))
    c
    b
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@has_add.add.{0} ennreal
       (@add_semigroup.to_has_add.{0} ennreal
          (@add_monoid.to_add_semigroup.{0} ennreal
             (@add_comm_monoid.to_add_monoid.{0} ennreal
                (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
                   (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                      (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                         ennreal.canonically_ordered_comm_semiring_1))))))
       (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
          (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) c a)))
       (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
          (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b c))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='c : real,
t : set.{0} real,
a b : real,
h : @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) t (@set.Ico.{0} real real.preorder a b),
hac :
  @has_le.le.{0} real
    (@preorder.to_has_le.{0} real
       (@partial_order.to_preorder.{0} real (@linear_order.to_partial_order.{0} real real.linear_order)))
    a
    c,
hcb :
  @has_le.le.{0} real
    (@preorder.to_has_le.{0} real
       (@partial_order.to_preorder.{0} real (@linear_order.to_partial_order.{0} real real.linear_order)))
    c
    b
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (@has_add.add.{0} nnreal nnreal.has_add
          (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) c a))
          (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b c))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='c : real,
t : set.{0} real,
a b : real,
h : @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) t (@set.Ico.{0} real real.preorder a b),
hac :
  @has_le.le.{0} real
    (@preorder.to_has_le.{0} real
       (@partial_order.to_preorder.{0} real (@linear_order.to_partial_order.{0} real real.linear_order)))
    a
    c,
hcb :
  @has_le.le.{0} real
    (@preorder.to_has_le.{0} real
       (@partial_order.to_preorder.{0} real (@linear_order.to_partial_order.{0} real real.linear_order)))
    c
    b
⊢ @has_le.le.{0} nnreal nnreal.has_le
    (@has_add.add.{0} nnreal nnreal.has_add
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) c a))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b c)))
    (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
case or.inr
c : real,
t : set.{0} real,
a b : real,
h : @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) t (@set.Ico.{0} real real.preorder a b),
hac :
  @has_le.le.{0} real
    (@preorder.to_has_le.{0} real
       (@partial_order.to_preorder.{0} real (@linear_order.to_partial_order.{0} real real.linear_order)))
    a
    c,
hcb :
  @has_le.le.{0} real
    (@preorder.to_has_le.{0} real
       (@partial_order.to_preorder.{0} real (@linear_order.to_partial_order.{0} real real.linear_order)))
    c
    b
⊢ @has_le.le.{0} nnreal nnreal.has_le
    (@has_add.add.{0} nnreal nnreal.has_add
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) c a))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b c)))
    (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a))

case or.inl
c : real,
t : set.{0} real,
a b : real,
h : @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) t (@set.Ico.{0} real real.preorder a b),
hca :
  @has_le.le.{0} real
    (@preorder.to_has_le.{0} real
       (@partial_order.to_preorder.{0} real (@linear_order.to_partial_order.{0} real real.linear_order)))
    c
    a,
hbc :
  @has_le.le.{0} real
    (@preorder.to_has_le.{0} real
       (@partial_order.to_preorder.{0} real (@linear_order.to_partial_order.{0} real real.linear_order)))
    b
    c
⊢ @has_le.le.{0} nnreal nnreal.has_le
    (@has_add.add.{0} nnreal nnreal.has_add
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
    (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>185    { simp [*, -nnreal.of_real_add, nnreal.of_real_add_of_real,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='blue'><a title='nnreal.of_real_add_of_real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/nnreal.lean&#x27;, &#x27;line&#x27;: 305, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {r p : real}, @has_le.le.{0} real real.has_le (@has_zero.zero.{0} real (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))) r → @has_le.le.{0} real real.has_le (@has_zero.zero.{0} real (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))) p → @eq.{1} nnreal (@has_add.add.{0} nnreal nnreal.has_add (nnreal.of_real r) (nnreal.of_real p)) (nnreal.of_real (@has_add.add.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring)) r p))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
case or.inr
c : real,
t : set.{0} real,
a b : real,
h : @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) t (@set.Ico.{0} real real.preorder a b),
hac :
  @has_le.le.{0} real
    (@preorder.to_has_le.{0} real
       (@partial_order.to_preorder.{0} real (@linear_order.to_partial_order.{0} real real.linear_order)))
    a
    c,
hcb :
  @has_le.le.{0} real
    (@preorder.to_has_le.{0} real
       (@partial_order.to_preorder.{0} real (@linear_order.to_partial_order.{0} real real.linear_order)))
    c
    b
⊢ @has_le.le.{0} nnreal nnreal.has_le
    (@has_add.add.{0} nnreal nnreal.has_add
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) c a))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b c)))
    (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a))

case or.inl
c : real,
t : set.{0} real,
a b : real,
h : @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) t (@set.Ico.{0} real real.preorder a b),
hca :
  @has_le.le.{0} real
    (@preorder.to_has_le.{0} real
       (@partial_order.to_preorder.{0} real (@linear_order.to_partial_order.{0} real real.linear_order)))
    c
    a,
hbc :
  @has_le.le.{0} real
    (@preorder.to_has_le.{0} real
       (@partial_order.to_preorder.{0} real (@linear_order.to_partial_order.{0} real real.linear_order)))
    b
    c
⊢ @has_le.le.{0} nnreal nnreal.has_le
    (@has_add.add.{0} nnreal nnreal.has_add
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
    (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case or.inr
c : real,
t : set.{0} real,
a b : real,
h : @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) t (@set.Ico.{0} real real.preorder a b),
hac :
  @has_le.le.{0} real
    (@preorder.to_has_le.{0} real
       (@partial_order.to_preorder.{0} real (@linear_order.to_partial_order.{0} real real.linear_order)))
    a
    c,
hcb :
  @has_le.le.{0} real
    (@preorder.to_has_le.{0} real
       (@partial_order.to_preorder.{0} real (@linear_order.to_partial_order.{0} real real.linear_order)))
    c
    b
⊢ @has_le.le.{0} nnreal nnreal.has_le
    (@has_add.add.{0} nnreal nnreal.has_add
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) c a))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b c)))
    (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>186        -sub_eq_add_neg, sub_add_sub_cancel&#x27;] },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='blue'><a title='sub_add_sub_cancel&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/group/basic.lean&#x27;, &#x27;line&#x27;: 236, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} [_inst_1 : add_comm_group.{?l_1} α] (a b c : α), @eq.{?l_1+1} α (@has_add.add.{?l_1} α (@add_semigroup.to_has_add.{?l_1} α (@add_monoid.to_add_semigroup.{?l_1} α (@add_group.to_add_monoid.{?l_1} α (@add_comm_group.to_add_group.{?l_1} α _inst_1)))) (@has_sub.sub.{?l_1} α (@add_group_has_sub.{?l_1} α (@add_comm_group.to_add_group.{?l_1} α _inst_1)) a b) (@has_sub.sub.{?l_1} α (@add_group_has_sub.{?l_1} α (@add_comm_group.to_add_group.{?l_1} α _inst_1)) c a)) (@has_sub.sub.{?l_1} α (@add_group_has_sub.{?l_1} α (@add_comm_group.to_add_group.{?l_1} α _inst_1)) c b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case or.inr
c : real,
t : set.{0} real,
a b : real,
h : @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) t (@set.Ico.{0} real real.preorder a b),
hac :
  @has_le.le.{0} real
    (@preorder.to_has_le.{0} real
       (@partial_order.to_preorder.{0} real (@linear_order.to_partial_order.{0} real real.linear_order)))
    a
    c,
hcb :
  @has_le.le.{0} real
    (@preorder.to_has_le.{0} real
       (@partial_order.to_preorder.{0} real (@linear_order.to_partial_order.{0} real real.linear_order)))
    c
    b
⊢ @has_le.le.{0} nnreal nnreal.has_le
    (@has_add.add.{0} nnreal nnreal.has_add
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) c a))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b c)))
    (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case or.inl
c : real,
t : set.{0} real,
a b : real,
h : @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) t (@set.Ico.{0} real real.preorder a b),
hca :
  @has_le.le.{0} real
    (@preorder.to_has_le.{0} real
       (@partial_order.to_preorder.{0} real (@linear_order.to_partial_order.{0} real real.linear_order)))
    c
    a,
hbc :
  @has_le.le.{0} real
    (@preorder.to_has_le.{0} real
       (@partial_order.to_preorder.{0} real (@linear_order.to_partial_order.{0} real real.linear_order)))
    b
    c
⊢ @has_le.le.{0} nnreal nnreal.has_le
    (@has_add.add.{0} nnreal nnreal.has_add
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
    (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>187    { rw nnreal.of_real_of_nonpos,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='nnreal.of_real_of_nonpos'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/nnreal.lean&#x27;, &#x27;line&#x27;: 282, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {r : real}, @has_le.le.{0} real real.has_le r (@has_zero.zero.{0} real (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))) → @eq.{1} nnreal (nnreal.of_real r) (@has_zero.zero.{0} nnreal nnreal.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case or.inl
c : real,
t : set.{0} real,
a b : real,
h : @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) t (@set.Ico.{0} real real.preorder a b),
hca :
  @has_le.le.{0} real
    (@preorder.to_has_le.{0} real
       (@partial_order.to_preorder.{0} real (@linear_order.to_partial_order.{0} real real.linear_order)))
    c
    a,
hbc :
  @has_le.le.{0} real
    (@preorder.to_has_le.{0} real
       (@partial_order.to_preorder.{0} real (@linear_order.to_partial_order.{0} real real.linear_order)))
    b
    c
⊢ @has_le.le.{0} nnreal nnreal.has_le
    (@has_add.add.{0} nnreal nnreal.has_add
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
    (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
case or.inl
c : real,
t : set.{0} real,
a b : real,
h : @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) t (@set.Ico.{0} real real.preorder a b),
hca :
  @has_le.le.{0} real
    (@preorder.to_has_le.{0} real
       (@partial_order.to_preorder.{0} real (@linear_order.to_partial_order.{0} real real.linear_order)))
    c
    a,
hbc :
  @has_le.le.{0} real
    (@preorder.to_has_le.{0} real
       (@partial_order.to_preorder.{0} real (@linear_order.to_partial_order.{0} real real.linear_order)))
    b
    c
⊢ @has_le.le.{0} nnreal nnreal.has_le
    (@has_add.add.{0} nnreal nnreal.has_add (@has_zero.zero.{0} nnreal nnreal.has_zero)
       (@has_zero.zero.{0} nnreal nnreal.has_zero))
    (@has_zero.zero.{0} nnreal nnreal.has_zero)

c : real,
t : set.{0} real,
a b : real,
h : @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) t (@set.Ico.{0} real real.preorder a b),
hca :
  @has_le.le.{0} real
    (@preorder.to_has_le.{0} real
       (@partial_order.to_preorder.{0} real (@linear_order.to_partial_order.{0} real real.linear_order)))
    c
    a,
hbc :
  @has_le.le.{0} real
    (@preorder.to_has_le.{0} real
       (@partial_order.to_preorder.{0} real (@linear_order.to_partial_order.{0} real real.linear_order)))
    b
    c
⊢ @has_le.le.{0} real real.has_le (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>188      { simp },</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
case or.inl
c : real,
t : set.{0} real,
a b : real,
h : @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) t (@set.Ico.{0} real real.preorder a b),
hca :
  @has_le.le.{0} real
    (@preorder.to_has_le.{0} real
       (@partial_order.to_preorder.{0} real (@linear_order.to_partial_order.{0} real real.linear_order)))
    c
    a,
hbc :
  @has_le.le.{0} real
    (@preorder.to_has_le.{0} real
       (@partial_order.to_preorder.{0} real (@linear_order.to_partial_order.{0} real real.linear_order)))
    b
    c
⊢ @has_le.le.{0} nnreal nnreal.has_le
    (@has_add.add.{0} nnreal nnreal.has_add (@has_zero.zero.{0} nnreal nnreal.has_zero)
       (@has_zero.zero.{0} nnreal nnreal.has_zero))
    (@has_zero.zero.{0} nnreal nnreal.has_zero)

c : real,
t : set.{0} real,
a b : real,
h : @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) t (@set.Ico.{0} real real.preorder a b),
hca :
  @has_le.le.{0} real
    (@preorder.to_has_le.{0} real
       (@partial_order.to_preorder.{0} real (@linear_order.to_partial_order.{0} real real.linear_order)))
    c
    a,
hbc :
  @has_le.le.{0} real
    (@preorder.to_has_le.{0} real
       (@partial_order.to_preorder.{0} real (@linear_order.to_partial_order.{0} real real.linear_order)))
    b
    c
⊢ @has_le.le.{0} real real.has_le (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case or.inl
c : real,
t : set.{0} real,
a b : real,
h : @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) t (@set.Ico.{0} real real.preorder a b),
hca :
  @has_le.le.{0} real
    (@preorder.to_has_le.{0} real
       (@partial_order.to_preorder.{0} real (@linear_order.to_partial_order.{0} real real.linear_order)))
    c
    a,
hbc :
  @has_le.le.{0} real
    (@preorder.to_has_le.{0} real
       (@partial_order.to_preorder.{0} real (@linear_order.to_partial_order.{0} real real.linear_order)))
    b
    c
⊢ @has_le.le.{0} nnreal nnreal.has_le
    (@has_add.add.{0} nnreal nnreal.has_add (@has_zero.zero.{0} nnreal nnreal.has_zero)
       (@has_zero.zero.{0} nnreal nnreal.has_zero))
    (@has_zero.zero.{0} nnreal nnreal.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='c : real,
t : set.{0} real,
a b : real,
h : @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) t (@set.Ico.{0} real real.preorder a b),
hca :
  @has_le.le.{0} real
    (@preorder.to_has_le.{0} real
       (@partial_order.to_preorder.{0} real (@linear_order.to_partial_order.{0} real real.linear_order)))
    c
    a,
hbc :
  @has_le.le.{0} real
    (@preorder.to_has_le.{0} real
       (@partial_order.to_preorder.{0} real (@linear_order.to_partial_order.{0} real real.linear_order)))
    b
    c
⊢ @has_le.le.{0} real real.has_le (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>189      exact sub_nonpos.2 (le_trans hbc hca) }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='sub_nonpos'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='le_trans'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hbc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hca'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/ordered_group.lean&#x27;, &#x27;line&#x27;: 570, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 33, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : ordered_comm_group.{0} α] {a b : α}, iff (@has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@ordered_comm_monoid.to_partial_order.{0} α (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} α (@ordered_comm_group.to_ordered_cancel_comm_monoid.{0} α _inst_1))))) (@has_sub.sub.{0} α (@add_group_has_sub.{0} α (@add_comm_group.to_add_group.{0} α (@ordered_comm_group.to_add_comm_group.{0} α _inst_1))) a b) (@has_zero.zero.{0} α (@add_monoid.to_has_zero.{0} α (@add_group.to_add_monoid.{0} α (@add_comm_group.to_add_group.{0} α (@ordered_comm_group.to_add_comm_group.{0} α _inst_1)))))) (@has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@ordered_comm_monoid.to_partial_order.{0} α (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} α (@ordered_comm_group.to_ordered_cancel_comm_monoid.{0} α _inst_1))))) a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type} [_inst_1 : preorder.{0} α] {a b c : α}, @has_le.le.{0} α (@preorder.to_has_le.{0} α _inst_1) a b → @has_le.le.{0} α (@preorder.to_has_le.{0} α _inst_1) b c → @has_le.le.{0} α (@preorder.to_has_le.{0} α _inst_1) a c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_le.le.{0} real (@preorder.to_has_le.{0} real (@partial_order.to_preorder.{0} real (@linear_order.to_partial_order.{0} real real.linear_order))) b c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_le.le.{0} real (@preorder.to_has_le.{0} real (@partial_order.to_preorder.{0} real (@linear_order.to_partial_order.{0} real real.linear_order))) c a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='c : real,
t : set.{0} real,
a b : real,
h : @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) t (@set.Ico.{0} real real.preorder a b),
hca :
  @has_le.le.{0} real
    (@preorder.to_has_le.{0} real
       (@partial_order.to_preorder.{0} real (@linear_order.to_partial_order.{0} real real.linear_order)))
    c
    a,
hbc :
  @has_le.le.{0} real
    (@preorder.to_has_le.{0} real
       (@partial_order.to_preorder.{0} real (@linear_order.to_partial_order.{0} real real.linear_order)))
    b
    c
⊢ @has_le.le.{0} real real.has_le (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>190  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>191  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>192  theorem lebesgue_outer_trim : lebesgue_outer.trim = lebesgue_outer :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='blue'><a title='measure_theory.lebesgue_outer'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='measure_theory.outer_measure.trim'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='measure_theory.lebesgue_outer'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='red'><a title='{&#x27;line&#x27;: 87, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measure_space.lean&#x27;, &#x27;line&#x27;: 140, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 87, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='green'><a title='measure_theory.outer_measure.{0} real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} [_inst_1 : measurable_space.{0} α], measure_theory.outer_measure.{0} α → measure_theory.outer_measure.{0} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='measure_theory.outer_measure.{0} real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='orange'><a title='The Lebesgue outer measure, as an outer measure of ℝ.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='The Lebesgue outer measure, as an outer measure of ℝ.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>193  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='⊢ @eq.{1} (measure_theory.outer_measure.{0} real)
    (@measure_theory.outer_measure.trim.{0} real
       (@borel.{0} real
          (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)))
       measure_theory.lebesgue_outer)
    measure_theory.lebesgue_outer'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>194    refine le_antisymm (λ s, _) (outer_measure.trim_ge _),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='le_antisymm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='measure_theory.outer_measure.trim_ge'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 45, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measure_space.lean&#x27;, &#x27;line&#x27;: 143, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : partial_order.{0} α] {a b : α}, @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α _inst_1)) a b → @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α _inst_1)) b a → @eq.{1} α a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type} [_inst_1 : measurable_space.{0} α] (m : measure_theory.outer_measure.{0} α), @has_le.le.{0} (measure_theory.outer_measure.{0} α) (@preorder.to_has_le.{0} (measure_theory.outer_measure.{0} α) (@partial_order.to_preorder.{0} (measure_theory.outer_measure.{0} α) (@lattice.order_bot.to_partial_order.{0} (measure_theory.outer_measure.{0} α) (@measure_theory.outer_measure.outer_measure.order_bot.{0} α)))) m (@measure_theory.outer_measure.trim.{0} α _inst_1 m)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='⊢ @eq.{1} (measure_theory.outer_measure.{0} real)
    (@measure_theory.outer_measure.trim.{0} real
       (@borel.{0} real
          (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)))
       measure_theory.lebesgue_outer)
    measure_theory.lebesgue_outer'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} real
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real) (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
       (@measure_theory.outer_measure.trim.{0} real
          (@borel.{0} real
             (@uniform_space.to_topological_space.{0} real
                (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)))
          measure_theory.lebesgue_outer)
       s)
    (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real) (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
       measure_theory.lebesgue_outer
       s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>195    rw outer_measure.trim_eq_infi,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='measure_theory.outer_measure.trim_eq_infi'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measure_space.lean&#x27;, &#x27;line&#x27;: 164, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : measurable_space.{0} α] (m : measure_theory.outer_measure.{0} α) (s : set.{0} α), @eq.{1} ennreal (@coe_fn.{1 1} (measure_theory.outer_measure.{0} α) (@measure_theory.outer_measure.has_coe_to_fun.{0} α) (@measure_theory.outer_measure.trim.{0} α _inst_1 m) s) (@lattice.infi.{0 1} ennreal (set.{0} α) (@lattice.conditionally_complete_lattice.to_has_Inf.{0} ennreal (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))) (λ (t : set.{0} α), @lattice.infi.{0 0} ennreal (@has_subset.subset.{0} (set.{0} α) (@set.has_subset.{0} α) s t) (@lattice.conditionally_complete_lattice.to_has_Inf.{0} ennreal (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))) (λ (st : @has_subset.subset.{0} (set.{0} α) (@set.has_subset.{0} α) s t), @lattice.infi.{0 0} ennreal (@is_measurable.{0} α _inst_1 t) (@lattice.conditionally_complete_lattice.to_has_Inf.{0} ennreal (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))) (λ (ht : @is_measurable.{0} α _inst_1 t), @coe_fn.{1 1} (measure_theory.outer_measure.{0} α) (@measure_theory.outer_measure.has_coe_to_fun.{0} α) m t))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} real
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real) (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
       (@measure_theory.outer_measure.trim.{0} real
          (@borel.{0} real
             (@uniform_space.to_topological_space.{0} real
                (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)))
          measure_theory.lebesgue_outer)
       s)
    (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real) (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
       measure_theory.lebesgue_outer
       s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} real
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@lattice.infi.{0 1} ennreal (set.{0} real)
       (@lattice.conditionally_complete_lattice.to_has_Inf.{0} ennreal
          (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
             (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
       (λ (t : set.{0} real),
          @lattice.infi.{0 0} ennreal (@has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) s t)
            (@lattice.conditionally_complete_lattice.to_has_Inf.{0} ennreal
               (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
                  (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
            (λ (st : @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) s t),
               @lattice.infi.{0 0} ennreal
                 (@is_measurable.{0} real
                    (@borel.{0} real
                       (@uniform_space.to_topological_space.{0} real
                          (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)))
                    t)
                 (@lattice.conditionally_complete_lattice.to_has_Inf.{0} ennreal
                    (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
                       (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal
                          ennreal.complete_linear_order_1)))
                 (λ
                  (ht :
                    @is_measurable.{0} real
                      (@borel.{0} real
                         (@uniform_space.to_topological_space.{0} real
                            (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)))
                      t),
                    @coe_fn.{1 1} (measure_theory.outer_measure.{0} real)
                      (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
                      measure_theory.lebesgue_outer
                      t))))
    (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real) (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
       measure_theory.lebesgue_outer
       s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>196    refine le_infi (λ f, le_infi $ λ hf,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='blue'><a title='lattice.le_infi'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/complete_lattice.lean&#x27;, &#x27;line&#x27;: 300, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α ι : Type} [_inst_1 : lattice.complete_lattice.{0} α] {s : ι → α} {a : α}, (∀ (i : ι), @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@lattice.order_bot.to_partial_order.{0} α (@lattice.bounded_lattice.to_order_bot.{0} α (@lattice.complete_lattice.to_bounded_lattice.{0} α _inst_1))))) a (s i)) → @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@lattice.order_bot.to_partial_order.{0} α (@lattice.bounded_lattice.to_order_bot.{0} α (@lattice.complete_lattice.to_bounded_lattice.{0} α _inst_1))))) a (@lattice.infi.{0 1} α ι (@lattice.complete_lattice.to_has_Inf.{0} α _inst_1) s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} real
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@lattice.infi.{0 1} ennreal (set.{0} real)
       (@lattice.conditionally_complete_lattice.to_has_Inf.{0} ennreal
          (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
             (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
       (λ (t : set.{0} real),
          @lattice.infi.{0 0} ennreal (@has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) s t)
            (@lattice.conditionally_complete_lattice.to_has_Inf.{0} ennreal
               (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
                  (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
            (λ (st : @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) s t),
               @lattice.infi.{0 0} ennreal
                 (@is_measurable.{0} real
                    (@borel.{0} real
                       (@uniform_space.to_topological_space.{0} real
                          (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)))
                    t)
                 (@lattice.conditionally_complete_lattice.to_has_Inf.{0} ennreal
                    (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
                       (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal
                          ennreal.complete_linear_order_1)))
                 (λ
                  (ht :
                    @is_measurable.{0} real
                      (@borel.{0} real
                         (@uniform_space.to_topological_space.{0} real
                            (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)))
                      t),
                    @coe_fn.{1 1} (measure_theory.outer_measure.{0} real)
                      (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
                      measure_theory.lebesgue_outer
                      t))))
    (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real) (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
       measure_theory.lebesgue_outer
       s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>197      ennreal.le_of_forall_epsilon_le $ λ ε ε0 h, _),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='ennreal.le_of_forall_epsilon_le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/ennreal.lean&#x27;, &#x27;line&#x27;: 259, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : ennreal}, (∀ (ε : nnreal), @has_lt.lt.{0} nnreal (@preorder.to_has_lt.{0} nnreal (@partial_order.to_preorder.{0} nnreal (@ordered_comm_monoid.to_partial_order.{0} nnreal (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring)))))) (@has_zero.zero.{0} nnreal nnreal.has_zero) ε → @has_lt.lt.{0} ennreal (@preorder.to_has_lt.{0} ennreal (@partial_order.to_preorder.{0} ennreal (@ordered_comm_monoid.to_partial_order.{0} ennreal (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal ennreal.canonically_ordered_comm_semiring_1))))) b (@lattice.has_top.top.{0} ennreal (@lattice.order_top.to_has_top.{0} ennreal (@lattice.bounded_lattice.to_order_top.{0} ennreal (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))))) → @has_le.le.{0} ennreal (@preorder.to_has_le.{0} ennreal (@partial_order.to_preorder.{0} ennreal (@ordered_comm_monoid.to_partial_order.{0} ennreal (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal ennreal.canonically_ordered_comm_semiring_1))))) a (@has_add.add.{0} ennreal (@distrib.to_has_add.{0} ennreal (@semiring.to_distrib.{0} ennreal (@comm_semiring.to_semiring.{0} ennreal (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal ennreal.canonically_ordered_comm_semiring_1)))) b (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe)) ε))) → @has_le.le.{0} ennreal (@preorder.to_has_le.{0} ennreal (@partial_order.to_preorder.{0} ennreal (@ordered_comm_monoid.to_partial_order.{0} ennreal (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal ennreal.canonically_ordered_comm_semiring_1))))) a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} real
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@lattice.infi.{0 1} ennreal (set.{0} real)
       (@lattice.conditionally_complete_lattice.to_has_Inf.{0} ennreal
          (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
             (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
       (λ (t : set.{0} real),
          @lattice.infi.{0 0} ennreal (@has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) s t)
            (@lattice.conditionally_complete_lattice.to_has_Inf.{0} ennreal
               (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
                  (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
            (λ (st : @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) s t),
               @lattice.infi.{0 0} ennreal
                 (@is_measurable.{0} real
                    (@borel.{0} real
                       (@uniform_space.to_topological_space.{0} real
                          (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)))
                    t)
                 (@lattice.conditionally_complete_lattice.to_has_Inf.{0} ennreal
                    (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
                       (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal
                          ennreal.complete_linear_order_1)))
                 (λ
                  (ht :
                    @is_measurable.{0} real
                      (@borel.{0} real
                         (@uniform_space.to_topological_space.{0} real
                            (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)))
                      t),
                    @coe_fn.{1 1} (measure_theory.outer_measure.{0} real)
                      (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
                      measure_theory.lebesgue_outer
                      t))))
    (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real) (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
       measure_theory.lebesgue_outer
       s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} real,
f : nat → set.{0} real,
hf : @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) s (@set.Union.{0 1} real nat (λ (i : nat), f i)),
ε : nnreal,
ε0 :
  @has_lt.lt.{0} nnreal
    (@preorder.to_has_lt.{0} nnreal
       (@partial_order.to_preorder.{0} nnreal
          (@ordered_comm_monoid.to_partial_order.{0} nnreal
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                   (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
    (@has_zero.zero.{0} nnreal nnreal.has_zero)
    ε,
h :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat), measure_theory.lebesgue_length (f i)))
    (@lattice.has_top.top.{0} ennreal
       (@lattice.order_top.to_has_top.{0} ennreal
          (@lattice.bounded_lattice.to_order_top.{0} ennreal
             (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))))
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@lattice.infi.{0 1} ennreal (set.{0} real)
       (@lattice.conditionally_complete_lattice.to_has_Inf.{0} ennreal
          (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
             (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
       (λ (t : set.{0} real),
          @lattice.infi.{0 0} ennreal (@has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) s t)
            (@lattice.conditionally_complete_lattice.to_has_Inf.{0} ennreal
               (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
                  (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
            (λ (st : @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) s t),
               @lattice.infi.{0 0} ennreal
                 (@is_measurable.{0} real
                    (@borel.{0} real
                       (@uniform_space.to_topological_space.{0} real
                          (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)))
                    t)
                 (@lattice.conditionally_complete_lattice.to_has_Inf.{0} ennreal
                    (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
                       (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal
                          ennreal.complete_linear_order_1)))
                 (λ
                  (ht :
                    @is_measurable.{0} real
                      (@borel.{0} real
                         (@uniform_space.to_topological_space.{0} real
                            (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)))
                      t),
                    @coe_fn.{1 1} (measure_theory.outer_measure.{0} real)
                      (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
                      measure_theory.lebesgue_outer
                      t))))
    (@has_add.add.{0} ennreal
       (@distrib.to_has_add.{0} ennreal
          (@semiring.to_distrib.{0} ennreal
             (@comm_semiring.to_semiring.{0} ennreal
                (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1))))
       (@tsum.{0 0} ennreal nat
          (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))
          ennreal.topological_space
          (λ (i : nat), measure_theory.lebesgue_length (f i)))
       (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
          ε))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>198    rcases ennreal.exists_pos_sum_of_encodable</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='ennreal.exists_pos_sum_of_encodable'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/specific_limits.lean&#x27;, &#x27;line&#x27;: 440, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {ε : ennreal}, @has_lt.lt.{0} ennreal (@preorder.to_has_lt.{0} ennreal (@partial_order.to_preorder.{0} ennreal (@ordered_comm_monoid.to_partial_order.{0} ennreal (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal ennreal.canonically_ordered_comm_semiring_1))))) (@has_zero.zero.{0} ennreal (@zero_ne_one_class.to_has_zero.{0} ennreal (@canonically_ordered_comm_semiring.to_zero_ne_one_class.{0} ennreal ennreal.canonically_ordered_comm_semiring_1))) ε → ∀ (ι : Type) [_inst_1 : encodable.{0} ι], @Exists.{1} (ι → nnreal) (λ (ε&#x27; : ι → nnreal), and (∀ (i : ι), @has_lt.lt.{0} nnreal (@preorder.to_has_lt.{0} nnreal (@partial_order.to_preorder.{0} nnreal (@ordered_comm_monoid.to_partial_order.{0} nnreal (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring)))))) (@has_zero.zero.{0} nnreal nnreal.has_zero) (ε&#x27; i)) (@has_lt.lt.{0} ennreal (@preorder.to_has_lt.{0} ennreal (@partial_order.to_preorder.{0} ennreal (@ordered_comm_monoid.to_partial_order.{0} ennreal (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal ennreal.canonically_ordered_comm_semiring_1))))) (@tsum.{0 0} ennreal ι (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal ennreal.canonically_ordered_comm_semiring_1))) ennreal.topological_space (λ (i : ι), @coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe)) (ε&#x27; i))) ε))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} real,
f : nat → set.{0} real,
hf : @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) s (@set.Union.{0 1} real nat (λ (i : nat), f i)),
ε : nnreal,
ε0 :
  @has_lt.lt.{0} nnreal
    (@preorder.to_has_lt.{0} nnreal
       (@partial_order.to_preorder.{0} nnreal
          (@ordered_comm_monoid.to_partial_order.{0} nnreal
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                   (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
    (@has_zero.zero.{0} nnreal nnreal.has_zero)
    ε,
h :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat), measure_theory.lebesgue_length (f i)))
    (@lattice.has_top.top.{0} ennreal
       (@lattice.order_top.to_has_top.{0} ennreal
          (@lattice.bounded_lattice.to_order_top.{0} ennreal
             (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))))
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@lattice.infi.{0 1} ennreal (set.{0} real)
       (@lattice.conditionally_complete_lattice.to_has_Inf.{0} ennreal
          (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
             (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
       (λ (t : set.{0} real),
          @lattice.infi.{0 0} ennreal (@has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) s t)
            (@lattice.conditionally_complete_lattice.to_has_Inf.{0} ennreal
               (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
                  (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
            (λ (st : @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) s t),
               @lattice.infi.{0 0} ennreal
                 (@is_measurable.{0} real
                    (@borel.{0} real
                       (@uniform_space.to_topological_space.{0} real
                          (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)))
                    t)
                 (@lattice.conditionally_complete_lattice.to_has_Inf.{0} ennreal
                    (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
                       (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal
                          ennreal.complete_linear_order_1)))
                 (λ
                  (ht :
                    @is_measurable.{0} real
                      (@borel.{0} real
                         (@uniform_space.to_topological_space.{0} real
                            (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)))
                      t),
                    @coe_fn.{1 1} (measure_theory.outer_measure.{0} real)
                      (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
                      measure_theory.lebesgue_outer
                      t))))
    (@has_add.add.{0} ennreal
       (@distrib.to_has_add.{0} ennreal
          (@semiring.to_distrib.{0} ennreal
             (@comm_semiring.to_semiring.{0} ennreal
                (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1))))
       (@tsum.{0 0} ennreal nat
          (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))
          ennreal.topological_space
          (λ (i : nat), measure_theory.lebesgue_length (f i)))
       (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
          ε))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>199      (ennreal.zero_lt_coe_iff.2 ε0) ℕ with ⟨ε&#x27;, ε&#x27;0, hε⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='ennreal.zero_lt_coe_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='ε0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/ennreal.lean&#x27;, &#x27;line&#x27;: 218, &#x27;column&#x27;: 25}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {p : nnreal}, iff (@has_lt.lt.{0} ennreal (@preorder.to_has_lt.{0} ennreal (@partial_order.to_preorder.{0} ennreal (@ordered_comm_monoid.to_partial_order.{0} ennreal (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal ennreal.canonically_ordered_comm_semiring_1))))) (@has_zero.zero.{0} ennreal (@zero_ne_one_class.to_has_zero.{0} ennreal (@canonically_ordered_comm_semiring.to_zero_ne_one_class.{0} ennreal ennreal.canonically_ordered_comm_semiring_1))) (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe)) p)) (@has_lt.lt.{0} nnreal (@preorder.to_has_lt.{0} nnreal (@partial_order.to_preorder.{0} nnreal (@ordered_comm_monoid.to_partial_order.{0} nnreal (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring)))))) (@has_zero.zero.{0} nnreal nnreal.has_zero) p)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_lt.lt.{0} nnreal (@preorder.to_has_lt.{0} nnreal (@partial_order.to_preorder.{0} nnreal (@ordered_comm_monoid.to_partial_order.{0} nnreal (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring)))))) (@has_zero.zero.{0} nnreal nnreal.has_zero) ε'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} real,
f : nat → set.{0} real,
hf : @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) s (@set.Union.{0 1} real nat (λ (i : nat), f i)),
ε : nnreal,
ε0 :
  @has_lt.lt.{0} nnreal
    (@preorder.to_has_lt.{0} nnreal
       (@partial_order.to_preorder.{0} nnreal
          (@ordered_comm_monoid.to_partial_order.{0} nnreal
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                   (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
    (@has_zero.zero.{0} nnreal nnreal.has_zero)
    ε,
h :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat), measure_theory.lebesgue_length (f i)))
    (@lattice.has_top.top.{0} ennreal
       (@lattice.order_top.to_has_top.{0} ennreal
          (@lattice.bounded_lattice.to_order_top.{0} ennreal
             (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))))
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@lattice.infi.{0 1} ennreal (set.{0} real)
       (@lattice.conditionally_complete_lattice.to_has_Inf.{0} ennreal
          (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
             (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
       (λ (t : set.{0} real),
          @lattice.infi.{0 0} ennreal (@has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) s t)
            (@lattice.conditionally_complete_lattice.to_has_Inf.{0} ennreal
               (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
                  (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
            (λ (st : @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) s t),
               @lattice.infi.{0 0} ennreal
                 (@is_measurable.{0} real
                    (@borel.{0} real
                       (@uniform_space.to_topological_space.{0} real
                          (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)))
                    t)
                 (@lattice.conditionally_complete_lattice.to_has_Inf.{0} ennreal
                    (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
                       (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal
                          ennreal.complete_linear_order_1)))
                 (λ
                  (ht :
                    @is_measurable.{0} real
                      (@borel.{0} real
                         (@uniform_space.to_topological_space.{0} real
                            (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)))
                      t),
                    @coe_fn.{1 1} (measure_theory.outer_measure.{0} real)
                      (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
                      measure_theory.lebesgue_outer
                      t))))
    (@has_add.add.{0} ennreal
       (@distrib.to_has_add.{0} ennreal
          (@semiring.to_distrib.{0} ennreal
             (@comm_semiring.to_semiring.{0} ennreal
                (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1))))
       (@tsum.{0 0} ennreal nat
          (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))
          ennreal.topological_space
          (λ (i : nat), measure_theory.lebesgue_length (f i)))
       (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
          ε))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} real,
f : nat → set.{0} real,
hf : @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) s (@set.Union.{0 1} real nat (λ (i : nat), f i)),
ε : nnreal,
ε0 :
  @has_lt.lt.{0} nnreal
    (@preorder.to_has_lt.{0} nnreal
       (@partial_order.to_preorder.{0} nnreal
          (@ordered_comm_monoid.to_partial_order.{0} nnreal
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                   (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
    (@has_zero.zero.{0} nnreal nnreal.has_zero)
    ε,
h :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat), measure_theory.lebesgue_length (f i)))
    (@lattice.has_top.top.{0} ennreal
       (@lattice.order_top.to_has_top.{0} ennreal
          (@lattice.bounded_lattice.to_order_top.{0} ennreal
             (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))))),
ε&#x27; : nat → nnreal,
ε&#x27;0 :
  ∀ (i : nat),
    @has_lt.lt.{0} nnreal
      (@preorder.to_has_lt.{0} nnreal
         (@partial_order.to_preorder.{0} nnreal
            (@ordered_comm_monoid.to_partial_order.{0} nnreal
               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                     (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
      (@has_zero.zero.{0} nnreal nnreal.has_zero)
      (ε&#x27; i),
hε :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat),
          @coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
            (ε&#x27; i)))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe)) ε)
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@lattice.infi.{0 1} ennreal (set.{0} real)
       (@lattice.conditionally_complete_lattice.to_has_Inf.{0} ennreal
          (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
             (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
       (λ (t : set.{0} real),
          @lattice.infi.{0 0} ennreal (@has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) s t)
            (@lattice.conditionally_complete_lattice.to_has_Inf.{0} ennreal
               (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
                  (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
            (λ (st : @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) s t),
               @lattice.infi.{0 0} ennreal
                 (@is_measurable.{0} real
                    (@borel.{0} real
                       (@uniform_space.to_topological_space.{0} real
                          (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)))
                    t)
                 (@lattice.conditionally_complete_lattice.to_has_Inf.{0} ennreal
                    (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
                       (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal
                          ennreal.complete_linear_order_1)))
                 (λ
                  (ht :
                    @is_measurable.{0} real
                      (@borel.{0} real
                         (@uniform_space.to_topological_space.{0} real
                            (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)))
                      t),
                    @coe_fn.{1 1} (measure_theory.outer_measure.{0} real)
                      (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
                      measure_theory.lebesgue_outer
                      t))))
    (@has_add.add.{0} ennreal
       (@distrib.to_has_add.{0} ennreal
          (@semiring.to_distrib.{0} ennreal
             (@comm_semiring.to_semiring.{0} ennreal
                (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1))))
       (@tsum.{0 0} ennreal nat
          (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))
          ennreal.topological_space
          (λ (i : nat), measure_theory.lebesgue_length (f i)))
       (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
          ε))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>200    refine le_trans _ (add_le_add_left&#x27; (le_of_lt hε)),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='le_trans'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='add_le_add_left&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='le_of_lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hε'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 33, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/ordered_group.lean&#x27;, &#x27;line&#x27;: 37, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 99, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : preorder.{0} α] {a b c : α}, @has_le.le.{0} α (@preorder.to_has_le.{0} α _inst_1) a b → @has_le.le.{0} α (@preorder.to_has_le.{0} α _inst_1) b c → @has_le.le.{0} α (@preorder.to_has_le.{0} α _inst_1) a c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type} [_inst_1 : ordered_comm_monoid.{0} α] {a b c : α}, @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@ordered_comm_monoid.to_partial_order.{0} α _inst_1))) a b → @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@ordered_comm_monoid.to_partial_order.{0} α _inst_1))) (@has_add.add.{0} α (@add_semigroup.to_has_add.{0} α (@add_monoid.to_add_semigroup.{0} α (@add_comm_monoid.to_add_monoid.{0} α (@ordered_comm_monoid.to_add_comm_monoid.{0} α _inst_1)))) c a) (@has_add.add.{0} α (@add_semigroup.to_has_add.{0} α (@add_monoid.to_add_semigroup.{0} α (@add_comm_monoid.to_add_monoid.{0} α (@ordered_comm_monoid.to_add_comm_monoid.{0} α _inst_1)))) c b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type} [_inst_1 : preorder.{0} α] {a b : α}, @has_lt.lt.{0} α (@preorder.to_has_lt.{0} α _inst_1) a b → @has_le.le.{0} α (@preorder.to_has_le.{0} α _inst_1) a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_lt.lt.{0} ennreal (@preorder.to_has_lt.{0} ennreal (@partial_order.to_preorder.{0} ennreal (@ordered_comm_monoid.to_partial_order.{0} ennreal (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal ennreal.canonically_ordered_comm_semiring_1))))) (@tsum.{0 0} ennreal nat (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal ennreal.canonically_ordered_comm_semiring_1))) ennreal.topological_space (λ (i : nat), @coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe)) (ε&#x27; i))) (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe)) ε)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} real,
f : nat → set.{0} real,
hf : @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) s (@set.Union.{0 1} real nat (λ (i : nat), f i)),
ε : nnreal,
ε0 :
  @has_lt.lt.{0} nnreal
    (@preorder.to_has_lt.{0} nnreal
       (@partial_order.to_preorder.{0} nnreal
          (@ordered_comm_monoid.to_partial_order.{0} nnreal
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                   (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
    (@has_zero.zero.{0} nnreal nnreal.has_zero)
    ε,
h :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat), measure_theory.lebesgue_length (f i)))
    (@lattice.has_top.top.{0} ennreal
       (@lattice.order_top.to_has_top.{0} ennreal
          (@lattice.bounded_lattice.to_order_top.{0} ennreal
             (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))))),
ε&#x27; : nat → nnreal,
ε&#x27;0 :
  ∀ (i : nat),
    @has_lt.lt.{0} nnreal
      (@preorder.to_has_lt.{0} nnreal
         (@partial_order.to_preorder.{0} nnreal
            (@ordered_comm_monoid.to_partial_order.{0} nnreal
               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                     (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
      (@has_zero.zero.{0} nnreal nnreal.has_zero)
      (ε&#x27; i),
hε :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat),
          @coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
            (ε&#x27; i)))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe)) ε)
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@lattice.infi.{0 1} ennreal (set.{0} real)
       (@lattice.conditionally_complete_lattice.to_has_Inf.{0} ennreal
          (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
             (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
       (λ (t : set.{0} real),
          @lattice.infi.{0 0} ennreal (@has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) s t)
            (@lattice.conditionally_complete_lattice.to_has_Inf.{0} ennreal
               (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
                  (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
            (λ (st : @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) s t),
               @lattice.infi.{0 0} ennreal
                 (@is_measurable.{0} real
                    (@borel.{0} real
                       (@uniform_space.to_topological_space.{0} real
                          (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)))
                    t)
                 (@lattice.conditionally_complete_lattice.to_has_Inf.{0} ennreal
                    (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
                       (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal
                          ennreal.complete_linear_order_1)))
                 (λ
                  (ht :
                    @is_measurable.{0} real
                      (@borel.{0} real
                         (@uniform_space.to_topological_space.{0} real
                            (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)))
                      t),
                    @coe_fn.{1 1} (measure_theory.outer_measure.{0} real)
                      (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
                      measure_theory.lebesgue_outer
                      t))))
    (@has_add.add.{0} ennreal
       (@distrib.to_has_add.{0} ennreal
          (@semiring.to_distrib.{0} ennreal
             (@comm_semiring.to_semiring.{0} ennreal
                (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1))))
       (@tsum.{0 0} ennreal nat
          (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))
          ennreal.topological_space
          (λ (i : nat), measure_theory.lebesgue_length (f i)))
       (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
          ε))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} real,
f : nat → set.{0} real,
hf : @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) s (@set.Union.{0 1} real nat (λ (i : nat), f i)),
ε : nnreal,
ε0 :
  @has_lt.lt.{0} nnreal
    (@preorder.to_has_lt.{0} nnreal
       (@partial_order.to_preorder.{0} nnreal
          (@ordered_comm_monoid.to_partial_order.{0} nnreal
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                   (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
    (@has_zero.zero.{0} nnreal nnreal.has_zero)
    ε,
h :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat), measure_theory.lebesgue_length (f i)))
    (@lattice.has_top.top.{0} ennreal
       (@lattice.order_top.to_has_top.{0} ennreal
          (@lattice.bounded_lattice.to_order_top.{0} ennreal
             (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))))),
ε&#x27; : nat → nnreal,
ε&#x27;0 :
  ∀ (i : nat),
    @has_lt.lt.{0} nnreal
      (@preorder.to_has_lt.{0} nnreal
         (@partial_order.to_preorder.{0} nnreal
            (@ordered_comm_monoid.to_partial_order.{0} nnreal
               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                     (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
      (@has_zero.zero.{0} nnreal nnreal.has_zero)
      (ε&#x27; i),
hε :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat),
          @coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
            (ε&#x27; i)))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe)) ε)
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@lattice.infi.{0 1} ennreal (set.{0} real)
       (@lattice.conditionally_complete_lattice.to_has_Inf.{0} ennreal
          (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
             (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
       (λ (t : set.{0} real),
          @lattice.infi.{0 0} ennreal (@has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) s t)
            (@lattice.conditionally_complete_lattice.to_has_Inf.{0} ennreal
               (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
                  (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
            (λ (st : @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) s t),
               @lattice.infi.{0 0} ennreal
                 (@is_measurable.{0} real
                    (@borel.{0} real
                       (@uniform_space.to_topological_space.{0} real
                          (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)))
                    t)
                 (@lattice.conditionally_complete_lattice.to_has_Inf.{0} ennreal
                    (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
                       (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal
                          ennreal.complete_linear_order_1)))
                 (λ
                  (ht :
                    @is_measurable.{0} real
                      (@borel.{0} real
                         (@uniform_space.to_topological_space.{0} real
                            (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)))
                      t),
                    @coe_fn.{1 1} (measure_theory.outer_measure.{0} real)
                      (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
                      measure_theory.lebesgue_outer
                      t))))
    (@has_add.add.{0} ennreal
       (@add_semigroup.to_has_add.{0} ennreal
          (@add_monoid.to_add_semigroup.{0} ennreal
             (@add_comm_monoid.to_add_monoid.{0} ennreal
                (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
                   (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                      (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                         ennreal.canonically_ordered_comm_semiring_1))))))
       (@tsum.{0 0} ennreal nat
          (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))
          ennreal.topological_space
          (λ (i : nat), measure_theory.lebesgue_length (f i)))
       (@tsum.{0 0} ennreal nat
          (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))
          ennreal.topological_space
          (λ (i : nat),
             @coe.{1 1} nnreal ennreal
               (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
               (ε&#x27; i))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>201    rw ← ennreal.tsum_add,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='ennreal.tsum_add'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/instances/ennreal.lean&#x27;, &#x27;line&#x27;: 470, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} {f g : α → ennreal}, @eq.{1} ennreal (@tsum.{0 0} ennreal α (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal ennreal.canonically_ordered_comm_semiring_1))) ennreal.topological_space (λ (a : α), @has_add.add.{0} ennreal (@distrib.to_has_add.{0} ennreal (@semiring.to_distrib.{0} ennreal (@comm_semiring.to_semiring.{0} ennreal (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal ennreal.canonically_ordered_comm_semiring_1)))) (f a) (g a))) (@has_add.add.{0} ennreal (@distrib.to_has_add.{0} ennreal (@semiring.to_distrib.{0} ennreal (@comm_semiring.to_semiring.{0} ennreal (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal ennreal.canonically_ordered_comm_semiring_1)))) (@tsum.{0 0} ennreal α (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal ennreal.canonically_ordered_comm_semiring_1))) ennreal.topological_space (λ (a : α), f a)) (@tsum.{0 0} ennreal α (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal ennreal.canonically_ordered_comm_semiring_1))) ennreal.topological_space (λ (a : α), g a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} real,
f : nat → set.{0} real,
hf : @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) s (@set.Union.{0 1} real nat (λ (i : nat), f i)),
ε : nnreal,
ε0 :
  @has_lt.lt.{0} nnreal
    (@preorder.to_has_lt.{0} nnreal
       (@partial_order.to_preorder.{0} nnreal
          (@ordered_comm_monoid.to_partial_order.{0} nnreal
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                   (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
    (@has_zero.zero.{0} nnreal nnreal.has_zero)
    ε,
h :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat), measure_theory.lebesgue_length (f i)))
    (@lattice.has_top.top.{0} ennreal
       (@lattice.order_top.to_has_top.{0} ennreal
          (@lattice.bounded_lattice.to_order_top.{0} ennreal
             (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))))),
ε&#x27; : nat → nnreal,
ε&#x27;0 :
  ∀ (i : nat),
    @has_lt.lt.{0} nnreal
      (@preorder.to_has_lt.{0} nnreal
         (@partial_order.to_preorder.{0} nnreal
            (@ordered_comm_monoid.to_partial_order.{0} nnreal
               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                     (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
      (@has_zero.zero.{0} nnreal nnreal.has_zero)
      (ε&#x27; i),
hε :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat),
          @coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
            (ε&#x27; i)))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe)) ε)
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@lattice.infi.{0 1} ennreal (set.{0} real)
       (@lattice.conditionally_complete_lattice.to_has_Inf.{0} ennreal
          (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
             (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
       (λ (t : set.{0} real),
          @lattice.infi.{0 0} ennreal (@has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) s t)
            (@lattice.conditionally_complete_lattice.to_has_Inf.{0} ennreal
               (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
                  (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
            (λ (st : @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) s t),
               @lattice.infi.{0 0} ennreal
                 (@is_measurable.{0} real
                    (@borel.{0} real
                       (@uniform_space.to_topological_space.{0} real
                          (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)))
                    t)
                 (@lattice.conditionally_complete_lattice.to_has_Inf.{0} ennreal
                    (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
                       (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal
                          ennreal.complete_linear_order_1)))
                 (λ
                  (ht :
                    @is_measurable.{0} real
                      (@borel.{0} real
                         (@uniform_space.to_topological_space.{0} real
                            (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)))
                      t),
                    @coe_fn.{1 1} (measure_theory.outer_measure.{0} real)
                      (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
                      measure_theory.lebesgue_outer
                      t))))
    (@has_add.add.{0} ennreal
       (@add_semigroup.to_has_add.{0} ennreal
          (@add_monoid.to_add_semigroup.{0} ennreal
             (@add_comm_monoid.to_add_monoid.{0} ennreal
                (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
                   (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                      (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                         ennreal.canonically_ordered_comm_semiring_1))))))
       (@tsum.{0 0} ennreal nat
          (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))
          ennreal.topological_space
          (λ (i : nat), measure_theory.lebesgue_length (f i)))
       (@tsum.{0 0} ennreal nat
          (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))
          ennreal.topological_space
          (λ (i : nat),
             @coe.{1 1} nnreal ennreal
               (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
               (ε&#x27; i))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} real,
f : nat → set.{0} real,
hf : @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) s (@set.Union.{0 1} real nat (λ (i : nat), f i)),
ε : nnreal,
ε0 :
  @has_lt.lt.{0} nnreal
    (@preorder.to_has_lt.{0} nnreal
       (@partial_order.to_preorder.{0} nnreal
          (@ordered_comm_monoid.to_partial_order.{0} nnreal
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                   (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
    (@has_zero.zero.{0} nnreal nnreal.has_zero)
    ε,
h :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat), measure_theory.lebesgue_length (f i)))
    (@lattice.has_top.top.{0} ennreal
       (@lattice.order_top.to_has_top.{0} ennreal
          (@lattice.bounded_lattice.to_order_top.{0} ennreal
             (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))))),
ε&#x27; : nat → nnreal,
ε&#x27;0 :
  ∀ (i : nat),
    @has_lt.lt.{0} nnreal
      (@preorder.to_has_lt.{0} nnreal
         (@partial_order.to_preorder.{0} nnreal
            (@ordered_comm_monoid.to_partial_order.{0} nnreal
               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                     (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
      (@has_zero.zero.{0} nnreal nnreal.has_zero)
      (ε&#x27; i),
hε :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat),
          @coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
            (ε&#x27; i)))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe)) ε)
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@lattice.infi.{0 1} ennreal (set.{0} real)
       (@lattice.conditionally_complete_lattice.to_has_Inf.{0} ennreal
          (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
             (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
       (λ (t : set.{0} real),
          @lattice.infi.{0 0} ennreal (@has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) s t)
            (@lattice.conditionally_complete_lattice.to_has_Inf.{0} ennreal
               (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
                  (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
            (λ (st : @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) s t),
               @lattice.infi.{0 0} ennreal
                 (@is_measurable.{0} real
                    (@borel.{0} real
                       (@uniform_space.to_topological_space.{0} real
                          (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)))
                    t)
                 (@lattice.conditionally_complete_lattice.to_has_Inf.{0} ennreal
                    (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
                       (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal
                          ennreal.complete_linear_order_1)))
                 (λ
                  (ht :
                    @is_measurable.{0} real
                      (@borel.{0} real
                         (@uniform_space.to_topological_space.{0} real
                            (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)))
                      t),
                    @coe_fn.{1 1} (measure_theory.outer_measure.{0} real)
                      (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
                      measure_theory.lebesgue_outer
                      t))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (a : nat),
          @has_add.add.{0} ennreal
            (@distrib.to_has_add.{0} ennreal
               (@semiring.to_distrib.{0} ennreal
                  (@comm_semiring.to_semiring.{0} ennreal
                     (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                        ennreal.canonically_ordered_comm_semiring_1))))
            (measure_theory.lebesgue_length (f a))
            (@coe.{1 1} nnreal ennreal
               (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
               (ε&#x27; a))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>202    choose g hg using show</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 511, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 511, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse name (λ (a : name), name.reflect a) lean.parser.ident → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse name (λ (a : name), name.reflect a) lean.parser.ident → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title=' `choose a b h using hyp` takes an hypothesis `hyp` of the form
`∀ (x : X) (y : Y), ∃ (a : A) (b : B), P x y a b` for some `P : X → Y → A → B → Prop` and outputs
into context a function `a : X → Y → A`, `b : X → Y → B` and a proposition `h` stating
`∀ (x : X) (y : Y), P x y (a x y) (b x y)`. It presumably also works with dependent versions.

Example:

```lean
example (h : ∀n m : ℕ, ∃i j, m = n + i ∨ m + j = n) : true :=
begin
  choose i j h using h,
  guard_hyp i := ℕ → ℕ → ℕ,
  guard_hyp j := ℕ → ℕ → ℕ,
  guard_hyp h := ∀ (n m : ℕ), m = n + i n m ∨ m + j n m = n,
  trivial
end
```'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title=' `choose a b h using hyp` takes an hypothesis `hyp` of the form
`∀ (x : X) (y : Y), ∃ (a : A) (b : B), P x y a b` for some `P : X → Y → A → B → Prop` and outputs
into context a function `a : X → Y → A`, `b : X → Y → B` and a proposition `h` stating
`∀ (x : X) (y : Y), P x y (a x y) (b x y)`. It presumably also works with dependent versions.

Example:

```lean
example (h : ∀n m : ℕ, ∃i j, m = n + i ∨ m + j = n) : true :=
begin
  choose i j h using h,
  guard_hyp i := ℕ → ℕ → ℕ,
  guard_hyp j := ℕ → ℕ → ℕ,
  guard_hyp h := ∀ (n m : ℕ), m = n + i n m ∨ m + j n m = n,
  trivial
end
```'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='choose'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='choose'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id&#x27;, &#x27;id*&#x27;, &#x27;(using expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id&#x27;, &#x27;id*&#x27;, &#x27;(using expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} real,
f : nat → set.{0} real,
hf : @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) s (@set.Union.{0 1} real nat (λ (i : nat), f i)),
ε : nnreal,
ε0 :
  @has_lt.lt.{0} nnreal
    (@preorder.to_has_lt.{0} nnreal
       (@partial_order.to_preorder.{0} nnreal
          (@ordered_comm_monoid.to_partial_order.{0} nnreal
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                   (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
    (@has_zero.zero.{0} nnreal nnreal.has_zero)
    ε,
h :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat), measure_theory.lebesgue_length (f i)))
    (@lattice.has_top.top.{0} ennreal
       (@lattice.order_top.to_has_top.{0} ennreal
          (@lattice.bounded_lattice.to_order_top.{0} ennreal
             (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))))),
ε&#x27; : nat → nnreal,
ε&#x27;0 :
  ∀ (i : nat),
    @has_lt.lt.{0} nnreal
      (@preorder.to_has_lt.{0} nnreal
         (@partial_order.to_preorder.{0} nnreal
            (@ordered_comm_monoid.to_partial_order.{0} nnreal
               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                     (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
      (@has_zero.zero.{0} nnreal nnreal.has_zero)
      (ε&#x27; i),
hε :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat),
          @coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
            (ε&#x27; i)))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe)) ε)
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@lattice.infi.{0 1} ennreal (set.{0} real)
       (@lattice.conditionally_complete_lattice.to_has_Inf.{0} ennreal
          (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
             (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
       (λ (t : set.{0} real),
          @lattice.infi.{0 0} ennreal (@has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) s t)
            (@lattice.conditionally_complete_lattice.to_has_Inf.{0} ennreal
               (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
                  (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
            (λ (st : @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) s t),
               @lattice.infi.{0 0} ennreal
                 (@is_measurable.{0} real
                    (@borel.{0} real
                       (@uniform_space.to_topological_space.{0} real
                          (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)))
                    t)
                 (@lattice.conditionally_complete_lattice.to_has_Inf.{0} ennreal
                    (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
                       (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal
                          ennreal.complete_linear_order_1)))
                 (λ
                  (ht :
                    @is_measurable.{0} real
                      (@borel.{0} real
                         (@uniform_space.to_topological_space.{0} real
                            (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)))
                      t),
                    @coe_fn.{1 1} (measure_theory.outer_measure.{0} real)
                      (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
                      measure_theory.lebesgue_outer
                      t))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (a : nat),
          @has_add.add.{0} ennreal
            (@distrib.to_has_add.{0} ennreal
               (@semiring.to_distrib.{0} ennreal
                  (@comm_semiring.to_semiring.{0} ennreal
                     (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                        ennreal.canonically_ordered_comm_semiring_1))))
            (measure_theory.lebesgue_length (f a))
            (@coe.{1 1} nnreal ennreal
               (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
               (ε&#x27; a))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>203      ∀ i, ∃ s, f i ⊆ s ∧ is_measurable s ∧ lebesgue_outer s ≤ lebesgue_length (f i) + of_real (ε&#x27; i),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='has_subset.subset'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='is_measurable'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='measure_theory.lebesgue_outer'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='has_le.le'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='measure_theory.lebesgue_length'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='nnreal.of_real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ε&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 511, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 511, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 511, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 511, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 511, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 511, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 511, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 327, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 511, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 511, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 511, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measurable_space.lean&#x27;, &#x27;line&#x27;: 79, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 511, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 511, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 511, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 87, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 511, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 511, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 319, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 511, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 17, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 511, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 511, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 511, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 511, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/nnreal.lean&#x27;, &#x27;line&#x27;: 32, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 511, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 511, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 511, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse name (λ (a : name), name.reflect a) lean.parser.ident → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse name (λ (a : name), name.reflect a) lean.parser.ident → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse name (λ (a : name), name.reflect a) lean.parser.ident → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse name (λ (a : name), name.reflect a) lean.parser.ident → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse name (λ (a : name), name.reflect a) lean.parser.ident → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse name (λ (a : name), name.reflect a) lean.parser.ident → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse name (λ (a : name), name.reflect a) lean.parser.ident → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} [c : has_subset.{0} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse name (λ (a : name), name.reflect a) lean.parser.ident → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse name (λ (a : name), name.reflect a) lean.parser.ident → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse name (λ (a : name), name.reflect a) lean.parser.ident → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} [_inst_1 : measurable_space.{0} α], set.{0} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse name (λ (a : name), name.reflect a) lean.parser.ident → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse name (λ (a : name), name.reflect a) lean.parser.ident → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse name (λ (a : name), name.reflect a) lean.parser.ident → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='measure_theory.outer_measure.{0} real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse name (λ (a : name), name.reflect a) lean.parser.ident → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse name (λ (a : name), name.reflect a) lean.parser.ident → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} [c : has_le.{0} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse name (λ (a : name), name.reflect a) lean.parser.ident → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{0} real → ennreal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse name (λ (a : name), name.reflect a) lean.parser.ident → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat → set.{0} real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse name (λ (a : name), name.reflect a) lean.parser.ident → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse name (λ (a : name), name.reflect a) lean.parser.ident → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} [c : has_add.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse name (λ (a : name), name.reflect a) lean.parser.ident → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='real → nnreal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse name (λ (a : name), name.reflect a) lean.parser.ident → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat → nnreal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse name (λ (a : name), name.reflect a) lean.parser.ident → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse name (λ (a : name), name.reflect a) lean.parser.ident → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title=' `choose a b h using hyp` takes an hypothesis `hyp` of the form
`∀ (x : X) (y : Y), ∃ (a : A) (b : B), P x y a b` for some `P : X → Y → A → B → Prop` and outputs
into context a function `a : X → Y → A`, `b : X → Y → B` and a proposition `h` stating
`∀ (x : X) (y : Y), P x y (a x y) (b x y)`. It presumably also works with dependent versions.

Example:

```lean
example (h : ∀n m : ℕ, ∃i j, m = n + i ∨ m + j = n) : true :=
begin
  choose i j h using h,
  guard_hyp i := ℕ → ℕ → ℕ,
  guard_hyp j := ℕ → ℕ → ℕ,
  guard_hyp h := ∀ (n m : ℕ), m = n + i n m ∨ m + j n m = n,
  trivial
end
```'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title=' `choose a b h using hyp` takes an hypothesis `hyp` of the form
`∀ (x : X) (y : Y), ∃ (a : A) (b : B), P x y a b` for some `P : X → Y → A → B → Prop` and outputs
into context a function `a : X → Y → A`, `b : X → Y → B` and a proposition `h` stating
`∀ (x : X) (y : Y), P x y (a x y) (b x y)`. It presumably also works with dependent versions.

Example:

```lean
example (h : ∀n m : ℕ, ∃i j, m = n + i ∨ m + j = n) : true :=
begin
  choose i j h using h,
  guard_hyp i := ℕ → ℕ → ℕ,
  guard_hyp j := ℕ → ℕ → ℕ,
  guard_hyp h := ∀ (n m : ℕ), m = n + i n m ∨ m + j n m = n,
  trivial
end
```'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title=' `choose a b h using hyp` takes an hypothesis `hyp` of the form
`∀ (x : X) (y : Y), ∃ (a : A) (b : B), P x y a b` for some `P : X → Y → A → B → Prop` and outputs
into context a function `a : X → Y → A`, `b : X → Y → B` and a proposition `h` stating
`∀ (x : X) (y : Y), P x y (a x y) (b x y)`. It presumably also works with dependent versions.

Example:

```lean
example (h : ∀n m : ℕ, ∃i j, m = n + i ∨ m + j = n) : true :=
begin
  choose i j h using h,
  guard_hyp i := ℕ → ℕ → ℕ,
  guard_hyp j := ℕ → ℕ → ℕ,
  guard_hyp h := ∀ (n m : ℕ), m = n + i n m ∨ m + j n m = n,
  trivial
end
```'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title=' `choose a b h using hyp` takes an hypothesis `hyp` of the form
`∀ (x : X) (y : Y), ∃ (a : A) (b : B), P x y a b` for some `P : X → Y → A → B → Prop` and outputs
into context a function `a : X → Y → A`, `b : X → Y → B` and a proposition `h` stating
`∀ (x : X) (y : Y), P x y (a x y) (b x y)`. It presumably also works with dependent versions.

Example:

```lean
example (h : ∀n m : ℕ, ∃i j, m = n + i ∨ m + j = n) : true :=
begin
  choose i j h using h,
  guard_hyp i := ℕ → ℕ → ℕ,
  guard_hyp j := ℕ → ℕ → ℕ,
  guard_hyp h := ∀ (n m : ℕ), m = n + i n m ∨ m + j n m = n,
  trivial
end
```'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title=' `choose a b h using hyp` takes an hypothesis `hyp` of the form
`∀ (x : X) (y : Y), ∃ (a : A) (b : B), P x y a b` for some `P : X → Y → A → B → Prop` and outputs
into context a function `a : X → Y → A`, `b : X → Y → B` and a proposition `h` stating
`∀ (x : X) (y : Y), P x y (a x y) (b x y)`. It presumably also works with dependent versions.

Example:

```lean
example (h : ∀n m : ℕ, ∃i j, m = n + i ∨ m + j = n) : true :=
begin
  choose i j h using h,
  guard_hyp i := ℕ → ℕ → ℕ,
  guard_hyp j := ℕ → ℕ → ℕ,
  guard_hyp h := ∀ (n m : ℕ), m = n + i n m ∨ m + j n m = n,
  trivial
end
```'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title=' `choose a b h using hyp` takes an hypothesis `hyp` of the form
`∀ (x : X) (y : Y), ∃ (a : A) (b : B), P x y a b` for some `P : X → Y → A → B → Prop` and outputs
into context a function `a : X → Y → A`, `b : X → Y → B` and a proposition `h` stating
`∀ (x : X) (y : Y), P x y (a x y) (b x y)`. It presumably also works with dependent versions.

Example:

```lean
example (h : ∀n m : ℕ, ∃i j, m = n + i ∨ m + j = n) : true :=
begin
  choose i j h using h,
  guard_hyp i := ℕ → ℕ → ℕ,
  guard_hyp j := ℕ → ℕ → ℕ,
  guard_hyp h := ∀ (n m : ℕ), m = n + i n m ∨ m + j n m = n,
  trivial
end
```'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title=' `choose a b h using hyp` takes an hypothesis `hyp` of the form
`∀ (x : X) (y : Y), ∃ (a : A) (b : B), P x y a b` for some `P : X → Y → A → B → Prop` and outputs
into context a function `a : X → Y → A`, `b : X → Y → B` and a proposition `h` stating
`∀ (x : X) (y : Y), P x y (a x y) (b x y)`. It presumably also works with dependent versions.

Example:

```lean
example (h : ∀n m : ℕ, ∃i j, m = n + i ∨ m + j = n) : true :=
begin
  choose i j h using h,
  guard_hyp i := ℕ → ℕ → ℕ,
  guard_hyp j := ℕ → ℕ → ℕ,
  guard_hyp h := ∀ (n m : ℕ), m = n + i n m ∨ m + j n m = n,
  trivial
end
```'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title=' `choose a b h using hyp` takes an hypothesis `hyp` of the form
`∀ (x : X) (y : Y), ∃ (a : A) (b : B), P x y a b` for some `P : X → Y → A → B → Prop` and outputs
into context a function `a : X → Y → A`, `b : X → Y → B` and a proposition `h` stating
`∀ (x : X) (y : Y), P x y (a x y) (b x y)`. It presumably also works with dependent versions.

Example:

```lean
example (h : ∀n m : ℕ, ∃i j, m = n + i ∨ m + j = n) : true :=
begin
  choose i j h using h,
  guard_hyp i := ℕ → ℕ → ℕ,
  guard_hyp j := ℕ → ℕ → ℕ,
  guard_hyp h := ∀ (n m : ℕ), m = n + i n m ∨ m + j n m = n,
  trivial
end
```'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title=' `choose a b h using hyp` takes an hypothesis `hyp` of the form
`∀ (x : X) (y : Y), ∃ (a : A) (b : B), P x y a b` for some `P : X → Y → A → B → Prop` and outputs
into context a function `a : X → Y → A`, `b : X → Y → B` and a proposition `h` stating
`∀ (x : X) (y : Y), P x y (a x y) (b x y)`. It presumably also works with dependent versions.

Example:

```lean
example (h : ∀n m : ℕ, ∃i j, m = n + i ∨ m + j = n) : true :=
begin
  choose i j h using h,
  guard_hyp i := ℕ → ℕ → ℕ,
  guard_hyp j := ℕ → ℕ → ℕ,
  guard_hyp h := ∀ (n m : ℕ), m = n + i n m ∨ m + j n m = n,
  trivial
end
```'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title=' `choose a b h using hyp` takes an hypothesis `hyp` of the form
`∀ (x : X) (y : Y), ∃ (a : A) (b : B), P x y a b` for some `P : X → Y → A → B → Prop` and outputs
into context a function `a : X → Y → A`, `b : X → Y → B` and a proposition `h` stating
`∀ (x : X) (y : Y), P x y (a x y) (b x y)`. It presumably also works with dependent versions.

Example:

```lean
example (h : ∀n m : ℕ, ∃i j, m = n + i ∨ m + j = n) : true :=
begin
  choose i j h using h,
  guard_hyp i := ℕ → ℕ → ℕ,
  guard_hyp j := ℕ → ℕ → ℕ,
  guard_hyp h := ∀ (n m : ℕ), m = n + i n m ∨ m + j n m = n,
  trivial
end
```'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`is_measurable s` means that `s` is measurable (in the ambient measure space on `α`)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title=' `choose a b h using hyp` takes an hypothesis `hyp` of the form
`∀ (x : X) (y : Y), ∃ (a : A) (b : B), P x y a b` for some `P : X → Y → A → B → Prop` and outputs
into context a function `a : X → Y → A`, `b : X → Y → B` and a proposition `h` stating
`∀ (x : X) (y : Y), P x y (a x y) (b x y)`. It presumably also works with dependent versions.

Example:

```lean
example (h : ∀n m : ℕ, ∃i j, m = n + i ∨ m + j = n) : true :=
begin
  choose i j h using h,
  guard_hyp i := ℕ → ℕ → ℕ,
  guard_hyp j := ℕ → ℕ → ℕ,
  guard_hyp h := ∀ (n m : ℕ), m = n + i n m ∨ m + j n m = n,
  trivial
end
```'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title=' `choose a b h using hyp` takes an hypothesis `hyp` of the form
`∀ (x : X) (y : Y), ∃ (a : A) (b : B), P x y a b` for some `P : X → Y → A → B → Prop` and outputs
into context a function `a : X → Y → A`, `b : X → Y → B` and a proposition `h` stating
`∀ (x : X) (y : Y), P x y (a x y) (b x y)`. It presumably also works with dependent versions.

Example:

```lean
example (h : ∀n m : ℕ, ∃i j, m = n + i ∨ m + j = n) : true :=
begin
  choose i j h using h,
  guard_hyp i := ℕ → ℕ → ℕ,
  guard_hyp j := ℕ → ℕ → ℕ,
  guard_hyp h := ∀ (n m : ℕ), m = n + i n m ∨ m + j n m = n,
  trivial
end
```'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title=' `choose a b h using hyp` takes an hypothesis `hyp` of the form
`∀ (x : X) (y : Y), ∃ (a : A) (b : B), P x y a b` for some `P : X → Y → A → B → Prop` and outputs
into context a function `a : X → Y → A`, `b : X → Y → B` and a proposition `h` stating
`∀ (x : X) (y : Y), P x y (a x y) (b x y)`. It presumably also works with dependent versions.

Example:

```lean
example (h : ∀n m : ℕ, ∃i j, m = n + i ∨ m + j = n) : true :=
begin
  choose i j h using h,
  guard_hyp i := ℕ → ℕ → ℕ,
  guard_hyp j := ℕ → ℕ → ℕ,
  guard_hyp h := ∀ (n m : ℕ), m = n + i n m ∨ m + j n m = n,
  trivial
end
```'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The Lebesgue outer measure, as an outer measure of ℝ.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title=' `choose a b h using hyp` takes an hypothesis `hyp` of the form
`∀ (x : X) (y : Y), ∃ (a : A) (b : B), P x y a b` for some `P : X → Y → A → B → Prop` and outputs
into context a function `a : X → Y → A`, `b : X → Y → B` and a proposition `h` stating
`∀ (x : X) (y : Y), P x y (a x y) (b x y)`. It presumably also works with dependent versions.

Example:

```lean
example (h : ∀n m : ℕ, ∃i j, m = n + i ∨ m + j = n) : true :=
begin
  choose i j h using h,
  guard_hyp i := ℕ → ℕ → ℕ,
  guard_hyp j := ℕ → ℕ → ℕ,
  guard_hyp h := ∀ (n m : ℕ), m = n + i n m ∨ m + j n m = n,
  trivial
end
```'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title=' `choose a b h using hyp` takes an hypothesis `hyp` of the form
`∀ (x : X) (y : Y), ∃ (a : A) (b : B), P x y a b` for some `P : X → Y → A → B → Prop` and outputs
into context a function `a : X → Y → A`, `b : X → Y → B` and a proposition `h` stating
`∀ (x : X) (y : Y), P x y (a x y) (b x y)`. It presumably also works with dependent versions.

Example:

```lean
example (h : ∀n m : ℕ, ∃i j, m = n + i ∨ m + j = n) : true :=
begin
  choose i j h using h,
  guard_hyp i := ℕ → ℕ → ℕ,
  guard_hyp j := ℕ → ℕ → ℕ,
  guard_hyp h := ∀ (n m : ℕ), m = n + i n m ∨ m + j n m = n,
  trivial
end
```'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title=' `choose a b h using hyp` takes an hypothesis `hyp` of the form
`∀ (x : X) (y : Y), ∃ (a : A) (b : B), P x y a b` for some `P : X → Y → A → B → Prop` and outputs
into context a function `a : X → Y → A`, `b : X → Y → B` and a proposition `h` stating
`∀ (x : X) (y : Y), P x y (a x y) (b x y)`. It presumably also works with dependent versions.

Example:

```lean
example (h : ∀n m : ℕ, ∃i j, m = n + i ∨ m + j = n) : true :=
begin
  choose i j h using h,
  guard_hyp i := ℕ → ℕ → ℕ,
  guard_hyp j := ℕ → ℕ → ℕ,
  guard_hyp h := ∀ (n m : ℕ), m = n + i n m ∨ m + j n m = n,
  trivial
end
```'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Length of an interval. This is the largest monotonic function which correctly
 measures all intervals.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title=' `choose a b h using hyp` takes an hypothesis `hyp` of the form
`∀ (x : X) (y : Y), ∃ (a : A) (b : B), P x y a b` for some `P : X → Y → A → B → Prop` and outputs
into context a function `a : X → Y → A`, `b : X → Y → B` and a proposition `h` stating
`∀ (x : X) (y : Y), P x y (a x y) (b x y)`. It presumably also works with dependent versions.

Example:

```lean
example (h : ∀n m : ℕ, ∃i j, m = n + i ∨ m + j = n) : true :=
begin
  choose i j h using h,
  guard_hyp i := ℕ → ℕ → ℕ,
  guard_hyp j := ℕ → ℕ → ℕ,
  guard_hyp h := ∀ (n m : ℕ), m = n + i n m ∨ m + j n m = n,
  trivial
end
```'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title=' `choose a b h using hyp` takes an hypothesis `hyp` of the form
`∀ (x : X) (y : Y), ∃ (a : A) (b : B), P x y a b` for some `P : X → Y → A → B → Prop` and outputs
into context a function `a : X → Y → A`, `b : X → Y → B` and a proposition `h` stating
`∀ (x : X) (y : Y), P x y (a x y) (b x y)`. It presumably also works with dependent versions.

Example:

```lean
example (h : ∀n m : ℕ, ∃i j, m = n + i ∨ m + j = n) : true :=
begin
  choose i j h using h,
  guard_hyp i := ℕ → ℕ → ℕ,
  guard_hyp j := ℕ → ℕ → ℕ,
  guard_hyp h := ∀ (n m : ℕ), m = n + i n m ∨ m + j n m = n,
  trivial
end
```'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title=' `choose a b h using hyp` takes an hypothesis `hyp` of the form
`∀ (x : X) (y : Y), ∃ (a : A) (b : B), P x y a b` for some `P : X → Y → A → B → Prop` and outputs
into context a function `a : X → Y → A`, `b : X → Y → B` and a proposition `h` stating
`∀ (x : X) (y : Y), P x y (a x y) (b x y)`. It presumably also works with dependent versions.

Example:

```lean
example (h : ∀n m : ℕ, ∃i j, m = n + i ∨ m + j = n) : true :=
begin
  choose i j h using h,
  guard_hyp i := ℕ → ℕ → ℕ,
  guard_hyp j := ℕ → ℕ → ℕ,
  guard_hyp h := ∀ (n m : ℕ), m = n + i n m ∨ m + j n m = n,
  trivial
end
```'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title=' `choose a b h using hyp` takes an hypothesis `hyp` of the form
`∀ (x : X) (y : Y), ∃ (a : A) (b : B), P x y a b` for some `P : X → Y → A → B → Prop` and outputs
into context a function `a : X → Y → A`, `b : X → Y → B` and a proposition `h` stating
`∀ (x : X) (y : Y), P x y (a x y) (b x y)`. It presumably also works with dependent versions.

Example:

```lean
example (h : ∀n m : ℕ, ∃i j, m = n + i ∨ m + j = n) : true :=
begin
  choose i j h using h,
  guard_hyp i := ℕ → ℕ → ℕ,
  guard_hyp j := ℕ → ℕ → ℕ,
  guard_hyp h := ∀ (n m : ℕ), m = n + i n m ∨ m + j n m = n,
  trivial
end
```'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title=' `choose a b h using hyp` takes an hypothesis `hyp` of the form
`∀ (x : X) (y : Y), ∃ (a : A) (b : B), P x y a b` for some `P : X → Y → A → B → Prop` and outputs
into context a function `a : X → Y → A`, `b : X → Y → B` and a proposition `h` stating
`∀ (x : X) (y : Y), P x y (a x y) (b x y)`. It presumably also works with dependent versions.

Example:

```lean
example (h : ∀n m : ℕ, ∃i j, m = n + i ∨ m + j = n) : true :=
begin
  choose i j h using h,
  guard_hyp i := ℕ → ℕ → ℕ,
  guard_hyp j := ℕ → ℕ → ℕ,
  guard_hyp h := ∀ (n m : ℕ), m = n + i n m ∨ m + j n m = n,
  trivial
end
```'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title=' `choose a b h using hyp` takes an hypothesis `hyp` of the form
`∀ (x : X) (y : Y), ∃ (a : A) (b : B), P x y a b` for some `P : X → Y → A → B → Prop` and outputs
into context a function `a : X → Y → A`, `b : X → Y → B` and a proposition `h` stating
`∀ (x : X) (y : Y), P x y (a x y) (b x y)`. It presumably also works with dependent versions.

Example:

```lean
example (h : ∀n m : ℕ, ∃i j, m = n + i ∨ m + j = n) : true :=
begin
  choose i j h using h,
  guard_hyp i := ℕ → ℕ → ℕ,
  guard_hyp j := ℕ → ℕ → ℕ,
  guard_hyp h := ∀ (n m : ℕ), m = n + i n m ∨ m + j n m = n,
  trivial
end
```'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title=' `choose a b h using hyp` takes an hypothesis `hyp` of the form
`∀ (x : X) (y : Y), ∃ (a : A) (b : B), P x y a b` for some `P : X → Y → A → B → Prop` and outputs
into context a function `a : X → Y → A`, `b : X → Y → B` and a proposition `h` stating
`∀ (x : X) (y : Y), P x y (a x y) (b x y)`. It presumably also works with dependent versions.

Example:

```lean
example (h : ∀n m : ℕ, ∃i j, m = n + i ∨ m + j = n) : true :=
begin
  choose i j h using h,
  guard_hyp i := ℕ → ℕ → ℕ,
  guard_hyp j := ℕ → ℕ → ℕ,
  guard_hyp h := ∀ (n m : ℕ), m = n + i n m ∨ m + j n m = n,
  trivial
end
```'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='choose'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='choose'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='choose'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='choose'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='choose'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='choose'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='choose'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='choose'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='choose'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='choose'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='choose'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='choose'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='choose'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='choose'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='choose'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='choose'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='choose'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='choose'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='choose'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='choose'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='choose'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='choose'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='choose'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id&#x27;, &#x27;id*&#x27;, &#x27;(using expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id&#x27;, &#x27;id*&#x27;, &#x27;(using expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id&#x27;, &#x27;id*&#x27;, &#x27;(using expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id&#x27;, &#x27;id*&#x27;, &#x27;(using expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id&#x27;, &#x27;id*&#x27;, &#x27;(using expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id&#x27;, &#x27;id*&#x27;, &#x27;(using expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id&#x27;, &#x27;id*&#x27;, &#x27;(using expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id&#x27;, &#x27;id*&#x27;, &#x27;(using expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id&#x27;, &#x27;id*&#x27;, &#x27;(using expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id&#x27;, &#x27;id*&#x27;, &#x27;(using expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;id&#x27;, &#x27;id*&#x27;, &#x27;(using expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id&#x27;, &#x27;id*&#x27;, &#x27;(using expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id&#x27;, &#x27;id*&#x27;, &#x27;(using expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;id&#x27;, &#x27;id*&#x27;, &#x27;(using expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id&#x27;, &#x27;id*&#x27;, &#x27;(using expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id&#x27;, &#x27;id*&#x27;, &#x27;(using expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;id&#x27;, &#x27;id*&#x27;, &#x27;(using expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id&#x27;, &#x27;id*&#x27;, &#x27;(using expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id&#x27;, &#x27;id*&#x27;, &#x27;(using expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id&#x27;, &#x27;id*&#x27;, &#x27;(using expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;id&#x27;, &#x27;id*&#x27;, &#x27;(using expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;id&#x27;, &#x27;id*&#x27;, &#x27;(using expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id&#x27;, &#x27;id*&#x27;, &#x27;(using expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} real,
f : nat → set.{0} real,
hf : @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) s (@set.Union.{0 1} real nat (λ (i : nat), f i)),
ε : nnreal,
ε0 :
  @has_lt.lt.{0} nnreal
    (@preorder.to_has_lt.{0} nnreal
       (@partial_order.to_preorder.{0} nnreal
          (@ordered_comm_monoid.to_partial_order.{0} nnreal
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                   (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
    (@has_zero.zero.{0} nnreal nnreal.has_zero)
    ε,
h :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat), measure_theory.lebesgue_length (f i)))
    (@lattice.has_top.top.{0} ennreal
       (@lattice.order_top.to_has_top.{0} ennreal
          (@lattice.bounded_lattice.to_order_top.{0} ennreal
             (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))))),
ε&#x27; : nat → nnreal,
ε&#x27;0 :
  ∀ (i : nat),
    @has_lt.lt.{0} nnreal
      (@preorder.to_has_lt.{0} nnreal
         (@partial_order.to_preorder.{0} nnreal
            (@ordered_comm_monoid.to_partial_order.{0} nnreal
               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                     (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
      (@has_zero.zero.{0} nnreal nnreal.has_zero)
      (ε&#x27; i),
hε :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat),
          @coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
            (ε&#x27; i)))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe)) ε)
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@lattice.infi.{0 1} ennreal (set.{0} real)
       (@lattice.conditionally_complete_lattice.to_has_Inf.{0} ennreal
          (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
             (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
       (λ (t : set.{0} real),
          @lattice.infi.{0 0} ennreal (@has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) s t)
            (@lattice.conditionally_complete_lattice.to_has_Inf.{0} ennreal
               (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
                  (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
            (λ (st : @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) s t),
               @lattice.infi.{0 0} ennreal
                 (@is_measurable.{0} real
                    (@borel.{0} real
                       (@uniform_space.to_topological_space.{0} real
                          (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)))
                    t)
                 (@lattice.conditionally_complete_lattice.to_has_Inf.{0} ennreal
                    (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
                       (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal
                          ennreal.complete_linear_order_1)))
                 (λ
                  (ht :
                    @is_measurable.{0} real
                      (@borel.{0} real
                         (@uniform_space.to_topological_space.{0} real
                            (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)))
                      t),
                    @coe_fn.{1 1} (measure_theory.outer_measure.{0} real)
                      (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
                      measure_theory.lebesgue_outer
                      t))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (a : nat),
          @has_add.add.{0} ennreal
            (@distrib.to_has_add.{0} ennreal
               (@semiring.to_distrib.{0} ennreal
                  (@comm_semiring.to_semiring.{0} ennreal
                     (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                        ennreal.canonically_ordered_comm_semiring_1))))
            (measure_theory.lebesgue_length (f a))
            (@coe.{1 1} nnreal ennreal
               (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
               (ε&#x27; a))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>204    { intro i,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 511, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 122, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 511, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse name (λ (a : name), name.reflect a) lean.parser.ident → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse name (λ (a : name), name.reflect a) lean.parser.ident → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title=' `choose a b h using hyp` takes an hypothesis `hyp` of the form
`∀ (x : X) (y : Y), ∃ (a : A) (b : B), P x y a b` for some `P : X → Y → A → B → Prop` and outputs
into context a function `a : X → Y → A`, `b : X → Y → B` and a proposition `h` stating
`∀ (x : X) (y : Y), P x y (a x y) (b x y)`. It presumably also works with dependent versions.

Example:

```lean
example (h : ∀n m : ℕ, ∃i j, m = n + i ∨ m + j = n) : true :=
begin
  choose i j h using h,
  guard_hyp i := ℕ → ℕ → ℕ,
  guard_hyp j := ℕ → ℕ → ℕ,
  guard_hyp h := ∀ (n m : ℕ), m = n + i n m ∨ m + j n m = n,
  trivial
end
```'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='If the current goal is a Pi/forall `∀ x : t, u` (resp. `let x := t in u`) then `intro` puts `x : t` (resp. `x := t`) in the local context. The new subgoal target is `u`.

If the goal is an arrow `t → u`, then it puts `h : t` in the local context and the new goal target is `u`.

If the goal is neither a Pi/forall nor begins with a let binder, the tactic `intro` applies the tactic `whnf` until an introduction can be applied or the goal is not head reducible. In the latter case, the tactic fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title=' `choose a b h using hyp` takes an hypothesis `hyp` of the form
`∀ (x : X) (y : Y), ∃ (a : A) (b : B), P x y a b` for some `P : X → Y → A → B → Prop` and outputs
into context a function `a : X → Y → A`, `b : X → Y → B` and a proposition `h` stating
`∀ (x : X) (y : Y), P x y (a x y) (b x y)`. It presumably also works with dependent versions.

Example:

```lean
example (h : ∀n m : ℕ, ∃i j, m = n + i ∨ m + j = n) : true :=
begin
  choose i j h using h,
  guard_hyp i := ℕ → ℕ → ℕ,
  guard_hyp j := ℕ → ℕ → ℕ,
  guard_hyp h := ∀ (n m : ℕ), m = n + i n m ∨ m + j n m = n,
  trivial
end
```'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='choose'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='intro'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='choose'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id&#x27;, &#x27;id*&#x27;, &#x27;(using expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id&#x27;, &#x27;id*&#x27;, &#x27;(using expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} real,
f : nat → set.{0} real,
hf : @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) s (@set.Union.{0 1} real nat (λ (i : nat), f i)),
ε : nnreal,
ε0 :
  @has_lt.lt.{0} nnreal
    (@preorder.to_has_lt.{0} nnreal
       (@partial_order.to_preorder.{0} nnreal
          (@ordered_comm_monoid.to_partial_order.{0} nnreal
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                   (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
    (@has_zero.zero.{0} nnreal nnreal.has_zero)
    ε,
h :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat), measure_theory.lebesgue_length (f i)))
    (@lattice.has_top.top.{0} ennreal
       (@lattice.order_top.to_has_top.{0} ennreal
          (@lattice.bounded_lattice.to_order_top.{0} ennreal
             (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))))),
ε&#x27; : nat → nnreal,
ε&#x27;0 :
  ∀ (i : nat),
    @has_lt.lt.{0} nnreal
      (@preorder.to_has_lt.{0} nnreal
         (@partial_order.to_preorder.{0} nnreal
            (@ordered_comm_monoid.to_partial_order.{0} nnreal
               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                     (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
      (@has_zero.zero.{0} nnreal nnreal.has_zero)
      (ε&#x27; i),
hε :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat),
          @coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
            (ε&#x27; i)))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe)) ε)
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@lattice.infi.{0 1} ennreal (set.{0} real)
       (@lattice.conditionally_complete_lattice.to_has_Inf.{0} ennreal
          (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
             (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
       (λ (t : set.{0} real),
          @lattice.infi.{0 0} ennreal (@has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) s t)
            (@lattice.conditionally_complete_lattice.to_has_Inf.{0} ennreal
               (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
                  (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
            (λ (st : @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) s t),
               @lattice.infi.{0 0} ennreal
                 (@is_measurable.{0} real
                    (@borel.{0} real
                       (@uniform_space.to_topological_space.{0} real
                          (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)))
                    t)
                 (@lattice.conditionally_complete_lattice.to_has_Inf.{0} ennreal
                    (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
                       (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal
                          ennreal.complete_linear_order_1)))
                 (λ
                  (ht :
                    @is_measurable.{0} real
                      (@borel.{0} real
                         (@uniform_space.to_topological_space.{0} real
                            (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)))
                      t),
                    @coe_fn.{1 1} (measure_theory.outer_measure.{0} real)
                      (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
                      measure_theory.lebesgue_outer
                      t))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (a : nat),
          @has_add.add.{0} ennreal
            (@distrib.to_has_add.{0} ennreal
               (@semiring.to_distrib.{0} ennreal
                  (@comm_semiring.to_semiring.{0} ennreal
                     (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                        ennreal.canonically_ordered_comm_semiring_1))))
            (measure_theory.lebesgue_length (f a))
            (@coe.{1 1} nnreal ennreal
               (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
               (ε&#x27; a))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} real,
f : nat → set.{0} real,
hf : @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) s (@set.Union.{0 1} real nat (λ (i : nat), f i)),
ε : nnreal,
ε0 :
  @has_lt.lt.{0} nnreal
    (@preorder.to_has_lt.{0} nnreal
       (@partial_order.to_preorder.{0} nnreal
          (@ordered_comm_monoid.to_partial_order.{0} nnreal
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                   (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
    (@has_zero.zero.{0} nnreal nnreal.has_zero)
    ε,
h :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat), measure_theory.lebesgue_length (f i)))
    (@lattice.has_top.top.{0} ennreal
       (@lattice.order_top.to_has_top.{0} ennreal
          (@lattice.bounded_lattice.to_order_top.{0} ennreal
             (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))))),
ε&#x27; : nat → nnreal,
ε&#x27;0 :
  ∀ (i : nat),
    @has_lt.lt.{0} nnreal
      (@preorder.to_has_lt.{0} nnreal
         (@partial_order.to_preorder.{0} nnreal
            (@ordered_comm_monoid.to_partial_order.{0} nnreal
               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                     (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
      (@has_zero.zero.{0} nnreal nnreal.has_zero)
      (ε&#x27; i),
hε :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat),
          @coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
            (ε&#x27; i)))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe)) ε)
⊢ ∀ (i : nat),
    @Exists.{1} (set.{0} real)
      (λ (s : set.{0} real),
         and (@has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (f i) s)
           (and
              (@is_measurable.{0} real
                 (@borel.{0} real
                    (@uniform_space.to_topological_space.{0} real
                       (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)))
                 s)
              (@has_le.le.{0} ennreal
                 (@preorder.to_has_le.{0} ennreal
                    (@partial_order.to_preorder.{0} ennreal
                       (@ordered_comm_monoid.to_partial_order.{0} ennreal
                          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                                ennreal.canonically_ordered_comm_semiring_1)))))
                 (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real)
                    (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
                    measure_theory.lebesgue_outer
                    s)
                 (@has_add.add.{0} ennreal
                    (@distrib.to_has_add.{0} ennreal
                       (@semiring.to_distrib.{0} ennreal
                          (@comm_semiring.to_semiring.{0} ennreal
                             (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                                ennreal.canonically_ordered_comm_semiring_1))))
                    (measure_theory.lebesgue_length (f i))
                    (@coe.{1 1} nnreal ennreal
                       (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
                       (nnreal.of_real
                          (@coe.{1 1} nnreal real
                             (@coe_to_lift.{1 1} nnreal real (@coe_base.{1 1} nnreal real nnreal.has_coe))
                             (ε&#x27; i))))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} real,
f : nat → set.{0} real,
hf : @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) s (@set.Union.{0 1} real nat (λ (i : nat), f i)),
ε : nnreal,
ε0 :
  @has_lt.lt.{0} nnreal
    (@preorder.to_has_lt.{0} nnreal
       (@partial_order.to_preorder.{0} nnreal
          (@ordered_comm_monoid.to_partial_order.{0} nnreal
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                   (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
    (@has_zero.zero.{0} nnreal nnreal.has_zero)
    ε,
h :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat), measure_theory.lebesgue_length (f i)))
    (@lattice.has_top.top.{0} ennreal
       (@lattice.order_top.to_has_top.{0} ennreal
          (@lattice.bounded_lattice.to_order_top.{0} ennreal
             (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))))),
ε&#x27; : nat → nnreal,
ε&#x27;0 :
  ∀ (i : nat),
    @has_lt.lt.{0} nnreal
      (@preorder.to_has_lt.{0} nnreal
         (@partial_order.to_preorder.{0} nnreal
            (@ordered_comm_monoid.to_partial_order.{0} nnreal
               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                     (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
      (@has_zero.zero.{0} nnreal nnreal.has_zero)
      (ε&#x27; i),
hε :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat),
          @coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
            (ε&#x27; i)))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe)) ε),
i : nat
⊢ @Exists.{1} (set.{0} real)
    (λ (s : set.{0} real),
       and (@has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (f i) s)
         (and
            (@is_measurable.{0} real
               (@borel.{0} real
                  (@uniform_space.to_topological_space.{0} real
                     (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)))
               s)
            (@has_le.le.{0} ennreal
               (@preorder.to_has_le.{0} ennreal
                  (@partial_order.to_preorder.{0} ennreal
                     (@ordered_comm_monoid.to_partial_order.{0} ennreal
                        (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                           (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                              ennreal.canonically_ordered_comm_semiring_1)))))
               (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real)
                  (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
                  measure_theory.lebesgue_outer
                  s)
               (@has_add.add.{0} ennreal
                  (@distrib.to_has_add.{0} ennreal
                     (@semiring.to_distrib.{0} ennreal
                        (@comm_semiring.to_semiring.{0} ennreal
                           (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                              ennreal.canonically_ordered_comm_semiring_1))))
                  (measure_theory.lebesgue_length (f i))
                  (@coe.{1 1} nnreal ennreal
                     (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
                     (nnreal.of_real
                        (@coe.{1 1} nnreal real
                           (@coe_to_lift.{1 1} nnreal real (@coe_base.{1 1} nnreal real nnreal.has_coe))
                           (ε&#x27; i))))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>205      have := (ennreal.lt_add_right (lt_of_le_of_lt (ennreal.le_tsum i) h)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='ennreal.lt_add_right'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='lt_of_le_of_lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ennreal.le_tsum'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 511, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/ennreal.lean&#x27;, &#x27;line&#x27;: 256, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 107, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/instances/ennreal.lean&#x27;, &#x27;line&#x27;: 485, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse name (λ (a : name), name.reflect a) lean.parser.ident → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {a b : ennreal}, @has_lt.lt.{0} ennreal (@preorder.to_has_lt.{0} ennreal (@partial_order.to_preorder.{0} ennreal (@ordered_comm_monoid.to_partial_order.{0} ennreal (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal ennreal.canonically_ordered_comm_semiring_1))))) a (@lattice.has_top.top.{0} ennreal (@lattice.order_top.to_has_top.{0} ennreal (@lattice.bounded_lattice.to_order_top.{0} ennreal (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))))) → @has_lt.lt.{0} ennreal (@preorder.to_has_lt.{0} ennreal (@partial_order.to_preorder.{0} ennreal (@ordered_comm_monoid.to_partial_order.{0} ennreal (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal ennreal.canonically_ordered_comm_semiring_1))))) (@has_zero.zero.{0} ennreal (@zero_ne_one_class.to_has_zero.{0} ennreal (@canonically_ordered_comm_semiring.to_zero_ne_one_class.{0} ennreal ennreal.canonically_ordered_comm_semiring_1))) b → @has_lt.lt.{0} ennreal (@preorder.to_has_lt.{0} ennreal (@partial_order.to_preorder.{0} ennreal (@ordered_comm_monoid.to_partial_order.{0} ennreal (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal ennreal.canonically_ordered_comm_semiring_1))))) a (@has_add.add.{0} ennreal (@distrib.to_has_add.{0} ennreal (@semiring.to_distrib.{0} ennreal (@comm_semiring.to_semiring.{0} ennreal (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal ennreal.canonically_ordered_comm_semiring_1)))) a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type} [_inst_1 : preorder.{0} α] {a b c : α}, @has_le.le.{0} α (@preorder.to_has_le.{0} α _inst_1) a b → @has_lt.lt.{0} α (@preorder.to_has_lt.{0} α _inst_1) b c → @has_lt.lt.{0} α (@preorder.to_has_lt.{0} α _inst_1) a c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type} {f : α → ennreal} (a : α), @has_le.le.{0} ennreal (@preorder.to_has_le.{0} ennreal (@partial_order.to_preorder.{0} ennreal (@ordered_comm_monoid.to_partial_order.{0} ennreal (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal ennreal.canonically_ordered_comm_semiring_1))))) (f a) (@tsum.{0 0} ennreal α (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal ennreal.canonically_ordered_comm_semiring_1))) ennreal.topological_space (λ (a : α), f a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_lt.lt.{0} ennreal (@preorder.to_has_lt.{0} ennreal (@partial_order.to_preorder.{0} ennreal (@ordered_comm_monoid.to_partial_order.{0} ennreal (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal ennreal.canonically_ordered_comm_semiring_1))))) (@tsum.{0 0} ennreal nat (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal ennreal.canonically_ordered_comm_semiring_1))) ennreal.topological_space (λ (i : nat), measure_theory.lebesgue_length (f i))) (@lattice.has_top.top.{0} ennreal (@lattice.order_top.to_has_top.{0} ennreal (@lattice.bounded_lattice.to_order_top.{0} ennreal (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title=' `choose a b h using hyp` takes an hypothesis `hyp` of the form
`∀ (x : X) (y : Y), ∃ (a : A) (b : B), P x y a b` for some `P : X → Y → A → B → Prop` and outputs
into context a function `a : X → Y → A`, `b : X → Y → B` and a proposition `h` stating
`∀ (x : X) (y : Y), P x y (a x y) (b x y)`. It presumably also works with dependent versions.

Example:

```lean
example (h : ∀n m : ℕ, ∃i j, m = n + i ∨ m + j = n) : true :=
begin
  choose i j h using h,
  guard_hyp i := ℕ → ℕ → ℕ,
  guard_hyp j := ℕ → ℕ → ℕ,
  guard_hyp h := ∀ (n m : ℕ), m = n + i n m ∨ m + j n m = n,
  trivial
end
```'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='choose'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id&#x27;, &#x27;id*&#x27;, &#x27;(using expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} real,
f : nat → set.{0} real,
hf : @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) s (@set.Union.{0 1} real nat (λ (i : nat), f i)),
ε : nnreal,
ε0 :
  @has_lt.lt.{0} nnreal
    (@preorder.to_has_lt.{0} nnreal
       (@partial_order.to_preorder.{0} nnreal
          (@ordered_comm_monoid.to_partial_order.{0} nnreal
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                   (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
    (@has_zero.zero.{0} nnreal nnreal.has_zero)
    ε,
h :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat), measure_theory.lebesgue_length (f i)))
    (@lattice.has_top.top.{0} ennreal
       (@lattice.order_top.to_has_top.{0} ennreal
          (@lattice.bounded_lattice.to_order_top.{0} ennreal
             (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))))),
ε&#x27; : nat → nnreal,
ε&#x27;0 :
  ∀ (i : nat),
    @has_lt.lt.{0} nnreal
      (@preorder.to_has_lt.{0} nnreal
         (@partial_order.to_preorder.{0} nnreal
            (@ordered_comm_monoid.to_partial_order.{0} nnreal
               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                     (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
      (@has_zero.zero.{0} nnreal nnreal.has_zero)
      (ε&#x27; i),
hε :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat),
          @coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
            (ε&#x27; i)))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe)) ε),
i : nat
⊢ @Exists.{1} (set.{0} real)
    (λ (s : set.{0} real),
       and (@has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (f i) s)
         (and
            (@is_measurable.{0} real
               (@borel.{0} real
                  (@uniform_space.to_topological_space.{0} real
                     (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)))
               s)
            (@has_le.le.{0} ennreal
               (@preorder.to_has_le.{0} ennreal
                  (@partial_order.to_preorder.{0} ennreal
                     (@ordered_comm_monoid.to_partial_order.{0} ennreal
                        (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                           (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                              ennreal.canonically_ordered_comm_semiring_1)))))
               (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real)
                  (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
                  measure_theory.lebesgue_outer
                  s)
               (@has_add.add.{0} ennreal
                  (@distrib.to_has_add.{0} ennreal
                     (@semiring.to_distrib.{0} ennreal
                        (@comm_semiring.to_semiring.{0} ennreal
                           (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                              ennreal.canonically_ordered_comm_semiring_1))))
                  (measure_theory.lebesgue_length (f i))
                  (@coe.{1 1} nnreal ennreal
                     (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
                     (nnreal.of_real
                        (@coe.{1 1} nnreal real
                           (@coe_to_lift.{1 1} nnreal real (@coe_base.{1 1} nnreal real nnreal.has_coe))
                           (ε&#x27; i))))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>206          (ennreal.zero_lt_coe_iff.2 (ε&#x27;0 i))),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='ennreal.zero_lt_coe_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='ε&#x27;0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/ennreal.lean&#x27;, &#x27;line&#x27;: 218, &#x27;column&#x27;: 25}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 511, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {p : nnreal}, iff (@has_lt.lt.{0} ennreal (@preorder.to_has_lt.{0} ennreal (@partial_order.to_preorder.{0} ennreal (@ordered_comm_monoid.to_partial_order.{0} ennreal (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal ennreal.canonically_ordered_comm_semiring_1))))) (@has_zero.zero.{0} ennreal (@zero_ne_one_class.to_has_zero.{0} ennreal (@canonically_ordered_comm_semiring.to_zero_ne_one_class.{0} ennreal ennreal.canonically_ordered_comm_semiring_1))) (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe)) p)) (@has_lt.lt.{0} nnreal (@preorder.to_has_lt.{0} nnreal (@partial_order.to_preorder.{0} nnreal (@ordered_comm_monoid.to_partial_order.{0} nnreal (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring)))))) (@has_zero.zero.{0} nnreal nnreal.has_zero) p)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ (i : nat), @has_lt.lt.{0} nnreal (@preorder.to_has_lt.{0} nnreal (@partial_order.to_preorder.{0} nnreal (@ordered_comm_monoid.to_partial_order.{0} nnreal (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring)))))) (@has_zero.zero.{0} nnreal nnreal.has_zero) (ε&#x27; i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse name (λ (a : name), name.reflect a) lean.parser.ident → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title=' `choose a b h using hyp` takes an hypothesis `hyp` of the form
`∀ (x : X) (y : Y), ∃ (a : A) (b : B), P x y a b` for some `P : X → Y → A → B → Prop` and outputs
into context a function `a : X → Y → A`, `b : X → Y → B` and a proposition `h` stating
`∀ (x : X) (y : Y), P x y (a x y) (b x y)`. It presumably also works with dependent versions.

Example:

```lean
example (h : ∀n m : ℕ, ∃i j, m = n + i ∨ m + j = n) : true :=
begin
  choose i j h using h,
  guard_hyp i := ℕ → ℕ → ℕ,
  guard_hyp j := ℕ → ℕ → ℕ,
  guard_hyp h := ∀ (n m : ℕ), m = n + i n m ∨ m + j n m = n,
  trivial
end
```'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='choose'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id&#x27;, &#x27;id*&#x27;, &#x27;(using expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} real,
f : nat → set.{0} real,
hf : @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) s (@set.Union.{0 1} real nat (λ (i : nat), f i)),
ε : nnreal,
ε0 :
  @has_lt.lt.{0} nnreal
    (@preorder.to_has_lt.{0} nnreal
       (@partial_order.to_preorder.{0} nnreal
          (@ordered_comm_monoid.to_partial_order.{0} nnreal
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                   (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
    (@has_zero.zero.{0} nnreal nnreal.has_zero)
    ε,
h :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat), measure_theory.lebesgue_length (f i)))
    (@lattice.has_top.top.{0} ennreal
       (@lattice.order_top.to_has_top.{0} ennreal
          (@lattice.bounded_lattice.to_order_top.{0} ennreal
             (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))))),
ε&#x27; : nat → nnreal,
ε&#x27;0 :
  ∀ (i : nat),
    @has_lt.lt.{0} nnreal
      (@preorder.to_has_lt.{0} nnreal
         (@partial_order.to_preorder.{0} nnreal
            (@ordered_comm_monoid.to_partial_order.{0} nnreal
               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                     (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
      (@has_zero.zero.{0} nnreal nnreal.has_zero)
      (ε&#x27; i),
hε :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat),
          @coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
            (ε&#x27; i)))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe)) ε),
i : nat
⊢ @Exists.{1} (set.{0} real)
    (λ (s : set.{0} real),
       and (@has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (f i) s)
         (and
            (@is_measurable.{0} real
               (@borel.{0} real
                  (@uniform_space.to_topological_space.{0} real
                     (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)))
               s)
            (@has_le.le.{0} ennreal
               (@preorder.to_has_le.{0} ennreal
                  (@partial_order.to_preorder.{0} ennreal
                     (@ordered_comm_monoid.to_partial_order.{0} ennreal
                        (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                           (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                              ennreal.canonically_ordered_comm_semiring_1)))))
               (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real)
                  (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
                  measure_theory.lebesgue_outer
                  s)
               (@has_add.add.{0} ennreal
                  (@distrib.to_has_add.{0} ennreal
                     (@semiring.to_distrib.{0} ennreal
                        (@comm_semiring.to_semiring.{0} ennreal
                           (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                              ennreal.canonically_ordered_comm_semiring_1))))
                  (measure_theory.lebesgue_length (f i))
                  (@coe.{1 1} nnreal ennreal
                     (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
                     (nnreal.of_real
                        (@coe.{1 1} nnreal real
                           (@coe_to_lift.{1 1} nnreal real (@coe_base.{1 1} nnreal real nnreal.has_coe))
                           (ε&#x27; i))))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} real,
f : nat → set.{0} real,
hf : @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) s (@set.Union.{0 1} real nat (λ (i : nat), f i)),
ε : nnreal,
ε0 :
  @has_lt.lt.{0} nnreal
    (@preorder.to_has_lt.{0} nnreal
       (@partial_order.to_preorder.{0} nnreal
          (@ordered_comm_monoid.to_partial_order.{0} nnreal
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                   (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
    (@has_zero.zero.{0} nnreal nnreal.has_zero)
    ε,
h :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat), measure_theory.lebesgue_length (f i)))
    (@lattice.has_top.top.{0} ennreal
       (@lattice.order_top.to_has_top.{0} ennreal
          (@lattice.bounded_lattice.to_order_top.{0} ennreal
             (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))))),
ε&#x27; : nat → nnreal,
ε&#x27;0 :
  ∀ (i : nat),
    @has_lt.lt.{0} nnreal
      (@preorder.to_has_lt.{0} nnreal
         (@partial_order.to_preorder.{0} nnreal
            (@ordered_comm_monoid.to_partial_order.{0} nnreal
               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                     (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
      (@has_zero.zero.{0} nnreal nnreal.has_zero)
      (ε&#x27; i),
hε :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat),
          @coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
            (ε&#x27; i)))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe)) ε),
i : nat,
this :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (measure_theory.lebesgue_length (f i))
    (@has_add.add.{0} ennreal
       (@distrib.to_has_add.{0} ennreal
          (@semiring.to_distrib.{0} ennreal
             (@comm_semiring.to_semiring.{0} ennreal
                (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1))))
       (measure_theory.lebesgue_length (f i))
       (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
          (ε&#x27; i)))
⊢ @Exists.{1} (set.{0} real)
    (λ (s : set.{0} real),
       and (@has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (f i) s)
         (and
            (@is_measurable.{0} real
               (@borel.{0} real
                  (@uniform_space.to_topological_space.{0} real
                     (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)))
               s)
            (@has_le.le.{0} ennreal
               (@preorder.to_has_le.{0} ennreal
                  (@partial_order.to_preorder.{0} ennreal
                     (@ordered_comm_monoid.to_partial_order.{0} ennreal
                        (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                           (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                              ennreal.canonically_ordered_comm_semiring_1)))))
               (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real)
                  (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
                  measure_theory.lebesgue_outer
                  s)
               (@has_add.add.{0} ennreal
                  (@distrib.to_has_add.{0} ennreal
                     (@semiring.to_distrib.{0} ennreal
                        (@comm_semiring.to_semiring.{0} ennreal
                           (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                              ennreal.canonically_ordered_comm_semiring_1))))
                  (measure_theory.lebesgue_length (f i))
                  (@coe.{1 1} nnreal ennreal
                     (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
                     (nnreal.of_real
                        (@coe.{1 1} nnreal real
                           (@coe_to_lift.{1 1} nnreal real (@coe_base.{1 1} nnreal real nnreal.has_coe))
                           (ε&#x27; i))))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>207      conv at this {to_lhs, rw lebesgue_length},</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='blue'><a title='measure_theory.lebesgue_length'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 511, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 65, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 17, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 511, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse name (λ (a : name), name.reflect a) lean.parser.ident → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit name (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.ident)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) (lean.parser.pexpr std.prec.max))) → conv.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit name (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.ident)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) (lean.parser.pexpr std.prec.max))) → conv.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{0} real → ennreal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit name (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.ident)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) (lean.parser.pexpr std.prec.max))) → conv.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse name (λ (a : name), name.reflect a) lean.parser.ident → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title=' `choose a b h using hyp` takes an hypothesis `hyp` of the form
`∀ (x : X) (y : Y), ∃ (a : A) (b : B), P x y a b` for some `P : X → Y → A → B → Prop` and outputs
into context a function `a : X → Y → A`, `b : X → Y → B` and a proposition `h` stating
`∀ (x : X) (y : Y), P x y (a x y) (b x y)`. It presumably also works with dependent versions.

Example:

```lean
example (h : ∀n m : ℕ, ∃i j, m = n + i ∨ m + j = n) : true :=
begin
  choose i j h using h,
  guard_hyp i := ℕ → ℕ → ℕ,
  guard_hyp j := ℕ → ℕ → ℕ,
  guard_hyp h := ∀ (n m : ℕ), m = n + i n m ∨ m + j n m = n,
  trivial
end
```'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='orange'><a title='Length of an interval. This is the largest monotonic function which correctly
 measures all intervals.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title=' `choose a b h using hyp` takes an hypothesis `hyp` of the form
`∀ (x : X) (y : Y), ∃ (a : A) (b : B), P x y a b` for some `P : X → Y → A → B → Prop` and outputs
into context a function `a : X → Y → A`, `b : X → Y → B` and a proposition `h` stating
`∀ (x : X) (y : Y), P x y (a x y) (b x y)`. It presumably also works with dependent versions.

Example:

```lean
example (h : ∀n m : ℕ, ∃i j, m = n + i ∨ m + j = n) : true :=
begin
  choose i j h using h,
  guard_hyp i := ℕ → ℕ → ℕ,
  guard_hyp j := ℕ → ℕ → ℕ,
  guard_hyp h := ∀ (n m : ℕ), m = n + i n m ∨ m + j n m = n,
  trivial
end
```'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='choose'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='conv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='to_lhs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='conv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='conv'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='choose'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id&#x27;, &#x27;id*&#x27;, &#x27;(using expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;(at id)?&#x27;, &#x27;(in expr)?&#x27;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;(at id)?&#x27;, &#x27;(in expr)?&#x27;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;(at id)?&#x27;, &#x27;(in expr)?&#x27;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id&#x27;, &#x27;id*&#x27;, &#x27;(using expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} real,
f : nat → set.{0} real,
hf : @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) s (@set.Union.{0 1} real nat (λ (i : nat), f i)),
ε : nnreal,
ε0 :
  @has_lt.lt.{0} nnreal
    (@preorder.to_has_lt.{0} nnreal
       (@partial_order.to_preorder.{0} nnreal
          (@ordered_comm_monoid.to_partial_order.{0} nnreal
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                   (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
    (@has_zero.zero.{0} nnreal nnreal.has_zero)
    ε,
h :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat), measure_theory.lebesgue_length (f i)))
    (@lattice.has_top.top.{0} ennreal
       (@lattice.order_top.to_has_top.{0} ennreal
          (@lattice.bounded_lattice.to_order_top.{0} ennreal
             (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))))),
ε&#x27; : nat → nnreal,
ε&#x27;0 :
  ∀ (i : nat),
    @has_lt.lt.{0} nnreal
      (@preorder.to_has_lt.{0} nnreal
         (@partial_order.to_preorder.{0} nnreal
            (@ordered_comm_monoid.to_partial_order.{0} nnreal
               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                     (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
      (@has_zero.zero.{0} nnreal nnreal.has_zero)
      (ε&#x27; i),
hε :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat),
          @coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
            (ε&#x27; i)))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe)) ε),
i : nat,
this :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (measure_theory.lebesgue_length (f i))
    (@has_add.add.{0} ennreal
       (@distrib.to_has_add.{0} ennreal
          (@semiring.to_distrib.{0} ennreal
             (@comm_semiring.to_semiring.{0} ennreal
                (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1))))
       (measure_theory.lebesgue_length (f i))
       (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
          (ε&#x27; i)))
⊢ @Exists.{1} (set.{0} real)
    (λ (s : set.{0} real),
       and (@has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (f i) s)
         (and
            (@is_measurable.{0} real
               (@borel.{0} real
                  (@uniform_space.to_topological_space.{0} real
                     (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)))
               s)
            (@has_le.le.{0} ennreal
               (@preorder.to_has_le.{0} ennreal
                  (@partial_order.to_preorder.{0} ennreal
                     (@ordered_comm_monoid.to_partial_order.{0} ennreal
                        (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                           (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                              ennreal.canonically_ordered_comm_semiring_1)))))
               (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real)
                  (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
                  measure_theory.lebesgue_outer
                  s)
               (@has_add.add.{0} ennreal
                  (@distrib.to_has_add.{0} ennreal
                     (@semiring.to_distrib.{0} ennreal
                        (@comm_semiring.to_semiring.{0} ennreal
                           (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                              ennreal.canonically_ordered_comm_semiring_1))))
                  (measure_theory.lebesgue_length (f i))
                  (@coe.{1 1} nnreal ennreal
                     (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
                     (nnreal.of_real
                        (@coe.{1 1} nnreal real
                           (@coe_to_lift.{1 1} nnreal real (@coe_base.{1 1} nnreal real nnreal.has_coe))
                           (ε&#x27; i))))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} real,
f : nat → set.{0} real,
hf : @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) s (@set.Union.{0 1} real nat (λ (i : nat), f i)),
ε : nnreal,
ε0 :
  @has_lt.lt.{0} nnreal
    (@preorder.to_has_lt.{0} nnreal
       (@partial_order.to_preorder.{0} nnreal
          (@ordered_comm_monoid.to_partial_order.{0} nnreal
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                   (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
    (@has_zero.zero.{0} nnreal nnreal.has_zero)
    ε,
h :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat), measure_theory.lebesgue_length (f i)))
    (@lattice.has_top.top.{0} ennreal
       (@lattice.order_top.to_has_top.{0} ennreal
          (@lattice.bounded_lattice.to_order_top.{0} ennreal
             (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))))),
ε&#x27; : nat → nnreal,
ε&#x27;0 :
  ∀ (i : nat),
    @has_lt.lt.{0} nnreal
      (@preorder.to_has_lt.{0} nnreal
         (@partial_order.to_preorder.{0} nnreal
            (@ordered_comm_monoid.to_partial_order.{0} nnreal
               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                     (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
      (@has_zero.zero.{0} nnreal nnreal.has_zero)
      (ε&#x27; i),
hε :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat),
          @coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
            (ε&#x27; i)))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe)) ε),
i : nat,
this :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (measure_theory.lebesgue_length (f i))
    (@has_add.add.{0} ennreal
       (@distrib.to_has_add.{0} ennreal
          (@semiring.to_distrib.{0} ennreal
             (@comm_semiring.to_semiring.{0} ennreal
                (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1))))
       (measure_theory.lebesgue_length (f i))
       (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
          (ε&#x27; i)))
| @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (measure_theory.lebesgue_length (f i))
    (@has_add.add.{0} ennreal
       (@distrib.to_has_add.{0} ennreal
          (@semiring.to_distrib.{0} ennreal
             (@comm_semiring.to_semiring.{0} ennreal
                (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1))))
       (measure_theory.lebesgue_length (f i))
       (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
          (ε&#x27; i)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} real,
f : nat → set.{0} real,
hf : @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) s (@set.Union.{0 1} real nat (λ (i : nat), f i)),
ε : nnreal,
ε0 :
  @has_lt.lt.{0} nnreal
    (@preorder.to_has_lt.{0} nnreal
       (@partial_order.to_preorder.{0} nnreal
          (@ordered_comm_monoid.to_partial_order.{0} nnreal
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                   (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
    (@has_zero.zero.{0} nnreal nnreal.has_zero)
    ε,
h :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat), measure_theory.lebesgue_length (f i)))
    (@lattice.has_top.top.{0} ennreal
       (@lattice.order_top.to_has_top.{0} ennreal
          (@lattice.bounded_lattice.to_order_top.{0} ennreal
             (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))))),
ε&#x27; : nat → nnreal,
ε&#x27;0 :
  ∀ (i : nat),
    @has_lt.lt.{0} nnreal
      (@preorder.to_has_lt.{0} nnreal
         (@partial_order.to_preorder.{0} nnreal
            (@ordered_comm_monoid.to_partial_order.{0} nnreal
               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                     (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
      (@has_zero.zero.{0} nnreal nnreal.has_zero)
      (ε&#x27; i),
hε :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat),
          @coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
            (ε&#x27; i)))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe)) ε),
i : nat,
this :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (measure_theory.lebesgue_length (f i))
    (@has_add.add.{0} ennreal
       (@distrib.to_has_add.{0} ennreal
          (@semiring.to_distrib.{0} ennreal
             (@comm_semiring.to_semiring.{0} ennreal
                (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1))))
       (measure_theory.lebesgue_length (f i))
       (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
          (ε&#x27; i)))
| measure_theory.lebesgue_length (f i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} real,
f : nat → set.{0} real,
hf : @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) s (@set.Union.{0 1} real nat (λ (i : nat), f i)),
ε : nnreal,
ε0 :
  @has_lt.lt.{0} nnreal
    (@preorder.to_has_lt.{0} nnreal
       (@partial_order.to_preorder.{0} nnreal
          (@ordered_comm_monoid.to_partial_order.{0} nnreal
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                   (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
    (@has_zero.zero.{0} nnreal nnreal.has_zero)
    ε,
h :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat), measure_theory.lebesgue_length (f i)))
    (@lattice.has_top.top.{0} ennreal
       (@lattice.order_top.to_has_top.{0} ennreal
          (@lattice.bounded_lattice.to_order_top.{0} ennreal
             (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))))),
ε&#x27; : nat → nnreal,
ε&#x27;0 :
  ∀ (i : nat),
    @has_lt.lt.{0} nnreal
      (@preorder.to_has_lt.{0} nnreal
         (@partial_order.to_preorder.{0} nnreal
            (@ordered_comm_monoid.to_partial_order.{0} nnreal
               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                     (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
      (@has_zero.zero.{0} nnreal nnreal.has_zero)
      (ε&#x27; i),
hε :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat),
          @coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
            (ε&#x27; i)))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe)) ε),
i : nat,
this :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (measure_theory.lebesgue_length (f i))
    (@has_add.add.{0} ennreal
       (@distrib.to_has_add.{0} ennreal
          (@semiring.to_distrib.{0} ennreal
             (@comm_semiring.to_semiring.{0} ennreal
                (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1))))
       (measure_theory.lebesgue_length (f i))
       (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
          (ε&#x27; i)))
| @lattice.infi.{0 1} ennreal real
    (@lattice.conditionally_complete_lattice.to_has_Inf.{0} ennreal
       (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
          (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
    (λ (a : real),
       @lattice.infi.{0 1} ennreal real
         (@lattice.conditionally_complete_lattice.to_has_Inf.{0} ennreal
            (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
               (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
         (λ (b : real),
            @lattice.infi.{0 0} ennreal
              (@has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (f i)
                 (@set.Ico.{0} real real.preorder a b))
              (@lattice.conditionally_complete_lattice.to_has_Inf.{0} ennreal
                 (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
                    (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
              (λ
               (h :
                 @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (f i)
                   (@set.Ico.{0} real real.preorder a b)),
                 @coe.{1 1} nnreal ennreal
                   (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
                   (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} real,
f : nat → set.{0} real,
hf : @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) s (@set.Union.{0 1} real nat (λ (i : nat), f i)),
ε : nnreal,
ε0 :
  @has_lt.lt.{0} nnreal
    (@preorder.to_has_lt.{0} nnreal
       (@partial_order.to_preorder.{0} nnreal
          (@ordered_comm_monoid.to_partial_order.{0} nnreal
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                   (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
    (@has_zero.zero.{0} nnreal nnreal.has_zero)
    ε,
h :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat), measure_theory.lebesgue_length (f i)))
    (@lattice.has_top.top.{0} ennreal
       (@lattice.order_top.to_has_top.{0} ennreal
          (@lattice.bounded_lattice.to_order_top.{0} ennreal
             (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))))),
ε&#x27; : nat → nnreal,
ε&#x27;0 :
  ∀ (i : nat),
    @has_lt.lt.{0} nnreal
      (@preorder.to_has_lt.{0} nnreal
         (@partial_order.to_preorder.{0} nnreal
            (@ordered_comm_monoid.to_partial_order.{0} nnreal
               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                     (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
      (@has_zero.zero.{0} nnreal nnreal.has_zero)
      (ε&#x27; i),
hε :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat),
          @coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
            (ε&#x27; i)))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe)) ε),
i : nat,
this :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@lattice.infi.{0 1} ennreal real
       (@lattice.conditionally_complete_lattice.to_has_Inf.{0} ennreal
          (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
             (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
       (λ (a : real),
          @lattice.infi.{0 1} ennreal real
            (@lattice.conditionally_complete_lattice.to_has_Inf.{0} ennreal
               (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
                  (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
            (λ (b : real),
               @lattice.infi.{0 0} ennreal
                 (@has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (f i)
                    (@set.Ico.{0} real real.preorder a b))
                 (@lattice.conditionally_complete_lattice.to_has_Inf.{0} ennreal
                    (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
                       (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal
                          ennreal.complete_linear_order_1)))
                 (λ
                  (h :
                    @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (f i)
                      (@set.Ico.{0} real real.preorder a b)),
                    @coe.{1 1} nnreal ennreal
                      (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
                      (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a))))))
    (@has_add.add.{0} ennreal
       (@distrib.to_has_add.{0} ennreal
          (@semiring.to_distrib.{0} ennreal
             (@comm_semiring.to_semiring.{0} ennreal
                (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1))))
       (measure_theory.lebesgue_length (f i))
       (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
          (ε&#x27; i)))
⊢ @Exists.{1} (set.{0} real)
    (λ (s : set.{0} real),
       and (@has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (f i) s)
         (and
            (@is_measurable.{0} real
               (@borel.{0} real
                  (@uniform_space.to_topological_space.{0} real
                     (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)))
               s)
            (@has_le.le.{0} ennreal
               (@preorder.to_has_le.{0} ennreal
                  (@partial_order.to_preorder.{0} ennreal
                     (@ordered_comm_monoid.to_partial_order.{0} ennreal
                        (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                           (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                              ennreal.canonically_ordered_comm_semiring_1)))))
               (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real)
                  (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
                  measure_theory.lebesgue_outer
                  s)
               (@has_add.add.{0} ennreal
                  (@distrib.to_has_add.{0} ennreal
                     (@semiring.to_distrib.{0} ennreal
                        (@comm_semiring.to_semiring.{0} ennreal
                           (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                              ennreal.canonically_ordered_comm_semiring_1))))
                  (measure_theory.lebesgue_length (f i))
                  (@coe.{1 1} nnreal ennreal
                     (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
                     (nnreal.of_real
                        (@coe.{1 1} nnreal real
                           (@coe_to_lift.{1 1} nnreal real (@coe_base.{1 1} nnreal real nnreal.has_coe))
                           (ε&#x27; i))))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>208      simp only [infi_lt_iff] at this,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='lattice.infi_lt_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 511, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/complete_lattice.lean&#x27;, &#x27;line&#x27;: 217, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 511, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse name (λ (a : name), name.reflect a) lean.parser.ident → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} [_inst_1 : lattice.complete_linear_order.{?l_1} α] {a : α} {ι : Sort ?l_2} {f : ι → α}, iff (@has_lt.lt.{?l_1} α (@preorder.to_has_lt.{?l_1} α (@partial_order.to_preorder.{?l_1} α (@lattice.order_bot.to_partial_order.{?l_1} α (@lattice.bounded_lattice.to_order_bot.{?l_1} α (@lattice.complete_lattice.to_bounded_lattice.{?l_1} α (@lattice.complete_linear_order.to_complete_lattice.{?l_1} α _inst_1)))))) (@lattice.infi.{?l_1 ?l_2} α ι (@lattice.complete_lattice.to_has_Inf.{?l_1} α (@lattice.complete_linear_order.to_complete_lattice.{?l_1} α _inst_1)) f) a) (@Exists.{?l_2} ι (λ (i : ι), @has_lt.lt.{?l_1} α (@preorder.to_has_lt.{?l_1} α (@partial_order.to_preorder.{?l_1} α (@lattice.order_bot.to_partial_order.{?l_1} α (@lattice.bounded_lattice.to_order_bot.{?l_1} α (@lattice.complete_lattice.to_bounded_lattice.{?l_1} α (@lattice.complete_linear_order.to_complete_lattice.{?l_1} α _inst_1)))))) (f i) a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse name (λ (a : name), name.reflect a) lean.parser.ident → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title=' `choose a b h using hyp` takes an hypothesis `hyp` of the form
`∀ (x : X) (y : Y), ∃ (a : A) (b : B), P x y a b` for some `P : X → Y → A → B → Prop` and outputs
into context a function `a : X → Y → A`, `b : X → Y → B` and a proposition `h` stating
`∀ (x : X) (y : Y), P x y (a x y) (b x y)`. It presumably also works with dependent versions.

Example:

```lean
example (h : ∀n m : ℕ, ∃i j, m = n + i ∨ m + j = n) : true :=
begin
  choose i j h using h,
  guard_hyp i := ℕ → ℕ → ℕ,
  guard_hyp j := ℕ → ℕ → ℕ,
  guard_hyp h := ∀ (n m : ℕ), m = n + i n m ∨ m + j n m = n,
  trivial
end
```'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title=' `choose a b h using hyp` takes an hypothesis `hyp` of the form
`∀ (x : X) (y : Y), ∃ (a : A) (b : B), P x y a b` for some `P : X → Y → A → B → Prop` and outputs
into context a function `a : X → Y → A`, `b : X → Y → B` and a proposition `h` stating
`∀ (x : X) (y : Y), P x y (a x y) (b x y)`. It presumably also works with dependent versions.

Example:

```lean
example (h : ∀n m : ℕ, ∃i j, m = n + i ∨ m + j = n) : true :=
begin
  choose i j h using h,
  guard_hyp i := ℕ → ℕ → ℕ,
  guard_hyp j := ℕ → ℕ → ℕ,
  guard_hyp h := ∀ (n m : ℕ), m = n + i n m ∨ m + j n m = n,
  trivial
end
```'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='choose'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='choose'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id&#x27;, &#x27;id*&#x27;, &#x27;(using expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id&#x27;, &#x27;id*&#x27;, &#x27;(using expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} real,
f : nat → set.{0} real,
hf : @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) s (@set.Union.{0 1} real nat (λ (i : nat), f i)),
ε : nnreal,
ε0 :
  @has_lt.lt.{0} nnreal
    (@preorder.to_has_lt.{0} nnreal
       (@partial_order.to_preorder.{0} nnreal
          (@ordered_comm_monoid.to_partial_order.{0} nnreal
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                   (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
    (@has_zero.zero.{0} nnreal nnreal.has_zero)
    ε,
h :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat), measure_theory.lebesgue_length (f i)))
    (@lattice.has_top.top.{0} ennreal
       (@lattice.order_top.to_has_top.{0} ennreal
          (@lattice.bounded_lattice.to_order_top.{0} ennreal
             (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))))),
ε&#x27; : nat → nnreal,
ε&#x27;0 :
  ∀ (i : nat),
    @has_lt.lt.{0} nnreal
      (@preorder.to_has_lt.{0} nnreal
         (@partial_order.to_preorder.{0} nnreal
            (@ordered_comm_monoid.to_partial_order.{0} nnreal
               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                     (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
      (@has_zero.zero.{0} nnreal nnreal.has_zero)
      (ε&#x27; i),
hε :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat),
          @coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
            (ε&#x27; i)))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe)) ε),
i : nat,
this :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@lattice.infi.{0 1} ennreal real
       (@lattice.conditionally_complete_lattice.to_has_Inf.{0} ennreal
          (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
             (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
       (λ (a : real),
          @lattice.infi.{0 1} ennreal real
            (@lattice.conditionally_complete_lattice.to_has_Inf.{0} ennreal
               (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
                  (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
            (λ (b : real),
               @lattice.infi.{0 0} ennreal
                 (@has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (f i)
                    (@set.Ico.{0} real real.preorder a b))
                 (@lattice.conditionally_complete_lattice.to_has_Inf.{0} ennreal
                    (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
                       (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal
                          ennreal.complete_linear_order_1)))
                 (λ
                  (h :
                    @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (f i)
                      (@set.Ico.{0} real real.preorder a b)),
                    @coe.{1 1} nnreal ennreal
                      (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
                      (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a))))))
    (@has_add.add.{0} ennreal
       (@distrib.to_has_add.{0} ennreal
          (@semiring.to_distrib.{0} ennreal
             (@comm_semiring.to_semiring.{0} ennreal
                (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1))))
       (measure_theory.lebesgue_length (f i))
       (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
          (ε&#x27; i)))
⊢ @Exists.{1} (set.{0} real)
    (λ (s : set.{0} real),
       and (@has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (f i) s)
         (and
            (@is_measurable.{0} real
               (@borel.{0} real
                  (@uniform_space.to_topological_space.{0} real
                     (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)))
               s)
            (@has_le.le.{0} ennreal
               (@preorder.to_has_le.{0} ennreal
                  (@partial_order.to_preorder.{0} ennreal
                     (@ordered_comm_monoid.to_partial_order.{0} ennreal
                        (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                           (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                              ennreal.canonically_ordered_comm_semiring_1)))))
               (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real)
                  (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
                  measure_theory.lebesgue_outer
                  s)
               (@has_add.add.{0} ennreal
                  (@distrib.to_has_add.{0} ennreal
                     (@semiring.to_distrib.{0} ennreal
                        (@comm_semiring.to_semiring.{0} ennreal
                           (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                              ennreal.canonically_ordered_comm_semiring_1))))
                  (measure_theory.lebesgue_length (f i))
                  (@coe.{1 1} nnreal ennreal
                     (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
                     (nnreal.of_real
                        (@coe.{1 1} nnreal real
                           (@coe_to_lift.{1 1} nnreal real (@coe_base.{1 1} nnreal real nnreal.has_coe))
                           (ε&#x27; i))))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} real,
f : nat → set.{0} real,
hf : @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) s (@set.Union.{0 1} real nat (λ (i : nat), f i)),
ε : nnreal,
ε0 :
  @has_lt.lt.{0} nnreal
    (@preorder.to_has_lt.{0} nnreal
       (@partial_order.to_preorder.{0} nnreal
          (@ordered_comm_monoid.to_partial_order.{0} nnreal
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                   (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
    (@has_zero.zero.{0} nnreal nnreal.has_zero)
    ε,
h :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat), measure_theory.lebesgue_length (f i)))
    (@lattice.has_top.top.{0} ennreal
       (@lattice.order_top.to_has_top.{0} ennreal
          (@lattice.bounded_lattice.to_order_top.{0} ennreal
             (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))))),
ε&#x27; : nat → nnreal,
ε&#x27;0 :
  ∀ (i : nat),
    @has_lt.lt.{0} nnreal
      (@preorder.to_has_lt.{0} nnreal
         (@partial_order.to_preorder.{0} nnreal
            (@ordered_comm_monoid.to_partial_order.{0} nnreal
               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                     (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
      (@has_zero.zero.{0} nnreal nnreal.has_zero)
      (ε&#x27; i),
hε :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat),
          @coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
            (ε&#x27; i)))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe)) ε),
i : nat,
this :
  @Exists.{1} real
    (λ (i_1 : real),
       @Exists.{1} real
         (λ (i_2 : real),
            @Exists.{0}
              (@has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (f i)
                 (@set.Ico.{0} real real.preorder i_1 i_2))
              (λ
               (i_3 :
                 @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (f i)
                   (@set.Ico.{0} real real.preorder i_1 i_2)),
                 @has_lt.lt.{0} ennreal
                   (@preorder.to_has_lt.{0} ennreal
                      (@partial_order.to_preorder.{0} ennreal
                         (@ordered_comm_monoid.to_partial_order.{0} ennreal
                            (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                               (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                                  ennreal.canonically_ordered_comm_semiring_1)))))
                   (@coe.{1 1} nnreal ennreal
                      (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
                      (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) i_2 i_1)))
                   (@has_add.add.{0} ennreal
                      (@distrib.to_has_add.{0} ennreal
                         (@semiring.to_distrib.{0} ennreal
                            (@comm_semiring.to_semiring.{0} ennreal
                               (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                                  ennreal.canonically_ordered_comm_semiring_1))))
                      (measure_theory.lebesgue_length (f i))
                      (@coe.{1 1} nnreal ennreal
                         (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
                         (ε&#x27; i))))))
⊢ @Exists.{1} (set.{0} real)
    (λ (s : set.{0} real),
       and (@has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (f i) s)
         (and
            (@is_measurable.{0} real
               (@borel.{0} real
                  (@uniform_space.to_topological_space.{0} real
                     (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)))
               s)
            (@has_le.le.{0} ennreal
               (@preorder.to_has_le.{0} ennreal
                  (@partial_order.to_preorder.{0} ennreal
                     (@ordered_comm_monoid.to_partial_order.{0} ennreal
                        (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                           (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                              ennreal.canonically_ordered_comm_semiring_1)))))
               (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real)
                  (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
                  measure_theory.lebesgue_outer
                  s)
               (@has_add.add.{0} ennreal
                  (@distrib.to_has_add.{0} ennreal
                     (@semiring.to_distrib.{0} ennreal
                        (@comm_semiring.to_semiring.{0} ennreal
                           (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                              ennreal.canonically_ordered_comm_semiring_1))))
                  (measure_theory.lebesgue_length (f i))
                  (@coe.{1 1} nnreal ennreal
                     (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
                     (nnreal.of_real
                        (@coe.{1 1} nnreal real
                           (@coe_to_lift.{1 1} nnreal real (@coe_base.{1 1} nnreal real nnreal.has_coe))
                           (ε&#x27; i))))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>209      rcases this with ⟨a, b, h₁, h₂⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 511, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 511, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse name (λ (a : name), name.reflect a) lean.parser.ident → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@Exists.{1} real (λ (i_1 : real), @Exists.{1} real (λ (i_2 : real), @Exists.{0} (@has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (f i) (@set.Ico.{0} real real.preorder i_1 i_2)) (λ (i_3 : @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (f i) (@set.Ico.{0} real real.preorder i_1 i_2)), @has_lt.lt.{0} ennreal (@preorder.to_has_lt.{0} ennreal (@partial_order.to_preorder.{0} ennreal (@ordered_comm_monoid.to_partial_order.{0} ennreal (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal ennreal.canonically_ordered_comm_semiring_1))))) (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe)) (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) i_2 i_1))) (@has_add.add.{0} ennreal (@distrib.to_has_add.{0} ennreal (@semiring.to_distrib.{0} ennreal (@comm_semiring.to_semiring.{0} ennreal (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal ennreal.canonically_ordered_comm_semiring_1)))) (measure_theory.lebesgue_length (f i)) (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe)) (ε&#x27; i))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse name (λ (a : name), name.reflect a) lean.parser.ident → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title=' `choose a b h using hyp` takes an hypothesis `hyp` of the form
`∀ (x : X) (y : Y), ∃ (a : A) (b : B), P x y a b` for some `P : X → Y → A → B → Prop` and outputs
into context a function `a : X → Y → A`, `b : X → Y → B` and a proposition `h` stating
`∀ (x : X) (y : Y), P x y (a x y) (b x y)`. It presumably also works with dependent versions.

Example:

```lean
example (h : ∀n m : ℕ, ∃i j, m = n + i ∨ m + j = n) : true :=
begin
  choose i j h using h,
  guard_hyp i := ℕ → ℕ → ℕ,
  guard_hyp j := ℕ → ℕ → ℕ,
  guard_hyp h := ∀ (n m : ℕ), m = n + i n m ∨ m + j n m = n,
  trivial
end
```'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title=' `choose a b h using hyp` takes an hypothesis `hyp` of the form
`∀ (x : X) (y : Y), ∃ (a : A) (b : B), P x y a b` for some `P : X → Y → A → B → Prop` and outputs
into context a function `a : X → Y → A`, `b : X → Y → B` and a proposition `h` stating
`∀ (x : X) (y : Y), P x y (a x y) (b x y)`. It presumably also works with dependent versions.

Example:

```lean
example (h : ∀n m : ℕ, ∃i j, m = n + i ∨ m + j = n) : true :=
begin
  choose i j h using h,
  guard_hyp i := ℕ → ℕ → ℕ,
  guard_hyp j := ℕ → ℕ → ℕ,
  guard_hyp h := ∀ (n m : ℕ), m = n + i n m ∨ m + j n m = n,
  trivial
end
```'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='choose'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='choose'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id&#x27;, &#x27;id*&#x27;, &#x27;(using expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id&#x27;, &#x27;id*&#x27;, &#x27;(using expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} real,
f : nat → set.{0} real,
hf : @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) s (@set.Union.{0 1} real nat (λ (i : nat), f i)),
ε : nnreal,
ε0 :
  @has_lt.lt.{0} nnreal
    (@preorder.to_has_lt.{0} nnreal
       (@partial_order.to_preorder.{0} nnreal
          (@ordered_comm_monoid.to_partial_order.{0} nnreal
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                   (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
    (@has_zero.zero.{0} nnreal nnreal.has_zero)
    ε,
h :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat), measure_theory.lebesgue_length (f i)))
    (@lattice.has_top.top.{0} ennreal
       (@lattice.order_top.to_has_top.{0} ennreal
          (@lattice.bounded_lattice.to_order_top.{0} ennreal
             (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))))),
ε&#x27; : nat → nnreal,
ε&#x27;0 :
  ∀ (i : nat),
    @has_lt.lt.{0} nnreal
      (@preorder.to_has_lt.{0} nnreal
         (@partial_order.to_preorder.{0} nnreal
            (@ordered_comm_monoid.to_partial_order.{0} nnreal
               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                     (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
      (@has_zero.zero.{0} nnreal nnreal.has_zero)
      (ε&#x27; i),
hε :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat),
          @coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
            (ε&#x27; i)))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe)) ε),
i : nat,
this :
  @Exists.{1} real
    (λ (i_1 : real),
       @Exists.{1} real
         (λ (i_2 : real),
            @Exists.{0}
              (@has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (f i)
                 (@set.Ico.{0} real real.preorder i_1 i_2))
              (λ
               (i_3 :
                 @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (f i)
                   (@set.Ico.{0} real real.preorder i_1 i_2)),
                 @has_lt.lt.{0} ennreal
                   (@preorder.to_has_lt.{0} ennreal
                      (@partial_order.to_preorder.{0} ennreal
                         (@ordered_comm_monoid.to_partial_order.{0} ennreal
                            (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                               (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                                  ennreal.canonically_ordered_comm_semiring_1)))))
                   (@coe.{1 1} nnreal ennreal
                      (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
                      (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) i_2 i_1)))
                   (@has_add.add.{0} ennreal
                      (@distrib.to_has_add.{0} ennreal
                         (@semiring.to_distrib.{0} ennreal
                            (@comm_semiring.to_semiring.{0} ennreal
                               (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                                  ennreal.canonically_ordered_comm_semiring_1))))
                      (measure_theory.lebesgue_length (f i))
                      (@coe.{1 1} nnreal ennreal
                         (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
                         (ε&#x27; i))))))
⊢ @Exists.{1} (set.{0} real)
    (λ (s : set.{0} real),
       and (@has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (f i) s)
         (and
            (@is_measurable.{0} real
               (@borel.{0} real
                  (@uniform_space.to_topological_space.{0} real
                     (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)))
               s)
            (@has_le.le.{0} ennreal
               (@preorder.to_has_le.{0} ennreal
                  (@partial_order.to_preorder.{0} ennreal
                     (@ordered_comm_monoid.to_partial_order.{0} ennreal
                        (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                           (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                              ennreal.canonically_ordered_comm_semiring_1)))))
               (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real)
                  (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
                  measure_theory.lebesgue_outer
                  s)
               (@has_add.add.{0} ennreal
                  (@distrib.to_has_add.{0} ennreal
                     (@semiring.to_distrib.{0} ennreal
                        (@comm_semiring.to_semiring.{0} ennreal
                           (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                              ennreal.canonically_ordered_comm_semiring_1))))
                  (measure_theory.lebesgue_length (f i))
                  (@coe.{1 1} nnreal ennreal
                     (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
                     (nnreal.of_real
                        (@coe.{1 1} nnreal real
                           (@coe_to_lift.{1 1} nnreal real (@coe_base.{1 1} nnreal real nnreal.has_coe))
                           (ε&#x27; i))))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} real,
f : nat → set.{0} real,
hf : @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) s (@set.Union.{0 1} real nat (λ (i : nat), f i)),
ε : nnreal,
ε0 :
  @has_lt.lt.{0} nnreal
    (@preorder.to_has_lt.{0} nnreal
       (@partial_order.to_preorder.{0} nnreal
          (@ordered_comm_monoid.to_partial_order.{0} nnreal
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                   (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
    (@has_zero.zero.{0} nnreal nnreal.has_zero)
    ε,
h :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat), measure_theory.lebesgue_length (f i)))
    (@lattice.has_top.top.{0} ennreal
       (@lattice.order_top.to_has_top.{0} ennreal
          (@lattice.bounded_lattice.to_order_top.{0} ennreal
             (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))))),
ε&#x27; : nat → nnreal,
ε&#x27;0 :
  ∀ (i : nat),
    @has_lt.lt.{0} nnreal
      (@preorder.to_has_lt.{0} nnreal
         (@partial_order.to_preorder.{0} nnreal
            (@ordered_comm_monoid.to_partial_order.{0} nnreal
               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                     (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
      (@has_zero.zero.{0} nnreal nnreal.has_zero)
      (ε&#x27; i),
hε :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat),
          @coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
            (ε&#x27; i)))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe)) ε),
i : nat,
a b : real,
h₁ : @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (f i) (@set.Ico.{0} real real.preorder a b),
h₂ :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
    (@has_add.add.{0} ennreal
       (@distrib.to_has_add.{0} ennreal
          (@semiring.to_distrib.{0} ennreal
             (@comm_semiring.to_semiring.{0} ennreal
                (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1))))
       (measure_theory.lebesgue_length (f i))
       (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
          (ε&#x27; i)))
⊢ @Exists.{1} (set.{0} real)
    (λ (s : set.{0} real),
       and (@has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (f i) s)
         (and
            (@is_measurable.{0} real
               (@borel.{0} real
                  (@uniform_space.to_topological_space.{0} real
                     (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)))
               s)
            (@has_le.le.{0} ennreal
               (@preorder.to_has_le.{0} ennreal
                  (@partial_order.to_preorder.{0} ennreal
                     (@ordered_comm_monoid.to_partial_order.{0} ennreal
                        (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                           (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                              ennreal.canonically_ordered_comm_semiring_1)))))
               (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real)
                  (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
                  measure_theory.lebesgue_outer
                  s)
               (@has_add.add.{0} ennreal
                  (@distrib.to_has_add.{0} ennreal
                     (@semiring.to_distrib.{0} ennreal
                        (@comm_semiring.to_semiring.{0} ennreal
                           (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                              ennreal.canonically_ordered_comm_semiring_1))))
                  (measure_theory.lebesgue_length (f i))
                  (@coe.{1 1} nnreal ennreal
                     (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
                     (nnreal.of_real
                        (@coe.{1 1} nnreal real
                           (@coe_to_lift.{1 1} nnreal real (@coe_base.{1 1} nnreal real nnreal.has_coe))
                           (ε&#x27; i))))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>210      rw ← lebesgue_outer_Ico at h₂,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='measure_theory.lebesgue_outer_Ico'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 511, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 151, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 511, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse name (λ (a : name), name.reflect a) lean.parser.ident → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (a b : real), @eq.{1} ennreal (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real) (@measure_theory.outer_measure.has_coe_to_fun.{0} real) measure_theory.lebesgue_outer (@set.Ico.{0} real real.preorder a b)) (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe)) (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse name (λ (a : name), name.reflect a) lean.parser.ident → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title=' `choose a b h using hyp` takes an hypothesis `hyp` of the form
`∀ (x : X) (y : Y), ∃ (a : A) (b : B), P x y a b` for some `P : X → Y → A → B → Prop` and outputs
into context a function `a : X → Y → A`, `b : X → Y → B` and a proposition `h` stating
`∀ (x : X) (y : Y), P x y (a x y) (b x y)`. It presumably also works with dependent versions.

Example:

```lean
example (h : ∀n m : ℕ, ∃i j, m = n + i ∨ m + j = n) : true :=
begin
  choose i j h using h,
  guard_hyp i := ℕ → ℕ → ℕ,
  guard_hyp j := ℕ → ℕ → ℕ,
  guard_hyp h := ∀ (n m : ℕ), m = n + i n m ∨ m + j n m = n,
  trivial
end
```'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title=' `choose a b h using hyp` takes an hypothesis `hyp` of the form
`∀ (x : X) (y : Y), ∃ (a : A) (b : B), P x y a b` for some `P : X → Y → A → B → Prop` and outputs
into context a function `a : X → Y → A`, `b : X → Y → B` and a proposition `h` stating
`∀ (x : X) (y : Y), P x y (a x y) (b x y)`. It presumably also works with dependent versions.

Example:

```lean
example (h : ∀n m : ℕ, ∃i j, m = n + i ∨ m + j = n) : true :=
begin
  choose i j h using h,
  guard_hyp i := ℕ → ℕ → ℕ,
  guard_hyp j := ℕ → ℕ → ℕ,
  guard_hyp h := ∀ (n m : ℕ), m = n + i n m ∨ m + j n m = n,
  trivial
end
```'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='choose'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='choose'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id&#x27;, &#x27;id*&#x27;, &#x27;(using expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id&#x27;, &#x27;id*&#x27;, &#x27;(using expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} real,
f : nat → set.{0} real,
hf : @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) s (@set.Union.{0 1} real nat (λ (i : nat), f i)),
ε : nnreal,
ε0 :
  @has_lt.lt.{0} nnreal
    (@preorder.to_has_lt.{0} nnreal
       (@partial_order.to_preorder.{0} nnreal
          (@ordered_comm_monoid.to_partial_order.{0} nnreal
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                   (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
    (@has_zero.zero.{0} nnreal nnreal.has_zero)
    ε,
h :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat), measure_theory.lebesgue_length (f i)))
    (@lattice.has_top.top.{0} ennreal
       (@lattice.order_top.to_has_top.{0} ennreal
          (@lattice.bounded_lattice.to_order_top.{0} ennreal
             (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))))),
ε&#x27; : nat → nnreal,
ε&#x27;0 :
  ∀ (i : nat),
    @has_lt.lt.{0} nnreal
      (@preorder.to_has_lt.{0} nnreal
         (@partial_order.to_preorder.{0} nnreal
            (@ordered_comm_monoid.to_partial_order.{0} nnreal
               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                     (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
      (@has_zero.zero.{0} nnreal nnreal.has_zero)
      (ε&#x27; i),
hε :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat),
          @coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
            (ε&#x27; i)))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe)) ε),
i : nat,
a b : real,
h₁ : @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (f i) (@set.Ico.{0} real real.preorder a b),
h₂ :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))
    (@has_add.add.{0} ennreal
       (@distrib.to_has_add.{0} ennreal
          (@semiring.to_distrib.{0} ennreal
             (@comm_semiring.to_semiring.{0} ennreal
                (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1))))
       (measure_theory.lebesgue_length (f i))
       (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
          (ε&#x27; i)))
⊢ @Exists.{1} (set.{0} real)
    (λ (s : set.{0} real),
       and (@has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (f i) s)
         (and
            (@is_measurable.{0} real
               (@borel.{0} real
                  (@uniform_space.to_topological_space.{0} real
                     (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)))
               s)
            (@has_le.le.{0} ennreal
               (@preorder.to_has_le.{0} ennreal
                  (@partial_order.to_preorder.{0} ennreal
                     (@ordered_comm_monoid.to_partial_order.{0} ennreal
                        (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                           (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                              ennreal.canonically_ordered_comm_semiring_1)))))
               (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real)
                  (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
                  measure_theory.lebesgue_outer
                  s)
               (@has_add.add.{0} ennreal
                  (@distrib.to_has_add.{0} ennreal
                     (@semiring.to_distrib.{0} ennreal
                        (@comm_semiring.to_semiring.{0} ennreal
                           (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                              ennreal.canonically_ordered_comm_semiring_1))))
                  (measure_theory.lebesgue_length (f i))
                  (@coe.{1 1} nnreal ennreal
                     (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
                     (nnreal.of_real
                        (@coe.{1 1} nnreal real
                           (@coe_to_lift.{1 1} nnreal real (@coe_base.{1 1} nnreal real nnreal.has_coe))
                           (ε&#x27; i))))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} real,
f : nat → set.{0} real,
hf : @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) s (@set.Union.{0 1} real nat (λ (i : nat), f i)),
ε : nnreal,
ε0 :
  @has_lt.lt.{0} nnreal
    (@preorder.to_has_lt.{0} nnreal
       (@partial_order.to_preorder.{0} nnreal
          (@ordered_comm_monoid.to_partial_order.{0} nnreal
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                   (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
    (@has_zero.zero.{0} nnreal nnreal.has_zero)
    ε,
h :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat), measure_theory.lebesgue_length (f i)))
    (@lattice.has_top.top.{0} ennreal
       (@lattice.order_top.to_has_top.{0} ennreal
          (@lattice.bounded_lattice.to_order_top.{0} ennreal
             (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))))),
ε&#x27; : nat → nnreal,
ε&#x27;0 :
  ∀ (i : nat),
    @has_lt.lt.{0} nnreal
      (@preorder.to_has_lt.{0} nnreal
         (@partial_order.to_preorder.{0} nnreal
            (@ordered_comm_monoid.to_partial_order.{0} nnreal
               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                     (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
      (@has_zero.zero.{0} nnreal nnreal.has_zero)
      (ε&#x27; i),
hε :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat),
          @coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
            (ε&#x27; i)))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe)) ε),
i : nat,
a b : real,
h₁ : @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (f i) (@set.Ico.{0} real real.preorder a b),
h₂ :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real) (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
       measure_theory.lebesgue_outer
       (@set.Ico.{0} real real.preorder a b))
    (@has_add.add.{0} ennreal
       (@distrib.to_has_add.{0} ennreal
          (@semiring.to_distrib.{0} ennreal
             (@comm_semiring.to_semiring.{0} ennreal
                (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1))))
       (measure_theory.lebesgue_length (f i))
       (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
          (ε&#x27; i)))
⊢ @Exists.{1} (set.{0} real)
    (λ (s : set.{0} real),
       and (@has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (f i) s)
         (and
            (@is_measurable.{0} real
               (@borel.{0} real
                  (@uniform_space.to_topological_space.{0} real
                     (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)))
               s)
            (@has_le.le.{0} ennreal
               (@preorder.to_has_le.{0} ennreal
                  (@partial_order.to_preorder.{0} ennreal
                     (@ordered_comm_monoid.to_partial_order.{0} ennreal
                        (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                           (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                              ennreal.canonically_ordered_comm_semiring_1)))))
               (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real)
                  (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
                  measure_theory.lebesgue_outer
                  s)
               (@has_add.add.{0} ennreal
                  (@distrib.to_has_add.{0} ennreal
                     (@semiring.to_distrib.{0} ennreal
                        (@comm_semiring.to_semiring.{0} ennreal
                           (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                              ennreal.canonically_ordered_comm_semiring_1))))
                  (measure_theory.lebesgue_length (f i))
                  (@coe.{1 1} nnreal ennreal
                     (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
                     (nnreal.of_real
                        (@coe.{1 1} nnreal real
                           (@coe_to_lift.{1 1} nnreal real (@coe_base.{1 1} nnreal real nnreal.has_coe))
                           (ε&#x27; i))))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>211      exact ⟨_, h₁, is_measurable_Ico, le_of_lt $ by simpa using h₂⟩ },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='h₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='is_measurable_Ico'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='le_of_lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='h₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 511, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/borel_space.lean&#x27;, &#x27;line&#x27;: 271, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 99, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 511, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse name (λ (a : name), name.reflect a) lean.parser.ident → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (f i) (@set.Ico.{0} real real.preorder a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : topological_space.{0} α] [_inst_2 : linear_order.{0} α] [_inst_3 : @order_closed_topology.{0} α _inst_1 (@partial_order.to_preorder.{0} α (@linear_order.to_partial_order.{0} α _inst_2))] {a b : α}, @is_measurable.{0} α (@borel.{0} α _inst_1) (@set.Ico.{0} α (@partial_order.to_preorder.{0} α (@linear_order.to_partial_order.{0} α _inst_2)) a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : preorder.{0} α] {a b : α}, @has_lt.lt.{0} α (@preorder.to_has_lt.{0} α _inst_1) a b → @has_le.le.{0} α (@preorder.to_has_le.{0} α _inst_1) a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_lt.lt.{0} ennreal (@preorder.to_has_lt.{0} ennreal (@partial_order.to_preorder.{0} ennreal (@ordered_comm_monoid.to_partial_order.{0} ennreal (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal ennreal.canonically_ordered_comm_semiring_1))))) (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real) (@measure_theory.outer_measure.has_coe_to_fun.{0} real) measure_theory.lebesgue_outer (@set.Ico.{0} real real.preorder a b)) (@has_add.add.{0} ennreal (@distrib.to_has_add.{0} ennreal (@semiring.to_distrib.{0} ennreal (@comm_semiring.to_semiring.{0} ennreal (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal ennreal.canonically_ordered_comm_semiring_1)))) (measure_theory.lebesgue_length (f i)) (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe)) (ε&#x27; i)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse name (λ (a : name), name.reflect a) lean.parser.ident → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title=' `choose a b h using hyp` takes an hypothesis `hyp` of the form
`∀ (x : X) (y : Y), ∃ (a : A) (b : B), P x y a b` for some `P : X → Y → A → B → Prop` and outputs
into context a function `a : X → Y → A`, `b : X → Y → B` and a proposition `h` stating
`∀ (x : X) (y : Y), P x y (a x y) (b x y)`. It presumably also works with dependent versions.

Example:

```lean
example (h : ∀n m : ℕ, ∃i j, m = n + i ∨ m + j = n) : true :=
begin
  choose i j h using h,
  guard_hyp i := ℕ → ℕ → ℕ,
  guard_hyp j := ℕ → ℕ → ℕ,
  guard_hyp h := ∀ (n m : ℕ), m = n + i n m ∨ m + j n m = n,
  trivial
end
```'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title=' `choose a b h using hyp` takes an hypothesis `hyp` of the form
`∀ (x : X) (y : Y), ∃ (a : A) (b : B), P x y a b` for some `P : X → Y → A → B → Prop` and outputs
into context a function `a : X → Y → A`, `b : X → Y → B` and a proposition `h` stating
`∀ (x : X) (y : Y), P x y (a x y) (b x y)`. It presumably also works with dependent versions.

Example:

```lean
example (h : ∀n m : ℕ, ∃i j, m = n + i ∨ m + j = n) : true :=
begin
  choose i j h using h,
  guard_hyp i := ℕ → ℕ → ℕ,
  guard_hyp j := ℕ → ℕ → ℕ,
  guard_hyp h := ∀ (n m : ℕ), m = n + i n m ∨ m + j n m = n,
  trivial
end
```'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='choose'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='choose'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id&#x27;, &#x27;id*&#x27;, &#x27;(using expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id&#x27;, &#x27;id*&#x27;, &#x27;(using expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} real,
f : nat → set.{0} real,
hf : @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) s (@set.Union.{0 1} real nat (λ (i : nat), f i)),
ε : nnreal,
ε0 :
  @has_lt.lt.{0} nnreal
    (@preorder.to_has_lt.{0} nnreal
       (@partial_order.to_preorder.{0} nnreal
          (@ordered_comm_monoid.to_partial_order.{0} nnreal
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                   (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
    (@has_zero.zero.{0} nnreal nnreal.has_zero)
    ε,
h :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat), measure_theory.lebesgue_length (f i)))
    (@lattice.has_top.top.{0} ennreal
       (@lattice.order_top.to_has_top.{0} ennreal
          (@lattice.bounded_lattice.to_order_top.{0} ennreal
             (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))))),
ε&#x27; : nat → nnreal,
ε&#x27;0 :
  ∀ (i : nat),
    @has_lt.lt.{0} nnreal
      (@preorder.to_has_lt.{0} nnreal
         (@partial_order.to_preorder.{0} nnreal
            (@ordered_comm_monoid.to_partial_order.{0} nnreal
               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                     (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
      (@has_zero.zero.{0} nnreal nnreal.has_zero)
      (ε&#x27; i),
hε :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat),
          @coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
            (ε&#x27; i)))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe)) ε),
i : nat,
a b : real,
h₁ : @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (f i) (@set.Ico.{0} real real.preorder a b),
h₂ :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real) (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
       measure_theory.lebesgue_outer
       (@set.Ico.{0} real real.preorder a b))
    (@has_add.add.{0} ennreal
       (@distrib.to_has_add.{0} ennreal
          (@semiring.to_distrib.{0} ennreal
             (@comm_semiring.to_semiring.{0} ennreal
                (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1))))
       (measure_theory.lebesgue_length (f i))
       (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
          (ε&#x27; i)))
⊢ @Exists.{1} (set.{0} real)
    (λ (s : set.{0} real),
       and (@has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (f i) s)
         (and
            (@is_measurable.{0} real
               (@borel.{0} real
                  (@uniform_space.to_topological_space.{0} real
                     (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)))
               s)
            (@has_le.le.{0} ennreal
               (@preorder.to_has_le.{0} ennreal
                  (@partial_order.to_preorder.{0} ennreal
                     (@ordered_comm_monoid.to_partial_order.{0} ennreal
                        (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                           (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                              ennreal.canonically_ordered_comm_semiring_1)))))
               (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real)
                  (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
                  measure_theory.lebesgue_outer
                  s)
               (@has_add.add.{0} ennreal
                  (@distrib.to_has_add.{0} ennreal
                     (@semiring.to_distrib.{0} ennreal
                        (@comm_semiring.to_semiring.{0} ennreal
                           (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                              ennreal.canonically_ordered_comm_semiring_1))))
                  (measure_theory.lebesgue_length (f i))
                  (@coe.{1 1} nnreal ennreal
                     (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
                     (nnreal.of_real
                        (@coe.{1 1} nnreal real
                           (@coe_to_lift.{1 1} nnreal real (@coe_base.{1 1} nnreal real nnreal.has_coe))
                           (ε&#x27; i))))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} real,
f : nat → set.{0} real,
hf : @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) s (@set.Union.{0 1} real nat (λ (i : nat), f i)),
ε : nnreal,
ε0 :
  @has_lt.lt.{0} nnreal
    (@preorder.to_has_lt.{0} nnreal
       (@partial_order.to_preorder.{0} nnreal
          (@ordered_comm_monoid.to_partial_order.{0} nnreal
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                   (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
    (@has_zero.zero.{0} nnreal nnreal.has_zero)
    ε,
h :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat), measure_theory.lebesgue_length (f i)))
    (@lattice.has_top.top.{0} ennreal
       (@lattice.order_top.to_has_top.{0} ennreal
          (@lattice.bounded_lattice.to_order_top.{0} ennreal
             (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))))),
ε&#x27; : nat → nnreal,
ε&#x27;0 :
  ∀ (i : nat),
    @has_lt.lt.{0} nnreal
      (@preorder.to_has_lt.{0} nnreal
         (@partial_order.to_preorder.{0} nnreal
            (@ordered_comm_monoid.to_partial_order.{0} nnreal
               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                     (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
      (@has_zero.zero.{0} nnreal nnreal.has_zero)
      (ε&#x27; i),
hε :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat),
          @coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
            (ε&#x27; i)))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe)) ε),
i : nat,
a b : real,
h₁ : @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (f i) (@set.Ico.{0} real real.preorder a b),
h₂ :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real) (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
       measure_theory.lebesgue_outer
       (@set.Ico.{0} real real.preorder a b))
    (@has_add.add.{0} ennreal
       (@distrib.to_has_add.{0} ennreal
          (@semiring.to_distrib.{0} ennreal
             (@comm_semiring.to_semiring.{0} ennreal
                (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1))))
       (measure_theory.lebesgue_length (f i))
       (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
          (ε&#x27; i)))
⊢ @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real) (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
       measure_theory.lebesgue_outer
       (@set.Ico.{0} real real.preorder a b))
    (@has_add.add.{0} ennreal
       (@distrib.to_has_add.{0} ennreal
          (@semiring.to_distrib.{0} ennreal
             (@comm_semiring.to_semiring.{0} ennreal
                (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1))))
       (measure_theory.lebesgue_length (f i))
       (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
          (nnreal.of_real
             (@coe.{1 1} nnreal real (@coe_to_lift.{1 1} nnreal real (@coe_base.{1 1} nnreal real nnreal.has_coe))
                (ε&#x27; i)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} real,
f : nat → set.{0} real,
hf : @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) s (@set.Union.{0 1} real nat (λ (i : nat), f i)),
ε : nnreal,
ε0 :
  @has_lt.lt.{0} nnreal
    (@preorder.to_has_lt.{0} nnreal
       (@partial_order.to_preorder.{0} nnreal
          (@ordered_comm_monoid.to_partial_order.{0} nnreal
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                   (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
    (@has_zero.zero.{0} nnreal nnreal.has_zero)
    ε,
h :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat), measure_theory.lebesgue_length (f i)))
    (@lattice.has_top.top.{0} ennreal
       (@lattice.order_top.to_has_top.{0} ennreal
          (@lattice.bounded_lattice.to_order_top.{0} ennreal
             (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))))),
ε&#x27; : nat → nnreal,
ε&#x27;0 :
  ∀ (i : nat),
    @has_lt.lt.{0} nnreal
      (@preorder.to_has_lt.{0} nnreal
         (@partial_order.to_preorder.{0} nnreal
            (@ordered_comm_monoid.to_partial_order.{0} nnreal
               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                     (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
      (@has_zero.zero.{0} nnreal nnreal.has_zero)
      (ε&#x27; i),
hε :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat),
          @coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
            (ε&#x27; i)))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe)) ε),
i : nat,
a b : real,
h₁ : @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (f i) (@set.Ico.{0} real real.preorder a b),
h₂ :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real) (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
       measure_theory.lebesgue_outer
       (@set.Ico.{0} real real.preorder a b))
    (@has_add.add.{0} ennreal
       (@distrib.to_has_add.{0} ennreal
          (@semiring.to_distrib.{0} ennreal
             (@comm_semiring.to_semiring.{0} ennreal
                (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1))))
       (measure_theory.lebesgue_length (f i))
       (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
          (ε&#x27; i)))
⊢ @Exists.{1} (set.{0} real)
    (λ (s : set.{0} real),
       and (@has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (f i) s)
         (and
            (@is_measurable.{0} real
               (@borel.{0} real
                  (@uniform_space.to_topological_space.{0} real
                     (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)))
               s)
            (@has_le.le.{0} ennreal
               (@preorder.to_has_le.{0} ennreal
                  (@partial_order.to_preorder.{0} ennreal
                     (@ordered_comm_monoid.to_partial_order.{0} ennreal
                        (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                           (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                              ennreal.canonically_ordered_comm_semiring_1)))))
               (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real)
                  (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
                  measure_theory.lebesgue_outer
                  s)
               (@has_add.add.{0} ennreal
                  (@distrib.to_has_add.{0} ennreal
                     (@semiring.to_distrib.{0} ennreal
                        (@comm_semiring.to_semiring.{0} ennreal
                           (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                              ennreal.canonically_ordered_comm_semiring_1))))
                  (measure_theory.lebesgue_length (f i))
                  (@coe.{1 1} nnreal ennreal
                     (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
                     (nnreal.of_real
                        (@coe.{1 1} nnreal real
                           (@coe_to_lift.{1 1} nnreal real (@coe_base.{1 1} nnreal real nnreal.has_coe))
                           (ε&#x27; i))))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} real,
f : nat → set.{0} real,
hf : @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) s (@set.Union.{0 1} real nat (λ (i : nat), f i)),
ε : nnreal,
ε0 :
  @has_lt.lt.{0} nnreal
    (@preorder.to_has_lt.{0} nnreal
       (@partial_order.to_preorder.{0} nnreal
          (@ordered_comm_monoid.to_partial_order.{0} nnreal
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                   (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
    (@has_zero.zero.{0} nnreal nnreal.has_zero)
    ε,
h :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat), measure_theory.lebesgue_length (f i)))
    (@lattice.has_top.top.{0} ennreal
       (@lattice.order_top.to_has_top.{0} ennreal
          (@lattice.bounded_lattice.to_order_top.{0} ennreal
             (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))))),
ε&#x27; : nat → nnreal,
ε&#x27;0 :
  ∀ (i : nat),
    @has_lt.lt.{0} nnreal
      (@preorder.to_has_lt.{0} nnreal
         (@partial_order.to_preorder.{0} nnreal
            (@ordered_comm_monoid.to_partial_order.{0} nnreal
               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                     (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
      (@has_zero.zero.{0} nnreal nnreal.has_zero)
      (ε&#x27; i),
hε :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat),
          @coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
            (ε&#x27; i)))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe)) ε),
g : nat → set.{0} real,
hg :
  ∀ (i : nat),
    and (@has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (f i) (g i))
      (and
         (@is_measurable.{0} real
            (@borel.{0} real
               (@uniform_space.to_topological_space.{0} real
                  (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)))
            (g i))
         (@has_le.le.{0} ennreal
            (@preorder.to_has_le.{0} ennreal
               (@partial_order.to_preorder.{0} ennreal
                  (@ordered_comm_monoid.to_partial_order.{0} ennreal
                     (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                        (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                           ennreal.canonically_ordered_comm_semiring_1)))))
            (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real)
               (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
               measure_theory.lebesgue_outer
               (g i))
            (@has_add.add.{0} ennreal
               (@distrib.to_has_add.{0} ennreal
                  (@semiring.to_distrib.{0} ennreal
                     (@comm_semiring.to_semiring.{0} ennreal
                        (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                           ennreal.canonically_ordered_comm_semiring_1))))
               (measure_theory.lebesgue_length (f i))
               (@coe.{1 1} nnreal ennreal
                  (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
                  (nnreal.of_real
                     (@coe.{1 1} nnreal real
                        (@coe_to_lift.{1 1} nnreal real (@coe_base.{1 1} nnreal real nnreal.has_coe))
                        (ε&#x27; i)))))))
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@lattice.infi.{0 1} ennreal (set.{0} real)
       (@lattice.conditionally_complete_lattice.to_has_Inf.{0} ennreal
          (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
             (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
       (λ (t : set.{0} real),
          @lattice.infi.{0 0} ennreal (@has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) s t)
            (@lattice.conditionally_complete_lattice.to_has_Inf.{0} ennreal
               (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
                  (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
            (λ (st : @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) s t),
               @lattice.infi.{0 0} ennreal
                 (@is_measurable.{0} real
                    (@borel.{0} real
                       (@uniform_space.to_topological_space.{0} real
                          (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)))
                    t)
                 (@lattice.conditionally_complete_lattice.to_has_Inf.{0} ennreal
                    (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
                       (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal
                          ennreal.complete_linear_order_1)))
                 (λ
                  (ht :
                    @is_measurable.{0} real
                      (@borel.{0} real
                         (@uniform_space.to_topological_space.{0} real
                            (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)))
                      t),
                    @coe_fn.{1 1} (measure_theory.outer_measure.{0} real)
                      (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
                      measure_theory.lebesgue_outer
                      t))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (a : nat),
          @has_add.add.{0} ennreal
            (@distrib.to_has_add.{0} ennreal
               (@semiring.to_distrib.{0} ennreal
                  (@comm_semiring.to_semiring.{0} ennreal
                     (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                        ennreal.canonically_ordered_comm_semiring_1))))
            (measure_theory.lebesgue_length (f a))
            (@coe.{1 1} nnreal ennreal
               (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
               (ε&#x27; a))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>212    simp at hg,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} real,
f : nat → set.{0} real,
hf : @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) s (@set.Union.{0 1} real nat (λ (i : nat), f i)),
ε : nnreal,
ε0 :
  @has_lt.lt.{0} nnreal
    (@preorder.to_has_lt.{0} nnreal
       (@partial_order.to_preorder.{0} nnreal
          (@ordered_comm_monoid.to_partial_order.{0} nnreal
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                   (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
    (@has_zero.zero.{0} nnreal nnreal.has_zero)
    ε,
h :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat), measure_theory.lebesgue_length (f i)))
    (@lattice.has_top.top.{0} ennreal
       (@lattice.order_top.to_has_top.{0} ennreal
          (@lattice.bounded_lattice.to_order_top.{0} ennreal
             (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))))),
ε&#x27; : nat → nnreal,
ε&#x27;0 :
  ∀ (i : nat),
    @has_lt.lt.{0} nnreal
      (@preorder.to_has_lt.{0} nnreal
         (@partial_order.to_preorder.{0} nnreal
            (@ordered_comm_monoid.to_partial_order.{0} nnreal
               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                     (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
      (@has_zero.zero.{0} nnreal nnreal.has_zero)
      (ε&#x27; i),
hε :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat),
          @coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
            (ε&#x27; i)))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe)) ε),
g : nat → set.{0} real,
hg :
  ∀ (i : nat),
    and (@has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (f i) (g i))
      (and
         (@is_measurable.{0} real
            (@borel.{0} real
               (@uniform_space.to_topological_space.{0} real
                  (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)))
            (g i))
         (@has_le.le.{0} ennreal
            (@preorder.to_has_le.{0} ennreal
               (@partial_order.to_preorder.{0} ennreal
                  (@ordered_comm_monoid.to_partial_order.{0} ennreal
                     (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                        (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                           ennreal.canonically_ordered_comm_semiring_1)))))
            (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real)
               (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
               measure_theory.lebesgue_outer
               (g i))
            (@has_add.add.{0} ennreal
               (@distrib.to_has_add.{0} ennreal
                  (@semiring.to_distrib.{0} ennreal
                     (@comm_semiring.to_semiring.{0} ennreal
                        (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                           ennreal.canonically_ordered_comm_semiring_1))))
               (measure_theory.lebesgue_length (f i))
               (@coe.{1 1} nnreal ennreal
                  (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
                  (nnreal.of_real
                     (@coe.{1 1} nnreal real
                        (@coe_to_lift.{1 1} nnreal real (@coe_base.{1 1} nnreal real nnreal.has_coe))
                        (ε&#x27; i)))))))
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@lattice.infi.{0 1} ennreal (set.{0} real)
       (@lattice.conditionally_complete_lattice.to_has_Inf.{0} ennreal
          (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
             (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
       (λ (t : set.{0} real),
          @lattice.infi.{0 0} ennreal (@has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) s t)
            (@lattice.conditionally_complete_lattice.to_has_Inf.{0} ennreal
               (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
                  (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
            (λ (st : @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) s t),
               @lattice.infi.{0 0} ennreal
                 (@is_measurable.{0} real
                    (@borel.{0} real
                       (@uniform_space.to_topological_space.{0} real
                          (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)))
                    t)
                 (@lattice.conditionally_complete_lattice.to_has_Inf.{0} ennreal
                    (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
                       (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal
                          ennreal.complete_linear_order_1)))
                 (λ
                  (ht :
                    @is_measurable.{0} real
                      (@borel.{0} real
                         (@uniform_space.to_topological_space.{0} real
                            (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)))
                      t),
                    @coe_fn.{1 1} (measure_theory.outer_measure.{0} real)
                      (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
                      measure_theory.lebesgue_outer
                      t))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (a : nat),
          @has_add.add.{0} ennreal
            (@distrib.to_has_add.{0} ennreal
               (@semiring.to_distrib.{0} ennreal
                  (@comm_semiring.to_semiring.{0} ennreal
                     (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                        ennreal.canonically_ordered_comm_semiring_1))))
            (measure_theory.lebesgue_length (f a))
            (@coe.{1 1} nnreal ennreal
               (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
               (ε&#x27; a))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} real,
f : nat → set.{0} real,
hf : @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) s (@set.Union.{0 1} real nat (λ (i : nat), f i)),
ε : nnreal,
ε0 :
  @has_lt.lt.{0} nnreal
    (@preorder.to_has_lt.{0} nnreal
       (@partial_order.to_preorder.{0} nnreal
          (@ordered_comm_monoid.to_partial_order.{0} nnreal
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                   (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
    (@has_zero.zero.{0} nnreal nnreal.has_zero)
    ε,
h :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat), measure_theory.lebesgue_length (f i)))
    (@lattice.has_top.top.{0} ennreal
       (@lattice.order_top.to_has_top.{0} ennreal
          (@lattice.bounded_lattice.to_order_top.{0} ennreal
             (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))))),
ε&#x27; : nat → nnreal,
ε&#x27;0 :
  ∀ (i : nat),
    @has_lt.lt.{0} nnreal
      (@preorder.to_has_lt.{0} nnreal
         (@partial_order.to_preorder.{0} nnreal
            (@ordered_comm_monoid.to_partial_order.{0} nnreal
               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                     (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
      (@has_zero.zero.{0} nnreal nnreal.has_zero)
      (ε&#x27; i),
hε :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat),
          @coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
            (ε&#x27; i)))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe)) ε),
g : nat → set.{0} real,
hg :
  ∀ (i : nat),
    and (@has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (f i) (g i))
      (and
         (@is_measurable.{0} real
            (@borel.{0} real
               (@uniform_space.to_topological_space.{0} real
                  (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)))
            (g i))
         (@has_le.le.{0} ennreal
            (@preorder.to_has_le.{0} ennreal
               (@partial_order.to_preorder.{0} ennreal
                  (@ordered_comm_monoid.to_partial_order.{0} ennreal
                     (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                        (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                           ennreal.canonically_ordered_comm_semiring_1)))))
            (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real)
               (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
               measure_theory.lebesgue_outer
               (g i))
            (@has_add.add.{0} ennreal
               (@distrib.to_has_add.{0} ennreal
                  (@semiring.to_distrib.{0} ennreal
                     (@comm_semiring.to_semiring.{0} ennreal
                        (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                           ennreal.canonically_ordered_comm_semiring_1))))
               (measure_theory.lebesgue_length (f i))
               (@coe.{1 1} nnreal ennreal
                  (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
                  (ε&#x27; i)))))
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@lattice.infi.{0 1} ennreal (set.{0} real)
       (@lattice.conditionally_complete_lattice.to_has_Inf.{0} ennreal
          (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
             (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
       (λ (t : set.{0} real),
          @lattice.infi.{0 0} ennreal (@has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) s t)
            (@lattice.conditionally_complete_lattice.to_has_Inf.{0} ennreal
               (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
                  (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
            (λ (st : @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) s t),
               @lattice.infi.{0 0} ennreal
                 (@is_measurable.{0} real
                    (@borel.{0} real
                       (@uniform_space.to_topological_space.{0} real
                          (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)))
                    t)
                 (@lattice.conditionally_complete_lattice.to_has_Inf.{0} ennreal
                    (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
                       (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal
                          ennreal.complete_linear_order_1)))
                 (λ
                  (ht :
                    @is_measurable.{0} real
                      (@borel.{0} real
                         (@uniform_space.to_topological_space.{0} real
                            (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)))
                      t),
                    @coe_fn.{1 1} (measure_theory.outer_measure.{0} real)
                      (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
                      measure_theory.lebesgue_outer
                      t))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (a : nat),
          @has_add.add.{0} ennreal
            (@distrib.to_has_add.{0} ennreal
               (@semiring.to_distrib.{0} ennreal
                  (@comm_semiring.to_semiring.{0} ennreal
                     (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                        ennreal.canonically_ordered_comm_semiring_1))))
            (measure_theory.lebesgue_length (f a))
            (@coe.{1 1} nnreal ennreal
               (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
               (ε&#x27; a))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>213    apply infi_le_of_le (Union g) _,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='lattice.infi_le_of_le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.Union'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/complete_lattice.lean&#x27;, &#x27;line&#x27;: 297, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/lattice.lean&#x27;, &#x27;line&#x27;: 72, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α ι : Type} [_inst_1 : lattice.complete_lattice.{0} α] {s : ι → α} {a : α} (i : ι), @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@lattice.order_bot.to_partial_order.{0} α (@lattice.bounded_lattice.to_order_bot.{0} α (@lattice.complete_lattice.to_bounded_lattice.{0} α _inst_1))))) (s i) a → @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@lattice.order_bot.to_partial_order.{0} α (@lattice.bounded_lattice.to_order_bot.{0} α (@lattice.complete_lattice.to_bounded_lattice.{0} α _inst_1))))) (@lattice.infi.{0 1} α ι (@lattice.complete_lattice.to_has_Inf.{0} α _inst_1) s) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {β ι : Type}, (ι → set.{0} β) → set.{0} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat → set.{0} real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Indexed union of a family of sets'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} real,
f : nat → set.{0} real,
hf : @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) s (@set.Union.{0 1} real nat (λ (i : nat), f i)),
ε : nnreal,
ε0 :
  @has_lt.lt.{0} nnreal
    (@preorder.to_has_lt.{0} nnreal
       (@partial_order.to_preorder.{0} nnreal
          (@ordered_comm_monoid.to_partial_order.{0} nnreal
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                   (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
    (@has_zero.zero.{0} nnreal nnreal.has_zero)
    ε,
h :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat), measure_theory.lebesgue_length (f i)))
    (@lattice.has_top.top.{0} ennreal
       (@lattice.order_top.to_has_top.{0} ennreal
          (@lattice.bounded_lattice.to_order_top.{0} ennreal
             (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))))),
ε&#x27; : nat → nnreal,
ε&#x27;0 :
  ∀ (i : nat),
    @has_lt.lt.{0} nnreal
      (@preorder.to_has_lt.{0} nnreal
         (@partial_order.to_preorder.{0} nnreal
            (@ordered_comm_monoid.to_partial_order.{0} nnreal
               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                     (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
      (@has_zero.zero.{0} nnreal nnreal.has_zero)
      (ε&#x27; i),
hε :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat),
          @coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
            (ε&#x27; i)))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe)) ε),
g : nat → set.{0} real,
hg :
  ∀ (i : nat),
    and (@has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (f i) (g i))
      (and
         (@is_measurable.{0} real
            (@borel.{0} real
               (@uniform_space.to_topological_space.{0} real
                  (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)))
            (g i))
         (@has_le.le.{0} ennreal
            (@preorder.to_has_le.{0} ennreal
               (@partial_order.to_preorder.{0} ennreal
                  (@ordered_comm_monoid.to_partial_order.{0} ennreal
                     (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                        (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                           ennreal.canonically_ordered_comm_semiring_1)))))
            (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real)
               (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
               measure_theory.lebesgue_outer
               (g i))
            (@has_add.add.{0} ennreal
               (@distrib.to_has_add.{0} ennreal
                  (@semiring.to_distrib.{0} ennreal
                     (@comm_semiring.to_semiring.{0} ennreal
                        (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                           ennreal.canonically_ordered_comm_semiring_1))))
               (measure_theory.lebesgue_length (f i))
               (@coe.{1 1} nnreal ennreal
                  (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
                  (ε&#x27; i)))))
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@lattice.infi.{0 1} ennreal (set.{0} real)
       (@lattice.conditionally_complete_lattice.to_has_Inf.{0} ennreal
          (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
             (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
       (λ (t : set.{0} real),
          @lattice.infi.{0 0} ennreal (@has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) s t)
            (@lattice.conditionally_complete_lattice.to_has_Inf.{0} ennreal
               (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
                  (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
            (λ (st : @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) s t),
               @lattice.infi.{0 0} ennreal
                 (@is_measurable.{0} real
                    (@borel.{0} real
                       (@uniform_space.to_topological_space.{0} real
                          (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)))
                    t)
                 (@lattice.conditionally_complete_lattice.to_has_Inf.{0} ennreal
                    (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
                       (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal
                          ennreal.complete_linear_order_1)))
                 (λ
                  (ht :
                    @is_measurable.{0} real
                      (@borel.{0} real
                         (@uniform_space.to_topological_space.{0} real
                            (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)))
                      t),
                    @coe_fn.{1 1} (measure_theory.outer_measure.{0} real)
                      (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
                      measure_theory.lebesgue_outer
                      t))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (a : nat),
          @has_add.add.{0} ennreal
            (@distrib.to_has_add.{0} ennreal
               (@semiring.to_distrib.{0} ennreal
                  (@comm_semiring.to_semiring.{0} ennreal
                     (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                        ennreal.canonically_ordered_comm_semiring_1))))
            (measure_theory.lebesgue_length (f a))
            (@coe.{1 1} nnreal ennreal
               (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
               (ε&#x27; a))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} real,
f : nat → set.{0} real,
hf : @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) s (@set.Union.{0 1} real nat (λ (i : nat), f i)),
ε : nnreal,
ε0 :
  @has_lt.lt.{0} nnreal
    (@preorder.to_has_lt.{0} nnreal
       (@partial_order.to_preorder.{0} nnreal
          (@ordered_comm_monoid.to_partial_order.{0} nnreal
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                   (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
    (@has_zero.zero.{0} nnreal nnreal.has_zero)
    ε,
h :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat), measure_theory.lebesgue_length (f i)))
    (@lattice.has_top.top.{0} ennreal
       (@lattice.order_top.to_has_top.{0} ennreal
          (@lattice.bounded_lattice.to_order_top.{0} ennreal
             (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))))),
ε&#x27; : nat → nnreal,
ε&#x27;0 :
  ∀ (i : nat),
    @has_lt.lt.{0} nnreal
      (@preorder.to_has_lt.{0} nnreal
         (@partial_order.to_preorder.{0} nnreal
            (@ordered_comm_monoid.to_partial_order.{0} nnreal
               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                     (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
      (@has_zero.zero.{0} nnreal nnreal.has_zero)
      (ε&#x27; i),
hε :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat),
          @coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
            (ε&#x27; i)))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe)) ε),
g : nat → set.{0} real,
hg :
  ∀ (i : nat),
    and (@has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (f i) (g i))
      (and
         (@is_measurable.{0} real
            (@borel.{0} real
               (@uniform_space.to_topological_space.{0} real
                  (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)))
            (g i))
         (@has_le.le.{0} ennreal
            (@preorder.to_has_le.{0} ennreal
               (@partial_order.to_preorder.{0} ennreal
                  (@ordered_comm_monoid.to_partial_order.{0} ennreal
                     (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                        (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                           ennreal.canonically_ordered_comm_semiring_1)))))
            (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real)
               (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
               measure_theory.lebesgue_outer
               (g i))
            (@has_add.add.{0} ennreal
               (@distrib.to_has_add.{0} ennreal
                  (@semiring.to_distrib.{0} ennreal
                     (@comm_semiring.to_semiring.{0} ennreal
                        (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                           ennreal.canonically_ordered_comm_semiring_1))))
               (measure_theory.lebesgue_length (f i))
               (@coe.{1 1} nnreal ennreal
                  (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
                  (ε&#x27; i)))))
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@lattice.order_bot.to_partial_order.{0} ennreal
             (@lattice.bounded_lattice.to_order_bot.{0} ennreal
                (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                   (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))))))
    (@lattice.infi.{0 0} ennreal
       (@has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) s (@set.Union.{0 1} real nat g))
       (@lattice.conditionally_complete_lattice.to_has_Inf.{0} ennreal
          (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
             (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
       (λ (st : @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) s (@set.Union.{0 1} real nat g)),
          @lattice.infi.{0 0} ennreal
            (@is_measurable.{0} real
               (@borel.{0} real
                  (@uniform_space.to_topological_space.{0} real
                     (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)))
               (@set.Union.{0 1} real nat g))
            (@lattice.conditionally_complete_lattice.to_has_Inf.{0} ennreal
               (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
                  (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
            (λ
             (ht :
               @is_measurable.{0} real
                 (@borel.{0} real
                    (@uniform_space.to_topological_space.{0} real
                       (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)))
                 (@set.Union.{0 1} real nat g)),
               @coe_fn.{1 1} (measure_theory.outer_measure.{0} real)
                 (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
                 measure_theory.lebesgue_outer
                 (@set.Union.{0 1} real nat g))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (a : nat),
          @has_add.add.{0} ennreal
            (@distrib.to_has_add.{0} ennreal
               (@semiring.to_distrib.{0} ennreal
                  (@comm_semiring.to_semiring.{0} ennreal
                     (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                        ennreal.canonically_ordered_comm_semiring_1))))
            (measure_theory.lebesgue_length (f a))
            (@coe.{1 1} nnreal ennreal
               (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
               (ε&#x27; a))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>214    apply infi_le_of_le (subset.trans hf $ Union_subset_Union (λ i, (hg i).1)) _,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='lattice.infi_le_of_le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.subset.trans'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='set.Union_subset_Union'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='hg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/complete_lattice.lean&#x27;, &#x27;line&#x27;: 297, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 94, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/lattice.lean&#x27;, &#x27;line&#x27;: 455, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} {ι : Prop} [_inst_1 : lattice.complete_lattice.{0} α] {s : ι → α} {a : α} (i : ι), @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@lattice.order_bot.to_partial_order.{0} α (@lattice.bounded_lattice.to_order_bot.{0} α (@lattice.complete_lattice.to_bounded_lattice.{0} α _inst_1))))) (s i) a → @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@lattice.order_bot.to_partial_order.{0} α (@lattice.bounded_lattice.to_order_bot.{0} α (@lattice.complete_lattice.to_bounded_lattice.{0} α _inst_1))))) (@lattice.infi.{0 0} α ι (@lattice.complete_lattice.to_has_Inf.{0} α _inst_1) s) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type} {a b c : set.{0} α}, @has_subset.subset.{0} (set.{0} α) (@set.has_subset.{0} α) a b → @has_subset.subset.{0} (set.{0} α) (@set.has_subset.{0} α) b c → @has_subset.subset.{0} (set.{0} α) (@set.has_subset.{0} α) a c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) s (@set.Union.{0 1} real nat (λ (i : nat), f i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α ι : Type} {s t : ι → set.{0} α}, (∀ (i : ι), @has_subset.subset.{0} (set.{0} α) (@set.has_subset.{0} α) (s i) (t i)) → @has_subset.subset.{0} (set.{0} α) (@set.has_subset.{0} α) (@set.Union.{0 1} α ι (λ (i : ι), s i)) (@set.Union.{0 1} α ι (λ (i : ι), t i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ (i : nat), and (@has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (f i) (g i)) (and (@is_measurable.{0} real (@borel.{0} real (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))) (g i)) (@has_le.le.{0} ennreal (@preorder.to_has_le.{0} ennreal (@partial_order.to_preorder.{0} ennreal (@ordered_comm_monoid.to_partial_order.{0} ennreal (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal ennreal.canonically_ordered_comm_semiring_1))))) (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real) (@measure_theory.outer_measure.has_coe_to_fun.{0} real) measure_theory.lebesgue_outer (g i)) (@has_add.add.{0} ennreal (@distrib.to_has_add.{0} ennreal (@semiring.to_distrib.{0} ennreal (@comm_semiring.to_semiring.{0} ennreal (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal ennreal.canonically_ordered_comm_semiring_1)))) (measure_theory.lebesgue_length (f i)) (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe)) (ε&#x27; i)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} real,
f : nat → set.{0} real,
hf : @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) s (@set.Union.{0 1} real nat (λ (i : nat), f i)),
ε : nnreal,
ε0 :
  @has_lt.lt.{0} nnreal
    (@preorder.to_has_lt.{0} nnreal
       (@partial_order.to_preorder.{0} nnreal
          (@ordered_comm_monoid.to_partial_order.{0} nnreal
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                   (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
    (@has_zero.zero.{0} nnreal nnreal.has_zero)
    ε,
h :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat), measure_theory.lebesgue_length (f i)))
    (@lattice.has_top.top.{0} ennreal
       (@lattice.order_top.to_has_top.{0} ennreal
          (@lattice.bounded_lattice.to_order_top.{0} ennreal
             (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))))),
ε&#x27; : nat → nnreal,
ε&#x27;0 :
  ∀ (i : nat),
    @has_lt.lt.{0} nnreal
      (@preorder.to_has_lt.{0} nnreal
         (@partial_order.to_preorder.{0} nnreal
            (@ordered_comm_monoid.to_partial_order.{0} nnreal
               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                     (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
      (@has_zero.zero.{0} nnreal nnreal.has_zero)
      (ε&#x27; i),
hε :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat),
          @coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
            (ε&#x27; i)))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe)) ε),
g : nat → set.{0} real,
hg :
  ∀ (i : nat),
    and (@has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (f i) (g i))
      (and
         (@is_measurable.{0} real
            (@borel.{0} real
               (@uniform_space.to_topological_space.{0} real
                  (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)))
            (g i))
         (@has_le.le.{0} ennreal
            (@preorder.to_has_le.{0} ennreal
               (@partial_order.to_preorder.{0} ennreal
                  (@ordered_comm_monoid.to_partial_order.{0} ennreal
                     (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                        (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                           ennreal.canonically_ordered_comm_semiring_1)))))
            (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real)
               (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
               measure_theory.lebesgue_outer
               (g i))
            (@has_add.add.{0} ennreal
               (@distrib.to_has_add.{0} ennreal
                  (@semiring.to_distrib.{0} ennreal
                     (@comm_semiring.to_semiring.{0} ennreal
                        (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                           ennreal.canonically_ordered_comm_semiring_1))))
               (measure_theory.lebesgue_length (f i))
               (@coe.{1 1} nnreal ennreal
                  (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
                  (ε&#x27; i)))))
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@lattice.order_bot.to_partial_order.{0} ennreal
             (@lattice.bounded_lattice.to_order_bot.{0} ennreal
                (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                   (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))))))
    (@lattice.infi.{0 0} ennreal
       (@has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) s (@set.Union.{0 1} real nat g))
       (@lattice.conditionally_complete_lattice.to_has_Inf.{0} ennreal
          (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
             (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
       (λ (st : @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) s (@set.Union.{0 1} real nat g)),
          @lattice.infi.{0 0} ennreal
            (@is_measurable.{0} real
               (@borel.{0} real
                  (@uniform_space.to_topological_space.{0} real
                     (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)))
               (@set.Union.{0 1} real nat g))
            (@lattice.conditionally_complete_lattice.to_has_Inf.{0} ennreal
               (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
                  (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
            (λ
             (ht :
               @is_measurable.{0} real
                 (@borel.{0} real
                    (@uniform_space.to_topological_space.{0} real
                       (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)))
                 (@set.Union.{0 1} real nat g)),
               @coe_fn.{1 1} (measure_theory.outer_measure.{0} real)
                 (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
                 measure_theory.lebesgue_outer
                 (@set.Union.{0 1} real nat g))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (a : nat),
          @has_add.add.{0} ennreal
            (@distrib.to_has_add.{0} ennreal
               (@semiring.to_distrib.{0} ennreal
                  (@comm_semiring.to_semiring.{0} ennreal
                     (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                        ennreal.canonically_ordered_comm_semiring_1))))
            (measure_theory.lebesgue_length (f a))
            (@coe.{1 1} nnreal ennreal
               (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
               (ε&#x27; a))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} real,
f : nat → set.{0} real,
hf : @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) s (@set.Union.{0 1} real nat (λ (i : nat), f i)),
ε : nnreal,
ε0 :
  @has_lt.lt.{0} nnreal
    (@preorder.to_has_lt.{0} nnreal
       (@partial_order.to_preorder.{0} nnreal
          (@ordered_comm_monoid.to_partial_order.{0} nnreal
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                   (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
    (@has_zero.zero.{0} nnreal nnreal.has_zero)
    ε,
h :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat), measure_theory.lebesgue_length (f i)))
    (@lattice.has_top.top.{0} ennreal
       (@lattice.order_top.to_has_top.{0} ennreal
          (@lattice.bounded_lattice.to_order_top.{0} ennreal
             (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))))),
ε&#x27; : nat → nnreal,
ε&#x27;0 :
  ∀ (i : nat),
    @has_lt.lt.{0} nnreal
      (@preorder.to_has_lt.{0} nnreal
         (@partial_order.to_preorder.{0} nnreal
            (@ordered_comm_monoid.to_partial_order.{0} nnreal
               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                     (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
      (@has_zero.zero.{0} nnreal nnreal.has_zero)
      (ε&#x27; i),
hε :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat),
          @coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
            (ε&#x27; i)))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe)) ε),
g : nat → set.{0} real,
hg :
  ∀ (i : nat),
    and (@has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (f i) (g i))
      (and
         (@is_measurable.{0} real
            (@borel.{0} real
               (@uniform_space.to_topological_space.{0} real
                  (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)))
            (g i))
         (@has_le.le.{0} ennreal
            (@preorder.to_has_le.{0} ennreal
               (@partial_order.to_preorder.{0} ennreal
                  (@ordered_comm_monoid.to_partial_order.{0} ennreal
                     (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                        (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                           ennreal.canonically_ordered_comm_semiring_1)))))
            (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real)
               (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
               measure_theory.lebesgue_outer
               (g i))
            (@has_add.add.{0} ennreal
               (@distrib.to_has_add.{0} ennreal
                  (@semiring.to_distrib.{0} ennreal
                     (@comm_semiring.to_semiring.{0} ennreal
                        (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                           ennreal.canonically_ordered_comm_semiring_1))))
               (measure_theory.lebesgue_length (f i))
               (@coe.{1 1} nnreal ennreal
                  (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
                  (ε&#x27; i)))))
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@lattice.order_bot.to_partial_order.{0} ennreal
             (@lattice.bounded_lattice.to_order_bot.{0} ennreal
                (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                   (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))))))
    (@lattice.infi.{0 0} ennreal
       (@is_measurable.{0} real
          (@borel.{0} real
             (@uniform_space.to_topological_space.{0} real
                (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)))
          (@set.Union.{0 1} real nat g))
       (@lattice.conditionally_complete_lattice.to_has_Inf.{0} ennreal
          (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
             (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
       (λ
        (ht :
          @is_measurable.{0} real
            (@borel.{0} real
               (@uniform_space.to_topological_space.{0} real
                  (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)))
            (@set.Union.{0 1} real nat g)),
          @coe_fn.{1 1} (measure_theory.outer_measure.{0} real) (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
            measure_theory.lebesgue_outer
            (@set.Union.{0 1} real nat g)))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (a : nat),
          @has_add.add.{0} ennreal
            (@distrib.to_has_add.{0} ennreal
               (@semiring.to_distrib.{0} ennreal
                  (@comm_semiring.to_semiring.{0} ennreal
                     (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                        ennreal.canonically_ordered_comm_semiring_1))))
            (measure_theory.lebesgue_length (f a))
            (@coe.{1 1} nnreal ennreal
               (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
               (ε&#x27; a))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>215    apply infi_le_of_le (is_measurable.Union (λ i, (hg i).2.1)) _,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='lattice.infi_le_of_le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='is_measurable.Union'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='hg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/complete_lattice.lean&#x27;, &#x27;line&#x27;: 297, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measurable_space.lean&#x27;, &#x27;line&#x27;: 106, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} {ι : Prop} [_inst_1 : lattice.complete_lattice.{0} α] {s : ι → α} {a : α} (i : ι), @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@lattice.order_bot.to_partial_order.{0} α (@lattice.bounded_lattice.to_order_bot.{0} α (@lattice.complete_lattice.to_bounded_lattice.{0} α _inst_1))))) (s i) a → @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@lattice.order_bot.to_partial_order.{0} α (@lattice.bounded_lattice.to_order_bot.{0} α (@lattice.complete_lattice.to_bounded_lattice.{0} α _inst_1))))) (@lattice.infi.{0 0} α ι (@lattice.complete_lattice.to_has_Inf.{0} α _inst_1) s) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α β : Type} [_inst_1 : measurable_space.{0} α] [_inst_2 : encodable.{0} β] {f : β → set.{0} α}, (∀ (b : β), @is_measurable.{0} α _inst_1 (f b)) → @is_measurable.{0} α _inst_1 (@set.Union.{0 1} α β (λ (b : β), f b))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ (i : nat), and (@has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (f i) (g i)) (and (@is_measurable.{0} real (@borel.{0} real (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))) (g i)) (@has_le.le.{0} ennreal (@preorder.to_has_le.{0} ennreal (@partial_order.to_preorder.{0} ennreal (@ordered_comm_monoid.to_partial_order.{0} ennreal (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal ennreal.canonically_ordered_comm_semiring_1))))) (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real) (@measure_theory.outer_measure.has_coe_to_fun.{0} real) measure_theory.lebesgue_outer (g i)) (@has_add.add.{0} ennreal (@distrib.to_has_add.{0} ennreal (@semiring.to_distrib.{0} ennreal (@comm_semiring.to_semiring.{0} ennreal (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal ennreal.canonically_ordered_comm_semiring_1)))) (measure_theory.lebesgue_length (f i)) (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe)) (ε&#x27; i)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} real,
f : nat → set.{0} real,
hf : @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) s (@set.Union.{0 1} real nat (λ (i : nat), f i)),
ε : nnreal,
ε0 :
  @has_lt.lt.{0} nnreal
    (@preorder.to_has_lt.{0} nnreal
       (@partial_order.to_preorder.{0} nnreal
          (@ordered_comm_monoid.to_partial_order.{0} nnreal
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                   (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
    (@has_zero.zero.{0} nnreal nnreal.has_zero)
    ε,
h :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat), measure_theory.lebesgue_length (f i)))
    (@lattice.has_top.top.{0} ennreal
       (@lattice.order_top.to_has_top.{0} ennreal
          (@lattice.bounded_lattice.to_order_top.{0} ennreal
             (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))))),
ε&#x27; : nat → nnreal,
ε&#x27;0 :
  ∀ (i : nat),
    @has_lt.lt.{0} nnreal
      (@preorder.to_has_lt.{0} nnreal
         (@partial_order.to_preorder.{0} nnreal
            (@ordered_comm_monoid.to_partial_order.{0} nnreal
               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                     (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
      (@has_zero.zero.{0} nnreal nnreal.has_zero)
      (ε&#x27; i),
hε :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat),
          @coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
            (ε&#x27; i)))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe)) ε),
g : nat → set.{0} real,
hg :
  ∀ (i : nat),
    and (@has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (f i) (g i))
      (and
         (@is_measurable.{0} real
            (@borel.{0} real
               (@uniform_space.to_topological_space.{0} real
                  (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)))
            (g i))
         (@has_le.le.{0} ennreal
            (@preorder.to_has_le.{0} ennreal
               (@partial_order.to_preorder.{0} ennreal
                  (@ordered_comm_monoid.to_partial_order.{0} ennreal
                     (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                        (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                           ennreal.canonically_ordered_comm_semiring_1)))))
            (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real)
               (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
               measure_theory.lebesgue_outer
               (g i))
            (@has_add.add.{0} ennreal
               (@distrib.to_has_add.{0} ennreal
                  (@semiring.to_distrib.{0} ennreal
                     (@comm_semiring.to_semiring.{0} ennreal
                        (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                           ennreal.canonically_ordered_comm_semiring_1))))
               (measure_theory.lebesgue_length (f i))
               (@coe.{1 1} nnreal ennreal
                  (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
                  (ε&#x27; i)))))
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@lattice.order_bot.to_partial_order.{0} ennreal
             (@lattice.bounded_lattice.to_order_bot.{0} ennreal
                (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                   (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))))))
    (@lattice.infi.{0 0} ennreal
       (@is_measurable.{0} real
          (@borel.{0} real
             (@uniform_space.to_topological_space.{0} real
                (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)))
          (@set.Union.{0 1} real nat g))
       (@lattice.conditionally_complete_lattice.to_has_Inf.{0} ennreal
          (@lattice.conditionally_complete_lattice_of_complete_lattice.{0} ennreal
             (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))
       (λ
        (ht :
          @is_measurable.{0} real
            (@borel.{0} real
               (@uniform_space.to_topological_space.{0} real
                  (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)))
            (@set.Union.{0 1} real nat g)),
          @coe_fn.{1 1} (measure_theory.outer_measure.{0} real) (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
            measure_theory.lebesgue_outer
            (@set.Union.{0 1} real nat g)))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (a : nat),
          @has_add.add.{0} ennreal
            (@distrib.to_has_add.{0} ennreal
               (@semiring.to_distrib.{0} ennreal
                  (@comm_semiring.to_semiring.{0} ennreal
                     (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                        ennreal.canonically_ordered_comm_semiring_1))))
            (measure_theory.lebesgue_length (f a))
            (@coe.{1 1} nnreal ennreal
               (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
               (ε&#x27; a))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} real,
f : nat → set.{0} real,
hf : @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) s (@set.Union.{0 1} real nat (λ (i : nat), f i)),
ε : nnreal,
ε0 :
  @has_lt.lt.{0} nnreal
    (@preorder.to_has_lt.{0} nnreal
       (@partial_order.to_preorder.{0} nnreal
          (@ordered_comm_monoid.to_partial_order.{0} nnreal
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                   (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
    (@has_zero.zero.{0} nnreal nnreal.has_zero)
    ε,
h :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat), measure_theory.lebesgue_length (f i)))
    (@lattice.has_top.top.{0} ennreal
       (@lattice.order_top.to_has_top.{0} ennreal
          (@lattice.bounded_lattice.to_order_top.{0} ennreal
             (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))))),
ε&#x27; : nat → nnreal,
ε&#x27;0 :
  ∀ (i : nat),
    @has_lt.lt.{0} nnreal
      (@preorder.to_has_lt.{0} nnreal
         (@partial_order.to_preorder.{0} nnreal
            (@ordered_comm_monoid.to_partial_order.{0} nnreal
               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                     (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
      (@has_zero.zero.{0} nnreal nnreal.has_zero)
      (ε&#x27; i),
hε :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat),
          @coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
            (ε&#x27; i)))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe)) ε),
g : nat → set.{0} real,
hg :
  ∀ (i : nat),
    and (@has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (f i) (g i))
      (and
         (@is_measurable.{0} real
            (@borel.{0} real
               (@uniform_space.to_topological_space.{0} real
                  (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)))
            (g i))
         (@has_le.le.{0} ennreal
            (@preorder.to_has_le.{0} ennreal
               (@partial_order.to_preorder.{0} ennreal
                  (@ordered_comm_monoid.to_partial_order.{0} ennreal
                     (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                        (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                           ennreal.canonically_ordered_comm_semiring_1)))))
            (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real)
               (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
               measure_theory.lebesgue_outer
               (g i))
            (@has_add.add.{0} ennreal
               (@distrib.to_has_add.{0} ennreal
                  (@semiring.to_distrib.{0} ennreal
                     (@comm_semiring.to_semiring.{0} ennreal
                        (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                           ennreal.canonically_ordered_comm_semiring_1))))
               (measure_theory.lebesgue_length (f i))
               (@coe.{1 1} nnreal ennreal
                  (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
                  (ε&#x27; i)))))
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@lattice.order_bot.to_partial_order.{0} ennreal
             (@lattice.bounded_lattice.to_order_bot.{0} ennreal
                (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                   (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))))))
    (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real) (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
       measure_theory.lebesgue_outer
       (@set.Union.{0 1} real nat g))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (a : nat),
          @has_add.add.{0} ennreal
            (@distrib.to_has_add.{0} ennreal
               (@semiring.to_distrib.{0} ennreal
                  (@comm_semiring.to_semiring.{0} ennreal
                     (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                        ennreal.canonically_ordered_comm_semiring_1))))
            (measure_theory.lebesgue_length (f a))
            (@coe.{1 1} nnreal ennreal
               (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
               (ε&#x27; a))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>216    exact le_trans (lebesgue_outer.Union _) (ennreal.tsum_le_tsum $ λ i, (hg i).2.2)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='le_trans'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='measure_theory.lebesgue_outer'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='ennreal.tsum_le_tsum'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='hg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 33, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/outer_measure.lean&#x27;, &#x27;line&#x27;: 87, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/instances/ennreal.lean&#x27;, &#x27;line&#x27;: 473, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : preorder.{0} α] {a b c : α}, @has_le.le.{0} α (@preorder.to_has_le.{0} α _inst_1) a b → @has_le.le.{0} α (@preorder.to_has_le.{0} α _inst_1) b c → @has_le.le.{0} α (@preorder.to_has_le.{0} α _inst_1) a c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='measure_theory.outer_measure.{0} real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type} {f g : α → ennreal}, (∀ (a : α), @has_le.le.{0} ennreal (@preorder.to_has_le.{0} ennreal (@partial_order.to_preorder.{0} ennreal (@ordered_comm_monoid.to_partial_order.{0} ennreal (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal ennreal.canonically_ordered_comm_semiring_1))))) (f a) (g a)) → @has_le.le.{0} ennreal (@preorder.to_has_le.{0} ennreal (@partial_order.to_preorder.{0} ennreal (@ordered_comm_monoid.to_partial_order.{0} ennreal (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal ennreal.canonically_ordered_comm_semiring_1))))) (@tsum.{0 0} ennreal α (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal ennreal.canonically_ordered_comm_semiring_1))) ennreal.topological_space (λ (a : α), f a)) (@tsum.{0 0} ennreal α (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal ennreal.canonically_ordered_comm_semiring_1))) ennreal.topological_space (λ (a : α), g a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ (i : nat), and (@has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (f i) (g i)) (and (@is_measurable.{0} real (@borel.{0} real (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))) (g i)) (@has_le.le.{0} ennreal (@preorder.to_has_le.{0} ennreal (@partial_order.to_preorder.{0} ennreal (@ordered_comm_monoid.to_partial_order.{0} ennreal (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal ennreal.canonically_ordered_comm_semiring_1))))) (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real) (@measure_theory.outer_measure.has_coe_to_fun.{0} real) measure_theory.lebesgue_outer (g i)) (@has_add.add.{0} ennreal (@distrib.to_has_add.{0} ennreal (@semiring.to_distrib.{0} ennreal (@comm_semiring.to_semiring.{0} ennreal (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal ennreal.canonically_ordered_comm_semiring_1)))) (measure_theory.lebesgue_length (f i)) (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe)) (ε&#x27; i)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The Lebesgue outer measure, as an outer measure of ℝ.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} real,
f : nat → set.{0} real,
hf : @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) s (@set.Union.{0 1} real nat (λ (i : nat), f i)),
ε : nnreal,
ε0 :
  @has_lt.lt.{0} nnreal
    (@preorder.to_has_lt.{0} nnreal
       (@partial_order.to_preorder.{0} nnreal
          (@ordered_comm_monoid.to_partial_order.{0} nnreal
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                   (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
    (@has_zero.zero.{0} nnreal nnreal.has_zero)
    ε,
h :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat), measure_theory.lebesgue_length (f i)))
    (@lattice.has_top.top.{0} ennreal
       (@lattice.order_top.to_has_top.{0} ennreal
          (@lattice.bounded_lattice.to_order_top.{0} ennreal
             (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))))),
ε&#x27; : nat → nnreal,
ε&#x27;0 :
  ∀ (i : nat),
    @has_lt.lt.{0} nnreal
      (@preorder.to_has_lt.{0} nnreal
         (@partial_order.to_preorder.{0} nnreal
            (@ordered_comm_monoid.to_partial_order.{0} nnreal
               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nnreal
                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nnreal
                     (@linear_ordered_semiring.to_ordered_semiring.{0} nnreal nnreal.linear_ordered_semiring))))))
      (@has_zero.zero.{0} nnreal nnreal.has_zero)
      (ε&#x27; i),
hε :
  @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (i : nat),
          @coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
            (ε&#x27; i)))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe)) ε),
g : nat → set.{0} real,
hg :
  ∀ (i : nat),
    and (@has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) (f i) (g i))
      (and
         (@is_measurable.{0} real
            (@borel.{0} real
               (@uniform_space.to_topological_space.{0} real
                  (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)))
            (g i))
         (@has_le.le.{0} ennreal
            (@preorder.to_has_le.{0} ennreal
               (@partial_order.to_preorder.{0} ennreal
                  (@ordered_comm_monoid.to_partial_order.{0} ennreal
                     (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                        (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                           ennreal.canonically_ordered_comm_semiring_1)))))
            (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real)
               (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
               measure_theory.lebesgue_outer
               (g i))
            (@has_add.add.{0} ennreal
               (@distrib.to_has_add.{0} ennreal
                  (@semiring.to_distrib.{0} ennreal
                     (@comm_semiring.to_semiring.{0} ennreal
                        (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                           ennreal.canonically_ordered_comm_semiring_1))))
               (measure_theory.lebesgue_length (f i))
               (@coe.{1 1} nnreal ennreal
                  (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
                  (ε&#x27; i)))))
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@lattice.order_bot.to_partial_order.{0} ennreal
             (@lattice.bounded_lattice.to_order_bot.{0} ennreal
                (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                   (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))))))
    (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real) (@measure_theory.outer_measure.has_coe_to_fun.{0} real)
       measure_theory.lebesgue_outer
       (@set.Union.{0 1} real nat g))
    (@tsum.{0 0} ennreal nat
       (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal
          (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
             (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                ennreal.canonically_ordered_comm_semiring_1)))
       ennreal.topological_space
       (λ (a : nat),
          @has_add.add.{0} ennreal
            (@distrib.to_has_add.{0} ennreal
               (@semiring.to_distrib.{0} ennreal
                  (@comm_semiring.to_semiring.{0} ennreal
                     (@canonically_ordered_comm_semiring.to_comm_semiring.{0} ennreal
                        ennreal.canonically_ordered_comm_semiring_1))))
            (measure_theory.lebesgue_length (f a))
            (@coe.{1 1} nnreal ennreal
               (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
               (ε&#x27; a))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>217  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>218  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>219  /-- Lebesgue measure on the Borel sets</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>220  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>221  The outer Lebesgue measure is the completion of this measure. (TODO: proof this)</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>222  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>223  instance : measure_space ℝ :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='measure_theory.measure_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measure_space.lean&#x27;, &#x27;line&#x27;: 801, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/basic.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='A measure space is a measurable space equipped with a
 measure, referred to as `volume`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>224  ⟨{to_outer_measure := lebesgue_outer,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='blue'><a title='measure_theory.lebesgue_outer'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='red'><a title='{&#x27;line&#x27;: 87, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='green'><a title='measure_theory.outer_measure.{0} real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='orange'><a title='The Lebesgue outer measure, as an outer measure of ℝ.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>225    m_Union :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>226      have borel ℝ ≤ lebesgue_outer.caratheodory,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='borel'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_le.le'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='measure_theory.lebesgue_outer'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='measure_theory.outer_measure.caratheodory'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/borel_space.lean&#x27;, &#x27;line&#x27;: 28, &#x27;column&#x27;: 30}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/basic.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 319, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 87, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/outer_measure.lean&#x27;, &#x27;line&#x27;: 404, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Π (α : Type) [_inst_1 : topological_space.{0} α], measurable_space.{0} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_le.{0} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='measure_theory.outer_measure.{0} real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type}, measure_theory.outer_measure.{0} α → measurable_space.{0} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='The Lebesgue outer measure, as an outer measure of ℝ.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Given an outer measure `μ`, the Caratheodory measurable space is
 defined such that `s` is measurable if `∀t, μ t = μ (t ∩ s) + μ (t \ s)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>227      by rw real.borel_eq_generate_from_Iio_rat;</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='real.borel_eq_generate_from_Iio_rat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/borel_space.lean&#x27;, &#x27;line&#x27;: 362, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{1} (measurable_space.{0} real) (@borel.{0} real (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))) (@measurable_space.generate_from.{0} real (@set.Union.{0 1} (set.{0} real) rat (λ (a : rat), @singleton.{0 0} (set.{0} real) (set.{0} (set.{0} real)) (@set.has_emptyc.{0} (set.{0} real)) (@set.has_insert.{0} (set.{0} real)) (@set.Iio.{0} real real.preorder (@coe.{1 1} rat real (@coe_to_lift.{1 1} rat real (@coe_base.{1 1} rat real (@rat.cast_coe.{0} real real.division_ring))) a)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='lime'><a title='⊢ @has_le.le.{0} (measurable_space.{0} real)
    (@preorder.to_has_le.{0} (measurable_space.{0} real)
       (@partial_order.to_preorder.{0} (measurable_space.{0} real) (@measurable_space.partial_order.{0} real)))
    (@borel.{0} real
       (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)))
    (@measure_theory.outer_measure.caratheodory.{0} real measure_theory.lebesgue_outer)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>228         refine measurable_space.generate_from_le _;</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='measurable_space.generate_from_le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measurable_space.lean&#x27;, &#x27;line&#x27;: 208, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} {s : set.{0} (set.{0} α)} {m : measurable_space.{0} α}, (∀ (t : set.{0} α), @has_mem.mem.{0 0} (set.{0} α) (set.{0} (set.{0} α)) (@set.has_mem.{0} (set.{0} α)) t s → @measurable_space.is_measurable.{0} α m t) → @has_le.le.{0} (measurable_space.{0} α) (@preorder.to_has_le.{0} (measurable_space.{0} α) (@partial_order.to_preorder.{0} (measurable_space.{0} α) (@measurable_space.partial_order.{0} α))) (@measurable_space.generate_from.{0} α s) m'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='⊢ @has_le.le.{0} (measurable_space.{0} real)
    (@preorder.to_has_le.{0} (measurable_space.{0} real)
       (@partial_order.to_preorder.{0} (measurable_space.{0} real) (@measurable_space.partial_order.{0} real)))
    (@borel.{0} real
       (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)))
    (@measure_theory.outer_measure.caratheodory.{0} real measure_theory.lebesgue_outer)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>229         simp [is_lebesgue_measurable_Iio] {contextual := tt},</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='measure_theory.is_lebesgue_measurable_Iio'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='bool.tt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 175, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 253, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {c : real}, @measurable_space.is_measurable.{0} real (@measure_theory.outer_measure.caratheodory.{0} real measure_theory.lebesgue_outer) (@set.Iio.{0} real real.preorder c)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='bool'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='5'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='5'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='⊢ @has_le.le.{0} (measurable_space.{0} real)
    (@preorder.to_has_le.{0} (measurable_space.{0} real)
       (@partial_order.to_preorder.{0} (measurable_space.{0} real) (@measurable_space.partial_order.{0} real)))
    (@borel.{0} real
       (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)))
    (@measure_theory.outer_measure.caratheodory.{0} real measure_theory.lebesgue_outer)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>230      λ f hf, lebesgue_outer.Union_eq_of_caratheodory (λ i, this _ (hf i)),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='measure_theory.lebesgue_outer'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='measure_theory.outer_measure.Union_eq_of_caratheodory'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;line&#x27;: 87, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/outer_measure.lean&#x27;, &#x27;line&#x27;: 415, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='nat → set.{0} real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ (i : nat), @is_measurable.{0} real (@borel.{0} real (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))) (f i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='measure_theory.outer_measure.{0} real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} (m : measure_theory.outer_measure.{0} α) {s : nat → set.{0} α}, (∀ (i : nat), @measurable_space.is_measurable.{0} α (@measure_theory.outer_measure.caratheodory.{0} α m) (s i)) → @pairwise.{0} nat (@function.on_fun.{1 1 1} nat (set.{0} α) Prop (@disjoint.{0} (set.{0} α) (@lattice.semilattice_inf_bot_of_bounded_lattice.{0} (set.{0} α) (@lattice.complete_lattice.to_bounded_lattice.{0} (set.{0} α) (@set.lattice_set.{0} α)))) s) → @eq.{1} ennreal (@coe_fn.{1 1} (measure_theory.outer_measure.{0} α) (@measure_theory.outer_measure.has_coe_to_fun.{0} α) m (@set.Union.{0 1} α nat (λ (i : nat), s i))) (@tsum.{0 0} ennreal nat (@ordered_comm_monoid.to_add_comm_monoid.{0} ennreal (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal ennreal.canonically_ordered_comm_semiring_1))) ennreal.topological_space (λ (i : nat), @coe_fn.{1 1} (measure_theory.outer_measure.{0} α) (@measure_theory.outer_measure.has_coe_to_fun.{0} α) m (s i)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_le.le.{0} (measurable_space.{0} real) (@preorder.to_has_le.{0} (measurable_space.{0} real) (@partial_order.to_preorder.{0} (measurable_space.{0} real) (@measurable_space.partial_order.{0} real))) (@borel.{0} real (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))) (@measure_theory.outer_measure.caratheodory.{0} real measure_theory.lebesgue_outer)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ (i : nat), @is_measurable.{0} real (@borel.{0} real (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))) (f i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='The Lebesgue outer measure, as an outer measure of ℝ.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>231    trimmed := lebesgue_outer_trim }⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='measure_theory.lebesgue_outer_trim'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;line&#x27;: 192, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='@eq.{1} (measure_theory.outer_measure.{0} real) (@measure_theory.outer_measure.trim.{0} real (@borel.{0} real (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))) measure_theory.lebesgue_outer) measure_theory.lebesgue_outer'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>232  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>233  @[simp] theorem lebesgue_to_outer_measure :</code>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>234    (measure_space.μ : measure ℝ).to_outer_measure = lebesgue_outer := rfl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='measure_theory.measure_space.μ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='measure_theory.measure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='measure_theory.measure.to_outer_measure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='measure_theory.lebesgue_outer'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measure_space.lean&#x27;, &#x27;line&#x27;: 801, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measure_space.lean&#x27;, &#x27;line&#x27;: 209, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/basic.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measure_space.lean&#x27;, &#x27;line&#x27;: 209, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 87, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u_1} [c : measure_theory.measure_space.{u_1} α], @measure_theory.measure.{u_1} α (@measure_theory.measure_space.to_measurable_space.{u_1} α c)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (α : Type u_1) [_inst_1 : measurable_space.{u_1} α], Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [_inst_1 : measurable_space.{0} α], @measure_theory.measure.{0} α _inst_1 → measure_theory.outer_measure.{0} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='measure_theory.outer_measure.{0} real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Type} {a : α}, @eq.{1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                   </code><font color='orange'><a title='The Lebesgue outer measure, as an outer measure of ℝ.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>235  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>236  end measure_theory</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>237  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>238  open measure_theory</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>239  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>240  section volume</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>241  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>242  open_locale interval</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>243  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>244  theorem real.volume_val (s) : volume s = lebesgue_outer s := rfl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='blue'><a title='measure_theory.volume'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='measure_theory.lebesgue_outer'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measure_space.lean&#x27;, &#x27;line&#x27;: 809, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 87, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : measure_theory.measure_space.{u_1} α], set.{u_1} α → ennreal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{0} real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='measure_theory.outer_measure.{0} real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{0} real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Type} {a : α}, @eq.{1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='orange'><a title='The Lebesgue outer measure, as an outer measure of ℝ.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>245  local attribute [simp] real.volume_val</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='blue'><a title='real.volume_val'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='red'><a title='{&#x27;line&#x27;: 244, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='green'><a title='∀ (s : set.{0} real), @eq.{1} ennreal (@measure_theory.volume.{0} real measure_theory.measure_theory.measure_space s) (@coe_fn.{1 1} (measure_theory.outer_measure.{0} real) (@measure_theory.outer_measure.has_coe_to_fun.{0} real) measure_theory.lebesgue_outer s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>246  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>247  @[simp] lemma real.volume_Ico {a b : ℝ} : volume (Ico a b) = of_real (b - a) := by simp</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='blue'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='measure_theory.volume'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.Ico'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='nnreal.of_real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_sub.sub'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/basic.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measure_space.lean&#x27;, &#x27;line&#x27;: 809, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/intervals/basic.lean&#x27;, &#x27;line&#x27;: 43, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/nnreal.lean&#x27;, &#x27;line&#x27;: 32, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 315, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : measure_theory.measure_space.{u_1} α], set.{u_1} α → ennreal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [_inst_1 : preorder.{u} α], α → α → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real → nnreal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_sub.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                            </code><font color='orange'><a title='Left-closed right-open interval'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                                   </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                                   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                                       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                                  </code><font color='lime'><a title='a b : real
⊢ @eq.{1} ennreal
    (@measure_theory.volume.{0} real measure_theory.measure_theory.measure_space (@set.Ico.{0} real real.preorder a b))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>248  @[simp] lemma real.volume_Icc {a b : ℝ} : volume (Icc a b) = of_real (b - a) := by simp</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='blue'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='measure_theory.volume'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.Icc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='nnreal.of_real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_sub.sub'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/basic.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measure_space.lean&#x27;, &#x27;line&#x27;: 809, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/intervals/basic.lean&#x27;, &#x27;line&#x27;: 49, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/nnreal.lean&#x27;, &#x27;line&#x27;: 32, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 315, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : measure_theory.measure_space.{u_1} α], set.{u_1} α → ennreal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [_inst_1 : preorder.{u} α], α → α → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real → nnreal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_sub.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                            </code><font color='orange'><a title='Left-closed right-closed interval'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                                   </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                                   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                                       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                                  </code><font color='lime'><a title='a b : real
⊢ @eq.{1} ennreal
    (@measure_theory.volume.{0} real measure_theory.measure_theory.measure_space (@set.Icc.{0} real real.preorder a b))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>249  @[simp] lemma real.volume_Ioo {a b : ℝ} : volume (Ioo a b) = of_real (b - a) := by simp</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='blue'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='measure_theory.volume'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.Ioo'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='nnreal.of_real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_sub.sub'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/basic.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measure_space.lean&#x27;, &#x27;line&#x27;: 809, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/intervals/basic.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/nnreal.lean&#x27;, &#x27;line&#x27;: 32, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 315, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : measure_theory.measure_space.{u_1} α], set.{u_1} α → ennreal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [_inst_1 : preorder.{u} α], α → α → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real → nnreal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_sub.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                            </code><font color='orange'><a title='Left-open right-open interval'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                                   </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                                   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                                       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                                  </code><font color='lime'><a title='a b : real
⊢ @eq.{1} ennreal
    (@measure_theory.volume.{0} real measure_theory.measure_theory.measure_space (@set.Ioo.{0} real real.preorder a b))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>250  @[simp] lemma real.volume_singleton {a : ℝ} : volume ({a} : set ℝ) = 0 := by simp</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='blue'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='measure_theory.volume'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='singleton'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/basic.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measure_space.lean&#x27;, &#x27;line&#x27;: 809, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 393, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/basic.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : measure_theory.measure_space.{u_1} α], set.{u_1} α → ennreal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α γ : Type} [_inst_1 : has_emptyc.{0} γ] [_inst_2 : has_insert.{0 0} α γ], α → γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                       </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                             </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                             </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                            </code><font color='lime'><a title='a : real
⊢ @eq.{1} ennreal
    (@measure_theory.volume.{0} real measure_theory.measure_theory.measure_space
       (@singleton.{0 0} real (set.{0} real) (@set.has_emptyc.{0} real) (@set.has_insert.{0} real) a))
    (@has_zero.zero.{0} ennreal
       (@zero_ne_one_class.to_has_zero.{0} ennreal
          (@canonically_ordered_comm_semiring.to_zero_ne_one_class.{0} ennreal
             ennreal.canonically_ordered_comm_semiring_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>251  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a : real
⊢ @eq.{1} ennreal
    (@measure_theory.volume.{0} real measure_theory.measure_theory.measure_space
       (@singleton.{0 0} real (set.{0} real) (@set.has_emptyc.{0} real) (@set.has_insert.{0} real) a))
    (@has_zero.zero.{0} ennreal
       (@zero_ne_one_class.to_has_zero.{0} ennreal
          (@canonically_ordered_comm_semiring.to_zero_ne_one_class.{0} ennreal
             ennreal.canonically_ordered_comm_semiring_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>252  @[simp] lemma real.volume_interval {a b : ℝ} : volume [a, b] = of_real (abs (b - a)) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                          </code><font color='blue'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='measure_theory.volume'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.interval'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='set.interval'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='set.interval'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='nnreal.of_real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='abs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_sub.sub'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/basic.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measure_space.lean&#x27;, &#x27;line&#x27;: 809, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/intervals/unordered_interval.lean&#x27;, &#x27;line&#x27;: 37, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/intervals/unordered_interval.lean&#x27;, &#x27;line&#x27;: 37, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/intervals/unordered_interval.lean&#x27;, &#x27;line&#x27;: 37, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/nnreal.lean&#x27;, &#x27;line&#x27;: 32, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/functions.lean&#x27;, &#x27;line&#x27;: 13, &#x27;column&#x27;: 11}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 315, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                          </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : measure_theory.measure_space.{u_1} α], set.{u_1} α → ennreal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [_inst_1 : decidable_linear_order.{0} α], α → α → set.{0} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} [_inst_1 : decidable_linear_order.{0} α], α → α → set.{0} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} [_inst_1 : decidable_linear_order.{0} α], α → α → set.{0} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real → nnreal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [_inst_1 : decidable_linear_ordered_comm_group.{u} α], α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_sub.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                </code><font color='orange'><a title='`interval a b` is the set of elements lying between `a` and `b`, with `a` and `b` included.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`interval a b` is the set of elements lying between `a` and `b`, with `a` and `b` included.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`interval a b` is the set of elements lying between `a` and `b`, with `a` and `b` included.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>253  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a b : real
⊢ @eq.{1} ennreal
    (@measure_theory.volume.{0} real measure_theory.measure_theory.measure_space
       (@set.interval.{0} real real.decidable_linear_order a b))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real
          (@abs.{0} real real.decidable_linear_ordered_comm_group
             (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>254    rw [interval, real.volume_Icc],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='set.interval'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='real.volume_Icc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/intervals/unordered_interval.lean&#x27;, &#x27;line&#x27;: 37, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 248, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type ?l_1} [_inst_1 : decidable_linear_order.{?l_1} α], α → α → set.{?l_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : real}, @eq.{1} ennreal (@measure_theory.volume.{0} real measure_theory.measure_theory.measure_space (@set.Icc.{0} real real.preorder a b)) (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe)) (nnreal.of_real (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`interval a b` is the set of elements lying between `a` and `b`, with `a` and `b` included.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a b : real
⊢ @eq.{1} ennreal
    (@measure_theory.volume.{0} real measure_theory.measure_theory.measure_space
       (@set.interval.{0} real real.decidable_linear_order a b))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real
          (@abs.{0} real real.decidable_linear_ordered_comm_group
             (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a b : real
⊢ @eq.{1} ennreal
    (@measure_theory.volume.{0} real measure_theory.measure_theory.measure_space
       (@set.Icc.{0} real
          (@partial_order.to_preorder.{0} real
             (@lattice.semilattice_inf.to_partial_order.{0} real
                (@lattice.lattice.to_semilattice_inf.{0} real
                   (@lattice.lattice_of_decidable_linear_order.{0} real real.decidable_linear_order))))
          (@min.{0} real real.decidable_linear_order a b)
          (@max.{0} real real.decidable_linear_order a b)))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real
          (@abs.{0} real real.decidable_linear_ordered_comm_group
             (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a b : real
⊢ @eq.{1} ennreal
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real
          (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group)
             (@max.{0} real real.decidable_linear_order a b)
             (@min.{0} real real.decidable_linear_order a b))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real
          (@abs.{0} real real.decidable_linear_ordered_comm_group
             (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>255    congr,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1543, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='congr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a b : real
⊢ @eq.{1} ennreal
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real
          (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group)
             (@max.{0} real real.decidable_linear_order a b)
             (@min.{0} real real.decidable_linear_order a b))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real
          (@abs.{0} real real.decidable_linear_ordered_comm_group
             (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a b : real
⊢ @eq.{1} real
    (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (@max.{0} real real.decidable_linear_order a b)
       (@min.{0} real real.decidable_linear_order a b))
    (@abs.{0} real real.decidable_linear_ordered_comm_group
       (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>256    exact max_sub_min_eq_abs _ _</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='max_sub_min_eq_abs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/order_functions.lean&#x27;, &#x27;line&#x27;: 285, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : decidable_linear_ordered_comm_group.{0} α] (a b : α), @eq.{1} α (@has_sub.sub.{0} α (@add_group_has_sub.{0} α (@add_comm_group.to_add_group.{0} α (@decidable_linear_ordered_comm_group.to_add_comm_group.{0} α _inst_1))) (@max.{0} α (@decidable_linear_ordered_cancel_comm_monoid.to_decidable_linear_order.{0} α (@decidable_linear_ordered_comm_group.decidable_linear_ordered_cancel_comm_monoid.{0} α _inst_1)) a b) (@min.{0} α (@decidable_linear_ordered_cancel_comm_monoid.to_decidable_linear_order.{0} α (@decidable_linear_ordered_comm_group.decidable_linear_ordered_cancel_comm_monoid.{0} α _inst_1)) a b)) (@abs.{0} α _inst_1 (@has_sub.sub.{0} α (@add_group_has_sub.{0} α (@add_comm_group.to_add_group.{0} α (@decidable_linear_ordered_comm_group.to_add_comm_group.{0} α _inst_1))) b a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='a b : real
⊢ @eq.{1} real
    (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (@max.{0} real real.decidable_linear_order a b)
       (@min.{0} real real.decidable_linear_order a b))
    (@abs.{0} real real.decidable_linear_ordered_comm_group
       (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>257  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>258  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>259  open metric</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>260  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>261  lemma real.volume_lt_top_of_bounded {s : set ℝ} (h : bounded s) : volume s &lt; ⊤ :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='metric.bounded'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='measure_theory.volume'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_lt.lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='lattice.has_top.top'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/basic.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/metric_space/basic.lean&#x27;, &#x27;line&#x27;: 1268, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measure_space.lean&#x27;, &#x27;line&#x27;: 809, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 320, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/bounded_lattice.lean&#x27;, &#x27;line&#x27;: 22, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π {α : Type} [_inst_1 : metric_space.{0} α], set.{0} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{0} real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : measure_theory.measure_space.{u_1} α], set.{u_1} α → ennreal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{0} real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_lt.{0} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (α : Type) [c : lattice.has_top.{0} α], α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                     </code><font color='orange'><a title=' Boundedness of a subset of a metric space. We formulate the definition to work
even in the empty space.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>262  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} real,
h : @metric.bounded.{0} real real.metric_space s
⊢ @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@measure_theory.volume.{0} real measure_theory.measure_theory.measure_space s)
    (@lattice.has_top.top.{0} ennreal
       (@lattice.order_top.to_has_top.{0} ennreal
          (@lattice.bounded_lattice.to_order_top.{0} ennreal
             (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>263    rw [real.bounded_iff_bdd_below_bdd_above, bdd_below_bdd_above_iff_subset_interval] at h,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='real.bounded_iff_bdd_below_bdd_above'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.bdd_below_bdd_above_iff_subset_interval'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/instances/real.lean&#x27;, &#x27;line&#x27;: 324, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/intervals/unordered_interval.lean&#x27;, &#x27;line&#x27;: 102, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {s : set.{0} real}, iff (@metric.bounded.{0} real real.metric_space s) (and (@bdd_below.{0} real real.preorder s) (@bdd_above.{0} real real.preorder s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : decidable_linear_order.{0} α] (s : set.{0} α), iff (and (@bdd_below.{0} α (@partial_order.to_preorder.{0} α (@lattice.semilattice_inf.to_partial_order.{0} α (@lattice.lattice.to_semilattice_inf.{0} α (@lattice.lattice_of_decidable_linear_order.{0} α _inst_1)))) s) (@bdd_above.{0} α (@partial_order.to_preorder.{0} α (@lattice.semilattice_inf.to_partial_order.{0} α (@lattice.lattice.to_semilattice_inf.{0} α (@lattice.lattice_of_decidable_linear_order.{0} α _inst_1)))) s)) (@Exists.{1} α (λ (a : α), @Exists.{1} α (λ (b : α), @has_subset.subset.{0} (set.{0} α) (@set.has_subset.{0} α) s (@set.interval.{0} α _inst_1 a b))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} real,
h : @metric.bounded.{0} real real.metric_space s
⊢ @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@measure_theory.volume.{0} real measure_theory.measure_theory.measure_space s)
    (@lattice.has_top.top.{0} ennreal
       (@lattice.order_top.to_has_top.{0} ennreal
          (@lattice.bounded_lattice.to_order_top.{0} ennreal
             (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} real,
h : and (@bdd_below.{0} real real.preorder s) (@bdd_above.{0} real real.preorder s)
⊢ @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@measure_theory.volume.{0} real measure_theory.measure_theory.measure_space s)
    (@lattice.has_top.top.{0} ennreal
       (@lattice.order_top.to_has_top.{0} ennreal
          (@lattice.bounded_lattice.to_order_top.{0} ennreal
             (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} real,
h :
  @Exists.{1} real
    (λ (a : real),
       @Exists.{1} real
         (λ (b : real),
            @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) s
              (@set.interval.{0} real real.decidable_linear_order a b)))
⊢ @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@measure_theory.volume.{0} real measure_theory.measure_theory.measure_space s)
    (@lattice.has_top.top.{0} ennreal
       (@lattice.order_top.to_has_top.{0} ennreal
          (@lattice.bounded_lattice.to_order_top.{0} ennreal
             (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} real,
h : @metric.bounded.{0} real real.metric_space s
⊢ @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@measure_theory.volume.{0} real measure_theory.measure_theory.measure_space s)
    (@lattice.has_top.top.{0} ennreal
       (@lattice.order_top.to_has_top.{0} ennreal
          (@lattice.bounded_lattice.to_order_top.{0} ennreal
             (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} real,
h :
  @Exists.{1} real
    (λ (a : real),
       @Exists.{1} real
         (λ (b : real),
            @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) s
              (@set.interval.{0} real real.decidable_linear_order a b)))
⊢ @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@measure_theory.volume.{0} real measure_theory.measure_theory.measure_space s)
    (@lattice.has_top.top.{0} ennreal
       (@lattice.order_top.to_has_top.{0} ennreal
          (@lattice.bounded_lattice.to_order_top.{0} ennreal
             (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>264    rcases h with ⟨a, b, h⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@Exists.{1} real (λ (a : real), @Exists.{1} real (λ (b : real), @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) s (@set.interval.{0} real real.decidable_linear_order a b)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} real,
h :
  @Exists.{1} real
    (λ (a : real),
       @Exists.{1} real
         (λ (b : real),
            @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) s
              (@set.interval.{0} real real.decidable_linear_order a b)))
⊢ @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@measure_theory.volume.{0} real measure_theory.measure_theory.measure_space s)
    (@lattice.has_top.top.{0} ennreal
       (@lattice.order_top.to_has_top.{0} ennreal
          (@lattice.bounded_lattice.to_order_top.{0} ennreal
             (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} real,
a b : real,
h :
  @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) s
    (@set.interval.{0} real real.decidable_linear_order a b)
⊢ @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@measure_theory.volume.{0} real measure_theory.measure_theory.measure_space s)
    (@lattice.has_top.top.{0} ennreal
       (@lattice.order_top.to_has_top.{0} ennreal
          (@lattice.bounded_lattice.to_order_top.{0} ennreal
             (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>265    calc volume s ≤ volume [a, b] : volume_mono h</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='tactic.interactive.exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='measure_theory.volume'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.interval'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='set.interval'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='set.interval'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='measure_theory.volume_mono'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measure_space.lean&#x27;, &#x27;line&#x27;: 809, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/intervals/unordered_interval.lean&#x27;, &#x27;line&#x27;: 37, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/intervals/unordered_interval.lean&#x27;, &#x27;line&#x27;: 37, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/intervals/unordered_interval.lean&#x27;, &#x27;line&#x27;: 37, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measure_space.lean&#x27;, &#x27;line&#x27;: 813, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='set.{0} real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type} [_inst_1 : measure_theory.measure_space.{0} α], set.{0} α → ennreal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [_inst_1 : decidable_linear_order.{0} α], α → α → set.{0} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} [_inst_1 : decidable_linear_order.{0} α], α → α → set.{0} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} [_inst_1 : decidable_linear_order.{0} α], α → α → set.{0} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {α : Type} [_inst_1 : measure_theory.measure_space.{0} α] {s₁ s₂ : set.{0} α}, @has_subset.subset.{0} (set.{0} α) (@set.has_subset.{0} α) s₁ s₂ → @has_le.le.{0} ennreal (@preorder.to_has_le.{0} ennreal (@partial_order.to_preorder.{0} ennreal (@ordered_comm_monoid.to_partial_order.{0} ennreal (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal ennreal.canonically_ordered_comm_semiring_1))))) (@measure_theory.volume.{0} α _inst_1 s₁) (@measure_theory.volume.{0} α _inst_1 s₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) s (@set.interval.{0} real real.decidable_linear_order a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='`interval a b` is the set of elements lying between `a` and `b`, with `a` and `b` included.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`interval a b` is the set of elements lying between `a` and `b`, with `a` and `b` included.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`interval a b` is the set of elements lying between `a` and `b`, with `a` and `b` included.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} real,
a b : real,
h :
  @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) s
    (@set.interval.{0} real real.decidable_linear_order a b)
⊢ @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@measure_theory.volume.{0} real measure_theory.measure_theory.measure_space s)
    (@lattice.has_top.top.{0} ennreal
       (@lattice.order_top.to_has_top.{0} ennreal
          (@lattice.bounded_lattice.to_order_top.{0} ennreal
             (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>266      ... &lt; ⊤ : by { rw real.volume_interval, exact ennreal.coe_lt_top }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='lattice.has_top.top'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='real.volume_interval'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='ennreal.coe_lt_top'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/bounded_lattice.lean&#x27;, &#x27;line&#x27;: 22, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 252, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/ennreal.lean&#x27;, &#x27;line&#x27;: 216, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='Π (α : Type) [c : lattice.has_top.{0} α], α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : real}, @eq.{1} ennreal (@measure_theory.volume.{0} real measure_theory.measure_theory.measure_space (@set.interval.{0} real real.decidable_linear_order a b)) (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe)) (nnreal.of_real (@abs.{0} real real.decidable_linear_ordered_comm_group (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {r : nnreal}, @has_lt.lt.{0} ennreal (@preorder.to_has_lt.{0} ennreal (@partial_order.to_preorder.{0} ennreal (@ordered_comm_monoid.to_partial_order.{0} ennreal (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal ennreal.canonically_ordered_comm_semiring_1))))) (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe)) r) (@lattice.has_top.top.{0} ennreal (@lattice.order_top.to_has_top.{0} ennreal (@lattice.bounded_lattice.to_order_top.{0} ennreal (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} real,
a b : real,
h :
  @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) s
    (@set.interval.{0} real real.decidable_linear_order a b)
⊢ @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@measure_theory.volume.{0} real measure_theory.measure_theory.measure_space s)
    (@lattice.has_top.top.{0} ennreal
       (@lattice.order_top.to_has_top.{0} ennreal
          (@lattice.bounded_lattice.to_order_top.{0} ennreal
             (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} real,
a b : real,
h :
  @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) s
    (@set.interval.{0} real real.decidable_linear_order a b)
⊢ @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@measure_theory.volume.{0} real measure_theory.measure_theory.measure_space
       (@set.interval.{0} real real.decidable_linear_order a b))
    (@lattice.has_top.top.{0} ennreal
       (@lattice.order_top.to_has_top.{0} ennreal
          (@lattice.bounded_lattice.to_order_top.{0} ennreal
             (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='s : set.{0} real,
a b : real,
h :
  @has_subset.subset.{0} (set.{0} real) (@set.has_subset.{0} real) s
    (@set.interval.{0} real real.decidable_linear_order a b)
⊢ @has_lt.lt.{0} ennreal
    (@preorder.to_has_lt.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@coe.{1 1} nnreal ennreal (@coe_to_lift.{1 1} nnreal ennreal (@coe_base.{1 1} nnreal ennreal ennreal.has_coe))
       (nnreal.of_real
          (@abs.{0} real real.decidable_linear_ordered_comm_group
             (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) b a))))
    (@lattice.has_top.top.{0} ennreal
       (@lattice.order_top.to_has_top.{0} ennreal
          (@lattice.bounded_lattice.to_order_top.{0} ennreal
             (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal
                (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>267  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>268  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>269  lemma real.volume_lt_top_of_compact {s : set ℝ} (h : compact s) : volume s &lt; ⊤ :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='compact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='measure_theory.volume'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_lt.lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='lattice.has_top.top'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/basic.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/subset_properties.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measure_space.lean&#x27;, &#x27;line&#x27;: 809, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 320, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/bounded_lattice.lean&#x27;, &#x27;line&#x27;: 22, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π {α : Type u} [_inst_1 : topological_space.{u} α], set.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{0} real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : measure_theory.measure_space.{u_1} α], set.{u_1} α → ennreal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{0} real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_lt.{0} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (α : Type) [c : lattice.has_top.{0} α], α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                     </code><font color='orange'><a title='A set `s` is compact if for every filter `f` that contains `s`,
   every set of `f` also meets every neighborhood of some `a ∈ s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>270  real.volume_lt_top_of_bounded (bounded_of_compact h)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='real.volume_lt_top_of_bounded'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='metric.bounded_of_compact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 261, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/metric_space/basic.lean&#x27;, &#x27;line&#x27;: 1333, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {s : set.{0} real}, @metric.bounded.{0} real real.metric_space s → @has_lt.lt.{0} ennreal (@preorder.to_has_lt.{0} ennreal (@partial_order.to_preorder.{0} ennreal (@ordered_comm_monoid.to_partial_order.{0} ennreal (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal ennreal.canonically_ordered_comm_semiring_1))))) (@measure_theory.volume.{0} real measure_theory.measure_theory.measure_space s) (@lattice.has_top.top.{0} ennreal (@lattice.order_top.to_has_top.{0} ennreal (@lattice.bounded_lattice.to_order_top.{0} ennreal (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type} [_inst_1 : metric_space.{0} α] {s : set.{0} α}, @compact.{0} α (@uniform_space.to_topological_space.{0} α (@metric_space.to_uniform_space&#x27;.{0} α _inst_1)) s → @metric.bounded.{0} α _inst_1 s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@compact.{0} real (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='orange'><a title='A compact set is bounded'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>271  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>272  end volume</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>273  /-</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>274  section vitali</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>275  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>276  def vitali_aux_h (x : ℝ) (h : x ∈ Icc (0:ℝ) 1) :</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>277    ∃ y ∈ Icc (0:ℝ) 1, ∃ q:ℚ, ↑q = x - y :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>278  ⟨x, h, 0, by simp⟩</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>279  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>280  def vitali_aux (x : ℝ) (h : x ∈ Icc (0:ℝ) 1) : ℝ :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>281  classical.some (vitali_aux_h x h)</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>282  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>283  theorem vitali_aux_mem (x : ℝ) (h : x ∈ Icc (0:ℝ) 1) : vitali_aux x h ∈ Icc (0:ℝ) 1 :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>284  Exists.fst (classical.some_spec (vitali_aux_h x h):_)</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>285  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>286  theorem vitali_aux_rel (x : ℝ) (h : x ∈ Icc (0:ℝ) 1) :</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>287   ∃ q:ℚ, ↑q = x - vitali_aux x h :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>288  Exists.snd (classical.some_spec (vitali_aux_h x h):_)</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>289  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>290  def vitali : set ℝ := {x | ∃ h, x = vitali_aux x h}</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>291  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>292  theorem vitali_nonmeasurable : ¬ is_null_measurable measure_space.μ vitali :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>293  sorry</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>294  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>295  end vitali</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>296  -/</code></pre>
</body>