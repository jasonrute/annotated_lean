<head>
<meta charset="UTF-8">
<link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro&display=swap" rel="stylesheet">
</head>

<body>
<pre>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  1  /-</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  2  Copyright (c) 2018 Mario Carneiro. All rights reserved.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  3  Released under Apache 2.0 license as described in the file LICENSE.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  4  Authors: Mario Carneiro</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  5  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  6  Additional theorems about the `vector` type.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  7  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  8  import data.vector data.list.basic category.traversable.basic data.set.basic tactic.tauto</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/list/basic.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category/traversable/basic.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/tauto.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  9  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 10  universes u</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 11  variables {n : ℕ}</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 293, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 12  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 13  namespace vector</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 14  variables {α : Type*}</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 15  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 16  attribute [simp] head_cons tail_cons</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='vector.head_cons'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='vector.tail_cons'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 38, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 45, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='∀ {α : Type u} {n : nat} (a : α) (v : vector.{u} α n), @eq.{u+1} α (@vector.head.{u} α n (@vector.cons.{u} α n a v)) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u} {n : nat} (a : α) (v : vector.{u} α n), @eq.{(max 1 (u+1))} (vector.{u} α (@has_sub.sub.{0} nat nat.has_sub (nat.succ n) (@has_one.one.{0} nat nat.has_one))) (@vector.tail.{u} α (nat.succ n) (@vector.cons.{u} α n a v)) v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 17  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 18  instance [inhabited α] : inhabited (vector α n) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='inhabited'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='inhabited'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='vector'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 768, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 768, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 14, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Sort u → Sort (max 1 u)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u → nat → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 19  ⟨of_fn (λ _, default α)⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='vector.of_fn'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='default'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 88, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 771, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} {n : nat}, (fin n → α) → vector.{u} α n'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='fin n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (α : Sort u) [_inst_1 : inhabited.{u} α], α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 20  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 21  theorem to_list_injective : function.injective (@to_list α n) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='blue'><a title='function.injective'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='vector.to_list'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/function.lean&#x27;, &#x27;line&#x27;: 64, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 52, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='green'><a title='Π {α : Sort u₁} {β : Sort u₂}, (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u} {n : nat}, vector.{u} α n → list.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 22  subtype.val_injective</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='subtype.val_injective'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/subtype.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {p : α → Prop}, @function.injective.{(max 1 (u_1+1)) u_1+1} (@subtype.{u_1+1} α p) α (@subtype.val.{u_1+1} α p)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 23  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 24  @[simp] theorem to_list_of_fn : ∀ {n} (f : fin n → α), to_list (of_fn f) = list.of_fn f</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='blue'><a title='to_list_of_fn'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='fin'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='vector.to_list'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='vector.of_fn'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='list.of_fn'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/fin/basic.lean&#x27;, &#x27;line&#x27;: 9, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 52, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 88, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/list/defs.lean&#x27;, &#x27;line&#x27;: 352, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='green'><a title='∀ {n : nat} (f : fin n → α), @eq.{u_1+1} (list.{u_1} α) (@vector.to_list.{u_1} α n (@vector.of_fn.{u_1} α n f)) (@list.of_fn.{u_1} α n f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='nat → Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='fin n → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u_1} {n : nat}, vector.{u_1} α n → list.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} {n : nat}, (fin n → α) → vector.{u_1} α n'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='fin n → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} {n : nat}, (fin n → α) → list.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='fin n → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 25  | 0     f := rfl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='∀ {α : Type u_1} {a : α}, @eq.{u_1+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 26  | (n+1) f := by rw [of_fn, list.of_fn_succ, to_list_cons, to_list_of_fn]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='vector.of_fn'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='list.of_fn_succ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='vector.to_list_cons'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 88, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/list/basic.lean&#x27;, &#x27;line&#x27;: 3383, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 123, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type} [c : has_add.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type ?l_1} {n : nat}, (fin n → α) → vector.{?l_1} α n'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {n : nat} (f : fin (nat.succ n) → α), @eq.{u_1+1} (list.{u_1} α) (@list.of_fn.{u_1} α (nat.succ n) f) (@list.cons.{u_1} α (f (@has_zero.zero.{0} (fin (nat.succ n)) (@fin.has_zero n))) (@list.of_fn.{u_1} α n (λ (i : fin n), f (@fin.succ n i))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {n : nat} (a : α) (v : vector.{u_1} α n), @eq.{u_1+1} (list.{u_1} α) (@vector.to_list.{u_1} α (nat.succ n) (@vector.cons.{u_1} α n a v)) (@list.cons.{u_1} α a (@vector.to_list.{u_1} α n v))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (f : fin n → α), @eq.{u_1+1} (list.{u_1} α) (@vector.to_list.{u_1} α n (@vector.of_fn.{u_1} α n f)) (@list.of_fn.{u_1} α n f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='lime'><a title='α : Type u_1,
to_list_of_fn :
  ∀ {n : nat} (f : fin n → α),
    @eq.{u_1+1} (list.{u_1} α) (@vector.to_list.{u_1} α n (@vector.of_fn.{u_1} α n f)) (@list.of_fn.{u_1} α n f),
n : nat,
f : fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → α
⊢ @eq.{u_1+1} (list.{u_1} α)
    (@vector.to_list.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
       (@vector.of_fn.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) f))
    (@list.of_fn.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
to_list_of_fn :
  ∀ {n : nat} (f : fin n → α),
    @eq.{u_1+1} (list.{u_1} α) (@vector.to_list.{u_1} α n (@vector.of_fn.{u_1} α n f)) (@list.of_fn.{u_1} α n f),
n : nat,
f : fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → α
⊢ @eq.{u_1+1} (list.{u_1} α)
    (@vector.to_list.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
       (@vector.cons.{u_1} α n
          (f
             (@has_zero.zero.{0} (fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
                (@fin.has_zero n)))
          (@vector.of_fn.{u_1} α n (λ (i : fin n), f (@fin.succ n i)))))
    (@list.of_fn.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
to_list_of_fn :
  ∀ {n : nat} (f : fin n → α),
    @eq.{u_1+1} (list.{u_1} α) (@vector.to_list.{u_1} α n (@vector.of_fn.{u_1} α n f)) (@list.of_fn.{u_1} α n f),
n : nat,
f : fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → α
⊢ @eq.{u_1+1} (list.{u_1} α)
    (@vector.to_list.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
       (@vector.cons.{u_1} α n
          (f
             (@has_zero.zero.{0} (fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
                (@fin.has_zero n)))
          (@vector.of_fn.{u_1} α n (λ (i : fin n), f (@fin.succ n i)))))
    (@list.cons.{u_1} α (f (@has_zero.zero.{0} (fin (nat.succ n)) (@fin.has_zero n)))
       (@list.of_fn.{u_1} α n (λ (i : fin n), f (@fin.succ n i))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
to_list_of_fn :
  ∀ {n : nat} (f : fin n → α),
    @eq.{u_1+1} (list.{u_1} α) (@vector.to_list.{u_1} α n (@vector.of_fn.{u_1} α n f)) (@list.of_fn.{u_1} α n f),
n : nat,
f : fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → α
⊢ @eq.{u_1+1} (list.{u_1} α)
    (@list.cons.{u_1} α
       (f
          (@has_zero.zero.{0} (fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
             (@fin.has_zero n)))
       (@vector.to_list.{u_1} α n (@vector.of_fn.{u_1} α n (λ (i : fin n), f (@fin.succ n i)))))
    (@list.cons.{u_1} α (f (@has_zero.zero.{0} (fin (nat.succ n)) (@fin.has_zero n)))
       (@list.of_fn.{u_1} α n (λ (i : fin n), f (@fin.succ n i))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
to_list_of_fn :
  ∀ {n : nat} (f : fin n → α),
    @eq.{u_1+1} (list.{u_1} α) (@vector.to_list.{u_1} α n (@vector.of_fn.{u_1} α n f)) (@list.of_fn.{u_1} α n f),
n : nat,
f : fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → α
⊢ @eq.{u_1+1} (list.{u_1} α)
    (@vector.to_list.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
       (@vector.of_fn.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) f))
    (@list.of_fn.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 27  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
to_list_of_fn :
  ∀ {n : nat} (f : fin n → α),
    @eq.{u_1+1} (list.{u_1} α) (@vector.to_list.{u_1} α n (@vector.of_fn.{u_1} α n f)) (@list.of_fn.{u_1} α n f),
n : nat,
f : fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → α
⊢ @eq.{u_1+1} (list.{u_1} α)
    (@vector.to_list.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
       (@vector.of_fn.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) f))
    (@list.of_fn.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 28  @[simp] theorem mk_to_list :</code>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 29    ∀ (v : vector α n) h, (⟨to_list v, h⟩ : vector α n) = v</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='mk_to_list'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='vector'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='vector.to_list'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='vector'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 14, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 52, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 14, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ (v : vector.{u_1} α n) (h : @eq.{1} nat (@list.length.{u_1} α (@vector.to_list.{u_1} α n v)) n), @eq.{(max 1 (u_1+1))} (@subtype.{u_1+1} (list.{u_1} α) (λ (l : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l) n)) (@subtype.mk.{u_1+1} (list.{u_1} α) (λ (l : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l) n) (@vector.to_list.{u_1} α n v) h) v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type u_1 → nat → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@eq.{1} nat (@list.length.{u_1} α (@vector.to_list.{u_1} α n v)) n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u_1} {n : nat}, vector.{u_1} α n → list.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='vector.{u_1} α n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@eq.{1} nat (@list.length.{u_1} α (@vector.to_list.{u_1} α n v)) n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type u_1 → nat → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='vector.{u_1} α n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 30  | ⟨l, h₁⟩ h₂ := rfl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='green'><a title='∀ {α : Type u_1} {a : α}, @eq.{(max 1 (u_1+1))} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 31  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 32  @[simp] lemma to_list_map {β : Type*} (v : vector α n) (f : α → β) : (v.map f).to_list =</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                           </code><font color='blue'><a title='vector'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='vector.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='vector.to_list'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 14, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 65, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 52, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                           </code><font color='green'><a title='Type u → nat → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='vector.{u_1} α n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} {n : nat}, (α → β) → vector.{u_1} α n → vector.{u_2} β n'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_2} {n : nat}, vector.{u_2} α n → list.{u_2} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_2}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 33    v.to_list.map f := by cases v; refl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='vector.to_list'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='list.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 52, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/list/basic.lean&#x27;, &#x27;line&#x27;: 110, &#x27;column&#x27;: 12}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1263, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='vector.{u_1} α n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} {n : nat}, vector.{u_1} α n → list.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2}, (α → β) → list.{u_1} α → list.{u_2} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='vector.{u_1} α n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='Shorter name for the tactic `reflexivity`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='lime'><a title='n : nat,
α : Type u_1,
β : Type u_2,
v : vector.{u_1} α n,
f : α → β
⊢ @eq.{u_2+1} (list.{u_2} β) (@vector.to_list.{u_2} β n (@vector.map.{u_1 u_2} α β n f v))
    (@list.map.{u_1 u_2} α β f (@vector.to_list.{u_1} α n v))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 34  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1263, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Shorter name for the tactic `reflexivity`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : nat,
α : Type u_1,
β : Type u_2,
v : vector.{u_1} α n,
f : α → β
⊢ @eq.{u_2+1} (list.{u_2} β) (@vector.to_list.{u_2} β n (@vector.map.{u_1 u_2} α β n f v))
    (@list.map.{u_1 u_2} α β f (@vector.to_list.{u_1} α n v))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 35  theorem nth_eq_nth_le : ∀ (v : vector α n) (i),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='blue'><a title='nth_eq_nth_le'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='vector'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 14, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='green'><a title='∀ (v : vector.{u_1} α n) (i : fin n), @eq.{u_1+1} α (@vector.nth.{u_1} α n v i) (@list.nth_le.{u_1} α (@vector.to_list.{u_1} α n v) (@fin.val n i) (@eq.mpr.{0} (@has_lt.lt.{0} nat nat.has_lt (@fin.val n i) (@list.length.{u_1} α (@vector.to_list.{u_1} α n v))) (@has_lt.lt.{0} nat nat.has_lt (@fin.val n i) n) (@id.{0} (@eq.{1} Prop (@has_lt.lt.{0} nat nat.has_lt (@fin.val n i) (@list.length.{u_1} α (@vector.to_list.{u_1} α n v))) (@has_lt.lt.{0} nat nat.has_lt (@fin.val n i) n)) (@eq.rec.{0 1} nat (@list.length.{u_1} α (@vector.to_list.{u_1} α n v)) (λ (_a : nat), @eq.{1} Prop (@has_lt.lt.{0} nat nat.has_lt (@fin.val n i) (@list.length.{u_1} α (@vector.to_list.{u_1} α n v))) (@has_lt.lt.{0} nat nat.has_lt (@fin.val n i) _a)) (@eq.refl.{1} Prop (@has_lt.lt.{0} nat nat.has_lt (@fin.val n i) (@list.length.{u_1} α (@vector.to_list.{u_1} α n v)))) n (@vector.to_list_length.{u_1} α n v))) (@fin.is_lt n i)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type u_1 → nat → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='fin n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 36    nth v i = v.to_list.nth_le i.1 (by rw to_list_length; exact i.2)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='vector.nth'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='vector.to_list'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='list.nth_le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='fin.val'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='vector.to_list_length'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 54, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 52, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/list/basic.lean&#x27;, &#x27;line&#x27;: 90, &#x27;column&#x27;: 12}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/fin/basic.lean&#x27;, &#x27;line&#x27;: 9, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 121, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} {n : nat}, vector.{u_1} α n → fin n → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='vector.{u_1} α n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='fin n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='vector.{u_1} α n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} {n : nat}, vector.{u_1} α n → list.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} (l : list.{u_1} α) (n : nat), @has_lt.lt.{0} nat nat.has_lt n (@list.length.{u_1} α l) → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='fin n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {n : nat}, fin n → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {n : nat} (v : vector.{u_1} α n), @eq.{1} nat (@list.length.{u_1} α (@vector.to_list.{u_1} α n v)) n'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='fin n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='lime'><a title='n : nat,
α : Type u_1,
v : vector.{u_1} α n,
i : fin n
⊢ @has_lt.lt.{0} nat nat.has_lt (@fin.val n i) (@list.length.{u_1} α (@vector.to_list.{u_1} α n v))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 37  | ⟨l, h⟩ i := rfl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='∀ {α : Type u_1} {a : α}, @eq.{u_1+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 38  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 39  @[simp] lemma nth_map {β : Type*} (v : vector α n) (f : α → β) (i : fin n) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='blue'><a title='vector'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='fin'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 14, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/fin/basic.lean&#x27;, &#x27;line&#x27;: 9, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='green'><a title='Type u → nat → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='nat → Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 40    (v.map f).nth i = f (v.nth i) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='vector.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='vector.nth'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='vector.nth'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 65, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 54, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 54, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='vector.{u_1} α n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} {n : nat}, (α → β) → vector.{u_1} α n → vector.{u_2} β n'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_2} {n : nat}, vector.{u_2} α n → fin n → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='fin n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_2}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='vector.{u_1} α n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} {n : nat}, vector.{u_1} α n → fin n → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='fin n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 41  by simp [nth_eq_nth_le]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='vector.nth_eq_nth_le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 35, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {n : nat} {α : Type ?l_1} (v : vector.{?l_1} α n) (i : fin n), @eq.{?l_1+1} α (@vector.nth.{?l_1} α n v i) (@list.nth_le.{?l_1} α (@vector.to_list.{?l_1} α n v) (@fin.val n i) (@eq.mpr.{0} (@has_lt.lt.{0} nat nat.has_lt (@fin.val n i) (@list.length.{?l_1} α (@vector.to_list.{?l_1} α n v))) (@has_lt.lt.{0} nat nat.has_lt (@fin.val n i) n) (@id.{0} (@eq.{1} Prop (@has_lt.lt.{0} nat nat.has_lt (@fin.val n i) (@list.length.{?l_1} α (@vector.to_list.{?l_1} α n v))) (@has_lt.lt.{0} nat nat.has_lt (@fin.val n i) n)) (@eq.rec.{0 1} nat (@list.length.{?l_1} α (@vector.to_list.{?l_1} α n v)) (λ (_a : nat), @eq.{1} Prop (@has_lt.lt.{0} nat nat.has_lt (@fin.val n i) (@list.length.{?l_1} α (@vector.to_list.{?l_1} α n v))) (@has_lt.lt.{0} nat nat.has_lt (@fin.val n i) _a)) (@eq.refl.{1} Prop (@has_lt.lt.{0} nat nat.has_lt (@fin.val n i) (@list.length.{?l_1} α (@vector.to_list.{?l_1} α n v)))) n (@vector.to_list_length.{?l_1} α n v))) (@fin.is_lt n i)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='n : nat,
α : Type u_1,
β : Type u_2,
v : vector.{u_1} α n,
f : α → β,
i : fin n
⊢ @eq.{u_2+1} β (@vector.nth.{u_2} β n (@vector.map.{u_1 u_2} α β n f v) i) (f (@vector.nth.{u_1} α n v i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 42  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : nat,
α : Type u_1,
β : Type u_2,
v : vector.{u_1} α n,
f : α → β,
i : fin n
⊢ @eq.{u_2+1} β (@vector.nth.{u_2} β n (@vector.map.{u_1 u_2} α β n f v) i) (f (@vector.nth.{u_1} α n v i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 43  @[simp] theorem nth_of_fn {n} (f : fin n → α) (i) : nth (of_fn f) i = f i :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='blue'><a title='fin'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='vector.nth'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='vector.of_fn'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/fin/basic.lean&#x27;, &#x27;line&#x27;: 9, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 54, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 88, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='green'><a title='nat → Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {α : Type u} {n : nat}, vector.{u} α n → fin n → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} {n : nat}, (fin n → α) → vector.{u} α n'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='fin n → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='fin n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='fin n → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='fin n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 44  by rw [nth_eq_nth_le, ← list.nth_le_of_fn f];</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='vector.nth_eq_nth_le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='list.nth_le_of_fn'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 35, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/list/basic.lean&#x27;, &#x27;line&#x27;: 3368, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {n : nat} {α : Type u_1} (v : vector.{u_1} α n) (i : fin n), @eq.{u_1+1} α (@vector.nth.{u_1} α n v i) (@list.nth_le.{u_1} α (@vector.to_list.{u_1} α n v) (@fin.val n i) (@eq.mpr.{0} (@has_lt.lt.{0} nat nat.has_lt (@fin.val n i) (@list.length.{u_1} α (@vector.to_list.{u_1} α n v))) (@has_lt.lt.{0} nat nat.has_lt (@fin.val n i) n) (@id.{0} (@eq.{1} Prop (@has_lt.lt.{0} nat nat.has_lt (@fin.val n i) (@list.length.{u_1} α (@vector.to_list.{u_1} α n v))) (@has_lt.lt.{0} nat nat.has_lt (@fin.val n i) n)) (@eq.rec.{0 1} nat (@list.length.{u_1} α (@vector.to_list.{u_1} α n v)) (λ (_a : nat), @eq.{1} Prop (@has_lt.lt.{0} nat nat.has_lt (@fin.val n i) (@list.length.{u_1} α (@vector.to_list.{u_1} α n v))) (@has_lt.lt.{0} nat nat.has_lt (@fin.val n i) _a)) (@eq.refl.{1} Prop (@has_lt.lt.{0} nat nat.has_lt (@fin.val n i) (@list.length.{u_1} α (@vector.to_list.{u_1} α n v)))) n (@vector.to_list_length.{u_1} α n v))) (@fin.is_lt n i)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {n : nat} (f : fin n → α) (i : fin n), @eq.{u_1+1} α (@list.nth_le.{u_1} α (@list.of_fn.{u_1} α n f) (@fin.val n i) (@eq.subst.{1} nat (λ (_x : nat), @has_lt.lt.{0} nat nat.has_lt (@fin.val n i) _x) n (@list.length.{u_1} α (@list.of_fn.{u_1} α n f)) (@eq.symm.{1} nat (@list.length.{u_1} α (@list.of_fn.{u_1} α n f)) n (@list.length_of_fn.{u_1} α n f)) (@fin.is_lt n i))) (f i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='fin n → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='α : Type u_1,
n : nat,
f : fin n → α,
i : fin n
⊢ @eq.{u_1+1} α (@vector.nth.{u_1} α n (@vector.of_fn.{u_1} α n f) i) (f i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
n : nat,
f : fin n → α,
i : fin n
⊢ @eq.{u_1+1} α
    (@list.nth_le.{u_1} α (@vector.to_list.{u_1} α n (@vector.of_fn.{u_1} α n f)) (@fin.val n i)
       (@eq.mpr.{0}
          (@has_lt.lt.{0} nat nat.has_lt (@fin.val n i)
             (@list.length.{u_1} α (@vector.to_list.{u_1} α n (@vector.of_fn.{u_1} α n f))))
          (@has_lt.lt.{0} nat nat.has_lt (@fin.val n i) n)
          (@id.{0}
             (@eq.{1} Prop
                (@has_lt.lt.{0} nat nat.has_lt (@fin.val n i)
                   (@list.length.{u_1} α (@vector.to_list.{u_1} α n (@vector.of_fn.{u_1} α n f))))
                (@has_lt.lt.{0} nat nat.has_lt (@fin.val n i) n))
             (@eq.rec.{0 1} nat (@list.length.{u_1} α (@vector.to_list.{u_1} α n (@vector.of_fn.{u_1} α n f)))
                (λ (_a : nat),
                   @eq.{1} Prop
                     (@has_lt.lt.{0} nat nat.has_lt (@fin.val n i)
                        (@list.length.{u_1} α (@vector.to_list.{u_1} α n (@vector.of_fn.{u_1} α n f))))
                     (@has_lt.lt.{0} nat nat.has_lt (@fin.val n i) _a))
                (@eq.refl.{1} Prop
                   (@has_lt.lt.{0} nat nat.has_lt (@fin.val n i)
                      (@list.length.{u_1} α (@vector.to_list.{u_1} α n (@vector.of_fn.{u_1} α n f)))))
                n
                (@vector.to_list_length.{u_1} α n (@vector.of_fn.{u_1} α n f))))
          (@fin.is_lt n i)))
    (f i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
n : nat,
f : fin n → α,
i : fin n
⊢ @eq.{u_1+1} α
    (@list.nth_le.{u_1} α (@vector.to_list.{u_1} α n (@vector.of_fn.{u_1} α n f)) (@fin.val n i)
       (@eq.mpr.{0}
          (@has_lt.lt.{0} nat nat.has_lt (@fin.val n i)
             (@list.length.{u_1} α (@vector.to_list.{u_1} α n (@vector.of_fn.{u_1} α n f))))
          (@has_lt.lt.{0} nat nat.has_lt (@fin.val n i) n)
          (@id.{0}
             (@eq.{1} Prop
                (@has_lt.lt.{0} nat nat.has_lt (@fin.val n i)
                   (@list.length.{u_1} α (@vector.to_list.{u_1} α n (@vector.of_fn.{u_1} α n f))))
                (@has_lt.lt.{0} nat nat.has_lt (@fin.val n i) n))
             (@eq.rec.{0 1} nat (@list.length.{u_1} α (@vector.to_list.{u_1} α n (@vector.of_fn.{u_1} α n f)))
                (λ (_a : nat),
                   @eq.{1} Prop
                     (@has_lt.lt.{0} nat nat.has_lt (@fin.val n i)
                        (@list.length.{u_1} α (@vector.to_list.{u_1} α n (@vector.of_fn.{u_1} α n f))))
                     (@has_lt.lt.{0} nat nat.has_lt (@fin.val n i) _a))
                (@eq.refl.{1} Prop
                   (@has_lt.lt.{0} nat nat.has_lt (@fin.val n i)
                      (@list.length.{u_1} α (@vector.to_list.{u_1} α n (@vector.of_fn.{u_1} α n f)))))
                n
                (@vector.to_list_length.{u_1} α n (@vector.of_fn.{u_1} α n f))))
          (@fin.is_lt n i)))
    (@list.nth_le.{u_1} α (@list.of_fn.{u_1} α n f) (@fin.val n i)
       (@eq.subst.{1} nat (λ (_x : nat), @has_lt.lt.{0} nat nat.has_lt (@fin.val n i) _x) n
          (@list.length.{u_1} α (@list.of_fn.{u_1} α n f))
          (@eq.symm.{1} nat (@list.length.{u_1} α (@list.of_fn.{u_1} α n f)) n (@list.length_of_fn.{u_1} α n f))
          (@fin.is_lt n i)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
n : nat,
f : fin n → α,
i : fin n
⊢ @eq.{u_1+1} α (@vector.nth.{u_1} α n (@vector.of_fn.{u_1} α n f) i) (f i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 45     congr; apply to_list_of_fn</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='vector.to_list_of_fn'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1543, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 24, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {n : nat} (f : fin n → α), @eq.{u_1+1} (list.{u_1} α) (@vector.to_list.{u_1} α n (@vector.of_fn.{u_1} α n f)) (@list.of_fn.{u_1} α n f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='congr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
n : nat,
f : fin n → α,
i : fin n
⊢ @eq.{u_1+1} α (@vector.nth.{u_1} α n (@vector.of_fn.{u_1} α n f) i) (f i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 46  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
n : nat,
f : fin n → α,
i : fin n
⊢ @eq.{u_1+1} α (@vector.nth.{u_1} α n (@vector.of_fn.{u_1} α n f) i) (f i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 47  @[simp] theorem of_fn_nth (v : vector α n) : of_fn (nth v) = v :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='blue'><a title='vector'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='vector.of_fn'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='vector.nth'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 14, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 88, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 54, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='green'><a title='Type u → nat → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='fin (@list.length.{u_1} α l)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u} {n : nat}, (fin n → α) → vector.{u} α n'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} {n : nat}, vector.{u} α n → fin n → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='vector.{u_1} α n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='vector.{u_1} α n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 48  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : nat,
α : Type u_1,
v : vector.{u_1} α n
⊢ @eq.{(max 1 (u_1+1))} (vector.{u_1} α n) (@vector.of_fn.{u_1} α n (@vector.nth.{u_1} α n v)) v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 49    rcases v with ⟨l, rfl⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='vector.{u_1} α n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : nat,
α : Type u_1,
v : vector.{u_1} α n
⊢ @eq.{(max 1 (u_1+1))} (vector.{u_1} α n) (@vector.of_fn.{u_1} α n (@vector.nth.{u_1} α n v)) v'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
l : list.{u_1} α
⊢ @eq.{(max 1 (u_1+1))} (vector.{u_1} α (@list.length.{u_1} α l))
    (@vector.of_fn.{u_1} α (@list.length.{u_1} α l)
       (@vector.nth.{u_1} α (@list.length.{u_1} α l)
          (@subtype.mk.{u_1+1} (list.{u_1} α)
             (λ (l_1 : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
             l
             (@eq.refl.{1} nat (@list.length.{u_1} α l)))))
    (@subtype.mk.{u_1+1} (list.{u_1} α)
       (λ (l_1 : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
       l
       (@eq.refl.{1} nat (@list.length.{u_1} α l)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 50    apply to_list_injective,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='vector.to_list_injective'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 21, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {n : nat} {α : Type u_1}, @function.injective.{(max 1 (u_1+1)) u_1+1} (vector.{u_1} α n) (list.{u_1} α) (@vector.to_list.{u_1} α n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
l : list.{u_1} α
⊢ @eq.{(max 1 (u_1+1))} (vector.{u_1} α (@list.length.{u_1} α l))
    (@vector.of_fn.{u_1} α (@list.length.{u_1} α l)
       (@vector.nth.{u_1} α (@list.length.{u_1} α l)
          (@subtype.mk.{u_1+1} (list.{u_1} α)
             (λ (l_1 : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
             l
             (@eq.refl.{1} nat (@list.length.{u_1} α l)))))
    (@subtype.mk.{u_1+1} (list.{u_1} α)
       (λ (l_1 : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
       l
       (@eq.refl.{1} nat (@list.length.{u_1} α l)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
l : list.{u_1} α
⊢ @eq.{u_1+1} (list.{u_1} α)
    (@vector.to_list.{u_1} α (@list.length.{u_1} α l)
       (@vector.of_fn.{u_1} α (@list.length.{u_1} α l)
          (@vector.nth.{u_1} α (@list.length.{u_1} α l)
             (@subtype.mk.{u_1+1} (list.{u_1} α)
                (λ (l_1 : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
                l
                (@eq.refl.{1} nat (@list.length.{u_1} α l))))))
    (@vector.to_list.{u_1} α (@list.length.{u_1} α l)
       (@subtype.mk.{u_1+1} (list.{u_1} α)
          (λ (l_1 : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
          l
          (@eq.refl.{1} nat (@list.length.{u_1} α l))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 51    change nth ⟨l, eq.refl _⟩ with λ i, nth ⟨l, rfl⟩ i,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='vector.nth'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq.refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='vector.nth'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 54, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 54, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} {n : nat}, vector.{u_1} α n → fin n → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='list.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} (a : α), @eq.{1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} {n : nat}, vector.{u_1} α n → fin n → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='list.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} {a : α}, @eq.{1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
l : list.{u_1} α
⊢ @eq.{u_1+1} (list.{u_1} α)
    (@vector.to_list.{u_1} α (@list.length.{u_1} α l)
       (@vector.of_fn.{u_1} α (@list.length.{u_1} α l)
          (@vector.nth.{u_1} α (@list.length.{u_1} α l)
             (@subtype.mk.{u_1+1} (list.{u_1} α)
                (λ (l_1 : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
                l
                (@eq.refl.{1} nat (@list.length.{u_1} α l))))))
    (@vector.to_list.{u_1} α (@list.length.{u_1} α l)
       (@subtype.mk.{u_1+1} (list.{u_1} α)
          (λ (l_1 : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
          l
          (@eq.refl.{1} nat (@list.length.{u_1} α l))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
l : list.{u_1} α
⊢ @eq.{u_1+1} (list.{u_1} α)
    (@vector.to_list.{u_1} α (@list.length.{u_1} α l)
       (@vector.of_fn.{u_1} α (@list.length.{u_1} α l)
          (λ (i : fin (@list.length.{u_1} α l)),
             @vector.nth.{u_1} α (@list.length.{u_1} α l)
               (@subtype.mk.{u_1+1} (list.{u_1} α)
                  (λ (l_1 : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
                  l
                  (@rfl.{1} nat (@list.length.{u_1} α l)))
               i)))
    (@vector.to_list.{u_1} α (@list.length.{u_1} α l)
       (@subtype.mk.{u_1+1} (list.{u_1} α)
          (λ (l_1 : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
          l
          (@eq.refl.{1} nat (@list.length.{u_1} α l))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 52    simp [nth, list.of_fn_nth_le]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='vector.nth'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='list.of_fn_nth_le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 54, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/list/basic.lean&#x27;, &#x27;line&#x27;: 3392, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type ?l_1} {n : nat}, vector.{?l_1} α n → fin n → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} (l : list.{?l_1} α), @eq.{?l_1+1} (list.{?l_1} α) (@list.of_fn.{?l_1} α (@list.length.{?l_1} α l) (λ (i : fin (@list.length.{?l_1} α l)), @list.nth_le.{?l_1} α l (@fin.val (@list.length.{?l_1} α l) i) (@fin.is_lt (@list.length.{?l_1} α l) i))) l'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
l : list.{u_1} α
⊢ @eq.{u_1+1} (list.{u_1} α)
    (@vector.to_list.{u_1} α (@list.length.{u_1} α l)
       (@vector.of_fn.{u_1} α (@list.length.{u_1} α l)
          (λ (i : fin (@list.length.{u_1} α l)),
             @vector.nth.{u_1} α (@list.length.{u_1} α l)
               (@subtype.mk.{u_1+1} (list.{u_1} α)
                  (λ (l_1 : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
                  l
                  (@rfl.{1} nat (@list.length.{u_1} α l)))
               i)))
    (@vector.to_list.{u_1} α (@list.length.{u_1} α l)
       (@subtype.mk.{u_1+1} (list.{u_1} α)
          (λ (l_1 : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
          l
          (@eq.refl.{1} nat (@list.length.{u_1} α l))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 53  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 54  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 55  @[simp] theorem nth_tail : ∀ (v : vector α n.succ) (i : fin n),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='blue'><a title='nth_tail'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='vector'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='nat.succ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='fin'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 14, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 293, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/fin/basic.lean&#x27;, &#x27;line&#x27;: 9, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='green'><a title='∀ (v : vector.{u_1} α (nat.succ n)) (i : fin n), @eq.{u_1+1} α (@vector.nth.{u_1} α (@has_sub.sub.{0} nat nat.has_sub (nat.succ n) (@has_one.one.{0} nat nat.has_one)) (@vector.tail.{u_1} α (nat.succ n) v) i) (@vector.nth.{u_1} α (nat.succ n) v (@fin.succ n i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type u_1 → nat → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='nat → Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 56    nth (tail v) i = nth v i.succ</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='vector.nth'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='vector.tail'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='vector.nth'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='fin.succ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 54, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 54, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/fin/ops.lean&#x27;, &#x27;line&#x27;: 13, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} {n : nat}, vector.{u_1} α n → fin n → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} {n : nat}, vector.{u_1} α n → vector.{u_1} α (@has_sub.sub.{0} nat nat.has_sub n (@has_one.one.{0} nat nat.has_one))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='vector.{u_1} α (nat.succ n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='fin n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} {n : nat}, vector.{u_1} α n → fin n → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='vector.{u_1} α (nat.succ n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='fin n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {n : nat}, fin n → fin (nat.succ n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 57  | ⟨a::l, e⟩ ⟨i, h⟩ := by simp [nth_eq_nth_le]; refl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='list.cons'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='blue'><a title='vector.nth_eq_nth_le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 286, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 35, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1263, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {T : Type u_1}, T → list.{u_1} T → list.{u_1} T'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {n : nat} {α : Type ?l_1} (v : vector.{?l_1} α n) (i : fin n), @eq.{?l_1+1} α (@vector.nth.{?l_1} α n v i) (@list.nth_le.{?l_1} α (@vector.to_list.{?l_1} α n v) (@fin.val n i) (@eq.mpr.{0} (@has_lt.lt.{0} nat nat.has_lt (@fin.val n i) (@list.length.{?l_1} α (@vector.to_list.{?l_1} α n v))) (@has_lt.lt.{0} nat nat.has_lt (@fin.val n i) n) (@id.{0} (@eq.{1} Prop (@has_lt.lt.{0} nat nat.has_lt (@fin.val n i) (@list.length.{?l_1} α (@vector.to_list.{?l_1} α n v))) (@has_lt.lt.{0} nat nat.has_lt (@fin.val n i) n)) (@eq.rec.{0 1} nat (@list.length.{?l_1} α (@vector.to_list.{?l_1} α n v)) (λ (_a : nat), @eq.{1} Prop (@has_lt.lt.{0} nat nat.has_lt (@fin.val n i) (@list.length.{?l_1} α (@vector.to_list.{?l_1} α n v))) (@has_lt.lt.{0} nat nat.has_lt (@fin.val n i) _a)) (@eq.refl.{1} Prop (@has_lt.lt.{0} nat nat.has_lt (@fin.val n i) (@list.length.{?l_1} α (@vector.to_list.{?l_1} α n v)))) n (@vector.to_list_length.{?l_1} α n v))) (@fin.is_lt n i)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Shorter name for the tactic `reflexivity`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='lime'><a title='n : nat,
α : Type u_1,
nth_tail :
  ∀ (v : vector.{u_1} α (nat.succ n)) (i : fin n),
    @eq.{u_1+1} α
      (@vector.nth.{u_1} α (@has_sub.sub.{0} nat nat.has_sub (nat.succ n) (@has_one.one.{0} nat nat.has_one))
         (@vector.tail.{u_1} α (nat.succ n) v)
         i)
      (@vector.nth.{u_1} α (nat.succ n) v (@fin.succ n i)),
a : α,
l : list.{u_1} α,
e : @eq.{1} nat (@list.length.{u_1} α (@list.cons.{u_1} α a l)) (nat.succ n),
i : nat,
h : @has_lt.lt.{0} nat nat.has_lt i n
⊢ @eq.{u_1+1} α
    (@vector.nth.{u_1} α (@has_sub.sub.{0} nat nat.has_sub (nat.succ n) (@has_one.one.{0} nat nat.has_one))
       (@vector.tail.{u_1} α (nat.succ n)
          (@subtype.mk.{u_1+1} (list.{u_1} α)
             (λ (l : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l) (nat.succ n))
             (@list.cons.{u_1} α a l)
             e))
       (@fin.mk n i h))
    (@vector.nth.{u_1} α (nat.succ n)
       (@subtype.mk.{u_1+1} (list.{u_1} α) (λ (l : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l) (nat.succ n))
          (@list.cons.{u_1} α a l)
          e)
       (@fin.succ n (@fin.mk n i h)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 58  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1263, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Shorter name for the tactic `reflexivity`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : nat,
α : Type u_1,
nth_tail :
  ∀ (v : vector.{u_1} α (nat.succ n)) (i : fin n),
    @eq.{u_1+1} α
      (@vector.nth.{u_1} α (@has_sub.sub.{0} nat nat.has_sub (nat.succ n) (@has_one.one.{0} nat nat.has_one))
         (@vector.tail.{u_1} α (nat.succ n) v)
         i)
      (@vector.nth.{u_1} α (nat.succ n) v (@fin.succ n i)),
a : α,
l : list.{u_1} α,
e : @eq.{1} nat (@list.length.{u_1} α (@list.cons.{u_1} α a l)) (nat.succ n),
i : nat,
h : @has_lt.lt.{0} nat nat.has_lt i n
⊢ @eq.{u_1+1} α
    (@vector.nth.{u_1} α (@has_sub.sub.{0} nat nat.has_sub (nat.succ n) (@has_one.one.{0} nat nat.has_one))
       (@vector.tail.{u_1} α (nat.succ n)
          (@subtype.mk.{u_1+1} (list.{u_1} α)
             (λ (l : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l) (nat.succ n))
             (@list.cons.{u_1} α a l)
             e))
       (@fin.mk n i h))
    (@vector.nth.{u_1} α (nat.succ n)
       (@subtype.mk.{u_1+1} (list.{u_1} α) (λ (l : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l) (nat.succ n))
          (@list.cons.{u_1} α a l)
          e)
       (@fin.succ n (@fin.mk n i h)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 59  @[simp] theorem tail_of_fn {n : ℕ} (f : fin n.succ → α) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='blue'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='fin'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='nat.succ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 293, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/fin/basic.lean&#x27;, &#x27;line&#x27;: 9, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 293, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='nat → Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 60    tail (of_fn f) = of_fn (λ i, f i.succ) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='vector.tail'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='vector.of_fn'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='vector.of_fn'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='fin.succ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 88, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 88, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/fin/ops.lean&#x27;, &#x27;line&#x27;: 13, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} {n : nat}, vector.{u} α n → vector.{u} α (@has_sub.sub.{0} nat nat.has_sub n (@has_one.one.{0} nat nat.has_one))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} {n : nat}, (fin n → α) → vector.{u} α n'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='fin (nat.succ n) → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} {n : nat}, (fin n → α) → vector.{u} α n'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='fin (@has_sub.sub.{0} nat nat.has_sub (nat.succ n) (@has_one.one.{0} nat nat.has_one))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='fin (nat.succ n) → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='fin (@has_sub.sub.{0} nat nat.has_sub (nat.succ n) (@has_one.one.{0} nat nat.has_one))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {n : nat}, fin n → fin (nat.succ n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 61  (of_fn_nth _).symm.trans $ by congr; funext i; simp</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='vector.of_fn_nth'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='eq.symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq.trans'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 47, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 198, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 195, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1543, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1489, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {n : nat} {α : Type u_1} (v : vector.{u_1} α n), @eq.{(max 1 (u_1+1))} (vector.{u_1} α n) (@vector.of_fn.{u_1} α n (@vector.nth.{u_1} α n v)) v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {α : Type u_1} {a b : α}, @eq.{(max 1 (u_1+1))} α a b → @eq.{(max 1 (u_1+1))} α b a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_1} {a b c : α}, @eq.{(max 1 (u_1+1))} α a b → @eq.{(max 1 (u_1+1))} α b c → @eq.{(max 1 (u_1+1))} α a c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='orange'><a title='Apply function extensionality and introduce new hypotheses.
The tactic `funext` will keep applying new the `funext` lemma until the goal target is not reducible to
```lean
  |-  ((fun x, ...) = (fun x, ...))
```
The variant `funext h₁ ... hₙ` applies `funext` `n` times, and uses the given identifiers to name the new hypotheses.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='teal'><a title='congr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='funext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='lime'><a title='α : Type u_1,
n : nat,
f : fin (nat.succ n) → α
⊢ @eq.{(max 1 (u_1+1))}
    (vector.{u_1} α (@has_sub.sub.{0} nat nat.has_sub (nat.succ n) (@has_one.one.{0} nat nat.has_one)))
    (@vector.of_fn.{u_1} α (@has_sub.sub.{0} nat nat.has_sub (nat.succ n) (@has_one.one.{0} nat nat.has_one))
       (@vector.nth.{u_1} α (@has_sub.sub.{0} nat nat.has_sub (nat.succ n) (@has_one.one.{0} nat nat.has_one))
          (@vector.tail.{u_1} α (nat.succ n) (@vector.of_fn.{u_1} α (nat.succ n) f))))
    (@vector.of_fn.{u_1} α (@has_sub.sub.{0} nat nat.has_sub (nat.succ n) (@has_one.one.{0} nat nat.has_one))
       (λ (i : fin (@has_sub.sub.{0} nat nat.has_sub (nat.succ n) (@has_one.one.{0} nat nat.has_one))),
          f (@fin.succ (@has_sub.sub.{0} nat nat.has_sub (nat.succ n) (@has_one.one.{0} nat nat.has_one)) i)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 62  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
n : nat,
f : fin (nat.succ n) → α
⊢ @eq.{(max 1 (u_1+1))}
    (vector.{u_1} α (@has_sub.sub.{0} nat nat.has_sub (nat.succ n) (@has_one.one.{0} nat nat.has_one)))
    (@vector.of_fn.{u_1} α (@has_sub.sub.{0} nat nat.has_sub (nat.succ n) (@has_one.one.{0} nat nat.has_one))
       (@vector.nth.{u_1} α (@has_sub.sub.{0} nat nat.has_sub (nat.succ n) (@has_one.one.{0} nat nat.has_one))
          (@vector.tail.{u_1} α (nat.succ n) (@vector.of_fn.{u_1} α (nat.succ n) f))))
    (@vector.of_fn.{u_1} α (@has_sub.sub.{0} nat nat.has_sub (nat.succ n) (@has_one.one.{0} nat nat.has_one))
       (λ (i : fin (@has_sub.sub.{0} nat nat.has_sub (nat.succ n) (@has_one.one.{0} nat nat.has_one))),
          f (@fin.succ (@has_sub.sub.{0} nat nat.has_sub (nat.succ n) (@has_one.one.{0} nat nat.has_one)) i)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 63  lemma mem_iff_nth {a : α} {v : vector α n} : a ∈ v.to_list ↔ ∃ i, v.nth i = a :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='vector'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='_fun_match'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='vector.to_list'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='vector.nth'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 14, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 52, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 54, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u → nat → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@Exists.{1} nat (λ (n_1 : nat), @Exists.{0} (@has_lt.lt.{0} nat nat.has_lt n_1 (@list.length.{u_1} α (@vector.to_list.{u_1} α n v))) (λ (h : @has_lt.lt.{0} nat nat.has_lt n_1 (@list.length.{u_1} α (@vector.to_list.{u_1} α n v))), @eq.{u_1+1} α (@list.nth_le.{u_1} α (@vector.to_list.{u_1} α n v) n_1 h) a)) → @Exists.{1} nat (λ (i : nat), @Exists.{0} (@has_lt.lt.{0} nat nat.has_lt i n) (λ (h : @has_lt.lt.{0} nat nat.has_lt i n), @eq.{u_1+1} α (@list.nth_le.{u_1} α (@vector.to_list.{u_1} α n v) i (@eq.mpr.{0} (@has_lt.lt.{0} nat nat.has_lt (@fin.val n (@fin.mk n i h)) (@list.length.{u_1} α (@vector.to_list.{u_1} α n v))) (@has_lt.lt.{0} nat nat.has_lt (@fin.val n (@fin.mk n i h)) n) (@id.{0} (@eq.{1} Prop (@has_lt.lt.{0} nat nat.has_lt (@fin.val n (@fin.mk n i h)) (@list.length.{u_1} α (@vector.to_list.{u_1} α n v))) (@has_lt.lt.{0} nat nat.has_lt (@fin.val n (@fin.mk n i h)) n)) (@eq.rec.{0 1} nat (@list.length.{u_1} α (@vector.to_list.{u_1} α n v)) (λ (_a : nat), @eq.{1} Prop (@has_lt.lt.{0} nat nat.has_lt (@fin.val n (@fin.mk n i h)) (@list.length.{u_1} α (@vector.to_list.{u_1} α n v))) (@has_lt.lt.{0} nat nat.has_lt (@fin.val n (@fin.mk n i h)) _a)) (@eq.refl.{1} Prop (@has_lt.lt.{0} nat nat.has_lt (@fin.val n (@fin.mk n i h)) (@list.length.{u_1} α (@vector.to_list.{u_1} α n v)))) n (@vector.to_list_length.{u_1} α n v))) (@fin.is_lt n (@fin.mk n i h)))) a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u_1} [c : has_mem.{u_1 u_1} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@Exists.{1} nat (λ (n_1 : nat), @Exists.{0} (@has_lt.lt.{0} nat nat.has_lt n_1 (@list.length.{u_1} α (@vector.to_list.{u_1} α n v))) (λ (h : @has_lt.lt.{0} nat nat.has_lt n_1 (@list.length.{u_1} α (@vector.to_list.{u_1} α n v))), @eq.{u_1+1} α (@list.nth_le.{u_1} α (@vector.to_list.{u_1} α n v) n_1 h) a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} {n : nat}, vector.{u_1} α n → list.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='fin n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='vector.{u_1} α n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} {n : nat}, vector.{u_1} α n → fin n → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='fin n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 64  by simp only [list.mem_iff_nth_le, fin.exists_iff, vector.nth_eq_nth_le];</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='list.mem_iff_nth_le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='fin.exists_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='vector.nth_eq_nth_le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/list/basic.lean&#x27;, &#x27;line&#x27;: 802, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/fin.lean&#x27;, &#x27;line&#x27;: 55, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 35, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {a : α} {l : list.{?l_1} α}, iff (@has_mem.mem.{?l_1 ?l_1} α (list.{?l_1} α) (@list.has_mem.{?l_1} α) a l) (@Exists.{1} nat (λ (n : nat), @Exists.{0} (@has_lt.lt.{0} nat nat.has_lt n (@list.length.{?l_1} α l)) (λ (h : @has_lt.lt.{0} nat nat.has_lt n (@list.length.{?l_1} α l)), @eq.{?l_1+1} α (@list.nth_le.{?l_1} α l n h) a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {n : nat} {p : fin n → Prop}, iff (@Exists.{1} (fin n) (λ (i : fin n), p i)) (@Exists.{1} nat (λ (i : nat), @Exists.{0} (@has_lt.lt.{0} nat nat.has_lt i n) (λ (h : @has_lt.lt.{0} nat nat.has_lt i n), p (@fin.mk n i h))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {n : nat} {α : Type ?l_1} (v : vector.{?l_1} α n) (i : fin n), @eq.{?l_1+1} α (@vector.nth.{?l_1} α n v i) (@list.nth_le.{?l_1} α (@vector.to_list.{?l_1} α n v) (@fin.val n i) (@eq.mpr.{0} (@has_lt.lt.{0} nat nat.has_lt (@fin.val n i) (@list.length.{?l_1} α (@vector.to_list.{?l_1} α n v))) (@has_lt.lt.{0} nat nat.has_lt (@fin.val n i) n) (@id.{0} (@eq.{1} Prop (@has_lt.lt.{0} nat nat.has_lt (@fin.val n i) (@list.length.{?l_1} α (@vector.to_list.{?l_1} α n v))) (@has_lt.lt.{0} nat nat.has_lt (@fin.val n i) n)) (@eq.rec.{0 1} nat (@list.length.{?l_1} α (@vector.to_list.{?l_1} α n v)) (λ (_a : nat), @eq.{1} Prop (@has_lt.lt.{0} nat nat.has_lt (@fin.val n i) (@list.length.{?l_1} α (@vector.to_list.{?l_1} α n v))) (@has_lt.lt.{0} nat nat.has_lt (@fin.val n i) _a)) (@eq.refl.{1} Prop (@has_lt.lt.{0} nat nat.has_lt (@fin.val n i) (@list.length.{?l_1} α (@vector.to_list.{?l_1} α n v)))) n (@vector.to_list_length.{?l_1} α n v))) (@fin.is_lt n i)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='n : nat,
α : Type u_1,
a : α,
v : vector.{u_1} α n
⊢ iff (@has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a (@vector.to_list.{u_1} α n v))
    (@Exists.{1} (fin n) (λ (i : fin n), @eq.{u_1+1} α (@vector.nth.{u_1} α n v i) a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 65    exact ⟨λ ⟨i, hi, h⟩, ⟨i, by rwa to_list_length at hi, h⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='vector.to_list_length'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 391, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 121, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 391, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u_1+1} α (@list.nth_le.{u_1} α (@vector.to_list.{u_1} α n v) i hi) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {n : nat} (v : vector.{u_1} α n), @eq.{1} nat (@list.length.{u_1} α (@vector.to_list.{u_1} α n v)) n'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`rewrite` followed by `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='`rewrite` followed by `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rwa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='rwa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : nat,
α : Type u_1,
a : α,
v : vector.{u_1} α n
⊢ iff (@has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a (@vector.to_list.{u_1} α n v))
    (@Exists.{1} (fin n) (λ (i : fin n), @eq.{u_1+1} α (@vector.nth.{u_1} α n v i) a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : nat,
α : Type u_1,
a : α,
v : vector.{u_1} α n,
_x :
  @Exists.{1} nat
    (λ (n_1 : nat),
       @Exists.{0} (@has_lt.lt.{0} nat nat.has_lt n_1 (@list.length.{u_1} α (@vector.to_list.{u_1} α n v)))
         (λ (h : @has_lt.lt.{0} nat nat.has_lt n_1 (@list.length.{u_1} α (@vector.to_list.{u_1} α n v))),
            @eq.{u_1+1} α (@list.nth_le.{u_1} α (@vector.to_list.{u_1} α n v) n_1 h) a)),
_fun_match :
  @Exists.{1} nat
    (λ (n_1 : nat),
       @Exists.{0} (@has_lt.lt.{0} nat nat.has_lt n_1 (@list.length.{u_1} α (@vector.to_list.{u_1} α n v)))
         (λ (h : @has_lt.lt.{0} nat nat.has_lt n_1 (@list.length.{u_1} α (@vector.to_list.{u_1} α n v))),
            @eq.{u_1+1} α (@list.nth_le.{u_1} α (@vector.to_list.{u_1} α n v) n_1 h) a)) →
  @Exists.{1} nat
    (λ (i : nat),
       @Exists.{0} (@has_lt.lt.{0} nat nat.has_lt i n)
         (λ (h : @has_lt.lt.{0} nat nat.has_lt i n),
            @eq.{u_1+1} α
              (@list.nth_le.{u_1} α (@vector.to_list.{u_1} α n v) i
                 (@eq.mpr.{0}
                    (@has_lt.lt.{0} nat nat.has_lt (@fin.val n (@fin.mk n i h))
                       (@list.length.{u_1} α (@vector.to_list.{u_1} α n v)))
                    (@has_lt.lt.{0} nat nat.has_lt (@fin.val n (@fin.mk n i h)) n)
                    (@id.{0}
                       (@eq.{1} Prop
                          (@has_lt.lt.{0} nat nat.has_lt (@fin.val n (@fin.mk n i h))
                             (@list.length.{u_1} α (@vector.to_list.{u_1} α n v)))
                          (@has_lt.lt.{0} nat nat.has_lt (@fin.val n (@fin.mk n i h)) n))
                       (@eq.rec.{0 1} nat (@list.length.{u_1} α (@vector.to_list.{u_1} α n v))
                          (λ (_a : nat),
                             @eq.{1} Prop
                               (@has_lt.lt.{0} nat nat.has_lt (@fin.val n (@fin.mk n i h))
                                  (@list.length.{u_1} α (@vector.to_list.{u_1} α n v)))
                               (@has_lt.lt.{0} nat nat.has_lt (@fin.val n (@fin.mk n i h)) _a))
                          (@eq.refl.{1} Prop
                             (@has_lt.lt.{0} nat nat.has_lt (@fin.val n (@fin.mk n i h))
                                (@list.length.{u_1} α (@vector.to_list.{u_1} α n v))))
                          n
                          (@vector.to_list_length.{u_1} α n v)))
                    (@fin.is_lt n (@fin.mk n i h))))
              a)),
i : nat,
hi : @has_lt.lt.{0} nat nat.has_lt i (@list.length.{u_1} α (@vector.to_list.{u_1} α n v)),
h : @eq.{u_1+1} α (@list.nth_le.{u_1} α (@vector.to_list.{u_1} α n v) i hi) a
⊢ @has_lt.lt.{0} nat nat.has_lt i n'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : nat,
α : Type u_1,
a : α,
v : vector.{u_1} α n
⊢ iff (@has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a (@vector.to_list.{u_1} α n v))
    (@Exists.{1} (fin n) (λ (i : fin n), @eq.{u_1+1} α (@vector.nth.{u_1} α n v i) a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 66      λ ⟨i, hi, h⟩, ⟨i, by rwa to_list_length, h⟩⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='vector.to_list_length'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 391, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 121, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u_1+1} α (@list.nth_le.{u_1} α (@vector.to_list.{u_1} α n v) i (@eq.mpr.{0} (@has_lt.lt.{0} nat nat.has_lt (@fin.val n (@fin.mk n i hi)) (@list.length.{u_1} α (@vector.to_list.{u_1} α n v))) (@has_lt.lt.{0} nat nat.has_lt (@fin.val n (@fin.mk n i hi)) n) (@id.{0} (@eq.{1} Prop (@has_lt.lt.{0} nat nat.has_lt (@fin.val n (@fin.mk n i hi)) (@list.length.{u_1} α (@vector.to_list.{u_1} α n v))) (@has_lt.lt.{0} nat nat.has_lt (@fin.val n (@fin.mk n i hi)) n)) (@eq.rec.{0 1} nat (@list.length.{u_1} α (@vector.to_list.{u_1} α n v)) (λ (_a : nat), @eq.{1} Prop (@has_lt.lt.{0} nat nat.has_lt (@fin.val n (@fin.mk n i hi)) (@list.length.{u_1} α (@vector.to_list.{u_1} α n v))) (@has_lt.lt.{0} nat nat.has_lt (@fin.val n (@fin.mk n i hi)) _a)) (@eq.refl.{1} Prop (@has_lt.lt.{0} nat nat.has_lt (@fin.val n (@fin.mk n i hi)) (@list.length.{u_1} α (@vector.to_list.{u_1} α n v)))) n (@vector.to_list_length.{u_1} α n v))) (@fin.is_lt n (@fin.mk n i hi)))) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {n : nat} (v : vector.{u_1} α n), @eq.{1} nat (@list.length.{u_1} α (@vector.to_list.{u_1} α n v)) n'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`rewrite` followed by `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rwa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : nat,
α : Type u_1,
a : α,
v : vector.{u_1} α n
⊢ iff (@has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a (@vector.to_list.{u_1} α n v))
    (@Exists.{1} (fin n) (λ (i : fin n), @eq.{u_1+1} α (@vector.nth.{u_1} α n v i) a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : nat,
α : Type u_1,
a : α,
v : vector.{u_1} α n,
_x :
  @Exists.{1} nat
    (λ (i : nat),
       @Exists.{0} (@has_lt.lt.{0} nat nat.has_lt i n)
         (λ (h : @has_lt.lt.{0} nat nat.has_lt i n),
            @eq.{u_1+1} α
              (@list.nth_le.{u_1} α (@vector.to_list.{u_1} α n v) i
                 (@eq.mpr.{0}
                    (@has_lt.lt.{0} nat nat.has_lt (@fin.val n (@fin.mk n i h))
                       (@list.length.{u_1} α (@vector.to_list.{u_1} α n v)))
                    (@has_lt.lt.{0} nat nat.has_lt (@fin.val n (@fin.mk n i h)) n)
                    (@id.{0}
                       (@eq.{1} Prop
                          (@has_lt.lt.{0} nat nat.has_lt (@fin.val n (@fin.mk n i h))
                             (@list.length.{u_1} α (@vector.to_list.{u_1} α n v)))
                          (@has_lt.lt.{0} nat nat.has_lt (@fin.val n (@fin.mk n i h)) n))
                       (@eq.rec.{0 1} nat (@list.length.{u_1} α (@vector.to_list.{u_1} α n v))
                          (λ (_a : nat),
                             @eq.{1} Prop
                               (@has_lt.lt.{0} nat nat.has_lt (@fin.val n (@fin.mk n i h))
                                  (@list.length.{u_1} α (@vector.to_list.{u_1} α n v)))
                               (@has_lt.lt.{0} nat nat.has_lt (@fin.val n (@fin.mk n i h)) _a))
                          (@eq.refl.{1} Prop
                             (@has_lt.lt.{0} nat nat.has_lt (@fin.val n (@fin.mk n i h))
                                (@list.length.{u_1} α (@vector.to_list.{u_1} α n v))))
                          n
                          (@vector.to_list_length.{u_1} α n v)))
                    (@fin.is_lt n (@fin.mk n i h))))
              a)),
_fun_match :
  @Exists.{1} nat
    (λ (i : nat),
       @Exists.{0} (@has_lt.lt.{0} nat nat.has_lt i n)
         (λ (h : @has_lt.lt.{0} nat nat.has_lt i n),
            @eq.{u_1+1} α
              (@list.nth_le.{u_1} α (@vector.to_list.{u_1} α n v) i
                 (@eq.mpr.{0}
                    (@has_lt.lt.{0} nat nat.has_lt (@fin.val n (@fin.mk n i h))
                       (@list.length.{u_1} α (@vector.to_list.{u_1} α n v)))
                    (@has_lt.lt.{0} nat nat.has_lt (@fin.val n (@fin.mk n i h)) n)
                    (@id.{0}
                       (@eq.{1} Prop
                          (@has_lt.lt.{0} nat nat.has_lt (@fin.val n (@fin.mk n i h))
                             (@list.length.{u_1} α (@vector.to_list.{u_1} α n v)))
                          (@has_lt.lt.{0} nat nat.has_lt (@fin.val n (@fin.mk n i h)) n))
                       (@eq.rec.{0 1} nat (@list.length.{u_1} α (@vector.to_list.{u_1} α n v))
                          (λ (_a : nat),
                             @eq.{1} Prop
                               (@has_lt.lt.{0} nat nat.has_lt (@fin.val n (@fin.mk n i h))
                                  (@list.length.{u_1} α (@vector.to_list.{u_1} α n v)))
                               (@has_lt.lt.{0} nat nat.has_lt (@fin.val n (@fin.mk n i h)) _a))
                          (@eq.refl.{1} Prop
                             (@has_lt.lt.{0} nat nat.has_lt (@fin.val n (@fin.mk n i h))
                                (@list.length.{u_1} α (@vector.to_list.{u_1} α n v))))
                          n
                          (@vector.to_list_length.{u_1} α n v)))
                    (@fin.is_lt n (@fin.mk n i h))))
              a)) →
  @Exists.{1} nat
    (λ (n_1 : nat),
       @Exists.{0} (@has_lt.lt.{0} nat nat.has_lt n_1 (@list.length.{u_1} α (@vector.to_list.{u_1} α n v)))
         (λ (h : @has_lt.lt.{0} nat nat.has_lt n_1 (@list.length.{u_1} α (@vector.to_list.{u_1} α n v))),
            @eq.{u_1+1} α (@list.nth_le.{u_1} α (@vector.to_list.{u_1} α n v) n_1 h) a)),
i : nat,
hi : @has_lt.lt.{0} nat nat.has_lt i n,
h :
  @eq.{u_1+1} α
    (@list.nth_le.{u_1} α (@vector.to_list.{u_1} α n v) i
       (@eq.mpr.{0}
          (@has_lt.lt.{0} nat nat.has_lt (@fin.val n (@fin.mk n i hi))
             (@list.length.{u_1} α (@vector.to_list.{u_1} α n v)))
          (@has_lt.lt.{0} nat nat.has_lt (@fin.val n (@fin.mk n i hi)) n)
          (@id.{0}
             (@eq.{1} Prop
                (@has_lt.lt.{0} nat nat.has_lt (@fin.val n (@fin.mk n i hi))
                   (@list.length.{u_1} α (@vector.to_list.{u_1} α n v)))
                (@has_lt.lt.{0} nat nat.has_lt (@fin.val n (@fin.mk n i hi)) n))
             (@eq.rec.{0 1} nat (@list.length.{u_1} α (@vector.to_list.{u_1} α n v))
                (λ (_a : nat),
                   @eq.{1} Prop
                     (@has_lt.lt.{0} nat nat.has_lt (@fin.val n (@fin.mk n i hi))
                        (@list.length.{u_1} α (@vector.to_list.{u_1} α n v)))
                     (@has_lt.lt.{0} nat nat.has_lt (@fin.val n (@fin.mk n i hi)) _a))
                (@eq.refl.{1} Prop
                   (@has_lt.lt.{0} nat nat.has_lt (@fin.val n (@fin.mk n i hi))
                      (@list.length.{u_1} α (@vector.to_list.{u_1} α n v))))
                n
                (@vector.to_list_length.{u_1} α n v)))
          (@fin.is_lt n (@fin.mk n i hi))))
    a
⊢ @has_lt.lt.{0} nat nat.has_lt i (@list.length.{u_1} α (@vector.to_list.{u_1} α n v))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : nat,
α : Type u_1,
a : α,
v : vector.{u_1} α n
⊢ iff (@has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a (@vector.to_list.{u_1} α n v))
    (@Exists.{1} (fin n) (λ (i : fin n), @eq.{u_1+1} α (@vector.nth.{u_1} α n v i) a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 67  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : nat,
α : Type u_1,
a : α,
v : vector.{u_1} α n
⊢ iff (@has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a (@vector.to_list.{u_1} α n v))
    (@Exists.{1} (fin n) (λ (i : fin n), @eq.{u_1+1} α (@vector.nth.{u_1} α n v i) a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 68  lemma nodup_iff_nth_inj {v : vector α n} : v.to_list.nodup ↔ function.injective v.nth :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='blue'><a title='vector'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='vector.to_list'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='list.nodup'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='function.injective'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='vector.nth'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 14, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 52, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/list/defs.lean&#x27;, &#x27;line&#x27;: 429, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/function.lean&#x27;, &#x27;line&#x27;: 64, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 54, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='green'><a title='Type u → nat → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='vector.{u_1} α n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} {n : nat}, vector.{u_1} α n → list.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1}, list.{u_1} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Sort u₁} {β : Sort u₂}, (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='vector.{u_1} α n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} {n : nat}, vector.{u_1} α n → fin n → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                    </code><font color='orange'><a title='`nodup l` means that `l` has no duplicates, that is, any element appears at most
 once in the list. It is defined as `pairwise (≠)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 69  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : nat,
α : Type u_1,
v : vector.{u_1} α n
⊢ iff (@list.nodup.{u_1} α (@vector.to_list.{u_1} α n v))
    (@function.injective.{1 u_1+1} (fin n) α (@vector.nth.{u_1} α n v))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 70    cases v with l hl,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='vector.{u_1} α n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : nat,
α : Type u_1,
v : vector.{u_1} α n
⊢ iff (@list.nodup.{u_1} α (@vector.to_list.{u_1} α n v))
    (@function.injective.{1 u_1+1} (fin n) α (@vector.nth.{u_1} α n v))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : nat,
α : Type u_1,
l : list.{u_1} α,
hl : @eq.{1} nat (@list.length.{u_1} α l) n
⊢ iff
    (@list.nodup.{u_1} α
       (@vector.to_list.{u_1} α n
          (@subtype.mk.{u_1+1} (list.{u_1} α) (λ (l : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l) n) l hl)))
    (@function.injective.{1 u_1+1} (fin n) α
       (@vector.nth.{u_1} α n
          (@subtype.mk.{u_1+1} (list.{u_1} α) (λ (l : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l) n) l hl)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 71    subst hl,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='hl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1306, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{1} nat (@list.length.{u_1} α l) n'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Given hypothesis `h : x = t` or `h : t = x`, where `x` is a local constant, `subst h` substitutes `x` by `t` everywhere in the main goal and then clears `h`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='subst'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : nat,
α : Type u_1,
l : list.{u_1} α,
hl : @eq.{1} nat (@list.length.{u_1} α l) n
⊢ iff
    (@list.nodup.{u_1} α
       (@vector.to_list.{u_1} α n
          (@subtype.mk.{u_1+1} (list.{u_1} α) (λ (l : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l) n) l hl)))
    (@function.injective.{1 u_1+1} (fin n) α
       (@vector.nth.{u_1} α n
          (@subtype.mk.{u_1+1} (list.{u_1} α) (λ (l : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l) n) l hl)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
l : list.{u_1} α
⊢ iff
    (@list.nodup.{u_1} α
       (@vector.to_list.{u_1} α (@list.length.{u_1} α l)
          (@subtype.mk.{u_1+1} (list.{u_1} α)
             (λ (l_1 : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
             l
             (@eq.refl.{1} nat (@list.length.{u_1} α l)))))
    (@function.injective.{1 u_1+1} (fin (@list.length.{u_1} α l)) α
       (@vector.nth.{u_1} α (@list.length.{u_1} α l)
          (@subtype.mk.{u_1+1} (list.{u_1} α)
             (λ (l_1 : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
             l
             (@eq.refl.{1} nat (@list.length.{u_1} α l)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 72    simp only [list.nodup_iff_nth_le_inj],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='list.nodup_iff_nth_le_inj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/list/basic.lean&#x27;, &#x27;line&#x27;: 4092, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {l : list.{?l_1} α}, iff (@list.nodup.{?l_1} α l) (∀ (i j : nat) (h₁ : @has_lt.lt.{0} nat nat.has_lt i (@list.length.{?l_1} α l)) (h₂ : @has_lt.lt.{0} nat nat.has_lt j (@list.length.{?l_1} α l)), @eq.{?l_1+1} α (@list.nth_le.{?l_1} α l i h₁) (@list.nth_le.{?l_1} α l j h₂) → @eq.{1} nat i j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
l : list.{u_1} α
⊢ iff
    (@list.nodup.{u_1} α
       (@vector.to_list.{u_1} α (@list.length.{u_1} α l)
          (@subtype.mk.{u_1+1} (list.{u_1} α)
             (λ (l_1 : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
             l
             (@eq.refl.{1} nat (@list.length.{u_1} α l)))))
    (@function.injective.{1 u_1+1} (fin (@list.length.{u_1} α l)) α
       (@vector.nth.{u_1} α (@list.length.{u_1} α l)
          (@subtype.mk.{u_1+1} (list.{u_1} α)
             (λ (l_1 : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
             l
             (@eq.refl.{1} nat (@list.length.{u_1} α l)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
l : list.{u_1} α
⊢ iff
    (∀ (i j : nat)
     (h₁ :
       @has_lt.lt.{0} nat nat.has_lt i
         (@list.length.{u_1} α
            (@vector.to_list.{u_1} α (@list.length.{u_1} α l)
               (@subtype.mk.{u_1+1} (list.{u_1} α)
                  (λ (l_1 : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
                  l
                  (@eq.refl.{1} nat (@list.length.{u_1} α l))))))
     (h₂ :
       @has_lt.lt.{0} nat nat.has_lt j
         (@list.length.{u_1} α
            (@vector.to_list.{u_1} α (@list.length.{u_1} α l)
               (@subtype.mk.{u_1+1} (list.{u_1} α)
                  (λ (l_1 : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
                  l
                  (@eq.refl.{1} nat (@list.length.{u_1} α l)))))),
       @eq.{u_1+1} α
         (@list.nth_le.{u_1} α
            (@vector.to_list.{u_1} α (@list.length.{u_1} α l)
               (@subtype.mk.{u_1+1} (list.{u_1} α)
                  (λ (l_1 : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
                  l
                  (@eq.refl.{1} nat (@list.length.{u_1} α l))))
            i
            h₁)
         (@list.nth_le.{u_1} α
            (@vector.to_list.{u_1} α (@list.length.{u_1} α l)
               (@subtype.mk.{u_1+1} (list.{u_1} α)
                  (λ (l_1 : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
                  l
                  (@eq.refl.{1} nat (@list.length.{u_1} α l))))
            j
            h₂) →
       @eq.{1} nat i j)
    (@function.injective.{1 u_1+1} (fin (@list.length.{u_1} α l)) α
       (@vector.nth.{u_1} α (@list.length.{u_1} α l)
          (@subtype.mk.{u_1+1} (list.{u_1} α)
             (λ (l_1 : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
             l
             (@eq.refl.{1} nat (@list.length.{u_1} α l)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 73    split,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1012, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Applies the constructor when the type of the target is an inductive data type with one constructor.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='split'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
l : list.{u_1} α
⊢ iff
    (∀ (i j : nat)
     (h₁ :
       @has_lt.lt.{0} nat nat.has_lt i
         (@list.length.{u_1} α
            (@vector.to_list.{u_1} α (@list.length.{u_1} α l)
               (@subtype.mk.{u_1+1} (list.{u_1} α)
                  (λ (l_1 : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
                  l
                  (@eq.refl.{1} nat (@list.length.{u_1} α l))))))
     (h₂ :
       @has_lt.lt.{0} nat nat.has_lt j
         (@list.length.{u_1} α
            (@vector.to_list.{u_1} α (@list.length.{u_1} α l)
               (@subtype.mk.{u_1+1} (list.{u_1} α)
                  (λ (l_1 : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
                  l
                  (@eq.refl.{1} nat (@list.length.{u_1} α l)))))),
       @eq.{u_1+1} α
         (@list.nth_le.{u_1} α
            (@vector.to_list.{u_1} α (@list.length.{u_1} α l)
               (@subtype.mk.{u_1+1} (list.{u_1} α)
                  (λ (l_1 : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
                  l
                  (@eq.refl.{1} nat (@list.length.{u_1} α l))))
            i
            h₁)
         (@list.nth_le.{u_1} α
            (@vector.to_list.{u_1} α (@list.length.{u_1} α l)
               (@subtype.mk.{u_1+1} (list.{u_1} α)
                  (λ (l_1 : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
                  l
                  (@eq.refl.{1} nat (@list.length.{u_1} α l))))
            j
            h₂) →
       @eq.{1} nat i j)
    (@function.injective.{1 u_1+1} (fin (@list.length.{u_1} α l)) α
       (@vector.nth.{u_1} α (@list.length.{u_1} α l)
          (@subtype.mk.{u_1+1} (list.{u_1} α)
             (λ (l_1 : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
             l
             (@eq.refl.{1} nat (@list.length.{u_1} α l)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u_1,
l : list.{u_1} α
⊢ (∀ (i j : nat)
   (h₁ :
     @has_lt.lt.{0} nat nat.has_lt i
       (@list.length.{u_1} α
          (@vector.to_list.{u_1} α (@list.length.{u_1} α l)
             (@subtype.mk.{u_1+1} (list.{u_1} α)
                (λ (l_1 : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
                l
                (@eq.refl.{1} nat (@list.length.{u_1} α l))))))
   (h₂ :
     @has_lt.lt.{0} nat nat.has_lt j
       (@list.length.{u_1} α
          (@vector.to_list.{u_1} α (@list.length.{u_1} α l)
             (@subtype.mk.{u_1+1} (list.{u_1} α)
                (λ (l_1 : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
                l
                (@eq.refl.{1} nat (@list.length.{u_1} α l)))))),
     @eq.{u_1+1} α
       (@list.nth_le.{u_1} α
          (@vector.to_list.{u_1} α (@list.length.{u_1} α l)
             (@subtype.mk.{u_1+1} (list.{u_1} α)
                (λ (l_1 : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
                l
                (@eq.refl.{1} nat (@list.length.{u_1} α l))))
          i
          h₁)
       (@list.nth_le.{u_1} α
          (@vector.to_list.{u_1} α (@list.length.{u_1} α l)
             (@subtype.mk.{u_1+1} (list.{u_1} α)
                (λ (l_1 : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
                l
                (@eq.refl.{1} nat (@list.length.{u_1} α l))))
          j
          h₂) →
     @eq.{1} nat i j) →
  @function.injective.{1 u_1+1} (fin (@list.length.{u_1} α l)) α
    (@vector.nth.{u_1} α (@list.length.{u_1} α l)
       (@subtype.mk.{u_1+1} (list.{u_1} α)
          (λ (l_1 : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
          l
          (@eq.refl.{1} nat (@list.length.{u_1} α l))))

α : Type u_1,
l : list.{u_1} α
⊢ @function.injective.{1 u_1+1} (fin (@list.length.{u_1} α l)) α
    (@vector.nth.{u_1} α (@list.length.{u_1} α l)
       (@subtype.mk.{u_1+1} (list.{u_1} α)
          (λ (l_1 : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
          l
          (@eq.refl.{1} nat (@list.length.{u_1} α l)))) →
  ∀ (i j : nat)
  (h₁ :
    @has_lt.lt.{0} nat nat.has_lt i
      (@list.length.{u_1} α
         (@vector.to_list.{u_1} α (@list.length.{u_1} α l)
            (@subtype.mk.{u_1+1} (list.{u_1} α)
               (λ (l_1 : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
               l
               (@eq.refl.{1} nat (@list.length.{u_1} α l))))))
  (h₂ :
    @has_lt.lt.{0} nat nat.has_lt j
      (@list.length.{u_1} α
         (@vector.to_list.{u_1} α (@list.length.{u_1} α l)
            (@subtype.mk.{u_1+1} (list.{u_1} α)
               (λ (l_1 : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
               l
               (@eq.refl.{1} nat (@list.length.{u_1} α l)))))),
    @eq.{u_1+1} α
      (@list.nth_le.{u_1} α
         (@vector.to_list.{u_1} α (@list.length.{u_1} α l)
            (@subtype.mk.{u_1+1} (list.{u_1} α)
               (λ (l_1 : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
               l
               (@eq.refl.{1} nat (@list.length.{u_1} α l))))
         i
         h₁)
      (@list.nth_le.{u_1} α
         (@vector.to_list.{u_1} α (@list.length.{u_1} α l)
            (@subtype.mk.{u_1+1} (list.{u_1} α)
               (λ (l_1 : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
               l
               (@eq.refl.{1} nat (@list.length.{u_1} α l))))
         j
         h₂) →
    @eq.{1} nat i j'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 74    { intros h i j hij,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u_1,
l : list.{u_1} α
⊢ (∀ (i j : nat)
   (h₁ :
     @has_lt.lt.{0} nat nat.has_lt i
       (@list.length.{u_1} α
          (@vector.to_list.{u_1} α (@list.length.{u_1} α l)
             (@subtype.mk.{u_1+1} (list.{u_1} α)
                (λ (l_1 : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
                l
                (@eq.refl.{1} nat (@list.length.{u_1} α l))))))
   (h₂ :
     @has_lt.lt.{0} nat nat.has_lt j
       (@list.length.{u_1} α
          (@vector.to_list.{u_1} α (@list.length.{u_1} α l)
             (@subtype.mk.{u_1+1} (list.{u_1} α)
                (λ (l_1 : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
                l
                (@eq.refl.{1} nat (@list.length.{u_1} α l)))))),
     @eq.{u_1+1} α
       (@list.nth_le.{u_1} α
          (@vector.to_list.{u_1} α (@list.length.{u_1} α l)
             (@subtype.mk.{u_1+1} (list.{u_1} α)
                (λ (l_1 : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
                l
                (@eq.refl.{1} nat (@list.length.{u_1} α l))))
          i
          h₁)
       (@list.nth_le.{u_1} α
          (@vector.to_list.{u_1} α (@list.length.{u_1} α l)
             (@subtype.mk.{u_1+1} (list.{u_1} α)
                (λ (l_1 : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
                l
                (@eq.refl.{1} nat (@list.length.{u_1} α l))))
          j
          h₂) →
     @eq.{1} nat i j) →
  @function.injective.{1 u_1+1} (fin (@list.length.{u_1} α l)) α
    (@vector.nth.{u_1} α (@list.length.{u_1} α l)
       (@subtype.mk.{u_1+1} (list.{u_1} α)
          (λ (l_1 : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
          l
          (@eq.refl.{1} nat (@list.length.{u_1} α l))))

α : Type u_1,
l : list.{u_1} α
⊢ @function.injective.{1 u_1+1} (fin (@list.length.{u_1} α l)) α
    (@vector.nth.{u_1} α (@list.length.{u_1} α l)
       (@subtype.mk.{u_1+1} (list.{u_1} α)
          (λ (l_1 : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
          l
          (@eq.refl.{1} nat (@list.length.{u_1} α l)))) →
  ∀ (i j : nat)
  (h₁ :
    @has_lt.lt.{0} nat nat.has_lt i
      (@list.length.{u_1} α
         (@vector.to_list.{u_1} α (@list.length.{u_1} α l)
            (@subtype.mk.{u_1+1} (list.{u_1} α)
               (λ (l_1 : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
               l
               (@eq.refl.{1} nat (@list.length.{u_1} α l))))))
  (h₂ :
    @has_lt.lt.{0} nat nat.has_lt j
      (@list.length.{u_1} α
         (@vector.to_list.{u_1} α (@list.length.{u_1} α l)
            (@subtype.mk.{u_1+1} (list.{u_1} α)
               (λ (l_1 : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
               l
               (@eq.refl.{1} nat (@list.length.{u_1} α l)))))),
    @eq.{u_1+1} α
      (@list.nth_le.{u_1} α
         (@vector.to_list.{u_1} α (@list.length.{u_1} α l)
            (@subtype.mk.{u_1+1} (list.{u_1} α)
               (λ (l_1 : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
               l
               (@eq.refl.{1} nat (@list.length.{u_1} α l))))
         i
         h₁)
      (@list.nth_le.{u_1} α
         (@vector.to_list.{u_1} α (@list.length.{u_1} α l)
            (@subtype.mk.{u_1+1} (list.{u_1} α)
               (λ (l_1 : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
               l
               (@eq.refl.{1} nat (@list.length.{u_1} α l))))
         j
         h₂) →
    @eq.{1} nat i j'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
l : list.{u_1} α
⊢ (∀ (i j : nat)
   (h₁ :
     @has_lt.lt.{0} nat nat.has_lt i
       (@list.length.{u_1} α
          (@vector.to_list.{u_1} α (@list.length.{u_1} α l)
             (@subtype.mk.{u_1+1} (list.{u_1} α)
                (λ (l_1 : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
                l
                (@eq.refl.{1} nat (@list.length.{u_1} α l))))))
   (h₂ :
     @has_lt.lt.{0} nat nat.has_lt j
       (@list.length.{u_1} α
          (@vector.to_list.{u_1} α (@list.length.{u_1} α l)
             (@subtype.mk.{u_1+1} (list.{u_1} α)
                (λ (l_1 : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
                l
                (@eq.refl.{1} nat (@list.length.{u_1} α l)))))),
     @eq.{u_1+1} α
       (@list.nth_le.{u_1} α
          (@vector.to_list.{u_1} α (@list.length.{u_1} α l)
             (@subtype.mk.{u_1+1} (list.{u_1} α)
                (λ (l_1 : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
                l
                (@eq.refl.{1} nat (@list.length.{u_1} α l))))
          i
          h₁)
       (@list.nth_le.{u_1} α
          (@vector.to_list.{u_1} α (@list.length.{u_1} α l)
             (@subtype.mk.{u_1+1} (list.{u_1} α)
                (λ (l_1 : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
                l
                (@eq.refl.{1} nat (@list.length.{u_1} α l))))
          j
          h₂) →
     @eq.{1} nat i j) →
  @function.injective.{1 u_1+1} (fin (@list.length.{u_1} α l)) α
    (@vector.nth.{u_1} α (@list.length.{u_1} α l)
       (@subtype.mk.{u_1+1} (list.{u_1} α)
          (λ (l_1 : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
          l
          (@eq.refl.{1} nat (@list.length.{u_1} α l))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
l : list.{u_1} α,
h :
  ∀ (i j : nat)
  (h₁ :
    @has_lt.lt.{0} nat nat.has_lt i
      (@list.length.{u_1} α
         (@vector.to_list.{u_1} α (@list.length.{u_1} α l)
            (@subtype.mk.{u_1+1} (list.{u_1} α)
               (λ (l_1 : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
               l
               (@eq.refl.{1} nat (@list.length.{u_1} α l))))))
  (h₂ :
    @has_lt.lt.{0} nat nat.has_lt j
      (@list.length.{u_1} α
         (@vector.to_list.{u_1} α (@list.length.{u_1} α l)
            (@subtype.mk.{u_1+1} (list.{u_1} α)
               (λ (l_1 : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
               l
               (@eq.refl.{1} nat (@list.length.{u_1} α l)))))),
    @eq.{u_1+1} α
      (@list.nth_le.{u_1} α
         (@vector.to_list.{u_1} α (@list.length.{u_1} α l)
            (@subtype.mk.{u_1+1} (list.{u_1} α)
               (λ (l_1 : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
               l
               (@eq.refl.{1} nat (@list.length.{u_1} α l))))
         i
         h₁)
      (@list.nth_le.{u_1} α
         (@vector.to_list.{u_1} α (@list.length.{u_1} α l)
            (@subtype.mk.{u_1+1} (list.{u_1} α)
               (λ (l_1 : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
               l
               (@eq.refl.{1} nat (@list.length.{u_1} α l))))
         j
         h₂) →
    @eq.{1} nat i j,
i j : fin (@list.length.{u_1} α l),
hij :
  @eq.{u_1+1} α
    (@vector.nth.{u_1} α (@list.length.{u_1} α l)
       (@subtype.mk.{u_1+1} (list.{u_1} α)
          (λ (l_1 : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
          l
          (@eq.refl.{1} nat (@list.length.{u_1} α l)))
       i)
    (@vector.nth.{u_1} α (@list.length.{u_1} α l)
       (@subtype.mk.{u_1+1} (list.{u_1} α)
          (λ (l_1 : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
          l
          (@eq.refl.{1} nat (@list.length.{u_1} α l)))
       j)
⊢ @eq.{1} (fin (@list.length.{u_1} α l)) i j'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 75      cases i, cases j, simp [nth_eq_nth_le] at *, tauto },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='vector.nth_eq_nth_le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 35, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/tauto.lean&#x27;, &#x27;line&#x27;: 229, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='fin (@list.length.{u_1} α l)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='fin (@list.length.{u_1} α l)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {n : nat} {α : Type ?l_1} (v : vector.{?l_1} α n) (i : fin n), @eq.{?l_1+1} α (@vector.nth.{?l_1} α n v i) (@list.nth_le.{?l_1} α (@vector.to_list.{?l_1} α n v) (@fin.val n i) (@eq.mpr.{0} (@has_lt.lt.{0} nat nat.has_lt (@fin.val n i) (@list.length.{?l_1} α (@vector.to_list.{?l_1} α n v))) (@has_lt.lt.{0} nat nat.has_lt (@fin.val n i) n) (@id.{0} (@eq.{1} Prop (@has_lt.lt.{0} nat nat.has_lt (@fin.val n i) (@list.length.{?l_1} α (@vector.to_list.{?l_1} α n v))) (@has_lt.lt.{0} nat nat.has_lt (@fin.val n i) n)) (@eq.rec.{0 1} nat (@list.length.{?l_1} α (@vector.to_list.{?l_1} α n v)) (λ (_a : nat), @eq.{1} Prop (@has_lt.lt.{0} nat nat.has_lt (@fin.val n i) (@list.length.{?l_1} α (@vector.to_list.{?l_1} α n v))) (@has_lt.lt.{0} nat nat.has_lt (@fin.val n i) _a)) (@eq.refl.{1} Prop (@has_lt.lt.{0} nat nat.has_lt (@fin.val n i) (@list.length.{?l_1} α (@vector.to_list.{?l_1} α n v)))) n (@vector.to_list_length.{?l_1} α n v))) (@fin.is_lt n i)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`tauto` breaks down assumptions of the form `_ ∧ _`, `_ ∨ _`, `_ ↔ _` and `∃ _, _`
and splits a goal of the form `_ ∧ _`, `_ ↔ _` or `∃ _, _` until it can be discharged
using `reflexivity` or `solve_by_elim`.
This is a finishing tactic: it either closes the goal of raises an error.
The variant `tauto!` uses the law of excluded middle.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='tauto'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
l : list.{u_1} α,
h :
  ∀ (i j : nat)
  (h₁ :
    @has_lt.lt.{0} nat nat.has_lt i
      (@list.length.{u_1} α
         (@vector.to_list.{u_1} α (@list.length.{u_1} α l)
            (@subtype.mk.{u_1+1} (list.{u_1} α)
               (λ (l_1 : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
               l
               (@eq.refl.{1} nat (@list.length.{u_1} α l))))))
  (h₂ :
    @has_lt.lt.{0} nat nat.has_lt j
      (@list.length.{u_1} α
         (@vector.to_list.{u_1} α (@list.length.{u_1} α l)
            (@subtype.mk.{u_1+1} (list.{u_1} α)
               (λ (l_1 : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
               l
               (@eq.refl.{1} nat (@list.length.{u_1} α l)))))),
    @eq.{u_1+1} α
      (@list.nth_le.{u_1} α
         (@vector.to_list.{u_1} α (@list.length.{u_1} α l)
            (@subtype.mk.{u_1+1} (list.{u_1} α)
               (λ (l_1 : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
               l
               (@eq.refl.{1} nat (@list.length.{u_1} α l))))
         i
         h₁)
      (@list.nth_le.{u_1} α
         (@vector.to_list.{u_1} α (@list.length.{u_1} α l)
            (@subtype.mk.{u_1+1} (list.{u_1} α)
               (λ (l_1 : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
               l
               (@eq.refl.{1} nat (@list.length.{u_1} α l))))
         j
         h₂) →
    @eq.{1} nat i j,
i j : fin (@list.length.{u_1} α l),
hij :
  @eq.{u_1+1} α
    (@vector.nth.{u_1} α (@list.length.{u_1} α l)
       (@subtype.mk.{u_1+1} (list.{u_1} α)
          (λ (l_1 : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
          l
          (@eq.refl.{1} nat (@list.length.{u_1} α l)))
       i)
    (@vector.nth.{u_1} α (@list.length.{u_1} α l)
       (@subtype.mk.{u_1+1} (list.{u_1} α)
          (λ (l_1 : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
          l
          (@eq.refl.{1} nat (@list.length.{u_1} α l)))
       j)
⊢ @eq.{1} (fin (@list.length.{u_1} α l)) i j'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
l : list.{u_1} α,
h :
  ∀ (i j : nat)
  (h₁ :
    @has_lt.lt.{0} nat nat.has_lt i
      (@list.length.{u_1} α
         (@vector.to_list.{u_1} α (@list.length.{u_1} α l)
            (@subtype.mk.{u_1+1} (list.{u_1} α)
               (λ (l_1 : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
               l
               (@eq.refl.{1} nat (@list.length.{u_1} α l))))))
  (h₂ :
    @has_lt.lt.{0} nat nat.has_lt j
      (@list.length.{u_1} α
         (@vector.to_list.{u_1} α (@list.length.{u_1} α l)
            (@subtype.mk.{u_1+1} (list.{u_1} α)
               (λ (l_1 : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
               l
               (@eq.refl.{1} nat (@list.length.{u_1} α l)))))),
    @eq.{u_1+1} α
      (@list.nth_le.{u_1} α
         (@vector.to_list.{u_1} α (@list.length.{u_1} α l)
            (@subtype.mk.{u_1+1} (list.{u_1} α)
               (λ (l_1 : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
               l
               (@eq.refl.{1} nat (@list.length.{u_1} α l))))
         i
         h₁)
      (@list.nth_le.{u_1} α
         (@vector.to_list.{u_1} α (@list.length.{u_1} α l)
            (@subtype.mk.{u_1+1} (list.{u_1} α)
               (λ (l_1 : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
               l
               (@eq.refl.{1} nat (@list.length.{u_1} α l))))
         j
         h₂) →
    @eq.{1} nat i j,
j : fin (@list.length.{u_1} α l),
i_val : nat,
i_is_lt : @has_lt.lt.{0} nat nat.has_lt i_val (@list.length.{u_1} α l),
hij :
  @eq.{u_1+1} α
    (@vector.nth.{u_1} α (@list.length.{u_1} α l)
       (@subtype.mk.{u_1+1} (list.{u_1} α)
          (λ (l_1 : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
          l
          (@eq.refl.{1} nat (@list.length.{u_1} α l)))
       (@fin.mk (@list.length.{u_1} α l) i_val i_is_lt))
    (@vector.nth.{u_1} α (@list.length.{u_1} α l)
       (@subtype.mk.{u_1+1} (list.{u_1} α)
          (λ (l_1 : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
          l
          (@eq.refl.{1} nat (@list.length.{u_1} α l)))
       j)
⊢ @eq.{1} (fin (@list.length.{u_1} α l)) (@fin.mk (@list.length.{u_1} α l) i_val i_is_lt) j'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
l : list.{u_1} α,
h :
  ∀ (i j : nat)
  (h₁ :
    @has_lt.lt.{0} nat nat.has_lt i
      (@list.length.{u_1} α
         (@vector.to_list.{u_1} α (@list.length.{u_1} α l)
            (@subtype.mk.{u_1+1} (list.{u_1} α)
               (λ (l_1 : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
               l
               (@eq.refl.{1} nat (@list.length.{u_1} α l))))))
  (h₂ :
    @has_lt.lt.{0} nat nat.has_lt j
      (@list.length.{u_1} α
         (@vector.to_list.{u_1} α (@list.length.{u_1} α l)
            (@subtype.mk.{u_1+1} (list.{u_1} α)
               (λ (l_1 : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
               l
               (@eq.refl.{1} nat (@list.length.{u_1} α l)))))),
    @eq.{u_1+1} α
      (@list.nth_le.{u_1} α
         (@vector.to_list.{u_1} α (@list.length.{u_1} α l)
            (@subtype.mk.{u_1+1} (list.{u_1} α)
               (λ (l_1 : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
               l
               (@eq.refl.{1} nat (@list.length.{u_1} α l))))
         i
         h₁)
      (@list.nth_le.{u_1} α
         (@vector.to_list.{u_1} α (@list.length.{u_1} α l)
            (@subtype.mk.{u_1+1} (list.{u_1} α)
               (λ (l_1 : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
               l
               (@eq.refl.{1} nat (@list.length.{u_1} α l))))
         j
         h₂) →
    @eq.{1} nat i j,
i_val : nat,
i_is_lt : @has_lt.lt.{0} nat nat.has_lt i_val (@list.length.{u_1} α l),
j_val : nat,
j_is_lt : @has_lt.lt.{0} nat nat.has_lt j_val (@list.length.{u_1} α l),
hij :
  @eq.{u_1+1} α
    (@vector.nth.{u_1} α (@list.length.{u_1} α l)
       (@subtype.mk.{u_1+1} (list.{u_1} α)
          (λ (l_1 : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
          l
          (@eq.refl.{1} nat (@list.length.{u_1} α l)))
       (@fin.mk (@list.length.{u_1} α l) i_val i_is_lt))
    (@vector.nth.{u_1} α (@list.length.{u_1} α l)
       (@subtype.mk.{u_1+1} (list.{u_1} α)
          (λ (l_1 : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
          l
          (@eq.refl.{1} nat (@list.length.{u_1} α l)))
       (@fin.mk (@list.length.{u_1} α l) j_val j_is_lt))
⊢ @eq.{1} (fin (@list.length.{u_1} α l)) (@fin.mk (@list.length.{u_1} α l) i_val i_is_lt)
    (@fin.mk (@list.length.{u_1} α l) j_val j_is_lt)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
l : list.{u_1} α,
h :
  ∀ (i j : nat)
  (h₁ :
    @has_lt.lt.{0} nat nat.has_lt i
      (@list.length.{u_1} α
         (@vector.to_list.{u_1} α (@list.length.{u_1} α l)
            (@subtype.mk.{u_1+1} (list.{u_1} α)
               (λ (l_1 : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
               l
               (@eq.refl.{1} nat (@list.length.{u_1} α l))))))
  (h₂ :
    @has_lt.lt.{0} nat nat.has_lt j
      (@list.length.{u_1} α
         (@vector.to_list.{u_1} α (@list.length.{u_1} α l)
            (@subtype.mk.{u_1+1} (list.{u_1} α)
               (λ (l_1 : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
               l
               (@eq.refl.{1} nat (@list.length.{u_1} α l)))))),
    @eq.{u_1+1} α
      (@list.nth_le.{u_1} α
         (@vector.to_list.{u_1} α (@list.length.{u_1} α l)
            (@subtype.mk.{u_1+1} (list.{u_1} α)
               (λ (l_1 : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
               l
               (@eq.refl.{1} nat (@list.length.{u_1} α l))))
         i
         h₁)
      (@list.nth_le.{u_1} α
         (@vector.to_list.{u_1} α (@list.length.{u_1} α l)
            (@subtype.mk.{u_1+1} (list.{u_1} α)
               (λ (l_1 : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
               l
               (@eq.refl.{1} nat (@list.length.{u_1} α l))))
         j
         h₂) →
    @eq.{1} nat i j,
i_val : nat,
i_is_lt : @has_lt.lt.{0} nat nat.has_lt i_val (@list.length.{u_1} α l),
j_val : nat,
j_is_lt : @has_lt.lt.{0} nat nat.has_lt j_val (@list.length.{u_1} α l),
hij :
  @eq.{u_1+1} α
    (@list.nth_le.{u_1} α l i_val
       (@eq.rec.{0 u_1+1} (list.{u_1} α)
          (@vector.to_list.{u_1} α (@list.length.{u_1} α l)
             (@subtype.mk.{u_1+1} (list.{u_1} α)
                (λ (l_1 : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
                l
                (@eq.refl.{1} nat (@list.length.{u_1} α l))))
          (λ (l : list.{u_1} α), @has_lt.lt.{0} nat nat.has_lt i_val (@list.length.{u_1} α l))
          (@eq.rec.{0 1} nat (@fin.val (@list.length.{u_1} α l) (@fin.mk (@list.length.{u_1} α l) i_val i_is_lt))
             (λ (n : nat),
                @has_lt.lt.{0} nat nat.has_lt n
                  (@list.length.{u_1} α
                     (@vector.to_list.{u_1} α (@list.length.{u_1} α l)
                        (@subtype.mk.{u_1+1} (list.{u_1} α)
                           (λ (l_1 : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
                           l
                           (@eq.refl.{1} nat (@list.length.{u_1} α l))))))
             (@eq.mpr.{0}
                (@has_lt.lt.{0} nat nat.has_lt
                   (@fin.val (@list.length.{u_1} α l) (@fin.mk (@list.length.{u_1} α l) i_val i_is_lt))
                   (@list.length.{u_1} α
                      (@vector.to_list.{u_1} α (@list.length.{u_1} α l)
                         (@subtype.mk.{u_1+1} (list.{u_1} α)
                            (λ (l_1 : list.{u_1} α),
                               @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
                            l
                            (@eq.refl.{1} nat (@list.length.{u_1} α l))))))
                (@has_lt.lt.{0} nat nat.has_lt
                   (@fin.val (@list.length.{u_1} α l) (@fin.mk (@list.length.{u_1} α l) i_val i_is_lt))
                   (@list.length.{u_1} α l))
                (@id.{0}
                   (@eq.{1} Prop
                      (@has_lt.lt.{0} nat nat.has_lt
                         (@fin.val (@list.length.{u_1} α l) (@fin.mk (@list.length.{u_1} α l) i_val i_is_lt))
                         (@list.length.{u_1} α
                            (@vector.to_list.{u_1} α (@list.length.{u_1} α l)
                               (@subtype.mk.{u_1+1} (list.{u_1} α)
                                  (λ (l_1 : list.{u_1} α),
                                     @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
                                  l
                                  (@eq.refl.{1} nat (@list.length.{u_1} α l))))))
                      (@has_lt.lt.{0} nat nat.has_lt
                         (@fin.val (@list.length.{u_1} α l) (@fin.mk (@list.length.{u_1} α l) i_val i_is_lt))
                         (@list.length.{u_1} α l)))
                   (@eq.rec.{0 1} nat
                      (@list.length.{u_1} α
                         (@vector.to_list.{u_1} α (@list.length.{u_1} α l)
                            (@subtype.mk.{u_1+1} (list.{u_1} α)
                               (λ (l_1 : list.{u_1} α),
                                  @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
                               l
                               (@eq.refl.{1} nat (@list.length.{u_1} α l)))))
                      (λ (_a : nat),
                         @eq.{1} Prop
                           (@has_lt.lt.{0} nat nat.has_lt
                              (@fin.val (@list.length.{u_1} α l) (@fin.mk (@list.length.{u_1} α l) i_val i_is_lt))
                              (@list.length.{u_1} α
                                 (@vector.to_list.{u_1} α (@list.length.{u_1} α l)
                                    (@subtype.mk.{u_1+1} (list.{u_1} α)
                                       (λ (l_1 : list.{u_1} α),
                                          @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
                                       l
                                       (@eq.refl.{1} nat (@list.length.{u_1} α l))))))
                           (@has_lt.lt.{0} nat nat.has_lt
                              (@fin.val (@list.length.{u_1} α l) (@fin.mk (@list.length.{u_1} α l) i_val i_is_lt))
                              _a))
                      (@eq.refl.{1} Prop
                         (@has_lt.lt.{0} nat nat.has_lt
                            (@fin.val (@list.length.{u_1} α l) (@fin.mk (@list.length.{u_1} α l) i_val i_is_lt))
                            (@list.length.{u_1} α
                               (@vector.to_list.{u_1} α (@list.length.{u_1} α l)
                                  (@subtype.mk.{u_1+1} (list.{u_1} α)
                                     (λ (l_1 : list.{u_1} α),
                                        @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
                                     l
                                     (@eq.refl.{1} nat (@list.length.{u_1} α l)))))))
                      (@list.length.{u_1} α l)
                      (@vector.to_list_length.{u_1} α (@list.length.{u_1} α l)
                         (@subtype.mk.{u_1+1} (list.{u_1} α)
                            (λ (l_1 : list.{u_1} α),
                               @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
                            l
                            (@eq.refl.{1} nat (@list.length.{u_1} α l))))))
                (@fin.is_lt (@list.length.{u_1} α l) (@fin.mk (@list.length.{u_1} α l) i_val i_is_lt)))
             i_val
             (@eq.refl.{1} nat i_val))
          l
          (@vector.to_list_mk.{u_1} α (@list.length.{u_1} α l) l (@eq.refl.{1} nat (@list.length.{u_1} α l)))))
    (@list.nth_le.{u_1} α l j_val
       (@eq.rec.{0 u_1+1} (list.{u_1} α)
          (@vector.to_list.{u_1} α (@list.length.{u_1} α l)
             (@subtype.mk.{u_1+1} (list.{u_1} α)
                (λ (l_1 : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
                l
                (@eq.refl.{1} nat (@list.length.{u_1} α l))))
          (λ (l : list.{u_1} α), @has_lt.lt.{0} nat nat.has_lt j_val (@list.length.{u_1} α l))
          (@eq.rec.{0 1} nat (@fin.val (@list.length.{u_1} α l) (@fin.mk (@list.length.{u_1} α l) j_val j_is_lt))
             (λ (n : nat),
                @has_lt.lt.{0} nat nat.has_lt n
                  (@list.length.{u_1} α
                     (@vector.to_list.{u_1} α (@list.length.{u_1} α l)
                        (@subtype.mk.{u_1+1} (list.{u_1} α)
                           (λ (l_1 : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
                           l
                           (@eq.refl.{1} nat (@list.length.{u_1} α l))))))
             (@eq.mpr.{0}
                (@has_lt.lt.{0} nat nat.has_lt
                   (@fin.val (@list.length.{u_1} α l) (@fin.mk (@list.length.{u_1} α l) j_val j_is_lt))
                   (@list.length.{u_1} α
                      (@vector.to_list.{u_1} α (@list.length.{u_1} α l)
                         (@subtype.mk.{u_1+1} (list.{u_1} α)
                            (λ (l_1 : list.{u_1} α),
                               @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
                            l
                            (@eq.refl.{1} nat (@list.length.{u_1} α l))))))
                (@has_lt.lt.{0} nat nat.has_lt
                   (@fin.val (@list.length.{u_1} α l) (@fin.mk (@list.length.{u_1} α l) j_val j_is_lt))
                   (@list.length.{u_1} α l))
                (@id.{0}
                   (@eq.{1} Prop
                      (@has_lt.lt.{0} nat nat.has_lt
                         (@fin.val (@list.length.{u_1} α l) (@fin.mk (@list.length.{u_1} α l) j_val j_is_lt))
                         (@list.length.{u_1} α
                            (@vector.to_list.{u_1} α (@list.length.{u_1} α l)
                               (@subtype.mk.{u_1+1} (list.{u_1} α)
                                  (λ (l_1 : list.{u_1} α),
                                     @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
                                  l
                                  (@eq.refl.{1} nat (@list.length.{u_1} α l))))))
                      (@has_lt.lt.{0} nat nat.has_lt
                         (@fin.val (@list.length.{u_1} α l) (@fin.mk (@list.length.{u_1} α l) j_val j_is_lt))
                         (@list.length.{u_1} α l)))
                   (@eq.rec.{0 1} nat
                      (@list.length.{u_1} α
                         (@vector.to_list.{u_1} α (@list.length.{u_1} α l)
                            (@subtype.mk.{u_1+1} (list.{u_1} α)
                               (λ (l_1 : list.{u_1} α),
                                  @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
                               l
                               (@eq.refl.{1} nat (@list.length.{u_1} α l)))))
                      (λ (_a : nat),
                         @eq.{1} Prop
                           (@has_lt.lt.{0} nat nat.has_lt
                              (@fin.val (@list.length.{u_1} α l) (@fin.mk (@list.length.{u_1} α l) j_val j_is_lt))
                              (@list.length.{u_1} α
                                 (@vector.to_list.{u_1} α (@list.length.{u_1} α l)
                                    (@subtype.mk.{u_1+1} (list.{u_1} α)
                                       (λ (l_1 : list.{u_1} α),
                                          @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
                                       l
                                       (@eq.refl.{1} nat (@list.length.{u_1} α l))))))
                           (@has_lt.lt.{0} nat nat.has_lt
                              (@fin.val (@list.length.{u_1} α l) (@fin.mk (@list.length.{u_1} α l) j_val j_is_lt))
                              _a))
                      (@eq.refl.{1} Prop
                         (@has_lt.lt.{0} nat nat.has_lt
                            (@fin.val (@list.length.{u_1} α l) (@fin.mk (@list.length.{u_1} α l) j_val j_is_lt))
                            (@list.length.{u_1} α
                               (@vector.to_list.{u_1} α (@list.length.{u_1} α l)
                                  (@subtype.mk.{u_1+1} (list.{u_1} α)
                                     (λ (l_1 : list.{u_1} α),
                                        @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
                                     l
                                     (@eq.refl.{1} nat (@list.length.{u_1} α l)))))))
                      (@list.length.{u_1} α l)
                      (@vector.to_list_length.{u_1} α (@list.length.{u_1} α l)
                         (@subtype.mk.{u_1+1} (list.{u_1} α)
                            (λ (l_1 : list.{u_1} α),
                               @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
                            l
                            (@eq.refl.{1} nat (@list.length.{u_1} α l))))))
                (@fin.is_lt (@list.length.{u_1} α l) (@fin.mk (@list.length.{u_1} α l) j_val j_is_lt)))
             j_val
             (@eq.refl.{1} nat j_val))
          l
          (@vector.to_list_mk.{u_1} α (@list.length.{u_1} α l) l (@eq.refl.{1} nat (@list.length.{u_1} α l)))))
⊢ @eq.{1} nat i_val j_val'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
l : list.{u_1} α
⊢ @function.injective.{1 u_1+1} (fin (@list.length.{u_1} α l)) α
    (@vector.nth.{u_1} α (@list.length.{u_1} α l)
       (@subtype.mk.{u_1+1} (list.{u_1} α)
          (λ (l_1 : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
          l
          (@eq.refl.{1} nat (@list.length.{u_1} α l)))) →
  ∀ (i j : nat)
  (h₁ :
    @has_lt.lt.{0} nat nat.has_lt i
      (@list.length.{u_1} α
         (@vector.to_list.{u_1} α (@list.length.{u_1} α l)
            (@subtype.mk.{u_1+1} (list.{u_1} α)
               (λ (l_1 : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
               l
               (@eq.refl.{1} nat (@list.length.{u_1} α l))))))
  (h₂ :
    @has_lt.lt.{0} nat nat.has_lt j
      (@list.length.{u_1} α
         (@vector.to_list.{u_1} α (@list.length.{u_1} α l)
            (@subtype.mk.{u_1+1} (list.{u_1} α)
               (λ (l_1 : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
               l
               (@eq.refl.{1} nat (@list.length.{u_1} α l)))))),
    @eq.{u_1+1} α
      (@list.nth_le.{u_1} α
         (@vector.to_list.{u_1} α (@list.length.{u_1} α l)
            (@subtype.mk.{u_1+1} (list.{u_1} α)
               (λ (l_1 : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
               l
               (@eq.refl.{1} nat (@list.length.{u_1} α l))))
         i
         h₁)
      (@list.nth_le.{u_1} α
         (@vector.to_list.{u_1} α (@list.length.{u_1} α l)
            (@subtype.mk.{u_1+1} (list.{u_1} α)
               (λ (l_1 : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
               l
               (@eq.refl.{1} nat (@list.length.{u_1} α l))))
         j
         h₂) →
    @eq.{1} nat i j'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 76    { intros h i j hi hj hij,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
l : list.{u_1} α
⊢ @function.injective.{1 u_1+1} (fin (@list.length.{u_1} α l)) α
    (@vector.nth.{u_1} α (@list.length.{u_1} α l)
       (@subtype.mk.{u_1+1} (list.{u_1} α)
          (λ (l_1 : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
          l
          (@eq.refl.{1} nat (@list.length.{u_1} α l)))) →
  ∀ (i j : nat)
  (h₁ :
    @has_lt.lt.{0} nat nat.has_lt i
      (@list.length.{u_1} α
         (@vector.to_list.{u_1} α (@list.length.{u_1} α l)
            (@subtype.mk.{u_1+1} (list.{u_1} α)
               (λ (l_1 : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
               l
               (@eq.refl.{1} nat (@list.length.{u_1} α l))))))
  (h₂ :
    @has_lt.lt.{0} nat nat.has_lt j
      (@list.length.{u_1} α
         (@vector.to_list.{u_1} α (@list.length.{u_1} α l)
            (@subtype.mk.{u_1+1} (list.{u_1} α)
               (λ (l_1 : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
               l
               (@eq.refl.{1} nat (@list.length.{u_1} α l)))))),
    @eq.{u_1+1} α
      (@list.nth_le.{u_1} α
         (@vector.to_list.{u_1} α (@list.length.{u_1} α l)
            (@subtype.mk.{u_1+1} (list.{u_1} α)
               (λ (l_1 : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
               l
               (@eq.refl.{1} nat (@list.length.{u_1} α l))))
         i
         h₁)
      (@list.nth_le.{u_1} α
         (@vector.to_list.{u_1} α (@list.length.{u_1} α l)
            (@subtype.mk.{u_1+1} (list.{u_1} α)
               (λ (l_1 : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
               l
               (@eq.refl.{1} nat (@list.length.{u_1} α l))))
         j
         h₂) →
    @eq.{1} nat i j'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
l : list.{u_1} α,
h :
  @function.injective.{1 u_1+1} (fin (@list.length.{u_1} α l)) α
    (@vector.nth.{u_1} α (@list.length.{u_1} α l)
       (@subtype.mk.{u_1+1} (list.{u_1} α)
          (λ (l_1 : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
          l
          (@eq.refl.{1} nat (@list.length.{u_1} α l)))),
i j : nat,
hi :
  @has_lt.lt.{0} nat nat.has_lt i
    (@list.length.{u_1} α
       (@vector.to_list.{u_1} α (@list.length.{u_1} α l)
          (@subtype.mk.{u_1+1} (list.{u_1} α)
             (λ (l_1 : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
             l
             (@eq.refl.{1} nat (@list.length.{u_1} α l))))),
hj :
  @has_lt.lt.{0} nat nat.has_lt j
    (@list.length.{u_1} α
       (@vector.to_list.{u_1} α (@list.length.{u_1} α l)
          (@subtype.mk.{u_1+1} (list.{u_1} α)
             (λ (l_1 : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
             l
             (@eq.refl.{1} nat (@list.length.{u_1} α l))))),
hij :
  @eq.{u_1+1} α
    (@list.nth_le.{u_1} α
       (@vector.to_list.{u_1} α (@list.length.{u_1} α l)
          (@subtype.mk.{u_1+1} (list.{u_1} α)
             (λ (l_1 : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
             l
             (@eq.refl.{1} nat (@list.length.{u_1} α l))))
       i
       hi)
    (@list.nth_le.{u_1} α
       (@vector.to_list.{u_1} α (@list.length.{u_1} α l)
          (@subtype.mk.{u_1+1} (list.{u_1} α)
             (λ (l_1 : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
             l
             (@eq.refl.{1} nat (@list.length.{u_1} α l))))
       j
       hj)
⊢ @eq.{1} nat i j'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 77      have := @h ⟨i, hi⟩ ⟨j, hj⟩, simp [nth_eq_nth_le] at *, tauto }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hi'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='vector.nth_eq_nth_le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 35, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/tauto.lean&#x27;, &#x27;line&#x27;: 229, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@function.injective.{1 u_1+1} (fin (@list.length.{u_1} α l)) α (@vector.nth.{u_1} α (@list.length.{u_1} α l) (@subtype.mk.{u_1+1} (list.{u_1} α) (λ (l_1 : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l)) l (@eq.refl.{1} nat (@list.length.{u_1} α l))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_lt.lt.{0} nat nat.has_lt i (@list.length.{u_1} α (@vector.to_list.{u_1} α (@list.length.{u_1} α l) (@subtype.mk.{u_1+1} (list.{u_1} α) (λ (l_1 : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l)) l (@eq.refl.{1} nat (@list.length.{u_1} α l)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_lt.lt.{0} nat nat.has_lt j (@list.length.{u_1} α (@vector.to_list.{u_1} α (@list.length.{u_1} α l) (@subtype.mk.{u_1+1} (list.{u_1} α) (λ (l_1 : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l)) l (@eq.refl.{1} nat (@list.length.{u_1} α l)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {n : nat} {α : Type ?l_1} (v : vector.{?l_1} α n) (i : fin n), @eq.{?l_1+1} α (@vector.nth.{?l_1} α n v i) (@list.nth_le.{?l_1} α (@vector.to_list.{?l_1} α n v) (@fin.val n i) (@eq.mpr.{0} (@has_lt.lt.{0} nat nat.has_lt (@fin.val n i) (@list.length.{?l_1} α (@vector.to_list.{?l_1} α n v))) (@has_lt.lt.{0} nat nat.has_lt (@fin.val n i) n) (@id.{0} (@eq.{1} Prop (@has_lt.lt.{0} nat nat.has_lt (@fin.val n i) (@list.length.{?l_1} α (@vector.to_list.{?l_1} α n v))) (@has_lt.lt.{0} nat nat.has_lt (@fin.val n i) n)) (@eq.rec.{0 1} nat (@list.length.{?l_1} α (@vector.to_list.{?l_1} α n v)) (λ (_a : nat), @eq.{1} Prop (@has_lt.lt.{0} nat nat.has_lt (@fin.val n i) (@list.length.{?l_1} α (@vector.to_list.{?l_1} α n v))) (@has_lt.lt.{0} nat nat.has_lt (@fin.val n i) _a)) (@eq.refl.{1} Prop (@has_lt.lt.{0} nat nat.has_lt (@fin.val n i) (@list.length.{?l_1} α (@vector.to_list.{?l_1} α n v)))) n (@vector.to_list_length.{?l_1} α n v))) (@fin.is_lt n i)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`tauto` breaks down assumptions of the form `_ ∧ _`, `_ ∨ _`, `_ ↔ _` and `∃ _, _`
and splits a goal of the form `_ ∧ _`, `_ ↔ _` or `∃ _, _` until it can be discharged
using `reflexivity` or `solve_by_elim`.
This is a finishing tactic: it either closes the goal of raises an error.
The variant `tauto!` uses the law of excluded middle.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='tauto'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
l : list.{u_1} α,
h :
  @function.injective.{1 u_1+1} (fin (@list.length.{u_1} α l)) α
    (@vector.nth.{u_1} α (@list.length.{u_1} α l)
       (@subtype.mk.{u_1+1} (list.{u_1} α)
          (λ (l_1 : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
          l
          (@eq.refl.{1} nat (@list.length.{u_1} α l)))),
i j : nat,
hi :
  @has_lt.lt.{0} nat nat.has_lt i
    (@list.length.{u_1} α
       (@vector.to_list.{u_1} α (@list.length.{u_1} α l)
          (@subtype.mk.{u_1+1} (list.{u_1} α)
             (λ (l_1 : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
             l
             (@eq.refl.{1} nat (@list.length.{u_1} α l))))),
hj :
  @has_lt.lt.{0} nat nat.has_lt j
    (@list.length.{u_1} α
       (@vector.to_list.{u_1} α (@list.length.{u_1} α l)
          (@subtype.mk.{u_1+1} (list.{u_1} α)
             (λ (l_1 : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
             l
             (@eq.refl.{1} nat (@list.length.{u_1} α l))))),
hij :
  @eq.{u_1+1} α
    (@list.nth_le.{u_1} α
       (@vector.to_list.{u_1} α (@list.length.{u_1} α l)
          (@subtype.mk.{u_1+1} (list.{u_1} α)
             (λ (l_1 : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
             l
             (@eq.refl.{1} nat (@list.length.{u_1} α l))))
       i
       hi)
    (@list.nth_le.{u_1} α
       (@vector.to_list.{u_1} α (@list.length.{u_1} α l)
          (@subtype.mk.{u_1+1} (list.{u_1} α)
             (λ (l_1 : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
             l
             (@eq.refl.{1} nat (@list.length.{u_1} α l))))
       j
       hj)
⊢ @eq.{1} nat i j'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
l : list.{u_1} α,
h :
  @function.injective.{1 u_1+1} (fin (@list.length.{u_1} α l)) α
    (@vector.nth.{u_1} α (@list.length.{u_1} α l)
       (@subtype.mk.{u_1+1} (list.{u_1} α)
          (λ (l_1 : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
          l
          (@eq.refl.{1} nat (@list.length.{u_1} α l)))),
i j : nat,
hi :
  @has_lt.lt.{0} nat nat.has_lt i
    (@list.length.{u_1} α
       (@vector.to_list.{u_1} α (@list.length.{u_1} α l)
          (@subtype.mk.{u_1+1} (list.{u_1} α)
             (λ (l_1 : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
             l
             (@eq.refl.{1} nat (@list.length.{u_1} α l))))),
hj :
  @has_lt.lt.{0} nat nat.has_lt j
    (@list.length.{u_1} α
       (@vector.to_list.{u_1} α (@list.length.{u_1} α l)
          (@subtype.mk.{u_1+1} (list.{u_1} α)
             (λ (l_1 : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
             l
             (@eq.refl.{1} nat (@list.length.{u_1} α l))))),
hij :
  @eq.{u_1+1} α
    (@list.nth_le.{u_1} α
       (@vector.to_list.{u_1} α (@list.length.{u_1} α l)
          (@subtype.mk.{u_1+1} (list.{u_1} α)
             (λ (l_1 : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
             l
             (@eq.refl.{1} nat (@list.length.{u_1} α l))))
       i
       hi)
    (@list.nth_le.{u_1} α
       (@vector.to_list.{u_1} α (@list.length.{u_1} α l)
          (@subtype.mk.{u_1+1} (list.{u_1} α)
             (λ (l_1 : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
             l
             (@eq.refl.{1} nat (@list.length.{u_1} α l))))
       j
       hj),
this :
  @eq.{u_1+1} α
    (@vector.nth.{u_1} α (@list.length.{u_1} α l)
       (@subtype.mk.{u_1+1} (list.{u_1} α)
          (λ (l_1 : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
          l
          (@eq.refl.{1} nat (@list.length.{u_1} α l)))
       (@fin.mk (@list.length.{u_1} α l) i hi))
    (@vector.nth.{u_1} α (@list.length.{u_1} α l)
       (@subtype.mk.{u_1+1} (list.{u_1} α)
          (λ (l_1 : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
          l
          (@eq.refl.{1} nat (@list.length.{u_1} α l)))
       (@fin.mk (@list.length.{u_1} α l) j hj)) →
  @eq.{1} (fin (@list.length.{u_1} α l)) (@fin.mk (@list.length.{u_1} α l) i hi)
    (@fin.mk (@list.length.{u_1} α l) j hj)
⊢ @eq.{1} nat i j'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
l : list.{u_1} α,
h :
  @function.injective.{1 u_1+1} (fin (@list.length.{u_1} α l)) α
    (@vector.nth.{u_1} α (@list.length.{u_1} α l)
       (@subtype.mk.{u_1+1} (list.{u_1} α)
          (λ (l_1 : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
          l
          (@eq.refl.{1} nat (@list.length.{u_1} α l)))),
i j : nat,
hi :
  @has_lt.lt.{0} nat nat.has_lt i
    (@list.length.{u_1} α
       (@vector.to_list.{u_1} α (@list.length.{u_1} α l)
          (@subtype.mk.{u_1+1} (list.{u_1} α)
             (λ (l_1 : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
             l
             (@eq.refl.{1} nat (@list.length.{u_1} α l))))),
hj :
  @has_lt.lt.{0} nat nat.has_lt j
    (@list.length.{u_1} α
       (@vector.to_list.{u_1} α (@list.length.{u_1} α l)
          (@subtype.mk.{u_1+1} (list.{u_1} α)
             (λ (l_1 : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
             l
             (@eq.refl.{1} nat (@list.length.{u_1} α l))))),
hij :
  @eq.{u_1+1} α
    (@list.nth_le.{u_1} α l i
       (@eq.rec.{0 u_1+1} (list.{u_1} α)
          (@vector.to_list.{u_1} α (@list.length.{u_1} α l)
             (@subtype.mk.{u_1+1} (list.{u_1} α)
                (λ (l_1 : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
                l
                (@eq.refl.{1} nat (@list.length.{u_1} α l))))
          (λ (l : list.{u_1} α), @has_lt.lt.{0} nat nat.has_lt i (@list.length.{u_1} α l))
          (@eq.rec.{0 1} nat i
             (λ (n : nat),
                @has_lt.lt.{0} nat nat.has_lt n
                  (@list.length.{u_1} α
                     (@vector.to_list.{u_1} α (@list.length.{u_1} α l)
                        (@subtype.mk.{u_1+1} (list.{u_1} α)
                           (λ (l_1 : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
                           l
                           (@eq.refl.{1} nat (@list.length.{u_1} α l))))))
             hi
             i
             (@eq.refl.{1} nat i))
          l
          (@vector.to_list_mk.{u_1} α (@list.length.{u_1} α l) l (@eq.refl.{1} nat (@list.length.{u_1} α l)))))
    (@list.nth_le.{u_1} α l j
       (@eq.rec.{0 u_1+1} (list.{u_1} α)
          (@vector.to_list.{u_1} α (@list.length.{u_1} α l)
             (@subtype.mk.{u_1+1} (list.{u_1} α)
                (λ (l_1 : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
                l
                (@eq.refl.{1} nat (@list.length.{u_1} α l))))
          (λ (l : list.{u_1} α), @has_lt.lt.{0} nat nat.has_lt j (@list.length.{u_1} α l))
          (@eq.rec.{0 1} nat j
             (λ (n : nat),
                @has_lt.lt.{0} nat nat.has_lt n
                  (@list.length.{u_1} α
                     (@vector.to_list.{u_1} α (@list.length.{u_1} α l)
                        (@subtype.mk.{u_1+1} (list.{u_1} α)
                           (λ (l_1 : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
                           l
                           (@eq.refl.{1} nat (@list.length.{u_1} α l))))))
             hj
             j
             (@eq.refl.{1} nat j))
          l
          (@vector.to_list_mk.{u_1} α (@list.length.{u_1} α l) l (@eq.refl.{1} nat (@list.length.{u_1} α l))))),
this :
  @eq.{u_1+1} α
    (@list.nth_le.{u_1} α l i
       (@eq.rec.{0 u_1+1} (list.{u_1} α)
          (@vector.to_list.{u_1} α (@list.length.{u_1} α l)
             (@subtype.mk.{u_1+1} (list.{u_1} α)
                (λ (l_1 : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
                l
                (@eq.refl.{1} nat (@list.length.{u_1} α l))))
          (λ (l : list.{u_1} α), @has_lt.lt.{0} nat nat.has_lt i (@list.length.{u_1} α l))
          (@eq.rec.{0 1} nat (@fin.val (@list.length.{u_1} α l) (@fin.mk (@list.length.{u_1} α l) i hi))
             (λ (n : nat),
                @has_lt.lt.{0} nat nat.has_lt n
                  (@list.length.{u_1} α
                     (@vector.to_list.{u_1} α (@list.length.{u_1} α l)
                        (@subtype.mk.{u_1+1} (list.{u_1} α)
                           (λ (l_1 : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
                           l
                           (@eq.refl.{1} nat (@list.length.{u_1} α l))))))
             (@eq.mpr.{0}
                (@has_lt.lt.{0} nat nat.has_lt
                   (@fin.val (@list.length.{u_1} α l) (@fin.mk (@list.length.{u_1} α l) i hi))
                   (@list.length.{u_1} α
                      (@vector.to_list.{u_1} α (@list.length.{u_1} α l)
                         (@subtype.mk.{u_1+1} (list.{u_1} α)
                            (λ (l_1 : list.{u_1} α),
                               @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
                            l
                            (@eq.refl.{1} nat (@list.length.{u_1} α l))))))
                (@has_lt.lt.{0} nat nat.has_lt
                   (@fin.val (@list.length.{u_1} α l) (@fin.mk (@list.length.{u_1} α l) i hi))
                   (@list.length.{u_1} α l))
                (@id.{0}
                   (@eq.{1} Prop
                      (@has_lt.lt.{0} nat nat.has_lt
                         (@fin.val (@list.length.{u_1} α l) (@fin.mk (@list.length.{u_1} α l) i hi))
                         (@list.length.{u_1} α
                            (@vector.to_list.{u_1} α (@list.length.{u_1} α l)
                               (@subtype.mk.{u_1+1} (list.{u_1} α)
                                  (λ (l_1 : list.{u_1} α),
                                     @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
                                  l
                                  (@eq.refl.{1} nat (@list.length.{u_1} α l))))))
                      (@has_lt.lt.{0} nat nat.has_lt
                         (@fin.val (@list.length.{u_1} α l) (@fin.mk (@list.length.{u_1} α l) i hi))
                         (@list.length.{u_1} α l)))
                   (@eq.rec.{0 1} nat
                      (@list.length.{u_1} α
                         (@vector.to_list.{u_1} α (@list.length.{u_1} α l)
                            (@subtype.mk.{u_1+1} (list.{u_1} α)
                               (λ (l_1 : list.{u_1} α),
                                  @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
                               l
                               (@eq.refl.{1} nat (@list.length.{u_1} α l)))))
                      (λ (_a : nat),
                         @eq.{1} Prop
                           (@has_lt.lt.{0} nat nat.has_lt
                              (@fin.val (@list.length.{u_1} α l) (@fin.mk (@list.length.{u_1} α l) i hi))
                              (@list.length.{u_1} α
                                 (@vector.to_list.{u_1} α (@list.length.{u_1} α l)
                                    (@subtype.mk.{u_1+1} (list.{u_1} α)
                                       (λ (l_1 : list.{u_1} α),
                                          @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
                                       l
                                       (@eq.refl.{1} nat (@list.length.{u_1} α l))))))
                           (@has_lt.lt.{0} nat nat.has_lt
                              (@fin.val (@list.length.{u_1} α l) (@fin.mk (@list.length.{u_1} α l) i hi))
                              _a))
                      (@eq.refl.{1} Prop
                         (@has_lt.lt.{0} nat nat.has_lt
                            (@fin.val (@list.length.{u_1} α l) (@fin.mk (@list.length.{u_1} α l) i hi))
                            (@list.length.{u_1} α
                               (@vector.to_list.{u_1} α (@list.length.{u_1} α l)
                                  (@subtype.mk.{u_1+1} (list.{u_1} α)
                                     (λ (l_1 : list.{u_1} α),
                                        @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
                                     l
                                     (@eq.refl.{1} nat (@list.length.{u_1} α l)))))))
                      (@list.length.{u_1} α l)
                      (@vector.to_list_length.{u_1} α (@list.length.{u_1} α l)
                         (@subtype.mk.{u_1+1} (list.{u_1} α)
                            (λ (l_1 : list.{u_1} α),
                               @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
                            l
                            (@eq.refl.{1} nat (@list.length.{u_1} α l))))))
                (@fin.is_lt (@list.length.{u_1} α l) (@fin.mk (@list.length.{u_1} α l) i hi)))
             i
             (@eq.refl.{1} nat i))
          l
          (@vector.to_list_mk.{u_1} α (@list.length.{u_1} α l) l (@eq.refl.{1} nat (@list.length.{u_1} α l)))))
    (@list.nth_le.{u_1} α l j
       (@eq.rec.{0 u_1+1} (list.{u_1} α)
          (@vector.to_list.{u_1} α (@list.length.{u_1} α l)
             (@subtype.mk.{u_1+1} (list.{u_1} α)
                (λ (l_1 : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
                l
                (@eq.refl.{1} nat (@list.length.{u_1} α l))))
          (λ (l : list.{u_1} α), @has_lt.lt.{0} nat nat.has_lt j (@list.length.{u_1} α l))
          (@eq.rec.{0 1} nat (@fin.val (@list.length.{u_1} α l) (@fin.mk (@list.length.{u_1} α l) j hj))
             (λ (n : nat),
                @has_lt.lt.{0} nat nat.has_lt n
                  (@list.length.{u_1} α
                     (@vector.to_list.{u_1} α (@list.length.{u_1} α l)
                        (@subtype.mk.{u_1+1} (list.{u_1} α)
                           (λ (l_1 : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
                           l
                           (@eq.refl.{1} nat (@list.length.{u_1} α l))))))
             (@eq.mpr.{0}
                (@has_lt.lt.{0} nat nat.has_lt
                   (@fin.val (@list.length.{u_1} α l) (@fin.mk (@list.length.{u_1} α l) j hj))
                   (@list.length.{u_1} α
                      (@vector.to_list.{u_1} α (@list.length.{u_1} α l)
                         (@subtype.mk.{u_1+1} (list.{u_1} α)
                            (λ (l_1 : list.{u_1} α),
                               @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
                            l
                            (@eq.refl.{1} nat (@list.length.{u_1} α l))))))
                (@has_lt.lt.{0} nat nat.has_lt
                   (@fin.val (@list.length.{u_1} α l) (@fin.mk (@list.length.{u_1} α l) j hj))
                   (@list.length.{u_1} α l))
                (@id.{0}
                   (@eq.{1} Prop
                      (@has_lt.lt.{0} nat nat.has_lt
                         (@fin.val (@list.length.{u_1} α l) (@fin.mk (@list.length.{u_1} α l) j hj))
                         (@list.length.{u_1} α
                            (@vector.to_list.{u_1} α (@list.length.{u_1} α l)
                               (@subtype.mk.{u_1+1} (list.{u_1} α)
                                  (λ (l_1 : list.{u_1} α),
                                     @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
                                  l
                                  (@eq.refl.{1} nat (@list.length.{u_1} α l))))))
                      (@has_lt.lt.{0} nat nat.has_lt
                         (@fin.val (@list.length.{u_1} α l) (@fin.mk (@list.length.{u_1} α l) j hj))
                         (@list.length.{u_1} α l)))
                   (@eq.rec.{0 1} nat
                      (@list.length.{u_1} α
                         (@vector.to_list.{u_1} α (@list.length.{u_1} α l)
                            (@subtype.mk.{u_1+1} (list.{u_1} α)
                               (λ (l_1 : list.{u_1} α),
                                  @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
                               l
                               (@eq.refl.{1} nat (@list.length.{u_1} α l)))))
                      (λ (_a : nat),
                         @eq.{1} Prop
                           (@has_lt.lt.{0} nat nat.has_lt
                              (@fin.val (@list.length.{u_1} α l) (@fin.mk (@list.length.{u_1} α l) j hj))
                              (@list.length.{u_1} α
                                 (@vector.to_list.{u_1} α (@list.length.{u_1} α l)
                                    (@subtype.mk.{u_1+1} (list.{u_1} α)
                                       (λ (l_1 : list.{u_1} α),
                                          @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
                                       l
                                       (@eq.refl.{1} nat (@list.length.{u_1} α l))))))
                           (@has_lt.lt.{0} nat nat.has_lt
                              (@fin.val (@list.length.{u_1} α l) (@fin.mk (@list.length.{u_1} α l) j hj))
                              _a))
                      (@eq.refl.{1} Prop
                         (@has_lt.lt.{0} nat nat.has_lt
                            (@fin.val (@list.length.{u_1} α l) (@fin.mk (@list.length.{u_1} α l) j hj))
                            (@list.length.{u_1} α
                               (@vector.to_list.{u_1} α (@list.length.{u_1} α l)
                                  (@subtype.mk.{u_1+1} (list.{u_1} α)
                                     (λ (l_1 : list.{u_1} α),
                                        @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
                                     l
                                     (@eq.refl.{1} nat (@list.length.{u_1} α l)))))))
                      (@list.length.{u_1} α l)
                      (@vector.to_list_length.{u_1} α (@list.length.{u_1} α l)
                         (@subtype.mk.{u_1+1} (list.{u_1} α)
                            (λ (l_1 : list.{u_1} α),
                               @eq.{1} nat (@list.length.{u_1} α l_1) (@list.length.{u_1} α l))
                            l
                            (@eq.refl.{1} nat (@list.length.{u_1} α l))))))
                (@fin.is_lt (@list.length.{u_1} α l) (@fin.mk (@list.length.{u_1} α l) j hj)))
             j
             (@eq.refl.{1} nat j))
          l
          (@vector.to_list_mk.{u_1} α (@list.length.{u_1} α l) l (@eq.refl.{1} nat (@list.length.{u_1} α l))))) →
  @eq.{1} nat i j
⊢ @eq.{1} nat i j'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 78  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 79  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 80  @[simp] lemma nth_mem (i : fin n) (v : vector α n) : v.nth i ∈ v.to_list :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='blue'><a title='fin'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='vector'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='vector.nth'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='vector.to_list'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/fin/basic.lean&#x27;, &#x27;line&#x27;: 9, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 14, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 54, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 52, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='green'><a title='nat → Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u → nat → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='vector.{u_1} α n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} {n : nat}, vector.{u_1} α n → fin n → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='fin n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u_1} [c : has_mem.{u_1 u_1} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='vector.{u_1} α n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} {n : nat}, vector.{u_1} α n → list.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 81  by rw [nth_eq_nth_le]; exact list.nth_le_mem _ _ _</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='vector.nth_eq_nth_le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='list.nth_le_mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 35, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/list/basic.lean&#x27;, &#x27;line&#x27;: 795, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {n : nat} {α : Type u_1} (v : vector.{u_1} α n) (i : fin n), @eq.{u_1+1} α (@vector.nth.{u_1} α n v i) (@list.nth_le.{u_1} α (@vector.to_list.{u_1} α n v) (@fin.val n i) (@eq.mpr.{0} (@has_lt.lt.{0} nat nat.has_lt (@fin.val n i) (@list.length.{u_1} α (@vector.to_list.{u_1} α n v))) (@has_lt.lt.{0} nat nat.has_lt (@fin.val n i) n) (@id.{0} (@eq.{1} Prop (@has_lt.lt.{0} nat nat.has_lt (@fin.val n i) (@list.length.{u_1} α (@vector.to_list.{u_1} α n v))) (@has_lt.lt.{0} nat nat.has_lt (@fin.val n i) n)) (@eq.rec.{0 1} nat (@list.length.{u_1} α (@vector.to_list.{u_1} α n v)) (λ (_a : nat), @eq.{1} Prop (@has_lt.lt.{0} nat nat.has_lt (@fin.val n i) (@list.length.{u_1} α (@vector.to_list.{u_1} α n v))) (@has_lt.lt.{0} nat nat.has_lt (@fin.val n i) _a)) (@eq.refl.{1} Prop (@has_lt.lt.{0} nat nat.has_lt (@fin.val n i) (@list.length.{u_1} α (@vector.to_list.{u_1} α n v)))) n (@vector.to_list_length.{u_1} α n v))) (@fin.is_lt n i)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} (l : list.{u_1} α) (n : nat) (h : @has_lt.lt.{0} nat nat.has_lt n (@list.length.{u_1} α l)), @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) (@list.nth_le.{u_1} α l n h) l'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='n : nat,
α : Type u_1,
i : fin n,
v : vector.{u_1} α n
⊢ @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) (@vector.nth.{u_1} α n v i)
    (@vector.to_list.{u_1} α n v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : nat,
α : Type u_1,
i : fin n,
v : vector.{u_1} α n
⊢ @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α)
    (@list.nth_le.{u_1} α (@vector.to_list.{u_1} α n v) (@fin.val n i)
       (@eq.mpr.{0}
          (@has_lt.lt.{0} nat nat.has_lt (@fin.val n i) (@list.length.{u_1} α (@vector.to_list.{u_1} α n v)))
          (@has_lt.lt.{0} nat nat.has_lt (@fin.val n i) n)
          (@id.{0}
             (@eq.{1} Prop
                (@has_lt.lt.{0} nat nat.has_lt (@fin.val n i) (@list.length.{u_1} α (@vector.to_list.{u_1} α n v)))
                (@has_lt.lt.{0} nat nat.has_lt (@fin.val n i) n))
             (@eq.rec.{0 1} nat (@list.length.{u_1} α (@vector.to_list.{u_1} α n v))
                (λ (_a : nat),
                   @eq.{1} Prop
                     (@has_lt.lt.{0} nat nat.has_lt (@fin.val n i)
                        (@list.length.{u_1} α (@vector.to_list.{u_1} α n v)))
                     (@has_lt.lt.{0} nat nat.has_lt (@fin.val n i) _a))
                (@eq.refl.{1} Prop
                   (@has_lt.lt.{0} nat nat.has_lt (@fin.val n i)
                      (@list.length.{u_1} α (@vector.to_list.{u_1} α n v))))
                n
                (@vector.to_list_length.{u_1} α n v)))
          (@fin.is_lt n i)))
    (@vector.to_list.{u_1} α n v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : nat,
α : Type u_1,
i : fin n,
v : vector.{u_1} α n
⊢ @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) (@vector.nth.{u_1} α n v i)
    (@vector.to_list.{u_1} α n v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 82  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : nat,
α : Type u_1,
i : fin n,
v : vector.{u_1} α n
⊢ @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) (@vector.nth.{u_1} α n v i)
    (@vector.to_list.{u_1} α n v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 83  theorem head&#x27;_to_list : ∀ (v : vector α n.succ),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='blue'><a title='head&#x27;_to_list'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='vector'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='nat.succ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 14, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 293, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='green'><a title='∀ (v : vector.{u_1} α (nat.succ n)), @eq.{u_1+1} (option.{u_1} α) (@list.head&#x27;.{u_1} α (@vector.to_list.{u_1} α (nat.succ n) v)) (@option.some.{u_1} α (@vector.head.{u_1} α n v))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type u_1 → nat → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 84    (to_list v).head&#x27; = some (head v)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='vector.to_list'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='list.head&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='option.some'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='vector.head'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 52, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/list/defs.lean&#x27;, &#x27;line&#x27;: 56, &#x27;column&#x27;: 12}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 34, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u_1} {n : nat}, vector.{u_1} α n → list.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='vector.{u_1} α (nat.succ n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1}, list.{u_1} α → option.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1}, α → option.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} {n : nat}, vector.{u_1} α (nat.succ n) → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='vector.{u_1} α (nat.succ n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 85  | ⟨a::l, e⟩ := rfl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='list.cons'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 286, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {T : Type u_1}, T → list.{u_1} T → list.{u_1} T'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='∀ {α : Type u_1} {a : α}, @eq.{u_1+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 86  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 87  def reverse (v : vector α n) : vector α n :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='vector'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='vector'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 14, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 14, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='Type u → nat → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type u → nat → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 88  ⟨v.to_list.reverse, by simp⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='vector.to_list'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='list.reverse'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 52, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/list/basic.lean&#x27;, &#x27;line&#x27;: 107, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='vector.{u_1} α n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} {n : nat}, vector.{u_1} α n → list.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1}, list.{u_1} α → list.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='lime'><a title='n : nat,
α : Type u_1,
v : vector.{u_1} α n
⊢ @eq.{1} nat (@list.length.{u_1} α (@list.reverse.{u_1} α (@vector.to_list.{u_1} α n v))) n'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 89  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 90  @[simp] theorem nth_zero : ∀ (v : vector α n.succ), nth v 0 = head v</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='blue'><a title='nth_zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='vector'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='nat.succ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='vector.nth'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='vector.head'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 14, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 293, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 54, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 34, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='green'><a title='∀ (v : vector.{u_1} α (nat.succ n)), @eq.{u_1+1} α (@vector.nth.{u_1} α (nat.succ n) v (@has_zero.zero.{0} (fin (nat.succ n)) (@fin.has_zero n))) (@vector.head.{u_1} α n v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type u_1 → nat → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u_1} {n : nat}, vector.{u_1} α n → fin n → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='vector.{u_1} α (nat.succ n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u_1}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} {n : nat}, vector.{u_1} α (nat.succ n) → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='vector.{u_1} α (nat.succ n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 91  | ⟨a::l, e⟩ := rfl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='list.cons'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 286, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {T : Type u_1}, T → list.{u_1} T → list.{u_1} T'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='∀ {α : Type u_1} {a : α}, @eq.{u_1+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 92  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 93  @[simp] theorem head_of_fn</code>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 94    {n : ℕ} (f : fin n.succ → α) : head (of_fn f) = f 0 :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='fin'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='nat.succ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='vector.head'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='vector.of_fn'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 293, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/fin/basic.lean&#x27;, &#x27;line&#x27;: 9, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 293, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 34, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 88, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='nat → Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u} {n : nat}, vector.{u} α (nat.succ n) → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} {n : nat}, (fin n → α) → vector.{u} α n'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='fin (nat.succ n) → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='fin (nat.succ n) → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 95  by rw [← nth_zero, nth_of_fn]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='vector.nth_zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='vector.nth_of_fn'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 90, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 43, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {n : nat} {α : Type u_1} (v : vector.{u_1} α (nat.succ n)), @eq.{u_1+1} α (@vector.nth.{u_1} α (nat.succ n) v (@has_zero.zero.{0} (fin (nat.succ n)) (@fin.has_zero n))) (@vector.head.{u_1} α n v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {n : nat} (f : fin n → α) (i : fin n), @eq.{u_1+1} α (@vector.nth.{u_1} α n (@vector.of_fn.{u_1} α n f) i) (f i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='α : Type u_1,
n : nat,
f : fin (nat.succ n) → α
⊢ @eq.{u_1+1} α (@vector.head.{u_1} α n (@vector.of_fn.{u_1} α (nat.succ n) f))
    (f (@has_zero.zero.{0} (fin (nat.succ n)) (@fin.has_zero n)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
n : nat,
f : fin (nat.succ n) → α
⊢ @eq.{u_1+1} α
    (@vector.nth.{u_1} α (nat.succ n) (@vector.of_fn.{u_1} α (nat.succ n) f)
       (@has_zero.zero.{0} (fin (nat.succ n)) (@fin.has_zero n)))
    (f (@has_zero.zero.{0} (fin (nat.succ n)) (@fin.has_zero n)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
n : nat,
f : fin (nat.succ n) → α
⊢ @eq.{u_1+1} α (@vector.head.{u_1} α n (@vector.of_fn.{u_1} α (nat.succ n) f))
    (f (@has_zero.zero.{0} (fin (nat.succ n)) (@fin.has_zero n)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 96  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
n : nat,
f : fin (nat.succ n) → α
⊢ @eq.{u_1+1} α (@vector.head.{u_1} α n (@vector.of_fn.{u_1} α (nat.succ n) f))
    (f (@has_zero.zero.{0} (fin (nat.succ n)) (@fin.has_zero n)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 97  @[simp] theorem nth_cons_zero</code>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 98    (a : α) (v : vector α n) : nth (a :: v) 0 = a :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='vector'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='vector.nth'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='vector.cons'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 14, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 54, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 25, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u → nat → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u} {n : nat}, vector.{u} α n → fin n → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} {n : nat}, α → vector.{u_1} α n → vector.{u_1} α (nat.succ n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='vector.{u_1} α n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u_1}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 99  by simp [nth_zero]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='vector.nth_zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 90, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {n : nat} {α : Type ?l_1} (v : vector.{?l_1} α (nat.succ n)), @eq.{?l_1+1} α (@vector.nth.{?l_1} α (nat.succ n) v (@has_zero.zero.{0} (fin (nat.succ n)) (@fin.has_zero n))) (@vector.head.{?l_1} α n v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='n : nat,
α : Type u_1,
a : α,
v : vector.{u_1} α n
⊢ @eq.{u_1+1} α
    (@vector.nth.{u_1} α (nat.succ n) (@vector.cons.{u_1} α n a v)
       (@has_zero.zero.{0} (fin (nat.succ n)) (@fin.has_zero n)))
    a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>100  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : nat,
α : Type u_1,
a : α,
v : vector.{u_1} α n
⊢ @eq.{u_1+1} α
    (@vector.nth.{u_1} α (nat.succ n) (@vector.cons.{u_1} α n a v)
       (@has_zero.zero.{0} (fin (nat.succ n)) (@fin.has_zero n)))
    a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>101  @[simp] theorem nth_cons_succ</code>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>102    (a : α) (v : vector α n) (i : fin n) : nth (a :: v) i.succ = nth v i :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='vector'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='fin'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='vector.nth'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='vector.cons'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='fin.succ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='vector.nth'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 14, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/fin/basic.lean&#x27;, &#x27;line&#x27;: 9, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 54, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 25, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/fin/ops.lean&#x27;, &#x27;line&#x27;: 13, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 54, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u → nat → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='nat → Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u} {n : nat}, vector.{u} α n → fin n → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} {n : nat}, α → vector.{u_1} α n → vector.{u_1} α (nat.succ n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='vector.{u_1} α n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='fin n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {n : nat}, fin n → fin (nat.succ n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} {n : nat}, vector.{u} α n → fin n → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='vector.{u_1} α n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='fin n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>103  by rw [← nth_tail, tail_cons]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='vector.nth_tail'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='vector.tail_cons'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 55, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 45, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {n : nat} {α : Type u_1} (v : vector.{u_1} α (nat.succ n)) (i : fin n), @eq.{u_1+1} α (@vector.nth.{u_1} α (@has_sub.sub.{0} nat nat.has_sub (nat.succ n) (@has_one.one.{0} nat nat.has_one)) (@vector.tail.{u_1} α (nat.succ n) v) i) (@vector.nth.{u_1} α (nat.succ n) v (@fin.succ n i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {n : nat} (a : α) (v : vector.{u_1} α n), @eq.{(max 1 (u_1+1))} (vector.{u_1} α (@has_sub.sub.{0} nat nat.has_sub (nat.succ n) (@has_one.one.{0} nat nat.has_one))) (@vector.tail.{u_1} α (nat.succ n) (@vector.cons.{u_1} α n a v)) v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='n : nat,
α : Type u_1,
a : α,
v : vector.{u_1} α n,
i : fin n
⊢ @eq.{u_1+1} α (@vector.nth.{u_1} α (nat.succ n) (@vector.cons.{u_1} α n a v) (@fin.succ n i))
    (@vector.nth.{u_1} α n v i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : nat,
α : Type u_1,
a : α,
v : vector.{u_1} α n,
i : fin n
⊢ @eq.{u_1+1} α
    (@vector.nth.{u_1} α (@has_sub.sub.{0} nat nat.has_sub (nat.succ n) (@has_one.one.{0} nat nat.has_one))
       (@vector.tail.{u_1} α (nat.succ n) (@vector.cons.{u_1} α n a v))
       i)
    (@vector.nth.{u_1} α n v i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : nat,
α : Type u_1,
a : α,
v : vector.{u_1} α n,
i : fin n
⊢ @eq.{u_1+1} α (@vector.nth.{u_1} α (nat.succ n) (@vector.cons.{u_1} α n a v) (@fin.succ n i))
    (@vector.nth.{u_1} α n v i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>104  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : nat,
α : Type u_1,
a : α,
v : vector.{u_1} α n,
i : fin n
⊢ @eq.{u_1+1} α (@vector.nth.{u_1} α (nat.succ n) (@vector.cons.{u_1} α n a v) (@fin.succ n i))
    (@vector.nth.{u_1} α n v i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>105  def m_of_fn {m} [monad m] {α : Type u} : ∀ {n}, (fin n → m α) → m (vector α n)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='monad'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='blue'><a title='m_of_fn'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='fin'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='vector'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/monad.lean&#x27;, &#x27;line&#x27;: 23, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/fin/basic.lean&#x27;, &#x27;line&#x27;: 9, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 14, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='(Type u → Type u_1) → Type (max (u+1) u_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='green'><a title='Π {n : nat}, (fin n → m α) → m (vector.{u} α n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='nat → Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='fin n → m α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type u → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u → nat → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>106  | 0     f := pure nil</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='has_pure.pure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='vector.nil'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/applicative.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 23, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='Π {f : Type u → Type v} [c : has_pure.{u v} f] {α : Type u}, α → f α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, vector.{u} α (@has_zero.zero.{0} nat nat.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>107  | (n+1) f := do a ← f 0, v ← m_of_fn (λi, f i.succ), pure (a :: v)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='m_of_fn'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='fin.succ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='has_pure.pure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='vector.cons'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/fin/ops.lean&#x27;, &#x27;line&#x27;: 13, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/applicative.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 25, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type} [c : has_add.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → m α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='vector.{u} α n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {n : nat}, (fin n → m α) → m (vector.{u} α n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='fin n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='fin n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {n : nat}, fin n → fin (nat.succ n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {f : Type u → Type u_1} [c : has_pure.{u u_1} f] {α : Type u}, α → f α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} {n : nat}, α → vector.{u} α n → vector.{u} α (nat.succ n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='vector.{u} α n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>108  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>109  theorem m_of_fn_pure {m} [monad m] [is_lawful_monad m] {α} :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='blue'><a title='monad'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='is_lawful_monad'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/monad.lean&#x27;, &#x27;line&#x27;: 23, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/lawful.lean&#x27;, &#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='green'><a title='(Type u_1 → Type u_2) → Type (max (u_1+1) u_2)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1 → Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (m : Type u_1 → Type u_2) [_inst_1 : monad.{u_1 u_2} m], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1 → Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>110    ∀ {n} (f : fin n → α), @m_of_fn m _ _ _ (λ i, pure (f i)) = pure (of_fn f)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='m_of_fn_pure'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='fin'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='vector.m_of_fn'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_pure.pure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_pure.pure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='vector.of_fn'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/fin/basic.lean&#x27;, &#x27;line&#x27;: 9, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;line&#x27;: 105, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/applicative.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/applicative.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 88, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {n : nat} (f : fin n → α), @eq.{u_2+1} (m (vector.{u_1} α n)) (@vector.m_of_fn.{u_1 u_2} m _inst_1 α n (λ (i : fin n), @has_pure.pure.{u_1 u_2} m (@applicative.to_has_pure.{u_1 u_2} m (@monad.to_applicative.{u_1 u_2} m _inst_1)) α (f i))) (@has_pure.pure.{u_1 u_2} m (@applicative.to_has_pure.{u_1 u_2} m (@monad.to_applicative.{u_1 u_2} m _inst_1)) (vector.{u_1} α n) (@vector.of_fn.{u_1} α n f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='nat → Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='fin n → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {m : Type u_1 → Type u_2} [_inst_1 : monad.{u_1 u_2} m] {α : Type u_1} {n : nat}, (fin n → m α) → m (vector.{u_1} α n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1 → Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='fin n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {f : Type u_1 → Type u_2} [c : has_pure.{u_1 u_2} f] {α : Type u_1}, α → f α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='fin n → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='fin n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u_2}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {f : Type u_1 → Type u_2} [c : has_pure.{u_1 u_2} f] {α : Type u_1}, α → f α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} {n : nat}, (fin n → α) → vector.{u_1} α n'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='fin n → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>111  | 0     f := rfl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='∀ {α : Type u_2} {a : α}, @eq.{u_2+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>112  | (n+1) f := by simp [m_of_fn, @m_of_fn_pure n, of_fn]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='vector.m_of_fn'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='m_of_fn_pure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='vector.of_fn'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 105, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 88, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type} [c : has_add.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {m : Type ?l_1 → Type ?l_2} [_inst_1 : monad.{?l_1 ?l_2} m] {α : Type ?l_1} {n : nat}, (fin n → m α) → m (vector.{?l_1} α n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {n : nat} (f : fin n → α), @eq.{u_2+1} (m (vector.{u_1} α n)) (@vector.m_of_fn.{u_1 u_2} m _inst_1 α n (λ (i : fin n), @has_pure.pure.{u_1 u_2} m (@applicative.to_has_pure.{u_1 u_2} m (@monad.to_applicative.{u_1 u_2} m _inst_1)) α (f i))) (@has_pure.pure.{u_1 u_2} m (@applicative.to_has_pure.{u_1 u_2} m (@monad.to_applicative.{u_1 u_2} m _inst_1)) (vector.{u_1} α n) (@vector.of_fn.{u_1} α n f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type ?l_1} {n : nat}, (fin n → α) → vector.{?l_1} α n'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='lime'><a title='m : Type u_1 → Type u_2,
_inst_1 : monad.{u_1 u_2} m,
_inst_2 : @is_lawful_monad.{u_1 u_2} m _inst_1,
α : Type u_1,
m_of_fn_pure :
  ∀ {n : nat} (f : fin n → α),
    @eq.{u_2+1} (m (vector.{u_1} α n))
      (@vector.m_of_fn.{u_1 u_2} m _inst_1 α n
         (λ (i : fin n),
            @has_pure.pure.{u_1 u_2} m
              (@applicative.to_has_pure.{u_1 u_2} m (@monad.to_applicative.{u_1 u_2} m _inst_1))
              α
              (f i)))
      (@has_pure.pure.{u_1 u_2} m (@applicative.to_has_pure.{u_1 u_2} m (@monad.to_applicative.{u_1 u_2} m _inst_1))
         (vector.{u_1} α n)
         (@vector.of_fn.{u_1} α n f)),
n : nat,
f : fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → α
⊢ @eq.{u_2+1} (m (vector.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))))
    (@vector.m_of_fn.{u_1 u_2} m _inst_1 α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
       (λ (i : fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))),
          @has_pure.pure.{u_1 u_2} m (@applicative.to_has_pure.{u_1 u_2} m (@monad.to_applicative.{u_1 u_2} m _inst_1))
            α
            (f i)))
    (@has_pure.pure.{u_1 u_2} m (@applicative.to_has_pure.{u_1 u_2} m (@monad.to_applicative.{u_1 u_2} m _inst_1))
       (vector.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
       (@vector.of_fn.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>113  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='m : Type u_1 → Type u_2,
_inst_1 : monad.{u_1 u_2} m,
_inst_2 : @is_lawful_monad.{u_1 u_2} m _inst_1,
α : Type u_1,
m_of_fn_pure :
  ∀ {n : nat} (f : fin n → α),
    @eq.{u_2+1} (m (vector.{u_1} α n))
      (@vector.m_of_fn.{u_1 u_2} m _inst_1 α n
         (λ (i : fin n),
            @has_pure.pure.{u_1 u_2} m
              (@applicative.to_has_pure.{u_1 u_2} m (@monad.to_applicative.{u_1 u_2} m _inst_1))
              α
              (f i)))
      (@has_pure.pure.{u_1 u_2} m (@applicative.to_has_pure.{u_1 u_2} m (@monad.to_applicative.{u_1 u_2} m _inst_1))
         (vector.{u_1} α n)
         (@vector.of_fn.{u_1} α n f)),
n : nat,
f : fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → α
⊢ @eq.{u_2+1} (m (vector.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))))
    (@vector.m_of_fn.{u_1 u_2} m _inst_1 α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
       (λ (i : fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))),
          @has_pure.pure.{u_1 u_2} m (@applicative.to_has_pure.{u_1 u_2} m (@monad.to_applicative.{u_1 u_2} m _inst_1))
            α
            (f i)))
    (@has_pure.pure.{u_1 u_2} m (@applicative.to_has_pure.{u_1 u_2} m (@monad.to_applicative.{u_1 u_2} m _inst_1))
       (vector.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
       (@vector.of_fn.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>114  def mmap {m} [monad m] {α} {β : Type u} (f : α → m β) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='monad'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/monad.lean&#x27;, &#x27;line&#x27;: 23, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='(Type u → Type u_1) → Type (max (u+1) u_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>115    ∀ {n}, vector α n → m (vector β n)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='mmap'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='vector'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='vector'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 14, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 14, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {n : nat}, vector.{u_2} α n → m (vector.{u} β n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u → nat → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u → nat → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>116  | _ ⟨[], rfl⟩   := pure nil</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='list.nil'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='has_pure.pure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='vector.nil'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 286, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/applicative.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 23, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {T : Type u_2}, list.{u_2} T'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type} {a : α}, @eq.{1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π {f : Type u → Type v} [c : has_pure.{u v} f] {α : Type u}, α → f α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, vector.{u} α (@has_zero.zero.{0} nat nat.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>117  | _ ⟨a::l, rfl⟩ := do h&#x27; ← f a, t&#x27; ← mmap ⟨l, rfl⟩, pure (h&#x27; :: t&#x27;)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='list.cons'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='h&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='t&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='mmap'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='has_pure.pure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='h&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='vector.cons'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='t&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 286, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/applicative.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 25, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {T : Type u_2}, T → list.{u_2} T → list.{u_2} T'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='list.{u_2} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type} {a : α}, @eq.{1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='α → m β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='vector.{u} β (@list.length.{u_2} α l)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {n : nat}, vector.{u_2} α n → m (vector.{u} β n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='∀ {α : Sort u} {a : α}, @eq.{u} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {f : Type u → Type u_1} [c : has_pure.{u u_1} f] {α : Type u}, α → f α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} {n : nat}, α → vector.{u} α n → vector.{u} α (nat.succ n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='vector.{u} β (@list.length.{u_2} α l)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>118  using_well_founded wf_tacs</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='blue'><a title='wf_tacs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/well_founded_tactics.lean&#x27;, &#x27;line&#x27;: 44, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='green'><a title='well_founded_tactics'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='The default `well_founded_tactics` provided in core are broken in some situations, often indicated
by the message
```lean
The nested exception contains the failure state for the decreasing tactic.
nested exception message:
tactic failed, there are no goals to be solved
state:
no goals
```

Use this replacement by adding
```lean
using_well_founded wf_tacs
```
at the end of your inductive definition.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>119  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>120  @[simp] theorem mmap_nil {m} [monad m] {α β} (f : α → m β) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='blue'><a title='monad'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/monad.lean&#x27;, &#x27;line&#x27;: 23, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='green'><a title='(Type u_1 → Type u_2) → Type (max (u_1+1) u_2)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1 → Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='Type u_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u_1 → Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>121    mmap f nil = pure nil := rfl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='vector.mmap'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='vector.nil'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_pure.pure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='vector.nil'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 114, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 23, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/applicative.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 23, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {m : Type u → Type u_1} [_inst_1 : monad.{u u_1} m] {α : Type u_2} {β : Type u}, (α → m β) → Π {n : nat}, vector.{u_2} α n → m (vector.{u} β n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → m β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, vector.{u} α (@has_zero.zero.{0} nat nat.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_2}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {f : Type u → Type v} [c : has_pure.{u v} f] {α : Type u}, α → f α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, vector.{u} α (@has_zero.zero.{0} nat nat.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Type u_2} {a : α}, @eq.{u_2+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>122  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>123  @[simp] theorem mmap_cons {m} [monad m] {α β} (f : α → m β) (a) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='blue'><a title='monad'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/monad.lean&#x27;, &#x27;line&#x27;: 23, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='green'><a title='(Type u_1 → Type u_2) → Type (max (u_1+1) u_2)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1 → Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='Type u_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u_1 → Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>124    ∀ {n} (v : vector α n), mmap f (a::v) =</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='mmap_cons'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='vector'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='vector.mmap'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='vector.cons'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 14, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;line&#x27;: 114, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 25, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {n : nat} (v : vector.{u_3} α n), @eq.{u_2+1} (m (vector.{u_1} β (nat.succ n))) (@vector.mmap.{u_1 u_2 u_3} m _inst_1 α β f (nat.succ n) (@vector.cons.{u_3} α n a v)) (@has_bind.bind.{u_1 u_2} m (@monad.to_has_bind.{u_1 u_2} m _inst_1) β (vector.{u_1} β (nat.succ n)) (f a) (λ (h&#x27; : β), @has_bind.bind.{u_1 u_2} m (@monad.to_has_bind.{u_1 u_2} m _inst_1) (vector.{u_1} β n) (vector.{u_1} β (nat.succ n)) (@vector.mmap.{u_1 u_2 u_3} m _inst_1 α β f n v) (λ (t&#x27; : vector.{u_1} β n), @has_pure.pure.{u_1 u_2} m (@applicative.to_has_pure.{u_1 u_2} m (@monad.to_applicative.{u_1 u_2} m _inst_1)) (vector.{u_1} β (nat.succ n)) (@vector.cons.{u_1} β n h&#x27; t&#x27;))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u_3 → nat → Type u_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {m : Type u_1 → Type u_2} [_inst_1 : monad.{u_1 u_2} m] {α : Type u_3} {β : Type u_1}, (α → m β) → Π {n : nat}, vector.{u_3} α n → m (vector.{u_1} β n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → m β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_3} {n : nat}, α → vector.{u_3} α n → vector.{u_3} α (nat.succ n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='vector.{u_3} α n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_2}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>125    do h&#x27; ← f a, t&#x27; ← mmap f v, pure (h&#x27; :: t&#x27;)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='h&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='t&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='vector.mmap'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_pure.pure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='h&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='vector.cons'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='t&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='red'><a title='{&#x27;line&#x27;: 114, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/applicative.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 25, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='α → m β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='vector.{u_1} β n'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {m : Type u_1 → Type u_2} [_inst_1 : monad.{u_1 u_2} m] {α : Type u_3} {β : Type u_1}, (α → m β) → Π {n : nat}, vector.{u_3} α n → m (vector.{u_1} β n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → m β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='vector.{u_3} α n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {f : Type u_1 → Type u_2} [c : has_pure.{u_1 u_2} f] {α : Type u_1}, α → f α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} {n : nat}, α → vector.{u_1} α n → vector.{u_1} α (nat.succ n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='vector.{u_1} β n'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>126  | _ ⟨l, rfl⟩ := rfl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='∀ {α : Type} {a : α}, @eq.{1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='∀ {α : Type u_2} {a : α}, @eq.{u_2+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>127  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>128  @[ext] theorem ext : ∀ {v w : vector α n}</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='blue'><a title='ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='vector'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 14, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='green'><a title='∀ {v w : vector.{u_1} α n}, (∀ (m : fin n), @eq.{u_1+1} α (@vector.nth.{u_1} α n v m) (@vector.nth.{u_1} α n w m)) → @eq.{(max 1 (u_1+1))} (vector.{u_1} α n) v w'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Type u_1 → nat → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='lemmas usable by `ext` tactic'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>129    (h : ∀ m : fin n, vector.nth v m = vector.nth w m), v = w</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='fin'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='vector.nth'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='vector.nth'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='w'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='w'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/fin/basic.lean&#x27;, &#x27;line&#x27;: 9, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 54, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 54, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='∀ (m : fin n), @eq.{u_1+1} α (@vector.nth.{u_1} α n v m) (@vector.nth.{u_1} α n w m)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='nat → Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} {n : nat}, vector.{u_1} α n → fin n → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='vector.{u_1} α n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='fin n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} {n : nat}, vector.{u_1} α n → fin n → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='vector.{u_1} α n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='fin n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='vector.{u_1} α n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='vector.{u_1} α n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>130  | ⟨v, hv⟩ ⟨w, hw⟩ h := subtype.eq (list.ext_le (by rw [hv, hw])</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='hv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='hw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='subtype.eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='list.ext_le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='hv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/subtype/basic.lean&#x27;, &#x27;line&#x27;: 22, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/list/basic.lean&#x27;, &#x27;line&#x27;: 884, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@eq.{1} nat (@list.length.{u_1} α v) n'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@eq.{1} nat (@list.length.{u_1} α w) n'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ (m : fin n), @eq.{u_1+1} α (@vector.nth.{u_1} α n (@subtype.mk.{u_1+1} (list.{u_1} α) (λ (l : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l) n) v hv) m) (@vector.nth.{u_1} α n (@subtype.mk.{u_1+1} (list.{u_1} α) (λ (l : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l) n) w hw) m)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Type u_1} {p : α → Prop} {a1 a2 : @subtype.{u_1+1} α (λ (x : α), p x)}, @eq.{u_1+1} α (@subtype.val.{u_1+1} α (λ (x : α), p x) a1) (@subtype.val.{u_1+1} α (λ (x : α), p x) a2) → @eq.{(max 1 (u_1+1))} (@subtype.{u_1+1} α (λ (x : α), p x)) a1 a2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u_1} {l₁ l₂ : list.{u_1} α}, @eq.{1} nat (@list.length.{u_1} α l₁) (@list.length.{u_1} α l₂) → (∀ (n : nat) (h₁ : @has_lt.lt.{0} nat nat.has_lt n (@list.length.{u_1} α l₁)) (h₂ : @has_lt.lt.{0} nat nat.has_lt n (@list.length.{u_1} α l₂)), @eq.{u_1+1} α (@list.nth_le.{u_1} α l₁ n h₁) (@list.nth_le.{u_1} α l₂ n h₂)) → @eq.{u_1+1} (list.{u_1} α) l₁ l₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{1} nat (@list.length.{u_1} α v) n'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{1} nat (@list.length.{u_1} α w) n'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                  </code><font color='lime'><a title='n : nat,
α : Type u_1,
ext :
  ∀ {v w : vector.{u_1} α n},
    (∀ (m : fin n), @eq.{u_1+1} α (@vector.nth.{u_1} α n v m) (@vector.nth.{u_1} α n w m)) →
    @eq.{(max 1 (u_1+1))} (vector.{u_1} α n) v w,
v : list.{u_1} α,
hv : @eq.{1} nat (@list.length.{u_1} α v) n,
w : list.{u_1} α,
hw : @eq.{1} nat (@list.length.{u_1} α w) n,
h :
  ∀ (m : fin n),
    @eq.{u_1+1} α
      (@vector.nth.{u_1} α n
         (@subtype.mk.{u_1+1} (list.{u_1} α) (λ (l : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l) n) v hv)
         m)
      (@vector.nth.{u_1} α n
         (@subtype.mk.{u_1+1} (list.{u_1} α) (λ (l : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l) n) w hw)
         m)
⊢ @eq.{1} nat
    (@list.length.{u_1} α
       (@subtype.val.{u_1+1} (list.{u_1} α) (λ (x : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α x) n)
          (@subtype.mk.{u_1+1} (list.{u_1} α) (λ (l : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l) n) v hv)))
    (@list.length.{u_1} α
       (@subtype.val.{u_1+1} (list.{u_1} α) (λ (x : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α x) n)
          (@subtype.mk.{u_1+1} (list.{u_1} α) (λ (l : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l) n) w hw)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : nat,
α : Type u_1,
ext :
  ∀ {v w : vector.{u_1} α n},
    (∀ (m : fin n), @eq.{u_1+1} α (@vector.nth.{u_1} α n v m) (@vector.nth.{u_1} α n w m)) →
    @eq.{(max 1 (u_1+1))} (vector.{u_1} α n) v w,
v : list.{u_1} α,
hv : @eq.{1} nat (@list.length.{u_1} α v) n,
w : list.{u_1} α,
hw : @eq.{1} nat (@list.length.{u_1} α w) n,
h :
  ∀ (m : fin n),
    @eq.{u_1+1} α
      (@vector.nth.{u_1} α n
         (@subtype.mk.{u_1+1} (list.{u_1} α) (λ (l : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l) n) v hv)
         m)
      (@vector.nth.{u_1} α n
         (@subtype.mk.{u_1+1} (list.{u_1} α) (λ (l : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l) n) w hw)
         m)
⊢ @eq.{1} nat n
    (@list.length.{u_1} α
       (@subtype.val.{u_1+1} (list.{u_1} α) (λ (x : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α x) n)
          (@subtype.mk.{u_1+1} (list.{u_1} α) (λ (l : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l) n) w hw)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>131    (λ m hm hn, h ⟨m, hv ▸ hm⟩))</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hn'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='eq.subst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 190, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_lt.lt.{0} nat nat.has_lt m (@list.length.{u_1} α (@subtype.val.{u_1+1} (list.{u_1} α) (λ (x : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α x) n) (@subtype.mk.{u_1+1} . (list.{u_1} α) . (λ (l : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l) n) v hv)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_lt.lt.{0} nat nat.has_lt m (@list.length.{u_1} α (@subtype.val.{u_1+1} (list.{u_1} α) (λ (x : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α x) n) (@subtype.mk.{u_1+1} . (list.{u_1} α) . (λ (l : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l) n) w hw)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='∀ {α : Type} {P : α → Prop} {a b : α}, @eq.{1} α a b → P a → P b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_lt.lt.{0} nat nat.has_lt m (@list.length.{u_1} α (@subtype.val.{u_1+1} (list.{u_1} α) (λ (x : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α x) n) (@subtype.mk.{u_1+1} . (list.{u_1} α) . (λ (l : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l) n) v hv)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>132  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>133  instance zero_subsingleton : subsingleton (vector α 0) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='blue'><a title='subsingleton'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='vector'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 804, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 14, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='green'><a title='Sort u → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u → nat → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>134  ⟨λ _ _, vector.ext (λ m, fin.elim0 m)⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='vector.ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='fin.elim0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;line&#x27;: 128, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/fin/basic.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='vector.{u_1} α (@has_zero.zero.{0} nat nat.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='vector.{u_1} α (@has_zero.zero.{0} nat nat.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {n : nat} {α : Type u_1} {v w : vector.{u_1} α n}, (∀ (m : fin n), @eq.{u_1+1} α (@vector.nth.{u_1} α n v m) (@vector.nth.{u_1} α n w m)) → @eq.{(max 1 (u_1+1))} (vector.{u_1} α n) v w'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='fin (@has_zero.zero.{0} nat nat.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Sort u}, fin (@has_zero.zero.{0} nat nat.has_zero) → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='fin (@has_zero.zero.{0} nat nat.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>135  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>136  def to_array : vector α n → array n α</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='vector'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='to_array'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='array'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 14, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/array/basic.lean&#x27;, &#x27;line&#x27;: 134, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='Type u → nat → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='vector.{u_1} α n → array.{u_1} n α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat → Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>137  | ⟨xs, h⟩ := cast (by rw h) xs.to_array</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='xs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='cast'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='list.to_array'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 88, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/list/defs.lean&#x27;, &#x27;line&#x27;: 61, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='list.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {α β : Sort u}, @eq.{u+1} (Sort u) α β → α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{1} nat (@list.length.{u_1} α xs) n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u_1} (l : list.{u_1} α), array.{u_1} (@list.length.{u_1} α l) α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='Convert a list into an array (whose length is the length of `l`).'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='lime'><a title='n : nat,
α : Type u_1,
to_array : vector.{u_1} α n → array.{u_1} n α,
xs : list.{u_1} α,
h : @eq.{1} nat (@list.length.{u_1} α xs) n
⊢ @eq.{u_1+2} (Type u_1) (array.{u_1} (@list.length.{u_1} α xs) α) (array.{u_1} n α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>138  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>139  section insert_nth</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>140  variable {a : α}</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>141  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>142  def insert_nth (a : α) (i : fin (n+1)) (v : vector α n) : vector α (n+1) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='fin'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='vector'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='vector'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/fin/basic.lean&#x27;, &#x27;line&#x27;: 9, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 14, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 14, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='nat → Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} [c : has_add.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Type u → nat → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type u → nat → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} [c : has_add.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>143  ⟨v.1.insert_nth i.1 a,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='subtype.val'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='list.insert_nth'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='fin.val'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/list/defs.lean&#x27;, &#x27;line&#x27;: 86, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/fin/basic.lean&#x27;, &#x27;line&#x27;: 9, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='vector.{u_1} α n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} {p : α → Prop}, @subtype.{u_1+1} α p → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1}, nat → α → list.{u_1} α → list.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {n : nat}, fin n → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>144    begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='n : nat,
α : Type u_1,
a : α,
i : fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)),
v : vector.{u_1} α n
⊢ @eq.{1} nat
    (@list.length.{u_1} α
       (@list.insert_nth.{u_1} α (@fin.val (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) i) a
          (@subtype.val.{u_1+1} (list.{u_1} α) (λ (l : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l) n) v)))
    (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>145      rw [list.length_insert_nth, v.2],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='list.length_insert_nth'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/list/basic.lean&#x27;, &#x27;line&#x27;: 1040, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {a : α} (n : nat) (as : list.{u_1} α), @has_le.le.{0} nat nat.has_le n (@list.length.{u_1} α as) → @eq.{1} nat (@list.length.{u_1} α (@list.insert_nth.{u_1} α n a as)) (@has_add.add.{0} nat nat.has_add (@list.length.{u_1} α as) (@has_one.one.{0} nat nat.has_one))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='vector.{u_1} α n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : nat,
α : Type u_1,
a : α,
i : fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)),
v : vector.{u_1} α n
⊢ @eq.{1} nat
    (@list.length.{u_1} α
       (@list.insert_nth.{u_1} α (@fin.val (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) i) a
          (@subtype.val.{u_1+1} (list.{u_1} α) (λ (l : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l) n) v)))
    (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
n : nat,
α : Type u_1,
a : α,
i : fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)),
v : vector.{u_1} α n
⊢ @eq.{1} nat
    (@has_add.add.{0} nat nat.has_add
       (@list.length.{u_1} α
          (@subtype.val.{u_1+1} (list.{u_1} α) (λ (l : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l) n) v))
       (@has_one.one.{0} nat nat.has_one))
    (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))

n : nat,
α : Type u_1,
a : α,
i : fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)),
v : vector.{u_1} α n
⊢ @has_le.le.{0} nat nat.has_le (@fin.val (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) i)
    (@list.length.{u_1} α
       (@subtype.val.{u_1+1} (list.{u_1} α) (λ (l : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l) n) v))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : nat,
α : Type u_1,
a : α,
i : fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)),
v : vector.{u_1} α n
⊢ @has_le.le.{0} nat nat.has_le (@fin.val (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) i)
    (@list.length.{u_1} α
       (@subtype.val.{u_1+1} (list.{u_1} α) (λ (l : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l) n) v))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>146      rw [v.2, ← nat.succ_le_succ_iff],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='nat.succ_le_succ_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/nat/basic.lean&#x27;, &#x27;line&#x27;: 38, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='vector.{u_1} α n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {m n : nat}, iff (@has_le.le.{0} nat nat.has_le (nat.succ m) (nat.succ n)) (@has_le.le.{0} nat nat.has_le m n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : nat,
α : Type u_1,
a : α,
i : fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)),
v : vector.{u_1} α n
⊢ @has_le.le.{0} nat nat.has_le (@fin.val (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) i)
    (@list.length.{u_1} α
       (@subtype.val.{u_1+1} (list.{u_1} α) (λ (l : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l) n) v))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : nat,
α : Type u_1,
a : α,
i : fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)),
v : vector.{u_1} α n
⊢ @has_le.le.{0} nat nat.has_le (@fin.val (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) i) n'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : nat,
α : Type u_1,
a : α,
i : fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)),
v : vector.{u_1} α n
⊢ @has_le.le.{0} nat nat.has_le
    (nat.succ (@fin.val (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) i))
    (nat.succ n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>147      exact i.2</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : nat,
α : Type u_1,
a : α,
i : fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)),
v : vector.{u_1} α n
⊢ @has_le.le.{0} nat nat.has_le
    (nat.succ (@fin.val (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) i))
    (nat.succ n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>148    end⟩</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : nat,
α : Type u_1,
a : α,
i : fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)),
v : vector.{u_1} α n
⊢ @has_le.le.{0} nat nat.has_le
    (nat.succ (@fin.val (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) i))
    (nat.succ n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>149  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>150  lemma insert_nth_val {i : fin (n+1)} {v : vector α n} :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='blue'><a title='fin'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='vector'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/fin/basic.lean&#x27;, &#x27;line&#x27;: 9, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 14, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='green'><a title='nat → Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} [c : has_add.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Type u → nat → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>151    (v.insert_nth a i).val = v.val.insert_nth i.1 a :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='vector.insert_nth'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='subtype.val'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='subtype.val'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='list.insert_nth'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='fin.val'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 142, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/list/defs.lean&#x27;, &#x27;line&#x27;: 86, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/fin/basic.lean&#x27;, &#x27;line&#x27;: 9, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='vector.{u_1} α n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {n : nat} {α : Type u_1}, α → fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → vector.{u_1} α n → vector.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} {p : α → Prop}, @subtype.{u_1+1} α p → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='vector.{u_1} α n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} {p : α → Prop}, @subtype.{u_1+1} α p → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1}, nat → α → list.{u_1} α → list.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {n : nat}, fin n → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>152  rfl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {a : α}, @eq.{u_1+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>153  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>154  @[simp] lemma remove_nth_val {i : fin n} :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='blue'><a title='fin'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/fin/basic.lean&#x27;, &#x27;line&#x27;: 9, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='green'><a title='nat → Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>155    ∀{v : vector α n}, (remove_nth i v).val = v.val.remove_nth i.1</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='remove_nth_val'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='vector'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='vector.remove_nth'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='subtype.val'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='subtype.val'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='list.remove_nth'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='fin.val'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 14, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 85, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/list/basic.lean&#x27;, &#x27;line&#x27;: 161, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/fin/basic.lean&#x27;, &#x27;line&#x27;: 9, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {v : vector.{u_1} α n}, @eq.{u_1+1} (list.{u_1} α) (@subtype.val.{u_1+1} (list.{u_1} α) (λ (l : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l) (@has_sub.sub.{0} nat nat.has_sub n (@has_one.one.{0} nat nat.has_one))) (@vector.remove_nth.{u_1} α n i v)) (@list.remove_nth.{u_1} α (@subtype.val.{u_1+1} (list.{u_1} α) (λ (l : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l) n) v) (@fin.val n i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type u_1 → nat → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u_1} {n : nat}, fin n → vector.{u_1} α n → vector.{u_1} α (@has_sub.sub.{0} nat nat.has_sub n (@has_one.one.{0} nat nat.has_one))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='fin n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='vector.{u_1} α n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} {p : α → Prop}, @subtype.{u_1+1} α p → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='vector.{u_1} α n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} {p : α → Prop}, @subtype.{u_1+1} α p → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1}, list.{u_1} α → nat → list.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='fin n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {n : nat}, fin n → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>156  | ⟨l, hl⟩ := rfl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='∀ {α : Type u_1} {a : α}, @eq.{u_1+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>157  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>158  lemma remove_nth_insert_nth {v : vector α n} {i : fin (n+1)} : remove_nth i (insert_nth a i v) = v :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='blue'><a title='vector'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='fin'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='vector.remove_nth'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='vector.insert_nth'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 14, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/fin/basic.lean&#x27;, &#x27;line&#x27;: 9, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 85, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 142, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='green'><a title='Type u → nat → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='nat → Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} [c : has_add.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Π {α : Type u} {n : nat}, fin n → vector.{u} α n → vector.{u} α (@has_sub.sub.{0} nat nat.has_sub n (@has_one.one.{0} nat nat.has_one))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {n : nat} {α : Type u_1}, α → fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → vector.{u_1} α n → vector.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='vector.{u_1} α n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='vector.{u_1} α n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>159  subtype.eq $ list.remove_nth_insert_nth i.1 v.1</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='subtype.eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='list.remove_nth_insert_nth'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='fin.val'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='subtype.val'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/subtype/basic.lean&#x27;, &#x27;line&#x27;: 22, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/list/basic.lean&#x27;, &#x27;line&#x27;: 1045, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/fin/basic.lean&#x27;, &#x27;line&#x27;: 9, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {p : α → Prop} {a1 a2 : @subtype.{u_1+1} α (λ (x : α), p x)}, @eq.{u_1+1} α (@subtype.val.{u_1+1} α (λ (x : α), p x) a1) (@subtype.val.{u_1+1} α (λ (x : α), p x) a2) → @eq.{(max 1 (u_1+1))} (@subtype.{u_1+1} α (λ (x : α), p x)) a1 a2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {α : Type u_1} {a : α} (n : nat) (l : list.{u_1} α), @eq.{u_1+1} (list.{u_1} α) (@list.remove_nth.{u_1} α (@list.insert_nth.{u_1} α n a l) n) l'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {n : nat}, fin n → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='vector.{u_1} α n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} {p : α → Prop}, @subtype.{u_1+1} α p → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>160  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>161  lemma remove_nth_insert_nth_ne {v : vector α (n+1)} :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='blue'><a title='vector'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 14, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='green'><a title='Type u → nat → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} [c : has_add.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>162    ∀{i j : fin (n+2)} (h : i ≠ j),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='remove_nth_insert_nth_ne'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='fin'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ne'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/fin/basic.lean&#x27;, &#x27;line&#x27;: 9, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 97, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {i j : fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))} (h : @ne.{1} (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))) i j), @eq.{(max 1 (u_1+1))} (vector.{u_1} α (@has_sub.sub.{0} nat nat.has_sub (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) (@has_one.one.{0} nat nat.has_one))) (@vector.remove_nth.{u_1} α (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) i (@vector.insert_nth.{u_1} (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) α a j v)) (@vector.insert_nth.{u_1} n α a (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) i j (@ne.symm.{1} (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))) i j h)) (@vector.remove_nth.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) j i h) v))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='nat → Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} [c : has_add.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>163      remove_nth i (insert_nth a j v) = insert_nth a (i.pred_above j h.symm) (remove_nth (j.pred_above i h) v)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='vector.remove_nth'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='vector.insert_nth'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='vector.insert_nth'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='fin.pred_above'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='ne.symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='vector.remove_nth'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='fin.pred_above'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 85, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 142, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 142, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/fin.lean&#x27;, &#x27;line&#x27;: 122, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 112, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 85, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/fin.lean&#x27;, &#x27;line&#x27;: 122, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u_1} {n : nat}, fin n → vector.{u_1} α n → vector.{u_1} α (@has_sub.sub.{0} nat nat.has_sub n (@has_one.one.{0} nat nat.has_one))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {n : nat} {α : Type u_1}, α → fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → vector.{u_1} α n → vector.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='vector.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {n : nat} {α : Type u_1}, α → fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → vector.{u_1} α n → vector.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {n : nat} (p i : fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))), @ne.{1} (fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) i p → fin n'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@ne.{1} (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))) i j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} {a b : α}, @ne.{1} α a b → @ne.{1} α b a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u_1} {n : nat}, fin n → vector.{u_1} α n → vector.{u_1} α (@has_sub.sub.{0} nat nat.has_sub n (@has_one.one.{0} nat nat.has_one))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {n : nat} (p i : fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))), @ne.{1} (fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) i p → fin n'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@ne.{1} (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))) i j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='vector.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                     </code><font color='orange'><a title='`pred_above p i h` embeds `i : fin (n+1)` into `fin n` by ignoring `p`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='orange'><a title='`pred_above p i h` embeds `i : fin (n+1)` into `fin n` by ignoring `p`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>164  | ⟨i, hi⟩ ⟨j, hj⟩ ne :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>165    begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='n : nat,
α : Type u_1,
a : α,
v : vector.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)),
remove_nth_insert_nth_ne :
  ∀ {i j : fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))}
  (h :
    @_root_.ne.{1}
      (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
      i
      j),
    @eq.{(max 1 (u_1+1))}
      (vector.{u_1} α
         (@has_sub.sub.{0} nat nat.has_sub
            (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
            (@has_one.one.{0} nat nat.has_one)))
      (@vector.remove_nth.{u_1} α
         (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
         i
         (@vector.insert_nth.{u_1} (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) α a j v))
      (@vector.insert_nth.{u_1} n α a
         (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) i j
            (@_root_.ne.symm.{1}
               (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
               i
               j
               h))
         (@vector.remove_nth.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
            (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) j i h)
            v)),
i : nat,
hi :
  @has_lt.lt.{0} nat nat.has_lt i
    (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))),
j : nat,
hj :
  @has_lt.lt.{0} nat nat.has_lt j
    (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))),
ne :
  @_root_.ne.{1}
    (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) i hi)
    (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) j hj)
⊢ @eq.{(max 1 (u_1+1))}
    (vector.{u_1} α
       (@has_sub.sub.{0} nat nat.has_sub
          (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
          (@has_one.one.{0} nat nat.has_one)))
    (@vector.remove_nth.{u_1} α
       (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
       (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) i
          hi)
       (@vector.insert_nth.{u_1} (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) α a
          (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) j
             hj)
          v))
    (@vector.insert_nth.{u_1} n α a
       (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
          (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) i
             hi)
          (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) j
             hj)
          (@_root_.ne.symm.{1}
             (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
             (@fin.mk
                (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                i
                hi)
             (@fin.mk
                (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                j
                hj)
             ne))
       (@vector.remove_nth.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
          (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
             (@fin.mk
                (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                j
                hj)
             (@fin.mk
                (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                i
                hi)
             ne)
          v))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>166      have : i ≠ j := fin.vne_of_ne ne,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ne'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='fin.vne_of_ne'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ne'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 97, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/fin/basic.lean&#x27;, &#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 97, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {n : nat} {i j : fin n}, @ne.{1} (fin n) i j → @ne.{1} nat (@fin.val n i) (@fin.val n j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@ne.{1} (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))) (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) i hi) (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) j hj)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : nat,
α : Type u_1,
a : α,
v : vector.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)),
remove_nth_insert_nth_ne :
  ∀ {i j : fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))}
  (h :
    @_root_.ne.{1}
      (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
      i
      j),
    @eq.{(max 1 (u_1+1))}
      (vector.{u_1} α
         (@has_sub.sub.{0} nat nat.has_sub
            (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
            (@has_one.one.{0} nat nat.has_one)))
      (@vector.remove_nth.{u_1} α
         (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
         i
         (@vector.insert_nth.{u_1} (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) α a j v))
      (@vector.insert_nth.{u_1} n α a
         (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) i j
            (@_root_.ne.symm.{1}
               (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
               i
               j
               h))
         (@vector.remove_nth.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
            (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) j i h)
            v)),
i : nat,
hi :
  @has_lt.lt.{0} nat nat.has_lt i
    (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))),
j : nat,
hj :
  @has_lt.lt.{0} nat nat.has_lt j
    (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))),
ne :
  @_root_.ne.{1}
    (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) i hi)
    (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) j hj)
⊢ @eq.{(max 1 (u_1+1))}
    (vector.{u_1} α
       (@has_sub.sub.{0} nat nat.has_sub
          (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
          (@has_one.one.{0} nat nat.has_one)))
    (@vector.remove_nth.{u_1} α
       (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
       (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) i
          hi)
       (@vector.insert_nth.{u_1} (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) α a
          (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) j
             hj)
          v))
    (@vector.insert_nth.{u_1} n α a
       (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
          (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) i
             hi)
          (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) j
             hj)
          (@_root_.ne.symm.{1}
             (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
             (@fin.mk
                (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                i
                hi)
             (@fin.mk
                (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                j
                hj)
             ne))
       (@vector.remove_nth.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
          (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
             (@fin.mk
                (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                j
                hj)
             (@fin.mk
                (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                i
                hi)
             ne)
          v))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : nat,
α : Type u_1,
a : α,
v : vector.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)),
remove_nth_insert_nth_ne :
  ∀ {i j : fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))}
  (h :
    @_root_.ne.{1}
      (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
      i
      j),
    @eq.{(max 1 (u_1+1))}
      (vector.{u_1} α
         (@has_sub.sub.{0} nat nat.has_sub
            (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
            (@has_one.one.{0} nat nat.has_one)))
      (@vector.remove_nth.{u_1} α
         (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
         i
         (@vector.insert_nth.{u_1} (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) α a j v))
      (@vector.insert_nth.{u_1} n α a
         (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) i j
            (@_root_.ne.symm.{1}
               (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
               i
               j
               h))
         (@vector.remove_nth.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
            (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) j i h)
            v)),
i : nat,
hi :
  @has_lt.lt.{0} nat nat.has_lt i
    (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))),
j : nat,
hj :
  @has_lt.lt.{0} nat nat.has_lt j
    (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))),
ne :
  @_root_.ne.{1}
    (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) i hi)
    (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) j hj),
this : @_root_.ne.{1} nat i j
⊢ @eq.{(max 1 (u_1+1))}
    (vector.{u_1} α
       (@has_sub.sub.{0} nat nat.has_sub
          (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
          (@has_one.one.{0} nat nat.has_one)))
    (@vector.remove_nth.{u_1} α
       (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
       (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) i
          hi)
       (@vector.insert_nth.{u_1} (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) α a
          (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) j
             hj)
          v))
    (@vector.insert_nth.{u_1} n α a
       (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
          (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) i
             hi)
          (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) j
             hj)
          (@_root_.ne.symm.{1}
             (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
             (@fin.mk
                (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                i
                hi)
             (@fin.mk
                (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                j
                hj)
             ne))
       (@vector.remove_nth.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
          (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
             (@fin.mk
                (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                j
                hj)
             (@fin.mk
                (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                i
                hi)
             ne)
          v))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>167      refine subtype.eq _,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='subtype.eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/subtype/basic.lean&#x27;, &#x27;line&#x27;: 22, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {p : α → Prop} {a1 a2 : @subtype.{u_1+1} α (λ (x : α), p x)}, @eq.{u_1+1} α (@subtype.val.{u_1+1} α (λ (x : α), p x) a1) (@subtype.val.{u_1+1} α (λ (x : α), p x) a2) → @eq.{(max 1 (u_1+1))} (@subtype.{u_1+1} α (λ (x : α), p x)) a1 a2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : nat,
α : Type u_1,
a : α,
v : vector.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)),
remove_nth_insert_nth_ne :
  ∀ {i j : fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))}
  (h :
    @_root_.ne.{1}
      (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
      i
      j),
    @eq.{(max 1 (u_1+1))}
      (vector.{u_1} α
         (@has_sub.sub.{0} nat nat.has_sub
            (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
            (@has_one.one.{0} nat nat.has_one)))
      (@vector.remove_nth.{u_1} α
         (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
         i
         (@vector.insert_nth.{u_1} (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) α a j v))
      (@vector.insert_nth.{u_1} n α a
         (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) i j
            (@_root_.ne.symm.{1}
               (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
               i
               j
               h))
         (@vector.remove_nth.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
            (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) j i h)
            v)),
i : nat,
hi :
  @has_lt.lt.{0} nat nat.has_lt i
    (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))),
j : nat,
hj :
  @has_lt.lt.{0} nat nat.has_lt j
    (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))),
ne :
  @_root_.ne.{1}
    (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) i hi)
    (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) j hj),
this : @_root_.ne.{1} nat i j
⊢ @eq.{(max 1 (u_1+1))}
    (vector.{u_1} α
       (@has_sub.sub.{0} nat nat.has_sub
          (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
          (@has_one.one.{0} nat nat.has_one)))
    (@vector.remove_nth.{u_1} α
       (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
       (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) i
          hi)
       (@vector.insert_nth.{u_1} (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) α a
          (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) j
             hj)
          v))
    (@vector.insert_nth.{u_1} n α a
       (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
          (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) i
             hi)
          (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) j
             hj)
          (@_root_.ne.symm.{1}
             (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
             (@fin.mk
                (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                i
                hi)
             (@fin.mk
                (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                j
                hj)
             ne))
       (@vector.remove_nth.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
          (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
             (@fin.mk
                (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                j
                hj)
             (@fin.mk
                (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                i
                hi)
             ne)
          v))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : nat,
α : Type u_1,
a : α,
v : vector.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)),
remove_nth_insert_nth_ne :
  ∀ {i j : fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))}
  (h :
    @_root_.ne.{1}
      (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
      i
      j),
    @eq.{(max 1 (u_1+1))}
      (vector.{u_1} α
         (@has_sub.sub.{0} nat nat.has_sub
            (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
            (@has_one.one.{0} nat nat.has_one)))
      (@vector.remove_nth.{u_1} α
         (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
         i
         (@vector.insert_nth.{u_1} (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) α a j v))
      (@vector.insert_nth.{u_1} n α a
         (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) i j
            (@_root_.ne.symm.{1}
               (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
               i
               j
               h))
         (@vector.remove_nth.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
            (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) j i h)
            v)),
i : nat,
hi :
  @has_lt.lt.{0} nat nat.has_lt i
    (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))),
j : nat,
hj :
  @has_lt.lt.{0} nat nat.has_lt j
    (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))),
ne :
  @_root_.ne.{1}
    (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) i hi)
    (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) j hj),
this : @_root_.ne.{1} nat i j
⊢ @eq.{u_1+1} (list.{u_1} α)
    (@subtype.val.{u_1+1} (list.{u_1} α)
       (λ (x : list.{u_1} α),
          @eq.{1} nat (@list.length.{u_1} α x)
            (@has_sub.sub.{0} nat nat.has_sub
               (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
               (@has_one.one.{0} nat nat.has_one)))
       (@vector.remove_nth.{u_1} α
          (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
          (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) i
             hi)
          (@vector.insert_nth.{u_1} (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) α a
             (@fin.mk
                (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                j
                hj)
             v)))
    (@subtype.val.{u_1+1} (list.{u_1} α)
       (λ (x : list.{u_1} α),
          @eq.{1} nat (@list.length.{u_1} α x)
            (@has_sub.sub.{0} nat nat.has_sub
               (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
               (@has_one.one.{0} nat nat.has_one)))
       (@vector.insert_nth.{u_1} n α a
          (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
             (@fin.mk
                (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                i
                hi)
             (@fin.mk
                (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                j
                hj)
             (@_root_.ne.symm.{1}
                (fin
                   (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
                (@fin.mk
                   (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                   i
                   hi)
                (@fin.mk
                   (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                   j
                   hj)
                ne))
          (@vector.remove_nth.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
             (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                (@fin.mk
                   (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                   j
                   hj)
                (@fin.mk
                   (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                   i
                   hi)
                ne)
             v)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>168      dsimp [insert_nth, remove_nth, fin.pred_above, fin.cast_lt],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='vector.insert_nth'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='vector.remove_nth'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='fin.pred_above'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='fin.cast_lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 142, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 85, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/fin.lean&#x27;, &#x27;line&#x27;: 122, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/fin.lean&#x27;, &#x27;line&#x27;: 103, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {n : nat} {α : Type ?l_1}, α → fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → vector.{?l_1} α n → vector.{?l_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type ?l_1} {n : nat}, fin n → vector.{?l_1} α n → vector.{?l_1} α (@has_sub.sub.{0} nat nat.has_sub n (@has_one.one.{0} nat nat.has_one))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {n : nat} (p i : fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))), @ne.{1} (fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) i p → fin n'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {n m : nat} (i : fin m), @has_lt.lt.{0} nat nat.has_lt (@fin.val m i) n → fin n'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`pred_above p i h` embeds `i : fin (n+1)` into `fin n` by ignoring `p`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`cast_lt i h` embeds `i` into a `fin` where `h` proves it belongs into.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : nat,
α : Type u_1,
a : α,
v : vector.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)),
remove_nth_insert_nth_ne :
  ∀ {i j : fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))}
  (h :
    @_root_.ne.{1}
      (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
      i
      j),
    @eq.{(max 1 (u_1+1))}
      (vector.{u_1} α
         (@has_sub.sub.{0} nat nat.has_sub
            (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
            (@has_one.one.{0} nat nat.has_one)))
      (@vector.remove_nth.{u_1} α
         (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
         i
         (@vector.insert_nth.{u_1} (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) α a j v))
      (@vector.insert_nth.{u_1} n α a
         (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) i j
            (@_root_.ne.symm.{1}
               (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
               i
               j
               h))
         (@vector.remove_nth.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
            (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) j i h)
            v)),
i : nat,
hi :
  @has_lt.lt.{0} nat nat.has_lt i
    (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))),
j : nat,
hj :
  @has_lt.lt.{0} nat nat.has_lt j
    (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))),
ne :
  @_root_.ne.{1}
    (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) i hi)
    (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) j hj),
this : @_root_.ne.{1} nat i j
⊢ @eq.{u_1+1} (list.{u_1} α)
    (@subtype.val.{u_1+1} (list.{u_1} α)
       (λ (x : list.{u_1} α),
          @eq.{1} nat (@list.length.{u_1} α x)
            (@has_sub.sub.{0} nat nat.has_sub
               (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
               (@has_one.one.{0} nat nat.has_one)))
       (@vector.remove_nth.{u_1} α
          (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
          (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) i
             hi)
          (@vector.insert_nth.{u_1} (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) α a
             (@fin.mk
                (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                j
                hj)
             v)))
    (@subtype.val.{u_1+1} (list.{u_1} α)
       (λ (x : list.{u_1} α),
          @eq.{1} nat (@list.length.{u_1} α x)
            (@has_sub.sub.{0} nat nat.has_sub
               (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
               (@has_one.one.{0} nat nat.has_one)))
       (@vector.insert_nth.{u_1} n α a
          (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
             (@fin.mk
                (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                i
                hi)
             (@fin.mk
                (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                j
                hj)
             (@_root_.ne.symm.{1}
                (fin
                   (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
                (@fin.mk
                   (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                   i
                   hi)
                (@fin.mk
                   (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                   j
                   hj)
                ne))
          (@vector.remove_nth.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
             (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                (@fin.mk
                   (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                   j
                   hj)
                (@fin.mk
                   (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                   i
                   hi)
                ne)
             v)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : nat,
α : Type u_1,
a : α,
v : vector.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)),
remove_nth_insert_nth_ne :
  ∀ {i j : fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))}
  (h :
    @_root_.ne.{1}
      (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
      i
      j),
    @eq.{(max 1 (u_1+1))}
      (vector.{u_1} α
         (@has_sub.sub.{0} nat nat.has_sub
            (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
            (@has_one.one.{0} nat nat.has_one)))
      (@vector.remove_nth.{u_1} α
         (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
         i
         (@vector.insert_nth.{u_1} (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) α a j v))
      (@vector.insert_nth.{u_1} n α a
         (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) i j
            (@_root_.ne.symm.{1}
               (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
               i
               j
               h))
         (@vector.remove_nth.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
            (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) j i h)
            v)),
i : nat,
hi :
  @has_lt.lt.{0} nat nat.has_lt i
    (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))),
j : nat,
hj :
  @has_lt.lt.{0} nat nat.has_lt j
    (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))),
ne :
  @_root_.ne.{1}
    (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) i hi)
    (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) j hj),
this : @_root_.ne.{1} nat i j
⊢ @eq.{u_1+1} (list.{u_1} α)
    (@list.remove_nth.{u_1} α
       (@list.insert_nth.{u_1} α j a
          (@subtype.val.{u_1+1} (list.{u_1} α)
             (λ (l : list.{u_1} α),
                @eq.{1} nat (@list.length.{u_1} α l)
                  (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
             v))
       i)
    (@list.insert_nth.{u_1} α
       (@fin.val (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
          (@dite.{1}
             (@has_lt.lt.{0}
                (fin
                   (@has_add.add.{0} nat nat.has_add
                      (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                      (@has_one.one.{0} nat nat.has_one)))
                (@fin.has_lt
                   (@has_add.add.{0} nat nat.has_add
                      (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                      (@has_one.one.{0} nat nat.has_one)))
                (@fin.mk
                   (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                   j
                   hj)
                (@fin.mk
                   (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                   i
                   hi))
             (@fin.decidable_lt
                (@has_add.add.{0} nat nat.has_add
                   (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                   (@has_one.one.{0} nat nat.has_one))
                (@fin.mk
                   (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                   j
                   hj)
                (@fin.mk
                   (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                   i
                   hi))
             (fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
             (λ
              (h :
                @has_lt.lt.{0}
                  (fin
                     (@has_add.add.{0} nat nat.has_add
                        (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                        (@has_one.one.{0} nat nat.has_one)))
                  (@fin.has_lt
                     (@has_add.add.{0} nat nat.has_add
                        (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                        (@has_one.one.{0} nat nat.has_one)))
                  (@fin.mk
                     (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                     j
                     hj)
                  (@fin.mk
                     (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                     i
                     hi)),
                @fin.mk (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) j
                  (@fin.pred_above._proof_1 (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        i
                        hi)
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        j
                        hj)
                     h))
             (λ
              (h :
                not
                  (@has_lt.lt.{0}
                     (fin
                        (@has_add.add.{0} nat nat.has_add
                           (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                           (@has_one.one.{0} nat nat.has_one)))
                     (@fin.has_lt
                        (@has_add.add.{0} nat nat.has_add
                           (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                           (@has_one.one.{0} nat nat.has_one)))
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        j
                        hj)
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        i
                        hi))),
                @fin.pred (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                  (@fin.mk
                     (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                     j
                     hj)
                  (@fin.pred_above._proof_2 (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        i
                        hi)
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        j
                        hj)
                     (@_root_.ne.symm.{1}
                        (fin
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           i
                           hi)
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           j
                           hj)
                        ne)
                     h))))
       a
       (@subtype.val.{u_1+1} (list.{u_1} α) (λ (l : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l) n)
          (@vector.remove_nth.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
             (@dite.{1}
                (@has_lt.lt.{0}
                   (fin
                      (@has_add.add.{0} nat nat.has_add
                         (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                         (@has_one.one.{0} nat nat.has_one)))
                   (@fin.has_lt
                      (@has_add.add.{0} nat nat.has_add
                         (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                         (@has_one.one.{0} nat nat.has_one)))
                   (@fin.mk
                      (@has_add.add.{0} nat nat.has_add n
                         (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                      i
                      hi)
                   (@fin.mk
                      (@has_add.add.{0} nat nat.has_add n
                         (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                      j
                      hj))
                (@fin.decidable_lt
                   (@has_add.add.{0} nat nat.has_add
                      (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                      (@has_one.one.{0} nat nat.has_one))
                   (@fin.mk
                      (@has_add.add.{0} nat nat.has_add n
                         (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                      i
                      hi)
                   (@fin.mk
                      (@has_add.add.{0} nat nat.has_add n
                         (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                      j
                      hj))
                (fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
                (λ
                 (h :
                   @has_lt.lt.{0}
                     (fin
                        (@has_add.add.{0} nat nat.has_add
                           (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                           (@has_one.one.{0} nat nat.has_one)))
                     (@fin.has_lt
                        (@has_add.add.{0} nat nat.has_add
                           (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                           (@has_one.one.{0} nat nat.has_one)))
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        i
                        hi)
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        j
                        hj)),
                   @fin.mk (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) i
                     (@fin.pred_above._proof_1 (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           j
                           hj)
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           i
                           hi)
                        h))
                (λ
                 (h :
                   not
                     (@has_lt.lt.{0}
                        (fin
                           (@has_add.add.{0} nat nat.has_add
                              (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                              (@has_one.one.{0} nat nat.has_one)))
                        (@fin.has_lt
                           (@has_add.add.{0} nat nat.has_add
                              (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                              (@has_one.one.{0} nat nat.has_one)))
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           i
                           hi)
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           j
                           hj))),
                   @fin.pred (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        i
                        hi)
                     (@fin.pred_above._proof_2 (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           j
                           hj)
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           i
                           hi)
                        ne
                        h)))
             v)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>169      rcases lt_trichotomy i j with h | h | h,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='lt_trichotomy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 139, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : linear_order.{0} α] (a b : α), or (@has_lt.lt.{0} α (@preorder.to_has_lt.{0} α (@partial_order.to_preorder.{0} α (@linear_order.to_partial_order.{0} α _inst_1))) a b) (or (@eq.{1} α a b) (@has_lt.lt.{0} α (@preorder.to_has_lt.{0} α (@partial_order.to_preorder.{0} α (@linear_order.to_partial_order.{0} α _inst_1))) b a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : nat,
α : Type u_1,
a : α,
v : vector.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)),
remove_nth_insert_nth_ne :
  ∀ {i j : fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))}
  (h :
    @_root_.ne.{1}
      (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
      i
      j),
    @eq.{(max 1 (u_1+1))}
      (vector.{u_1} α
         (@has_sub.sub.{0} nat nat.has_sub
            (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
            (@has_one.one.{0} nat nat.has_one)))
      (@vector.remove_nth.{u_1} α
         (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
         i
         (@vector.insert_nth.{u_1} (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) α a j v))
      (@vector.insert_nth.{u_1} n α a
         (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) i j
            (@_root_.ne.symm.{1}
               (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
               i
               j
               h))
         (@vector.remove_nth.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
            (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) j i h)
            v)),
i : nat,
hi :
  @has_lt.lt.{0} nat nat.has_lt i
    (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))),
j : nat,
hj :
  @has_lt.lt.{0} nat nat.has_lt j
    (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))),
ne :
  @_root_.ne.{1}
    (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) i hi)
    (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) j hj),
this : @_root_.ne.{1} nat i j
⊢ @eq.{u_1+1} (list.{u_1} α)
    (@list.remove_nth.{u_1} α
       (@list.insert_nth.{u_1} α j a
          (@subtype.val.{u_1+1} (list.{u_1} α)
             (λ (l : list.{u_1} α),
                @eq.{1} nat (@list.length.{u_1} α l)
                  (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
             v))
       i)
    (@list.insert_nth.{u_1} α
       (@fin.val (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
          (@dite.{1}
             (@has_lt.lt.{0}
                (fin
                   (@has_add.add.{0} nat nat.has_add
                      (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                      (@has_one.one.{0} nat nat.has_one)))
                (@fin.has_lt
                   (@has_add.add.{0} nat nat.has_add
                      (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                      (@has_one.one.{0} nat nat.has_one)))
                (@fin.mk
                   (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                   j
                   hj)
                (@fin.mk
                   (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                   i
                   hi))
             (@fin.decidable_lt
                (@has_add.add.{0} nat nat.has_add
                   (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                   (@has_one.one.{0} nat nat.has_one))
                (@fin.mk
                   (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                   j
                   hj)
                (@fin.mk
                   (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                   i
                   hi))
             (fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
             (λ
              (h :
                @has_lt.lt.{0}
                  (fin
                     (@has_add.add.{0} nat nat.has_add
                        (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                        (@has_one.one.{0} nat nat.has_one)))
                  (@fin.has_lt
                     (@has_add.add.{0} nat nat.has_add
                        (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                        (@has_one.one.{0} nat nat.has_one)))
                  (@fin.mk
                     (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                     j
                     hj)
                  (@fin.mk
                     (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                     i
                     hi)),
                @fin.mk (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) j
                  (@fin.pred_above._proof_1 (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        i
                        hi)
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        j
                        hj)
                     h))
             (λ
              (h :
                not
                  (@has_lt.lt.{0}
                     (fin
                        (@has_add.add.{0} nat nat.has_add
                           (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                           (@has_one.one.{0} nat nat.has_one)))
                     (@fin.has_lt
                        (@has_add.add.{0} nat nat.has_add
                           (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                           (@has_one.one.{0} nat nat.has_one)))
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        j
                        hj)
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        i
                        hi))),
                @fin.pred (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                  (@fin.mk
                     (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                     j
                     hj)
                  (@fin.pred_above._proof_2 (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        i
                        hi)
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        j
                        hj)
                     (@_root_.ne.symm.{1}
                        (fin
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           i
                           hi)
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           j
                           hj)
                        ne)
                     h))))
       a
       (@subtype.val.{u_1+1} (list.{u_1} α) (λ (l : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l) n)
          (@vector.remove_nth.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
             (@dite.{1}
                (@has_lt.lt.{0}
                   (fin
                      (@has_add.add.{0} nat nat.has_add
                         (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                         (@has_one.one.{0} nat nat.has_one)))
                   (@fin.has_lt
                      (@has_add.add.{0} nat nat.has_add
                         (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                         (@has_one.one.{0} nat nat.has_one)))
                   (@fin.mk
                      (@has_add.add.{0} nat nat.has_add n
                         (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                      i
                      hi)
                   (@fin.mk
                      (@has_add.add.{0} nat nat.has_add n
                         (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                      j
                      hj))
                (@fin.decidable_lt
                   (@has_add.add.{0} nat nat.has_add
                      (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                      (@has_one.one.{0} nat nat.has_one))
                   (@fin.mk
                      (@has_add.add.{0} nat nat.has_add n
                         (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                      i
                      hi)
                   (@fin.mk
                      (@has_add.add.{0} nat nat.has_add n
                         (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                      j
                      hj))
                (fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
                (λ
                 (h :
                   @has_lt.lt.{0}
                     (fin
                        (@has_add.add.{0} nat nat.has_add
                           (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                           (@has_one.one.{0} nat nat.has_one)))
                     (@fin.has_lt
                        (@has_add.add.{0} nat nat.has_add
                           (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                           (@has_one.one.{0} nat nat.has_one)))
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        i
                        hi)
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        j
                        hj)),
                   @fin.mk (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) i
                     (@fin.pred_above._proof_1 (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           j
                           hj)
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           i
                           hi)
                        h))
                (λ
                 (h :
                   not
                     (@has_lt.lt.{0}
                        (fin
                           (@has_add.add.{0} nat nat.has_add
                              (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                              (@has_one.one.{0} nat nat.has_one)))
                        (@fin.has_lt
                           (@has_add.add.{0} nat nat.has_add
                              (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                              (@has_one.one.{0} nat nat.has_one)))
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           i
                           hi)
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           j
                           hj))),
                   @fin.pred (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        i
                        hi)
                     (@fin.pred_above._proof_2 (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           j
                           hj)
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           i
                           hi)
                        ne
                        h)))
             v)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
n : nat,
α : Type u_1,
a : α,
v : vector.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)),
remove_nth_insert_nth_ne :
  ∀ {i j : fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))}
  (h :
    @_root_.ne.{1}
      (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
      i
      j),
    @eq.{(max 1 (u_1+1))}
      (vector.{u_1} α
         (@has_sub.sub.{0} nat nat.has_sub
            (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
            (@has_one.one.{0} nat nat.has_one)))
      (@vector.remove_nth.{u_1} α
         (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
         i
         (@vector.insert_nth.{u_1} (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) α a j v))
      (@vector.insert_nth.{u_1} n α a
         (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) i j
            (@_root_.ne.symm.{1}
               (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
               i
               j
               h))
         (@vector.remove_nth.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
            (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) j i h)
            v)),
i : nat,
hi :
  @has_lt.lt.{0} nat nat.has_lt i
    (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))),
j : nat,
hj :
  @has_lt.lt.{0} nat nat.has_lt j
    (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))),
ne :
  @_root_.ne.{1}
    (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) i hi)
    (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) j hj),
this : @_root_.ne.{1} nat i j,
h :
  @has_lt.lt.{0} nat
    (@preorder.to_has_lt.{0} nat
       (@partial_order.to_preorder.{0} nat (@linear_order.to_partial_order.{0} nat nat.linear_order)))
    i
    j
⊢ @eq.{u_1+1} (list.{u_1} α)
    (@list.remove_nth.{u_1} α
       (@list.insert_nth.{u_1} α j a
          (@subtype.val.{u_1+1} (list.{u_1} α)
             (λ (l : list.{u_1} α),
                @eq.{1} nat (@list.length.{u_1} α l)
                  (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
             v))
       i)
    (@list.insert_nth.{u_1} α
       (@fin.val (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
          (@dite.{1}
             (@has_lt.lt.{0}
                (fin
                   (@has_add.add.{0} nat nat.has_add
                      (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                      (@has_one.one.{0} nat nat.has_one)))
                (@fin.has_lt
                   (@has_add.add.{0} nat nat.has_add
                      (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                      (@has_one.one.{0} nat nat.has_one)))
                (@fin.mk
                   (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                   j
                   hj)
                (@fin.mk
                   (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                   i
                   hi))
             (@fin.decidable_lt
                (@has_add.add.{0} nat nat.has_add
                   (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                   (@has_one.one.{0} nat nat.has_one))
                (@fin.mk
                   (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                   j
                   hj)
                (@fin.mk
                   (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                   i
                   hi))
             (fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
             (λ
              (h :
                @has_lt.lt.{0}
                  (fin
                     (@has_add.add.{0} nat nat.has_add
                        (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                        (@has_one.one.{0} nat nat.has_one)))
                  (@fin.has_lt
                     (@has_add.add.{0} nat nat.has_add
                        (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                        (@has_one.one.{0} nat nat.has_one)))
                  (@fin.mk
                     (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                     j
                     hj)
                  (@fin.mk
                     (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                     i
                     hi)),
                @fin.mk (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) j
                  (@fin.pred_above._proof_1 (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        i
                        hi)
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        j
                        hj)
                     h))
             (λ
              (h :
                not
                  (@has_lt.lt.{0}
                     (fin
                        (@has_add.add.{0} nat nat.has_add
                           (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                           (@has_one.one.{0} nat nat.has_one)))
                     (@fin.has_lt
                        (@has_add.add.{0} nat nat.has_add
                           (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                           (@has_one.one.{0} nat nat.has_one)))
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        j
                        hj)
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        i
                        hi))),
                @fin.pred (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                  (@fin.mk
                     (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                     j
                     hj)
                  (@fin.pred_above._proof_2 (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        i
                        hi)
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        j
                        hj)
                     (@_root_.ne.symm.{1}
                        (fin
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           i
                           hi)
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           j
                           hj)
                        ne)
                     h))))
       a
       (@subtype.val.{u_1+1} (list.{u_1} α) (λ (l : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l) n)
          (@vector.remove_nth.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
             (@dite.{1}
                (@has_lt.lt.{0}
                   (fin
                      (@has_add.add.{0} nat nat.has_add
                         (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                         (@has_one.one.{0} nat nat.has_one)))
                   (@fin.has_lt
                      (@has_add.add.{0} nat nat.has_add
                         (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                         (@has_one.one.{0} nat nat.has_one)))
                   (@fin.mk
                      (@has_add.add.{0} nat nat.has_add n
                         (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                      i
                      hi)
                   (@fin.mk
                      (@has_add.add.{0} nat nat.has_add n
                         (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                      j
                      hj))
                (@fin.decidable_lt
                   (@has_add.add.{0} nat nat.has_add
                      (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                      (@has_one.one.{0} nat nat.has_one))
                   (@fin.mk
                      (@has_add.add.{0} nat nat.has_add n
                         (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                      i
                      hi)
                   (@fin.mk
                      (@has_add.add.{0} nat nat.has_add n
                         (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                      j
                      hj))
                (fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
                (λ
                 (h :
                   @has_lt.lt.{0}
                     (fin
                        (@has_add.add.{0} nat nat.has_add
                           (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                           (@has_one.one.{0} nat nat.has_one)))
                     (@fin.has_lt
                        (@has_add.add.{0} nat nat.has_add
                           (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                           (@has_one.one.{0} nat nat.has_one)))
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        i
                        hi)
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        j
                        hj)),
                   @fin.mk (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) i
                     (@fin.pred_above._proof_1 (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           j
                           hj)
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           i
                           hi)
                        h))
                (λ
                 (h :
                   not
                     (@has_lt.lt.{0}
                        (fin
                           (@has_add.add.{0} nat nat.has_add
                              (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                              (@has_one.one.{0} nat nat.has_one)))
                        (@fin.has_lt
                           (@has_add.add.{0} nat nat.has_add
                              (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                              (@has_one.one.{0} nat nat.has_one)))
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           i
                           hi)
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           j
                           hj))),
                   @fin.pred (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        i
                        hi)
                     (@fin.pred_above._proof_2 (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           j
                           hj)
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           i
                           hi)
                        ne
                        h)))
             v)))

n : nat,
α : Type u_1,
a : α,
v : vector.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)),
remove_nth_insert_nth_ne :
  ∀ {i j : fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))}
  (h :
    @_root_.ne.{1}
      (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
      i
      j),
    @eq.{(max 1 (u_1+1))}
      (vector.{u_1} α
         (@has_sub.sub.{0} nat nat.has_sub
            (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
            (@has_one.one.{0} nat nat.has_one)))
      (@vector.remove_nth.{u_1} α
         (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
         i
         (@vector.insert_nth.{u_1} (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) α a j v))
      (@vector.insert_nth.{u_1} n α a
         (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) i j
            (@_root_.ne.symm.{1}
               (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
               i
               j
               h))
         (@vector.remove_nth.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
            (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) j i h)
            v)),
i : nat,
hi :
  @has_lt.lt.{0} nat nat.has_lt i
    (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))),
j : nat,
hj :
  @has_lt.lt.{0} nat nat.has_lt j
    (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))),
ne :
  @_root_.ne.{1}
    (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) i hi)
    (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) j hj),
this : @_root_.ne.{1} nat i j,
h : @eq.{1} nat i j
⊢ @eq.{u_1+1} (list.{u_1} α)
    (@list.remove_nth.{u_1} α
       (@list.insert_nth.{u_1} α j a
          (@subtype.val.{u_1+1} (list.{u_1} α)
             (λ (l : list.{u_1} α),
                @eq.{1} nat (@list.length.{u_1} α l)
                  (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
             v))
       i)
    (@list.insert_nth.{u_1} α
       (@fin.val (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
          (@dite.{1}
             (@has_lt.lt.{0}
                (fin
                   (@has_add.add.{0} nat nat.has_add
                      (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                      (@has_one.one.{0} nat nat.has_one)))
                (@fin.has_lt
                   (@has_add.add.{0} nat nat.has_add
                      (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                      (@has_one.one.{0} nat nat.has_one)))
                (@fin.mk
                   (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                   j
                   hj)
                (@fin.mk
                   (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                   i
                   hi))
             (@fin.decidable_lt
                (@has_add.add.{0} nat nat.has_add
                   (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                   (@has_one.one.{0} nat nat.has_one))
                (@fin.mk
                   (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                   j
                   hj)
                (@fin.mk
                   (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                   i
                   hi))
             (fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
             (λ
              (h :
                @has_lt.lt.{0}
                  (fin
                     (@has_add.add.{0} nat nat.has_add
                        (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                        (@has_one.one.{0} nat nat.has_one)))
                  (@fin.has_lt
                     (@has_add.add.{0} nat nat.has_add
                        (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                        (@has_one.one.{0} nat nat.has_one)))
                  (@fin.mk
                     (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                     j
                     hj)
                  (@fin.mk
                     (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                     i
                     hi)),
                @fin.mk (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) j
                  (@fin.pred_above._proof_1 (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        i
                        hi)
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        j
                        hj)
                     h))
             (λ
              (h :
                not
                  (@has_lt.lt.{0}
                     (fin
                        (@has_add.add.{0} nat nat.has_add
                           (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                           (@has_one.one.{0} nat nat.has_one)))
                     (@fin.has_lt
                        (@has_add.add.{0} nat nat.has_add
                           (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                           (@has_one.one.{0} nat nat.has_one)))
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        j
                        hj)
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        i
                        hi))),
                @fin.pred (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                  (@fin.mk
                     (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                     j
                     hj)
                  (@fin.pred_above._proof_2 (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        i
                        hi)
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        j
                        hj)
                     (@_root_.ne.symm.{1}
                        (fin
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           i
                           hi)
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           j
                           hj)
                        ne)
                     h))))
       a
       (@subtype.val.{u_1+1} (list.{u_1} α) (λ (l : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l) n)
          (@vector.remove_nth.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
             (@dite.{1}
                (@has_lt.lt.{0}
                   (fin
                      (@has_add.add.{0} nat nat.has_add
                         (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                         (@has_one.one.{0} nat nat.has_one)))
                   (@fin.has_lt
                      (@has_add.add.{0} nat nat.has_add
                         (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                         (@has_one.one.{0} nat nat.has_one)))
                   (@fin.mk
                      (@has_add.add.{0} nat nat.has_add n
                         (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                      i
                      hi)
                   (@fin.mk
                      (@has_add.add.{0} nat nat.has_add n
                         (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                      j
                      hj))
                (@fin.decidable_lt
                   (@has_add.add.{0} nat nat.has_add
                      (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                      (@has_one.one.{0} nat nat.has_one))
                   (@fin.mk
                      (@has_add.add.{0} nat nat.has_add n
                         (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                      i
                      hi)
                   (@fin.mk
                      (@has_add.add.{0} nat nat.has_add n
                         (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                      j
                      hj))
                (fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
                (λ
                 (h :
                   @has_lt.lt.{0}
                     (fin
                        (@has_add.add.{0} nat nat.has_add
                           (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                           (@has_one.one.{0} nat nat.has_one)))
                     (@fin.has_lt
                        (@has_add.add.{0} nat nat.has_add
                           (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                           (@has_one.one.{0} nat nat.has_one)))
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        i
                        hi)
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        j
                        hj)),
                   @fin.mk (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) i
                     (@fin.pred_above._proof_1 (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           j
                           hj)
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           i
                           hi)
                        h))
                (λ
                 (h :
                   not
                     (@has_lt.lt.{0}
                        (fin
                           (@has_add.add.{0} nat nat.has_add
                              (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                              (@has_one.one.{0} nat nat.has_one)))
                        (@fin.has_lt
                           (@has_add.add.{0} nat nat.has_add
                              (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                              (@has_one.one.{0} nat nat.has_one)))
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           i
                           hi)
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           j
                           hj))),
                   @fin.pred (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        i
                        hi)
                     (@fin.pred_above._proof_2 (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           j
                           hj)
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           i
                           hi)
                        ne
                        h)))
             v)))

n : nat,
α : Type u_1,
a : α,
v : vector.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)),
remove_nth_insert_nth_ne :
  ∀ {i j : fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))}
  (h :
    @_root_.ne.{1}
      (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
      i
      j),
    @eq.{(max 1 (u_1+1))}
      (vector.{u_1} α
         (@has_sub.sub.{0} nat nat.has_sub
            (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
            (@has_one.one.{0} nat nat.has_one)))
      (@vector.remove_nth.{u_1} α
         (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
         i
         (@vector.insert_nth.{u_1} (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) α a j v))
      (@vector.insert_nth.{u_1} n α a
         (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) i j
            (@_root_.ne.symm.{1}
               (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
               i
               j
               h))
         (@vector.remove_nth.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
            (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) j i h)
            v)),
i : nat,
hi :
  @has_lt.lt.{0} nat nat.has_lt i
    (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))),
j : nat,
hj :
  @has_lt.lt.{0} nat nat.has_lt j
    (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))),
ne :
  @_root_.ne.{1}
    (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) i hi)
    (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) j hj),
this : @_root_.ne.{1} nat i j,
h :
  @has_lt.lt.{0} nat
    (@preorder.to_has_lt.{0} nat
       (@partial_order.to_preorder.{0} nat (@linear_order.to_partial_order.{0} nat nat.linear_order)))
    j
    i
⊢ @eq.{u_1+1} (list.{u_1} α)
    (@list.remove_nth.{u_1} α
       (@list.insert_nth.{u_1} α j a
          (@subtype.val.{u_1+1} (list.{u_1} α)
             (λ (l : list.{u_1} α),
                @eq.{1} nat (@list.length.{u_1} α l)
                  (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
             v))
       i)
    (@list.insert_nth.{u_1} α
       (@fin.val (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
          (@dite.{1}
             (@has_lt.lt.{0}
                (fin
                   (@has_add.add.{0} nat nat.has_add
                      (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                      (@has_one.one.{0} nat nat.has_one)))
                (@fin.has_lt
                   (@has_add.add.{0} nat nat.has_add
                      (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                      (@has_one.one.{0} nat nat.has_one)))
                (@fin.mk
                   (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                   j
                   hj)
                (@fin.mk
                   (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                   i
                   hi))
             (@fin.decidable_lt
                (@has_add.add.{0} nat nat.has_add
                   (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                   (@has_one.one.{0} nat nat.has_one))
                (@fin.mk
                   (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                   j
                   hj)
                (@fin.mk
                   (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                   i
                   hi))
             (fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
             (λ
              (h :
                @has_lt.lt.{0}
                  (fin
                     (@has_add.add.{0} nat nat.has_add
                        (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                        (@has_one.one.{0} nat nat.has_one)))
                  (@fin.has_lt
                     (@has_add.add.{0} nat nat.has_add
                        (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                        (@has_one.one.{0} nat nat.has_one)))
                  (@fin.mk
                     (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                     j
                     hj)
                  (@fin.mk
                     (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                     i
                     hi)),
                @fin.mk (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) j
                  (@fin.pred_above._proof_1 (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        i
                        hi)
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        j
                        hj)
                     h))
             (λ
              (h :
                not
                  (@has_lt.lt.{0}
                     (fin
                        (@has_add.add.{0} nat nat.has_add
                           (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                           (@has_one.one.{0} nat nat.has_one)))
                     (@fin.has_lt
                        (@has_add.add.{0} nat nat.has_add
                           (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                           (@has_one.one.{0} nat nat.has_one)))
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        j
                        hj)
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        i
                        hi))),
                @fin.pred (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                  (@fin.mk
                     (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                     j
                     hj)
                  (@fin.pred_above._proof_2 (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        i
                        hi)
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        j
                        hj)
                     (@_root_.ne.symm.{1}
                        (fin
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           i
                           hi)
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           j
                           hj)
                        ne)
                     h))))
       a
       (@subtype.val.{u_1+1} (list.{u_1} α) (λ (l : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l) n)
          (@vector.remove_nth.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
             (@dite.{1}
                (@has_lt.lt.{0}
                   (fin
                      (@has_add.add.{0} nat nat.has_add
                         (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                         (@has_one.one.{0} nat nat.has_one)))
                   (@fin.has_lt
                      (@has_add.add.{0} nat nat.has_add
                         (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                         (@has_one.one.{0} nat nat.has_one)))
                   (@fin.mk
                      (@has_add.add.{0} nat nat.has_add n
                         (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                      i
                      hi)
                   (@fin.mk
                      (@has_add.add.{0} nat nat.has_add n
                         (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                      j
                      hj))
                (@fin.decidable_lt
                   (@has_add.add.{0} nat nat.has_add
                      (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                      (@has_one.one.{0} nat nat.has_one))
                   (@fin.mk
                      (@has_add.add.{0} nat nat.has_add n
                         (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                      i
                      hi)
                   (@fin.mk
                      (@has_add.add.{0} nat nat.has_add n
                         (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                      j
                      hj))
                (fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
                (λ
                 (h :
                   @has_lt.lt.{0}
                     (fin
                        (@has_add.add.{0} nat nat.has_add
                           (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                           (@has_one.one.{0} nat nat.has_one)))
                     (@fin.has_lt
                        (@has_add.add.{0} nat nat.has_add
                           (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                           (@has_one.one.{0} nat nat.has_one)))
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        i
                        hi)
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        j
                        hj)),
                   @fin.mk (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) i
                     (@fin.pred_above._proof_1 (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           j
                           hj)
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           i
                           hi)
                        h))
                (λ
                 (h :
                   not
                     (@has_lt.lt.{0}
                        (fin
                           (@has_add.add.{0} nat nat.has_add
                              (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                              (@has_one.one.{0} nat nat.has_one)))
                        (@fin.has_lt
                           (@has_add.add.{0} nat nat.has_add
                              (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                              (@has_one.one.{0} nat nat.has_one)))
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           i
                           hi)
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           j
                           hj))),
                   @fin.pred (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        i
                        hi)
                     (@fin.pred_above._proof_2 (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           j
                           hj)
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           i
                           hi)
                        ne
                        h)))
             v)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>170      { have h_nji : ¬ j &lt; i := lt_asymm h,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_lt.lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='lt_asymm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 320, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 93, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} [c : has_lt.{0} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : preorder.{0} α] {a b : α}, @has_lt.lt.{0} α (@preorder.to_has_lt.{0} α _inst_1) a b → not (@has_lt.lt.{0} α (@preorder.to_has_lt.{0} α _inst_1) b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_lt.lt.{0} nat (@preorder.to_has_lt.{0} nat (@partial_order.to_preorder.{0} nat (@linear_order.to_partial_order.{0} nat nat.linear_order))) i j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
n : nat,
α : Type u_1,
a : α,
v : vector.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)),
remove_nth_insert_nth_ne :
  ∀ {i j : fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))}
  (h :
    @_root_.ne.{1}
      (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
      i
      j),
    @eq.{(max 1 (u_1+1))}
      (vector.{u_1} α
         (@has_sub.sub.{0} nat nat.has_sub
            (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
            (@has_one.one.{0} nat nat.has_one)))
      (@vector.remove_nth.{u_1} α
         (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
         i
         (@vector.insert_nth.{u_1} (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) α a j v))
      (@vector.insert_nth.{u_1} n α a
         (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) i j
            (@_root_.ne.symm.{1}
               (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
               i
               j
               h))
         (@vector.remove_nth.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
            (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) j i h)
            v)),
i : nat,
hi :
  @has_lt.lt.{0} nat nat.has_lt i
    (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))),
j : nat,
hj :
  @has_lt.lt.{0} nat nat.has_lt j
    (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))),
ne :
  @_root_.ne.{1}
    (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) i hi)
    (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) j hj),
this : @_root_.ne.{1} nat i j,
h :
  @has_lt.lt.{0} nat
    (@preorder.to_has_lt.{0} nat
       (@partial_order.to_preorder.{0} nat (@linear_order.to_partial_order.{0} nat nat.linear_order)))
    i
    j
⊢ @eq.{u_1+1} (list.{u_1} α)
    (@list.remove_nth.{u_1} α
       (@list.insert_nth.{u_1} α j a
          (@subtype.val.{u_1+1} (list.{u_1} α)
             (λ (l : list.{u_1} α),
                @eq.{1} nat (@list.length.{u_1} α l)
                  (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
             v))
       i)
    (@list.insert_nth.{u_1} α
       (@fin.val (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
          (@dite.{1}
             (@has_lt.lt.{0}
                (fin
                   (@has_add.add.{0} nat nat.has_add
                      (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                      (@has_one.one.{0} nat nat.has_one)))
                (@fin.has_lt
                   (@has_add.add.{0} nat nat.has_add
                      (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                      (@has_one.one.{0} nat nat.has_one)))
                (@fin.mk
                   (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                   j
                   hj)
                (@fin.mk
                   (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                   i
                   hi))
             (@fin.decidable_lt
                (@has_add.add.{0} nat nat.has_add
                   (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                   (@has_one.one.{0} nat nat.has_one))
                (@fin.mk
                   (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                   j
                   hj)
                (@fin.mk
                   (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                   i
                   hi))
             (fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
             (λ
              (h :
                @has_lt.lt.{0}
                  (fin
                     (@has_add.add.{0} nat nat.has_add
                        (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                        (@has_one.one.{0} nat nat.has_one)))
                  (@fin.has_lt
                     (@has_add.add.{0} nat nat.has_add
                        (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                        (@has_one.one.{0} nat nat.has_one)))
                  (@fin.mk
                     (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                     j
                     hj)
                  (@fin.mk
                     (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                     i
                     hi)),
                @fin.mk (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) j
                  (@fin.pred_above._proof_1 (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        i
                        hi)
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        j
                        hj)
                     h))
             (λ
              (h :
                not
                  (@has_lt.lt.{0}
                     (fin
                        (@has_add.add.{0} nat nat.has_add
                           (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                           (@has_one.one.{0} nat nat.has_one)))
                     (@fin.has_lt
                        (@has_add.add.{0} nat nat.has_add
                           (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                           (@has_one.one.{0} nat nat.has_one)))
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        j
                        hj)
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        i
                        hi))),
                @fin.pred (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                  (@fin.mk
                     (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                     j
                     hj)
                  (@fin.pred_above._proof_2 (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        i
                        hi)
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        j
                        hj)
                     (@_root_.ne.symm.{1}
                        (fin
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           i
                           hi)
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           j
                           hj)
                        ne)
                     h))))
       a
       (@subtype.val.{u_1+1} (list.{u_1} α) (λ (l : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l) n)
          (@vector.remove_nth.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
             (@dite.{1}
                (@has_lt.lt.{0}
                   (fin
                      (@has_add.add.{0} nat nat.has_add
                         (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                         (@has_one.one.{0} nat nat.has_one)))
                   (@fin.has_lt
                      (@has_add.add.{0} nat nat.has_add
                         (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                         (@has_one.one.{0} nat nat.has_one)))
                   (@fin.mk
                      (@has_add.add.{0} nat nat.has_add n
                         (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                      i
                      hi)
                   (@fin.mk
                      (@has_add.add.{0} nat nat.has_add n
                         (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                      j
                      hj))
                (@fin.decidable_lt
                   (@has_add.add.{0} nat nat.has_add
                      (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                      (@has_one.one.{0} nat nat.has_one))
                   (@fin.mk
                      (@has_add.add.{0} nat nat.has_add n
                         (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                      i
                      hi)
                   (@fin.mk
                      (@has_add.add.{0} nat nat.has_add n
                         (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                      j
                      hj))
                (fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
                (λ
                 (h :
                   @has_lt.lt.{0}
                     (fin
                        (@has_add.add.{0} nat nat.has_add
                           (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                           (@has_one.one.{0} nat nat.has_one)))
                     (@fin.has_lt
                        (@has_add.add.{0} nat nat.has_add
                           (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                           (@has_one.one.{0} nat nat.has_one)))
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        i
                        hi)
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        j
                        hj)),
                   @fin.mk (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) i
                     (@fin.pred_above._proof_1 (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           j
                           hj)
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           i
                           hi)
                        h))
                (λ
                 (h :
                   not
                     (@has_lt.lt.{0}
                        (fin
                           (@has_add.add.{0} nat nat.has_add
                              (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                              (@has_one.one.{0} nat nat.has_one)))
                        (@fin.has_lt
                           (@has_add.add.{0} nat nat.has_add
                              (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                              (@has_one.one.{0} nat nat.has_one)))
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           i
                           hi)
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           j
                           hj))),
                   @fin.pred (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        i
                        hi)
                     (@fin.pred_above._proof_2 (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           j
                           hj)
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           i
                           hi)
                        ne
                        h)))
             v)))

n : nat,
α : Type u_1,
a : α,
v : vector.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)),
remove_nth_insert_nth_ne :
  ∀ {i j : fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))}
  (h :
    @_root_.ne.{1}
      (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
      i
      j),
    @eq.{(max 1 (u_1+1))}
      (vector.{u_1} α
         (@has_sub.sub.{0} nat nat.has_sub
            (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
            (@has_one.one.{0} nat nat.has_one)))
      (@vector.remove_nth.{u_1} α
         (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
         i
         (@vector.insert_nth.{u_1} (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) α a j v))
      (@vector.insert_nth.{u_1} n α a
         (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) i j
            (@_root_.ne.symm.{1}
               (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
               i
               j
               h))
         (@vector.remove_nth.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
            (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) j i h)
            v)),
i : nat,
hi :
  @has_lt.lt.{0} nat nat.has_lt i
    (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))),
j : nat,
hj :
  @has_lt.lt.{0} nat nat.has_lt j
    (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))),
ne :
  @_root_.ne.{1}
    (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) i hi)
    (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) j hj),
this : @_root_.ne.{1} nat i j,
h : @eq.{1} nat i j
⊢ @eq.{u_1+1} (list.{u_1} α)
    (@list.remove_nth.{u_1} α
       (@list.insert_nth.{u_1} α j a
          (@subtype.val.{u_1+1} (list.{u_1} α)
             (λ (l : list.{u_1} α),
                @eq.{1} nat (@list.length.{u_1} α l)
                  (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
             v))
       i)
    (@list.insert_nth.{u_1} α
       (@fin.val (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
          (@dite.{1}
             (@has_lt.lt.{0}
                (fin
                   (@has_add.add.{0} nat nat.has_add
                      (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                      (@has_one.one.{0} nat nat.has_one)))
                (@fin.has_lt
                   (@has_add.add.{0} nat nat.has_add
                      (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                      (@has_one.one.{0} nat nat.has_one)))
                (@fin.mk
                   (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                   j
                   hj)
                (@fin.mk
                   (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                   i
                   hi))
             (@fin.decidable_lt
                (@has_add.add.{0} nat nat.has_add
                   (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                   (@has_one.one.{0} nat nat.has_one))
                (@fin.mk
                   (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                   j
                   hj)
                (@fin.mk
                   (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                   i
                   hi))
             (fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
             (λ
              (h :
                @has_lt.lt.{0}
                  (fin
                     (@has_add.add.{0} nat nat.has_add
                        (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                        (@has_one.one.{0} nat nat.has_one)))
                  (@fin.has_lt
                     (@has_add.add.{0} nat nat.has_add
                        (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                        (@has_one.one.{0} nat nat.has_one)))
                  (@fin.mk
                     (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                     j
                     hj)
                  (@fin.mk
                     (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                     i
                     hi)),
                @fin.mk (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) j
                  (@fin.pred_above._proof_1 (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        i
                        hi)
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        j
                        hj)
                     h))
             (λ
              (h :
                not
                  (@has_lt.lt.{0}
                     (fin
                        (@has_add.add.{0} nat nat.has_add
                           (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                           (@has_one.one.{0} nat nat.has_one)))
                     (@fin.has_lt
                        (@has_add.add.{0} nat nat.has_add
                           (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                           (@has_one.one.{0} nat nat.has_one)))
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        j
                        hj)
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        i
                        hi))),
                @fin.pred (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                  (@fin.mk
                     (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                     j
                     hj)
                  (@fin.pred_above._proof_2 (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        i
                        hi)
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        j
                        hj)
                     (@_root_.ne.symm.{1}
                        (fin
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           i
                           hi)
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           j
                           hj)
                        ne)
                     h))))
       a
       (@subtype.val.{u_1+1} (list.{u_1} α) (λ (l : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l) n)
          (@vector.remove_nth.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
             (@dite.{1}
                (@has_lt.lt.{0}
                   (fin
                      (@has_add.add.{0} nat nat.has_add
                         (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                         (@has_one.one.{0} nat nat.has_one)))
                   (@fin.has_lt
                      (@has_add.add.{0} nat nat.has_add
                         (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                         (@has_one.one.{0} nat nat.has_one)))
                   (@fin.mk
                      (@has_add.add.{0} nat nat.has_add n
                         (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                      i
                      hi)
                   (@fin.mk
                      (@has_add.add.{0} nat nat.has_add n
                         (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                      j
                      hj))
                (@fin.decidable_lt
                   (@has_add.add.{0} nat nat.has_add
                      (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                      (@has_one.one.{0} nat nat.has_one))
                   (@fin.mk
                      (@has_add.add.{0} nat nat.has_add n
                         (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                      i
                      hi)
                   (@fin.mk
                      (@has_add.add.{0} nat nat.has_add n
                         (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                      j
                      hj))
                (fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
                (λ
                 (h :
                   @has_lt.lt.{0}
                     (fin
                        (@has_add.add.{0} nat nat.has_add
                           (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                           (@has_one.one.{0} nat nat.has_one)))
                     (@fin.has_lt
                        (@has_add.add.{0} nat nat.has_add
                           (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                           (@has_one.one.{0} nat nat.has_one)))
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        i
                        hi)
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        j
                        hj)),
                   @fin.mk (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) i
                     (@fin.pred_above._proof_1 (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           j
                           hj)
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           i
                           hi)
                        h))
                (λ
                 (h :
                   not
                     (@has_lt.lt.{0}
                        (fin
                           (@has_add.add.{0} nat nat.has_add
                              (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                              (@has_one.one.{0} nat nat.has_one)))
                        (@fin.has_lt
                           (@has_add.add.{0} nat nat.has_add
                              (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                              (@has_one.one.{0} nat nat.has_one)))
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           i
                           hi)
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           j
                           hj))),
                   @fin.pred (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        i
                        hi)
                     (@fin.pred_above._proof_2 (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           j
                           hj)
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           i
                           hi)
                        ne
                        h)))
             v)))

n : nat,
α : Type u_1,
a : α,
v : vector.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)),
remove_nth_insert_nth_ne :
  ∀ {i j : fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))}
  (h :
    @_root_.ne.{1}
      (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
      i
      j),
    @eq.{(max 1 (u_1+1))}
      (vector.{u_1} α
         (@has_sub.sub.{0} nat nat.has_sub
            (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
            (@has_one.one.{0} nat nat.has_one)))
      (@vector.remove_nth.{u_1} α
         (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
         i
         (@vector.insert_nth.{u_1} (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) α a j v))
      (@vector.insert_nth.{u_1} n α a
         (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) i j
            (@_root_.ne.symm.{1}
               (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
               i
               j
               h))
         (@vector.remove_nth.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
            (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) j i h)
            v)),
i : nat,
hi :
  @has_lt.lt.{0} nat nat.has_lt i
    (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))),
j : nat,
hj :
  @has_lt.lt.{0} nat nat.has_lt j
    (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))),
ne :
  @_root_.ne.{1}
    (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) i hi)
    (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) j hj),
this : @_root_.ne.{1} nat i j,
h :
  @has_lt.lt.{0} nat
    (@preorder.to_has_lt.{0} nat
       (@partial_order.to_preorder.{0} nat (@linear_order.to_partial_order.{0} nat nat.linear_order)))
    j
    i
⊢ @eq.{u_1+1} (list.{u_1} α)
    (@list.remove_nth.{u_1} α
       (@list.insert_nth.{u_1} α j a
          (@subtype.val.{u_1+1} (list.{u_1} α)
             (λ (l : list.{u_1} α),
                @eq.{1} nat (@list.length.{u_1} α l)
                  (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
             v))
       i)
    (@list.insert_nth.{u_1} α
       (@fin.val (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
          (@dite.{1}
             (@has_lt.lt.{0}
                (fin
                   (@has_add.add.{0} nat nat.has_add
                      (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                      (@has_one.one.{0} nat nat.has_one)))
                (@fin.has_lt
                   (@has_add.add.{0} nat nat.has_add
                      (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                      (@has_one.one.{0} nat nat.has_one)))
                (@fin.mk
                   (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                   j
                   hj)
                (@fin.mk
                   (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                   i
                   hi))
             (@fin.decidable_lt
                (@has_add.add.{0} nat nat.has_add
                   (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                   (@has_one.one.{0} nat nat.has_one))
                (@fin.mk
                   (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                   j
                   hj)
                (@fin.mk
                   (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                   i
                   hi))
             (fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
             (λ
              (h :
                @has_lt.lt.{0}
                  (fin
                     (@has_add.add.{0} nat nat.has_add
                        (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                        (@has_one.one.{0} nat nat.has_one)))
                  (@fin.has_lt
                     (@has_add.add.{0} nat nat.has_add
                        (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                        (@has_one.one.{0} nat nat.has_one)))
                  (@fin.mk
                     (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                     j
                     hj)
                  (@fin.mk
                     (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                     i
                     hi)),
                @fin.mk (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) j
                  (@fin.pred_above._proof_1 (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        i
                        hi)
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        j
                        hj)
                     h))
             (λ
              (h :
                not
                  (@has_lt.lt.{0}
                     (fin
                        (@has_add.add.{0} nat nat.has_add
                           (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                           (@has_one.one.{0} nat nat.has_one)))
                     (@fin.has_lt
                        (@has_add.add.{0} nat nat.has_add
                           (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                           (@has_one.one.{0} nat nat.has_one)))
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        j
                        hj)
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        i
                        hi))),
                @fin.pred (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                  (@fin.mk
                     (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                     j
                     hj)
                  (@fin.pred_above._proof_2 (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        i
                        hi)
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        j
                        hj)
                     (@_root_.ne.symm.{1}
                        (fin
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           i
                           hi)
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           j
                           hj)
                        ne)
                     h))))
       a
       (@subtype.val.{u_1+1} (list.{u_1} α) (λ (l : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l) n)
          (@vector.remove_nth.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
             (@dite.{1}
                (@has_lt.lt.{0}
                   (fin
                      (@has_add.add.{0} nat nat.has_add
                         (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                         (@has_one.one.{0} nat nat.has_one)))
                   (@fin.has_lt
                      (@has_add.add.{0} nat nat.has_add
                         (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                         (@has_one.one.{0} nat nat.has_one)))
                   (@fin.mk
                      (@has_add.add.{0} nat nat.has_add n
                         (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                      i
                      hi)
                   (@fin.mk
                      (@has_add.add.{0} nat nat.has_add n
                         (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                      j
                      hj))
                (@fin.decidable_lt
                   (@has_add.add.{0} nat nat.has_add
                      (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                      (@has_one.one.{0} nat nat.has_one))
                   (@fin.mk
                      (@has_add.add.{0} nat nat.has_add n
                         (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                      i
                      hi)
                   (@fin.mk
                      (@has_add.add.{0} nat nat.has_add n
                         (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                      j
                      hj))
                (fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
                (λ
                 (h :
                   @has_lt.lt.{0}
                     (fin
                        (@has_add.add.{0} nat nat.has_add
                           (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                           (@has_one.one.{0} nat nat.has_one)))
                     (@fin.has_lt
                        (@has_add.add.{0} nat nat.has_add
                           (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                           (@has_one.one.{0} nat nat.has_one)))
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        i
                        hi)
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        j
                        hj)),
                   @fin.mk (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) i
                     (@fin.pred_above._proof_1 (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           j
                           hj)
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           i
                           hi)
                        h))
                (λ
                 (h :
                   not
                     (@has_lt.lt.{0}
                        (fin
                           (@has_add.add.{0} nat nat.has_add
                              (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                              (@has_one.one.{0} nat nat.has_one)))
                        (@fin.has_lt
                           (@has_add.add.{0} nat nat.has_add
                              (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                              (@has_one.one.{0} nat nat.has_one)))
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           i
                           hi)
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           j
                           hj))),
                   @fin.pred (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        i
                        hi)
                     (@fin.pred_above._proof_2 (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           j
                           hj)
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           i
                           hi)
                        ne
                        h)))
             v)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : nat,
α : Type u_1,
a : α,
v : vector.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)),
remove_nth_insert_nth_ne :
  ∀ {i j : fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))}
  (h :
    @_root_.ne.{1}
      (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
      i
      j),
    @eq.{(max 1 (u_1+1))}
      (vector.{u_1} α
         (@has_sub.sub.{0} nat nat.has_sub
            (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
            (@has_one.one.{0} nat nat.has_one)))
      (@vector.remove_nth.{u_1} α
         (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
         i
         (@vector.insert_nth.{u_1} (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) α a j v))
      (@vector.insert_nth.{u_1} n α a
         (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) i j
            (@_root_.ne.symm.{1}
               (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
               i
               j
               h))
         (@vector.remove_nth.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
            (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) j i h)
            v)),
i : nat,
hi :
  @has_lt.lt.{0} nat nat.has_lt i
    (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))),
j : nat,
hj :
  @has_lt.lt.{0} nat nat.has_lt j
    (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))),
ne :
  @_root_.ne.{1}
    (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) i hi)
    (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) j hj),
this : @_root_.ne.{1} nat i j,
h :
  @has_lt.lt.{0} nat
    (@preorder.to_has_lt.{0} nat
       (@partial_order.to_preorder.{0} nat (@linear_order.to_partial_order.{0} nat nat.linear_order)))
    i
    j
⊢ @eq.{u_1+1} (list.{u_1} α)
    (@list.remove_nth.{u_1} α
       (@list.insert_nth.{u_1} α j a
          (@subtype.val.{u_1+1} (list.{u_1} α)
             (λ (l : list.{u_1} α),
                @eq.{1} nat (@list.length.{u_1} α l)
                  (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
             v))
       i)
    (@list.insert_nth.{u_1} α
       (@fin.val (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
          (@dite.{1}
             (@has_lt.lt.{0}
                (fin
                   (@has_add.add.{0} nat nat.has_add
                      (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                      (@has_one.one.{0} nat nat.has_one)))
                (@fin.has_lt
                   (@has_add.add.{0} nat nat.has_add
                      (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                      (@has_one.one.{0} nat nat.has_one)))
                (@fin.mk
                   (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                   j
                   hj)
                (@fin.mk
                   (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                   i
                   hi))
             (@fin.decidable_lt
                (@has_add.add.{0} nat nat.has_add
                   (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                   (@has_one.one.{0} nat nat.has_one))
                (@fin.mk
                   (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                   j
                   hj)
                (@fin.mk
                   (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                   i
                   hi))
             (fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
             (λ
              (h :
                @has_lt.lt.{0}
                  (fin
                     (@has_add.add.{0} nat nat.has_add
                        (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                        (@has_one.one.{0} nat nat.has_one)))
                  (@fin.has_lt
                     (@has_add.add.{0} nat nat.has_add
                        (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                        (@has_one.one.{0} nat nat.has_one)))
                  (@fin.mk
                     (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                     j
                     hj)
                  (@fin.mk
                     (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                     i
                     hi)),
                @fin.mk (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) j
                  (@fin.pred_above._proof_1 (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        i
                        hi)
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        j
                        hj)
                     h))
             (λ
              (h :
                not
                  (@has_lt.lt.{0}
                     (fin
                        (@has_add.add.{0} nat nat.has_add
                           (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                           (@has_one.one.{0} nat nat.has_one)))
                     (@fin.has_lt
                        (@has_add.add.{0} nat nat.has_add
                           (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                           (@has_one.one.{0} nat nat.has_one)))
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        j
                        hj)
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        i
                        hi))),
                @fin.pred (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                  (@fin.mk
                     (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                     j
                     hj)
                  (@fin.pred_above._proof_2 (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        i
                        hi)
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        j
                        hj)
                     (@_root_.ne.symm.{1}
                        (fin
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           i
                           hi)
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           j
                           hj)
                        ne)
                     h))))
       a
       (@subtype.val.{u_1+1} (list.{u_1} α) (λ (l : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l) n)
          (@vector.remove_nth.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
             (@dite.{1}
                (@has_lt.lt.{0}
                   (fin
                      (@has_add.add.{0} nat nat.has_add
                         (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                         (@has_one.one.{0} nat nat.has_one)))
                   (@fin.has_lt
                      (@has_add.add.{0} nat nat.has_add
                         (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                         (@has_one.one.{0} nat nat.has_one)))
                   (@fin.mk
                      (@has_add.add.{0} nat nat.has_add n
                         (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                      i
                      hi)
                   (@fin.mk
                      (@has_add.add.{0} nat nat.has_add n
                         (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                      j
                      hj))
                (@fin.decidable_lt
                   (@has_add.add.{0} nat nat.has_add
                      (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                      (@has_one.one.{0} nat nat.has_one))
                   (@fin.mk
                      (@has_add.add.{0} nat nat.has_add n
                         (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                      i
                      hi)
                   (@fin.mk
                      (@has_add.add.{0} nat nat.has_add n
                         (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                      j
                      hj))
                (fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
                (λ
                 (h :
                   @has_lt.lt.{0}
                     (fin
                        (@has_add.add.{0} nat nat.has_add
                           (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                           (@has_one.one.{0} nat nat.has_one)))
                     (@fin.has_lt
                        (@has_add.add.{0} nat nat.has_add
                           (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                           (@has_one.one.{0} nat nat.has_one)))
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        i
                        hi)
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        j
                        hj)),
                   @fin.mk (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) i
                     (@fin.pred_above._proof_1 (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           j
                           hj)
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           i
                           hi)
                        h))
                (λ
                 (h :
                   not
                     (@has_lt.lt.{0}
                        (fin
                           (@has_add.add.{0} nat nat.has_add
                              (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                              (@has_one.one.{0} nat nat.has_one)))
                        (@fin.has_lt
                           (@has_add.add.{0} nat nat.has_add
                              (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                              (@has_one.one.{0} nat nat.has_one)))
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           i
                           hi)
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           j
                           hj))),
                   @fin.pred (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        i
                        hi)
                     (@fin.pred_above._proof_2 (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           j
                           hj)
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           i
                           hi)
                        ne
                        h)))
             v)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : nat,
α : Type u_1,
a : α,
v : vector.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)),
remove_nth_insert_nth_ne :
  ∀ {i j : fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))}
  (h :
    @_root_.ne.{1}
      (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
      i
      j),
    @eq.{(max 1 (u_1+1))}
      (vector.{u_1} α
         (@has_sub.sub.{0} nat nat.has_sub
            (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
            (@has_one.one.{0} nat nat.has_one)))
      (@vector.remove_nth.{u_1} α
         (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
         i
         (@vector.insert_nth.{u_1} (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) α a j v))
      (@vector.insert_nth.{u_1} n α a
         (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) i j
            (@_root_.ne.symm.{1}
               (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
               i
               j
               h))
         (@vector.remove_nth.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
            (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) j i h)
            v)),
i : nat,
hi :
  @has_lt.lt.{0} nat nat.has_lt i
    (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))),
j : nat,
hj :
  @has_lt.lt.{0} nat nat.has_lt j
    (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))),
ne :
  @_root_.ne.{1}
    (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) i hi)
    (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) j hj),
this : @_root_.ne.{1} nat i j,
h :
  @has_lt.lt.{0} nat
    (@preorder.to_has_lt.{0} nat
       (@partial_order.to_preorder.{0} nat (@linear_order.to_partial_order.{0} nat nat.linear_order)))
    i
    j,
h_nji : not (@has_lt.lt.{0} nat nat.has_lt j i)
⊢ @eq.{u_1+1} (list.{u_1} α)
    (@list.remove_nth.{u_1} α
       (@list.insert_nth.{u_1} α j a
          (@subtype.val.{u_1+1} (list.{u_1} α)
             (λ (l : list.{u_1} α),
                @eq.{1} nat (@list.length.{u_1} α l)
                  (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
             v))
       i)
    (@list.insert_nth.{u_1} α
       (@fin.val (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
          (@dite.{1}
             (@has_lt.lt.{0}
                (fin
                   (@has_add.add.{0} nat nat.has_add
                      (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                      (@has_one.one.{0} nat nat.has_one)))
                (@fin.has_lt
                   (@has_add.add.{0} nat nat.has_add
                      (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                      (@has_one.one.{0} nat nat.has_one)))
                (@fin.mk
                   (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                   j
                   hj)
                (@fin.mk
                   (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                   i
                   hi))
             (@fin.decidable_lt
                (@has_add.add.{0} nat nat.has_add
                   (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                   (@has_one.one.{0} nat nat.has_one))
                (@fin.mk
                   (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                   j
                   hj)
                (@fin.mk
                   (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                   i
                   hi))
             (fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
             (λ
              (h :
                @has_lt.lt.{0}
                  (fin
                     (@has_add.add.{0} nat nat.has_add
                        (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                        (@has_one.one.{0} nat nat.has_one)))
                  (@fin.has_lt
                     (@has_add.add.{0} nat nat.has_add
                        (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                        (@has_one.one.{0} nat nat.has_one)))
                  (@fin.mk
                     (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                     j
                     hj)
                  (@fin.mk
                     (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                     i
                     hi)),
                @fin.mk (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) j
                  (@fin.pred_above._proof_1 (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        i
                        hi)
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        j
                        hj)
                     h))
             (λ
              (h :
                not
                  (@has_lt.lt.{0}
                     (fin
                        (@has_add.add.{0} nat nat.has_add
                           (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                           (@has_one.one.{0} nat nat.has_one)))
                     (@fin.has_lt
                        (@has_add.add.{0} nat nat.has_add
                           (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                           (@has_one.one.{0} nat nat.has_one)))
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        j
                        hj)
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        i
                        hi))),
                @fin.pred (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                  (@fin.mk
                     (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                     j
                     hj)
                  (@fin.pred_above._proof_2 (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        i
                        hi)
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        j
                        hj)
                     (@_root_.ne.symm.{1}
                        (fin
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           i
                           hi)
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           j
                           hj)
                        ne)
                     h))))
       a
       (@subtype.val.{u_1+1} (list.{u_1} α) (λ (l : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l) n)
          (@vector.remove_nth.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
             (@dite.{1}
                (@has_lt.lt.{0}
                   (fin
                      (@has_add.add.{0} nat nat.has_add
                         (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                         (@has_one.one.{0} nat nat.has_one)))
                   (@fin.has_lt
                      (@has_add.add.{0} nat nat.has_add
                         (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                         (@has_one.one.{0} nat nat.has_one)))
                   (@fin.mk
                      (@has_add.add.{0} nat nat.has_add n
                         (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                      i
                      hi)
                   (@fin.mk
                      (@has_add.add.{0} nat nat.has_add n
                         (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                      j
                      hj))
                (@fin.decidable_lt
                   (@has_add.add.{0} nat nat.has_add
                      (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                      (@has_one.one.{0} nat nat.has_one))
                   (@fin.mk
                      (@has_add.add.{0} nat nat.has_add n
                         (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                      i
                      hi)
                   (@fin.mk
                      (@has_add.add.{0} nat nat.has_add n
                         (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                      j
                      hj))
                (fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
                (λ
                 (h :
                   @has_lt.lt.{0}
                     (fin
                        (@has_add.add.{0} nat nat.has_add
                           (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                           (@has_one.one.{0} nat nat.has_one)))
                     (@fin.has_lt
                        (@has_add.add.{0} nat nat.has_add
                           (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                           (@has_one.one.{0} nat nat.has_one)))
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        i
                        hi)
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        j
                        hj)),
                   @fin.mk (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) i
                     (@fin.pred_above._proof_1 (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           j
                           hj)
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           i
                           hi)
                        h))
                (λ
                 (h :
                   not
                     (@has_lt.lt.{0}
                        (fin
                           (@has_add.add.{0} nat nat.has_add
                              (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                              (@has_one.one.{0} nat nat.has_one)))
                        (@fin.has_lt
                           (@has_add.add.{0} nat nat.has_add
                              (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                              (@has_one.one.{0} nat nat.has_one)))
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           i
                           hi)
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           j
                           hj))),
                   @fin.pred (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        i
                        hi)
                     (@fin.pred_above._proof_2 (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           j
                           hj)
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           i
                           hi)
                        ne
                        h)))
             v)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>171        have j_pos : 0 &lt; j := lt_of_le_of_lt (zero_le i) h,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='lt_of_le_of_lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='zero_le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 107, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/ordered_group.lean&#x27;, &#x27;line&#x27;: 355, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : preorder.{0} α] {a b c : α}, @has_le.le.{0} α (@preorder.to_has_le.{0} α _inst_1) a b → @has_lt.lt.{0} α (@preorder.to_has_lt.{0} α _inst_1) b c → @has_lt.lt.{0} α (@preorder.to_has_lt.{0} α _inst_1) a c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type} [_inst_1 : canonically_ordered_monoid.{0} α] (a : α), @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@ordered_comm_monoid.to_partial_order.{0} α (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} α _inst_1)))) (@has_zero.zero.{0} α (@add_monoid.to_has_zero.{0} α (@add_comm_monoid.to_add_monoid.{0} α (@ordered_comm_monoid.to_add_comm_monoid.{0} α (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} α _inst_1))))) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_lt.lt.{0} nat (@preorder.to_has_lt.{0} nat (@partial_order.to_preorder.{0} nat (@linear_order.to_partial_order.{0} nat nat.linear_order))) i j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : nat,
α : Type u_1,
a : α,
v : vector.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)),
remove_nth_insert_nth_ne :
  ∀ {i j : fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))}
  (h :
    @_root_.ne.{1}
      (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
      i
      j),
    @eq.{(max 1 (u_1+1))}
      (vector.{u_1} α
         (@has_sub.sub.{0} nat nat.has_sub
            (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
            (@has_one.one.{0} nat nat.has_one)))
      (@vector.remove_nth.{u_1} α
         (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
         i
         (@vector.insert_nth.{u_1} (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) α a j v))
      (@vector.insert_nth.{u_1} n α a
         (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) i j
            (@_root_.ne.symm.{1}
               (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
               i
               j
               h))
         (@vector.remove_nth.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
            (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) j i h)
            v)),
i : nat,
hi :
  @has_lt.lt.{0} nat nat.has_lt i
    (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))),
j : nat,
hj :
  @has_lt.lt.{0} nat nat.has_lt j
    (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))),
ne :
  @_root_.ne.{1}
    (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) i hi)
    (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) j hj),
this : @_root_.ne.{1} nat i j,
h :
  @has_lt.lt.{0} nat
    (@preorder.to_has_lt.{0} nat
       (@partial_order.to_preorder.{0} nat (@linear_order.to_partial_order.{0} nat nat.linear_order)))
    i
    j,
h_nji : not (@has_lt.lt.{0} nat nat.has_lt j i)
⊢ @eq.{u_1+1} (list.{u_1} α)
    (@list.remove_nth.{u_1} α
       (@list.insert_nth.{u_1} α j a
          (@subtype.val.{u_1+1} (list.{u_1} α)
             (λ (l : list.{u_1} α),
                @eq.{1} nat (@list.length.{u_1} α l)
                  (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
             v))
       i)
    (@list.insert_nth.{u_1} α
       (@fin.val (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
          (@dite.{1}
             (@has_lt.lt.{0}
                (fin
                   (@has_add.add.{0} nat nat.has_add
                      (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                      (@has_one.one.{0} nat nat.has_one)))
                (@fin.has_lt
                   (@has_add.add.{0} nat nat.has_add
                      (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                      (@has_one.one.{0} nat nat.has_one)))
                (@fin.mk
                   (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                   j
                   hj)
                (@fin.mk
                   (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                   i
                   hi))
             (@fin.decidable_lt
                (@has_add.add.{0} nat nat.has_add
                   (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                   (@has_one.one.{0} nat nat.has_one))
                (@fin.mk
                   (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                   j
                   hj)
                (@fin.mk
                   (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                   i
                   hi))
             (fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
             (λ
              (h :
                @has_lt.lt.{0}
                  (fin
                     (@has_add.add.{0} nat nat.has_add
                        (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                        (@has_one.one.{0} nat nat.has_one)))
                  (@fin.has_lt
                     (@has_add.add.{0} nat nat.has_add
                        (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                        (@has_one.one.{0} nat nat.has_one)))
                  (@fin.mk
                     (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                     j
                     hj)
                  (@fin.mk
                     (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                     i
                     hi)),
                @fin.mk (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) j
                  (@fin.pred_above._proof_1 (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        i
                        hi)
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        j
                        hj)
                     h))
             (λ
              (h :
                not
                  (@has_lt.lt.{0}
                     (fin
                        (@has_add.add.{0} nat nat.has_add
                           (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                           (@has_one.one.{0} nat nat.has_one)))
                     (@fin.has_lt
                        (@has_add.add.{0} nat nat.has_add
                           (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                           (@has_one.one.{0} nat nat.has_one)))
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        j
                        hj)
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        i
                        hi))),
                @fin.pred (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                  (@fin.mk
                     (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                     j
                     hj)
                  (@fin.pred_above._proof_2 (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        i
                        hi)
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        j
                        hj)
                     (@_root_.ne.symm.{1}
                        (fin
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           i
                           hi)
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           j
                           hj)
                        ne)
                     h))))
       a
       (@subtype.val.{u_1+1} (list.{u_1} α) (λ (l : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l) n)
          (@vector.remove_nth.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
             (@dite.{1}
                (@has_lt.lt.{0}
                   (fin
                      (@has_add.add.{0} nat nat.has_add
                         (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                         (@has_one.one.{0} nat nat.has_one)))
                   (@fin.has_lt
                      (@has_add.add.{0} nat nat.has_add
                         (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                         (@has_one.one.{0} nat nat.has_one)))
                   (@fin.mk
                      (@has_add.add.{0} nat nat.has_add n
                         (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                      i
                      hi)
                   (@fin.mk
                      (@has_add.add.{0} nat nat.has_add n
                         (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                      j
                      hj))
                (@fin.decidable_lt
                   (@has_add.add.{0} nat nat.has_add
                      (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                      (@has_one.one.{0} nat nat.has_one))
                   (@fin.mk
                      (@has_add.add.{0} nat nat.has_add n
                         (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                      i
                      hi)
                   (@fin.mk
                      (@has_add.add.{0} nat nat.has_add n
                         (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                      j
                      hj))
                (fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
                (λ
                 (h :
                   @has_lt.lt.{0}
                     (fin
                        (@has_add.add.{0} nat nat.has_add
                           (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                           (@has_one.one.{0} nat nat.has_one)))
                     (@fin.has_lt
                        (@has_add.add.{0} nat nat.has_add
                           (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                           (@has_one.one.{0} nat nat.has_one)))
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        i
                        hi)
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        j
                        hj)),
                   @fin.mk (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) i
                     (@fin.pred_above._proof_1 (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           j
                           hj)
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           i
                           hi)
                        h))
                (λ
                 (h :
                   not
                     (@has_lt.lt.{0}
                        (fin
                           (@has_add.add.{0} nat nat.has_add
                              (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                              (@has_one.one.{0} nat nat.has_one)))
                        (@fin.has_lt
                           (@has_add.add.{0} nat nat.has_add
                              (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                              (@has_one.one.{0} nat nat.has_one)))
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           i
                           hi)
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           j
                           hj))),
                   @fin.pred (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        i
                        hi)
                     (@fin.pred_above._proof_2 (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           j
                           hj)
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           i
                           hi)
                        ne
                        h)))
             v)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : nat,
α : Type u_1,
a : α,
v : vector.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)),
remove_nth_insert_nth_ne :
  ∀ {i j : fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))}
  (h :
    @_root_.ne.{1}
      (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
      i
      j),
    @eq.{(max 1 (u_1+1))}
      (vector.{u_1} α
         (@has_sub.sub.{0} nat nat.has_sub
            (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
            (@has_one.one.{0} nat nat.has_one)))
      (@vector.remove_nth.{u_1} α
         (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
         i
         (@vector.insert_nth.{u_1} (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) α a j v))
      (@vector.insert_nth.{u_1} n α a
         (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) i j
            (@_root_.ne.symm.{1}
               (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
               i
               j
               h))
         (@vector.remove_nth.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
            (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) j i h)
            v)),
i : nat,
hi :
  @has_lt.lt.{0} nat nat.has_lt i
    (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))),
j : nat,
hj :
  @has_lt.lt.{0} nat nat.has_lt j
    (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))),
ne :
  @_root_.ne.{1}
    (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) i hi)
    (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) j hj),
this : @_root_.ne.{1} nat i j,
h :
  @has_lt.lt.{0} nat
    (@preorder.to_has_lt.{0} nat
       (@partial_order.to_preorder.{0} nat (@linear_order.to_partial_order.{0} nat nat.linear_order)))
    i
    j,
h_nji : not (@has_lt.lt.{0} nat nat.has_lt j i),
j_pos : @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) j
⊢ @eq.{u_1+1} (list.{u_1} α)
    (@list.remove_nth.{u_1} α
       (@list.insert_nth.{u_1} α j a
          (@subtype.val.{u_1+1} (list.{u_1} α)
             (λ (l : list.{u_1} α),
                @eq.{1} nat (@list.length.{u_1} α l)
                  (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
             v))
       i)
    (@list.insert_nth.{u_1} α
       (@fin.val (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
          (@dite.{1}
             (@has_lt.lt.{0}
                (fin
                   (@has_add.add.{0} nat nat.has_add
                      (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                      (@has_one.one.{0} nat nat.has_one)))
                (@fin.has_lt
                   (@has_add.add.{0} nat nat.has_add
                      (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                      (@has_one.one.{0} nat nat.has_one)))
                (@fin.mk
                   (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                   j
                   hj)
                (@fin.mk
                   (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                   i
                   hi))
             (@fin.decidable_lt
                (@has_add.add.{0} nat nat.has_add
                   (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                   (@has_one.one.{0} nat nat.has_one))
                (@fin.mk
                   (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                   j
                   hj)
                (@fin.mk
                   (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                   i
                   hi))
             (fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
             (λ
              (h :
                @has_lt.lt.{0}
                  (fin
                     (@has_add.add.{0} nat nat.has_add
                        (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                        (@has_one.one.{0} nat nat.has_one)))
                  (@fin.has_lt
                     (@has_add.add.{0} nat nat.has_add
                        (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                        (@has_one.one.{0} nat nat.has_one)))
                  (@fin.mk
                     (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                     j
                     hj)
                  (@fin.mk
                     (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                     i
                     hi)),
                @fin.mk (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) j
                  (@fin.pred_above._proof_1 (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        i
                        hi)
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        j
                        hj)
                     h))
             (λ
              (h :
                not
                  (@has_lt.lt.{0}
                     (fin
                        (@has_add.add.{0} nat nat.has_add
                           (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                           (@has_one.one.{0} nat nat.has_one)))
                     (@fin.has_lt
                        (@has_add.add.{0} nat nat.has_add
                           (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                           (@has_one.one.{0} nat nat.has_one)))
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        j
                        hj)
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        i
                        hi))),
                @fin.pred (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                  (@fin.mk
                     (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                     j
                     hj)
                  (@fin.pred_above._proof_2 (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        i
                        hi)
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        j
                        hj)
                     (@_root_.ne.symm.{1}
                        (fin
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           i
                           hi)
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           j
                           hj)
                        ne)
                     h))))
       a
       (@subtype.val.{u_1+1} (list.{u_1} α) (λ (l : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l) n)
          (@vector.remove_nth.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
             (@dite.{1}
                (@has_lt.lt.{0}
                   (fin
                      (@has_add.add.{0} nat nat.has_add
                         (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                         (@has_one.one.{0} nat nat.has_one)))
                   (@fin.has_lt
                      (@has_add.add.{0} nat nat.has_add
                         (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                         (@has_one.one.{0} nat nat.has_one)))
                   (@fin.mk
                      (@has_add.add.{0} nat nat.has_add n
                         (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                      i
                      hi)
                   (@fin.mk
                      (@has_add.add.{0} nat nat.has_add n
                         (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                      j
                      hj))
                (@fin.decidable_lt
                   (@has_add.add.{0} nat nat.has_add
                      (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                      (@has_one.one.{0} nat nat.has_one))
                   (@fin.mk
                      (@has_add.add.{0} nat nat.has_add n
                         (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                      i
                      hi)
                   (@fin.mk
                      (@has_add.add.{0} nat nat.has_add n
                         (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                      j
                      hj))
                (fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
                (λ
                 (h :
                   @has_lt.lt.{0}
                     (fin
                        (@has_add.add.{0} nat nat.has_add
                           (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                           (@has_one.one.{0} nat nat.has_one)))
                     (@fin.has_lt
                        (@has_add.add.{0} nat nat.has_add
                           (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                           (@has_one.one.{0} nat nat.has_one)))
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        i
                        hi)
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        j
                        hj)),
                   @fin.mk (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) i
                     (@fin.pred_above._proof_1 (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           j
                           hj)
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           i
                           hi)
                        h))
                (λ
                 (h :
                   not
                     (@has_lt.lt.{0}
                        (fin
                           (@has_add.add.{0} nat nat.has_add
                              (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                              (@has_one.one.{0} nat nat.has_one)))
                        (@fin.has_lt
                           (@has_add.add.{0} nat nat.has_add
                              (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                              (@has_one.one.{0} nat nat.has_one)))
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           i
                           hi)
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           j
                           hj))),
                   @fin.pred (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        i
                        hi)
                     (@fin.pred_above._proof_2 (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           j
                           hj)
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           i
                           hi)
                        ne
                        h)))
             v)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>172        simp [h, h_nji, fin.lt_iff_val_lt_val],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='h_nji'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='fin.lt_iff_val_lt_val'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/fin.lean&#x27;, &#x27;line&#x27;: 64, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_lt.lt.{0} nat (@preorder.to_has_lt.{0} nat (@partial_order.to_preorder.{0} nat (@linear_order.to_partial_order.{0} nat nat.linear_order))) i j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='not (@has_lt.lt.{0} nat nat.has_lt j i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {n : nat} {a b : fin n}, iff (@has_lt.lt.{0} (fin n) (@fin.has_lt n) a b) (@has_lt.lt.{0} nat nat.has_lt (@fin.val n a) (@fin.val n b))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : nat,
α : Type u_1,
a : α,
v : vector.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)),
remove_nth_insert_nth_ne :
  ∀ {i j : fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))}
  (h :
    @_root_.ne.{1}
      (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
      i
      j),
    @eq.{(max 1 (u_1+1))}
      (vector.{u_1} α
         (@has_sub.sub.{0} nat nat.has_sub
            (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
            (@has_one.one.{0} nat nat.has_one)))
      (@vector.remove_nth.{u_1} α
         (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
         i
         (@vector.insert_nth.{u_1} (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) α a j v))
      (@vector.insert_nth.{u_1} n α a
         (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) i j
            (@_root_.ne.symm.{1}
               (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
               i
               j
               h))
         (@vector.remove_nth.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
            (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) j i h)
            v)),
i : nat,
hi :
  @has_lt.lt.{0} nat nat.has_lt i
    (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))),
j : nat,
hj :
  @has_lt.lt.{0} nat nat.has_lt j
    (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))),
ne :
  @_root_.ne.{1}
    (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) i hi)
    (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) j hj),
this : @_root_.ne.{1} nat i j,
h :
  @has_lt.lt.{0} nat
    (@preorder.to_has_lt.{0} nat
       (@partial_order.to_preorder.{0} nat (@linear_order.to_partial_order.{0} nat nat.linear_order)))
    i
    j,
h_nji : not (@has_lt.lt.{0} nat nat.has_lt j i),
j_pos : @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) j
⊢ @eq.{u_1+1} (list.{u_1} α)
    (@list.remove_nth.{u_1} α
       (@list.insert_nth.{u_1} α j a
          (@subtype.val.{u_1+1} (list.{u_1} α)
             (λ (l : list.{u_1} α),
                @eq.{1} nat (@list.length.{u_1} α l)
                  (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
             v))
       i)
    (@list.insert_nth.{u_1} α
       (@fin.val (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
          (@dite.{1}
             (@has_lt.lt.{0}
                (fin
                   (@has_add.add.{0} nat nat.has_add
                      (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                      (@has_one.one.{0} nat nat.has_one)))
                (@fin.has_lt
                   (@has_add.add.{0} nat nat.has_add
                      (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                      (@has_one.one.{0} nat nat.has_one)))
                (@fin.mk
                   (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                   j
                   hj)
                (@fin.mk
                   (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                   i
                   hi))
             (@fin.decidable_lt
                (@has_add.add.{0} nat nat.has_add
                   (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                   (@has_one.one.{0} nat nat.has_one))
                (@fin.mk
                   (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                   j
                   hj)
                (@fin.mk
                   (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                   i
                   hi))
             (fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
             (λ
              (h :
                @has_lt.lt.{0}
                  (fin
                     (@has_add.add.{0} nat nat.has_add
                        (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                        (@has_one.one.{0} nat nat.has_one)))
                  (@fin.has_lt
                     (@has_add.add.{0} nat nat.has_add
                        (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                        (@has_one.one.{0} nat nat.has_one)))
                  (@fin.mk
                     (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                     j
                     hj)
                  (@fin.mk
                     (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                     i
                     hi)),
                @fin.mk (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) j
                  (@fin.pred_above._proof_1 (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        i
                        hi)
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        j
                        hj)
                     h))
             (λ
              (h :
                not
                  (@has_lt.lt.{0}
                     (fin
                        (@has_add.add.{0} nat nat.has_add
                           (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                           (@has_one.one.{0} nat nat.has_one)))
                     (@fin.has_lt
                        (@has_add.add.{0} nat nat.has_add
                           (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                           (@has_one.one.{0} nat nat.has_one)))
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        j
                        hj)
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        i
                        hi))),
                @fin.pred (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                  (@fin.mk
                     (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                     j
                     hj)
                  (@fin.pred_above._proof_2 (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        i
                        hi)
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        j
                        hj)
                     (@_root_.ne.symm.{1}
                        (fin
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           i
                           hi)
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           j
                           hj)
                        ne)
                     h))))
       a
       (@subtype.val.{u_1+1} (list.{u_1} α) (λ (l : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l) n)
          (@vector.remove_nth.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
             (@dite.{1}
                (@has_lt.lt.{0}
                   (fin
                      (@has_add.add.{0} nat nat.has_add
                         (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                         (@has_one.one.{0} nat nat.has_one)))
                   (@fin.has_lt
                      (@has_add.add.{0} nat nat.has_add
                         (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                         (@has_one.one.{0} nat nat.has_one)))
                   (@fin.mk
                      (@has_add.add.{0} nat nat.has_add n
                         (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                      i
                      hi)
                   (@fin.mk
                      (@has_add.add.{0} nat nat.has_add n
                         (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                      j
                      hj))
                (@fin.decidable_lt
                   (@has_add.add.{0} nat nat.has_add
                      (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                      (@has_one.one.{0} nat nat.has_one))
                   (@fin.mk
                      (@has_add.add.{0} nat nat.has_add n
                         (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                      i
                      hi)
                   (@fin.mk
                      (@has_add.add.{0} nat nat.has_add n
                         (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                      j
                      hj))
                (fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
                (λ
                 (h :
                   @has_lt.lt.{0}
                     (fin
                        (@has_add.add.{0} nat nat.has_add
                           (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                           (@has_one.one.{0} nat nat.has_one)))
                     (@fin.has_lt
                        (@has_add.add.{0} nat nat.has_add
                           (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                           (@has_one.one.{0} nat nat.has_one)))
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        i
                        hi)
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        j
                        hj)),
                   @fin.mk (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) i
                     (@fin.pred_above._proof_1 (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           j
                           hj)
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           i
                           hi)
                        h))
                (λ
                 (h :
                   not
                     (@has_lt.lt.{0}
                        (fin
                           (@has_add.add.{0} nat nat.has_add
                              (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                              (@has_one.one.{0} nat nat.has_one)))
                        (@fin.has_lt
                           (@has_add.add.{0} nat nat.has_add
                              (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                              (@has_one.one.{0} nat nat.has_one)))
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           i
                           hi)
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           j
                           hj))),
                   @fin.pred (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        i
                        hi)
                     (@fin.pred_above._proof_2 (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           j
                           hj)
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           i
                           hi)
                        ne
                        h)))
             v)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : nat,
α : Type u_1,
a : α,
v : vector.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)),
remove_nth_insert_nth_ne :
  ∀ {i j : fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))}
  (h :
    @_root_.ne.{1}
      (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
      i
      j),
    @eq.{(max 1 (u_1+1))}
      (vector.{u_1} α
         (@has_sub.sub.{0} nat nat.has_sub
            (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
            (@has_one.one.{0} nat nat.has_one)))
      (@vector.remove_nth.{u_1} α
         (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
         i
         (@vector.insert_nth.{u_1} (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) α a j v))
      (@vector.insert_nth.{u_1} n α a
         (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) i j
            (@_root_.ne.symm.{1}
               (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
               i
               j
               h))
         (@vector.remove_nth.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
            (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) j i h)
            v)),
i : nat,
hi :
  @has_lt.lt.{0} nat nat.has_lt i
    (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))),
j : nat,
hj :
  @has_lt.lt.{0} nat nat.has_lt j
    (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))),
ne :
  @_root_.ne.{1}
    (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) i hi)
    (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) j hj),
this : @_root_.ne.{1} nat i j,
h :
  @has_lt.lt.{0} nat
    (@preorder.to_has_lt.{0} nat
       (@partial_order.to_preorder.{0} nat (@linear_order.to_partial_order.{0} nat nat.linear_order)))
    i
    j,
h_nji : not (@has_lt.lt.{0} nat nat.has_lt j i),
j_pos : @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) j
⊢ @eq.{u_1+1} (list.{u_1} α)
    (@list.remove_nth.{u_1} α
       (@list.insert_nth.{u_1} α j a
          (@subtype.val.{u_1+1} (list.{u_1} α)
             (λ (l : list.{u_1} α),
                @eq.{1} nat (@list.length.{u_1} α l)
                  (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
             v))
       i)
    (@list.insert_nth.{u_1} α (nat.pred j) a
       (@list.remove_nth.{u_1} α
          (@subtype.val.{u_1+1} (list.{u_1} α)
             (λ (l : list.{u_1} α),
                @eq.{1} nat (@list.length.{u_1} α l)
                  (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
             v)
          i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>173        rw [show j.pred = j - 1, from rfl, list.insert_nth_remove_nth_of_ge, nat.sub_add_cancel j_pos],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='nat.pred'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_sub.sub'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='list.insert_nth_remove_nth_of_ge'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='nat.sub_add_cancel'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j_pos'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/nat/basic.lean&#x27;, &#x27;line&#x27;: 26, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 315, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/list/basic.lean&#x27;, &#x27;line&#x27;: 1049, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/nat/lemmas.lean&#x27;, &#x27;line&#x27;: 594, &#x27;column&#x27;: 18}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} [c : has_sub.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} {a : α}, @eq.{1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {a : α} (n m : nat) (as : list.{u_1} α), @has_lt.lt.{0} nat nat.has_lt n (@list.length.{u_1} α as) → @ge.{0} nat nat.has_le m n → @eq.{u_1+1} (list.{u_1} α) (@list.insert_nth.{u_1} α m a (@list.remove_nth.{u_1} α as n)) (@list.remove_nth.{u_1} α (@list.insert_nth.{u_1} α (@has_add.add.{0} nat nat.has_add m (@has_one.one.{0} nat nat.has_one)) a as) n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {n m : nat}, @ge.{0} nat nat.has_le n m → @eq.{1} nat (@has_add.add.{0} nat nat.has_add (@has_sub.sub.{0} nat nat.has_sub n m) m) n'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) j'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : nat,
α : Type u_1,
a : α,
v : vector.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)),
remove_nth_insert_nth_ne :
  ∀ {i j : fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))}
  (h :
    @_root_.ne.{1}
      (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
      i
      j),
    @eq.{(max 1 (u_1+1))}
      (vector.{u_1} α
         (@has_sub.sub.{0} nat nat.has_sub
            (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
            (@has_one.one.{0} nat nat.has_one)))
      (@vector.remove_nth.{u_1} α
         (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
         i
         (@vector.insert_nth.{u_1} (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) α a j v))
      (@vector.insert_nth.{u_1} n α a
         (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) i j
            (@_root_.ne.symm.{1}
               (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
               i
               j
               h))
         (@vector.remove_nth.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
            (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) j i h)
            v)),
i : nat,
hi :
  @has_lt.lt.{0} nat nat.has_lt i
    (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))),
j : nat,
hj :
  @has_lt.lt.{0} nat nat.has_lt j
    (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))),
ne :
  @_root_.ne.{1}
    (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) i hi)
    (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) j hj),
this : @_root_.ne.{1} nat i j,
h :
  @has_lt.lt.{0} nat
    (@preorder.to_has_lt.{0} nat
       (@partial_order.to_preorder.{0} nat (@linear_order.to_partial_order.{0} nat nat.linear_order)))
    i
    j,
h_nji : not (@has_lt.lt.{0} nat nat.has_lt j i),
j_pos : @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) j
⊢ @eq.{u_1+1} (list.{u_1} α)
    (@list.remove_nth.{u_1} α
       (@list.insert_nth.{u_1} α j a
          (@subtype.val.{u_1+1} (list.{u_1} α)
             (λ (l : list.{u_1} α),
                @eq.{1} nat (@list.length.{u_1} α l)
                  (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
             v))
       i)
    (@list.insert_nth.{u_1} α (nat.pred j) a
       (@list.remove_nth.{u_1} α
          (@subtype.val.{u_1+1} (list.{u_1} α)
             (λ (l : list.{u_1} α),
                @eq.{1} nat (@list.length.{u_1} α l)
                  (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
             v)
          i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : nat,
α : Type u_1,
a : α,
v : vector.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)),
remove_nth_insert_nth_ne :
  ∀ {i j : fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))}
  (h :
    @_root_.ne.{1}
      (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
      i
      j),
    @eq.{(max 1 (u_1+1))}
      (vector.{u_1} α
         (@has_sub.sub.{0} nat nat.has_sub
            (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
            (@has_one.one.{0} nat nat.has_one)))
      (@vector.remove_nth.{u_1} α
         (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
         i
         (@vector.insert_nth.{u_1} (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) α a j v))
      (@vector.insert_nth.{u_1} n α a
         (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) i j
            (@_root_.ne.symm.{1}
               (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
               i
               j
               h))
         (@vector.remove_nth.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
            (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) j i h)
            v)),
i : nat,
hi :
  @has_lt.lt.{0} nat nat.has_lt i
    (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))),
j : nat,
hj :
  @has_lt.lt.{0} nat nat.has_lt j
    (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))),
ne :
  @_root_.ne.{1}
    (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) i hi)
    (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) j hj),
this : @_root_.ne.{1} nat i j,
h :
  @has_lt.lt.{0} nat
    (@preorder.to_has_lt.{0} nat
       (@partial_order.to_preorder.{0} nat (@linear_order.to_partial_order.{0} nat nat.linear_order)))
    i
    j,
h_nji : not (@has_lt.lt.{0} nat nat.has_lt j i),
j_pos : @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) j
⊢ @eq.{u_1+1} (list.{u_1} α)
    (@list.remove_nth.{u_1} α
       (@list.insert_nth.{u_1} α j a
          (@subtype.val.{u_1+1} (list.{u_1} α)
             (λ (l : list.{u_1} α),
                @eq.{1} nat (@list.length.{u_1} α l)
                  (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
             v))
       i)
    (@list.insert_nth.{u_1} α (@has_sub.sub.{0} nat nat.has_sub j (@has_one.one.{0} nat nat.has_one)) a
       (@list.remove_nth.{u_1} α
          (@subtype.val.{u_1+1} (list.{u_1} α)
             (λ (l : list.{u_1} α),
                @eq.{1} nat (@list.length.{u_1} α l)
                  (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
             v)
          i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
n : nat,
α : Type u_1,
a : α,
v : vector.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)),
remove_nth_insert_nth_ne :
  ∀ {i j : fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))}
  (h :
    @_root_.ne.{1}
      (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
      i
      j),
    @eq.{(max 1 (u_1+1))}
      (vector.{u_1} α
         (@has_sub.sub.{0} nat nat.has_sub
            (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
            (@has_one.one.{0} nat nat.has_one)))
      (@vector.remove_nth.{u_1} α
         (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
         i
         (@vector.insert_nth.{u_1} (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) α a j v))
      (@vector.insert_nth.{u_1} n α a
         (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) i j
            (@_root_.ne.symm.{1}
               (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
               i
               j
               h))
         (@vector.remove_nth.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
            (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) j i h)
            v)),
i : nat,
hi :
  @has_lt.lt.{0} nat nat.has_lt i
    (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))),
j : nat,
hj :
  @has_lt.lt.{0} nat nat.has_lt j
    (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))),
ne :
  @_root_.ne.{1}
    (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) i hi)
    (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) j hj),
this : @_root_.ne.{1} nat i j,
h :
  @has_lt.lt.{0} nat
    (@preorder.to_has_lt.{0} nat
       (@partial_order.to_preorder.{0} nat (@linear_order.to_partial_order.{0} nat nat.linear_order)))
    i
    j,
h_nji : not (@has_lt.lt.{0} nat nat.has_lt j i),
j_pos : @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) j
⊢ @eq.{u_1+1} (list.{u_1} α)
    (@list.remove_nth.{u_1} α
       (@list.insert_nth.{u_1} α j a
          (@subtype.val.{u_1+1} (list.{u_1} α)
             (λ (l : list.{u_1} α),
                @eq.{1} nat (@list.length.{u_1} α l)
                  (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
             v))
       i)
    (@list.remove_nth.{u_1} α
       (@list.insert_nth.{u_1} α
          (@has_add.add.{0} nat nat.has_add (@has_sub.sub.{0} nat nat.has_sub j (@has_one.one.{0} nat nat.has_one))
             (@has_one.one.{0} nat nat.has_one))
          a
          (@subtype.val.{u_1+1} (list.{u_1} α)
             (λ (l : list.{u_1} α),
                @eq.{1} nat (@list.length.{u_1} α l)
                  (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
             v))
       i)

n : nat,
α : Type u_1,
a : α,
v : vector.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)),
remove_nth_insert_nth_ne :
  ∀ {i j : fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))}
  (h :
    @_root_.ne.{1}
      (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
      i
      j),
    @eq.{(max 1 (u_1+1))}
      (vector.{u_1} α
         (@has_sub.sub.{0} nat nat.has_sub
            (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
            (@has_one.one.{0} nat nat.has_one)))
      (@vector.remove_nth.{u_1} α
         (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
         i
         (@vector.insert_nth.{u_1} (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) α a j v))
      (@vector.insert_nth.{u_1} n α a
         (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) i j
            (@_root_.ne.symm.{1}
               (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
               i
               j
               h))
         (@vector.remove_nth.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
            (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) j i h)
            v)),
i : nat,
hi :
  @has_lt.lt.{0} nat nat.has_lt i
    (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))),
j : nat,
hj :
  @has_lt.lt.{0} nat nat.has_lt j
    (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))),
ne :
  @_root_.ne.{1}
    (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) i hi)
    (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) j hj),
this : @_root_.ne.{1} nat i j,
h :
  @has_lt.lt.{0} nat
    (@preorder.to_has_lt.{0} nat
       (@partial_order.to_preorder.{0} nat (@linear_order.to_partial_order.{0} nat nat.linear_order)))
    i
    j,
h_nji : not (@has_lt.lt.{0} nat nat.has_lt j i),
j_pos : @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) j
⊢ @has_lt.lt.{0} nat nat.has_lt i
    (@list.length.{u_1} α
       (@subtype.val.{u_1+1} (list.{u_1} α)
          (λ (l : list.{u_1} α),
             @eq.{1} nat (@list.length.{u_1} α l)
               (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
          v))

n : nat,
α : Type u_1,
a : α,
v : vector.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)),
remove_nth_insert_nth_ne :
  ∀ {i j : fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))}
  (h :
    @_root_.ne.{1}
      (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
      i
      j),
    @eq.{(max 1 (u_1+1))}
      (vector.{u_1} α
         (@has_sub.sub.{0} nat nat.has_sub
            (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
            (@has_one.one.{0} nat nat.has_one)))
      (@vector.remove_nth.{u_1} α
         (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
         i
         (@vector.insert_nth.{u_1} (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) α a j v))
      (@vector.insert_nth.{u_1} n α a
         (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) i j
            (@_root_.ne.symm.{1}
               (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
               i
               j
               h))
         (@vector.remove_nth.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
            (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) j i h)
            v)),
i : nat,
hi :
  @has_lt.lt.{0} nat nat.has_lt i
    (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))),
j : nat,
hj :
  @has_lt.lt.{0} nat nat.has_lt j
    (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))),
ne :
  @_root_.ne.{1}
    (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) i hi)
    (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) j hj),
this : @_root_.ne.{1} nat i j,
h :
  @has_lt.lt.{0} nat
    (@preorder.to_has_lt.{0} nat
       (@partial_order.to_preorder.{0} nat (@linear_order.to_partial_order.{0} nat nat.linear_order)))
    i
    j,
h_nji : not (@has_lt.lt.{0} nat nat.has_lt j i),
j_pos : @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) j
⊢ @ge.{0} nat nat.has_le (@has_sub.sub.{0} nat nat.has_sub j (@has_one.one.{0} nat nat.has_one)) i'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
n : nat,
α : Type u_1,
a : α,
v : vector.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)),
remove_nth_insert_nth_ne :
  ∀ {i j : fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))}
  (h :
    @_root_.ne.{1}
      (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
      i
      j),
    @eq.{(max 1 (u_1+1))}
      (vector.{u_1} α
         (@has_sub.sub.{0} nat nat.has_sub
            (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
            (@has_one.one.{0} nat nat.has_one)))
      (@vector.remove_nth.{u_1} α
         (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
         i
         (@vector.insert_nth.{u_1} (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) α a j v))
      (@vector.insert_nth.{u_1} n α a
         (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) i j
            (@_root_.ne.symm.{1}
               (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
               i
               j
               h))
         (@vector.remove_nth.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
            (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) j i h)
            v)),
i : nat,
hi :
  @has_lt.lt.{0} nat nat.has_lt i
    (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))),
j : nat,
hj :
  @has_lt.lt.{0} nat nat.has_lt j
    (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))),
ne :
  @_root_.ne.{1}
    (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) i hi)
    (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) j hj),
this : @_root_.ne.{1} nat i j,
h :
  @has_lt.lt.{0} nat
    (@preorder.to_has_lt.{0} nat
       (@partial_order.to_preorder.{0} nat (@linear_order.to_partial_order.{0} nat nat.linear_order)))
    i
    j,
h_nji : not (@has_lt.lt.{0} nat nat.has_lt j i),
j_pos : @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) j
⊢ @has_lt.lt.{0} nat nat.has_lt i
    (@list.length.{u_1} α
       (@subtype.val.{u_1+1} (list.{u_1} α)
          (λ (l : list.{u_1} α),
             @eq.{1} nat (@list.length.{u_1} α l)
               (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
          v))

n : nat,
α : Type u_1,
a : α,
v : vector.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)),
remove_nth_insert_nth_ne :
  ∀ {i j : fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))}
  (h :
    @_root_.ne.{1}
      (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
      i
      j),
    @eq.{(max 1 (u_1+1))}
      (vector.{u_1} α
         (@has_sub.sub.{0} nat nat.has_sub
            (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
            (@has_one.one.{0} nat nat.has_one)))
      (@vector.remove_nth.{u_1} α
         (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
         i
         (@vector.insert_nth.{u_1} (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) α a j v))
      (@vector.insert_nth.{u_1} n α a
         (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) i j
            (@_root_.ne.symm.{1}
               (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
               i
               j
               h))
         (@vector.remove_nth.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
            (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) j i h)
            v)),
i : nat,
hi :
  @has_lt.lt.{0} nat nat.has_lt i
    (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))),
j : nat,
hj :
  @has_lt.lt.{0} nat nat.has_lt j
    (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))),
ne :
  @_root_.ne.{1}
    (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) i hi)
    (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) j hj),
this : @_root_.ne.{1} nat i j,
h :
  @has_lt.lt.{0} nat
    (@preorder.to_has_lt.{0} nat
       (@partial_order.to_preorder.{0} nat (@linear_order.to_partial_order.{0} nat nat.linear_order)))
    i
    j,
h_nji : not (@has_lt.lt.{0} nat nat.has_lt j i),
j_pos : @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) j
⊢ @ge.{0} nat nat.has_le (@has_sub.sub.{0} nat nat.has_sub j (@has_one.one.{0} nat nat.has_one)) i'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>174        { rw [v.2], exact lt_of_lt_of_le h (nat.le_of_succ_le_succ hj) },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='lt_of_lt_of_le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='nat.le_of_succ_le_succ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 102, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/nat/basic.lean&#x27;, &#x27;line&#x27;: 94, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='vector.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : preorder.{0} α] {a b c : α}, @has_lt.lt.{0} α (@preorder.to_has_lt.{0} α _inst_1) a b → @has_le.le.{0} α (@preorder.to_has_le.{0} α _inst_1) b c → @has_lt.lt.{0} α (@preorder.to_has_lt.{0} α _inst_1) a c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_lt.lt.{0} nat (@preorder.to_has_lt.{0} nat (@partial_order.to_preorder.{0} nat (@linear_order.to_partial_order.{0} nat nat.linear_order))) i j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {n m : nat}, @has_le.le.{0} nat nat.has_le (nat.succ n) (nat.succ m) → @has_le.le.{0} nat nat.has_le n m'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_lt.lt.{0} nat nat.has_lt j (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
n : nat,
α : Type u_1,
a : α,
v : vector.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)),
remove_nth_insert_nth_ne :
  ∀ {i j : fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))}
  (h :
    @_root_.ne.{1}
      (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
      i
      j),
    @eq.{(max 1 (u_1+1))}
      (vector.{u_1} α
         (@has_sub.sub.{0} nat nat.has_sub
            (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
            (@has_one.one.{0} nat nat.has_one)))
      (@vector.remove_nth.{u_1} α
         (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
         i
         (@vector.insert_nth.{u_1} (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) α a j v))
      (@vector.insert_nth.{u_1} n α a
         (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) i j
            (@_root_.ne.symm.{1}
               (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
               i
               j
               h))
         (@vector.remove_nth.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
            (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) j i h)
            v)),
i : nat,
hi :
  @has_lt.lt.{0} nat nat.has_lt i
    (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))),
j : nat,
hj :
  @has_lt.lt.{0} nat nat.has_lt j
    (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))),
ne :
  @_root_.ne.{1}
    (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) i hi)
    (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) j hj),
this : @_root_.ne.{1} nat i j,
h :
  @has_lt.lt.{0} nat
    (@preorder.to_has_lt.{0} nat
       (@partial_order.to_preorder.{0} nat (@linear_order.to_partial_order.{0} nat nat.linear_order)))
    i
    j,
h_nji : not (@has_lt.lt.{0} nat nat.has_lt j i),
j_pos : @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) j
⊢ @has_lt.lt.{0} nat nat.has_lt i
    (@list.length.{u_1} α
       (@subtype.val.{u_1+1} (list.{u_1} α)
          (λ (l : list.{u_1} α),
             @eq.{1} nat (@list.length.{u_1} α l)
               (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
          v))

n : nat,
α : Type u_1,
a : α,
v : vector.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)),
remove_nth_insert_nth_ne :
  ∀ {i j : fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))}
  (h :
    @_root_.ne.{1}
      (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
      i
      j),
    @eq.{(max 1 (u_1+1))}
      (vector.{u_1} α
         (@has_sub.sub.{0} nat nat.has_sub
            (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
            (@has_one.one.{0} nat nat.has_one)))
      (@vector.remove_nth.{u_1} α
         (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
         i
         (@vector.insert_nth.{u_1} (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) α a j v))
      (@vector.insert_nth.{u_1} n α a
         (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) i j
            (@_root_.ne.symm.{1}
               (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
               i
               j
               h))
         (@vector.remove_nth.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
            (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) j i h)
            v)),
i : nat,
hi :
  @has_lt.lt.{0} nat nat.has_lt i
    (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))),
j : nat,
hj :
  @has_lt.lt.{0} nat nat.has_lt j
    (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))),
ne :
  @_root_.ne.{1}
    (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) i hi)
    (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) j hj),
this : @_root_.ne.{1} nat i j,
h :
  @has_lt.lt.{0} nat
    (@preorder.to_has_lt.{0} nat
       (@partial_order.to_preorder.{0} nat (@linear_order.to_partial_order.{0} nat nat.linear_order)))
    i
    j,
h_nji : not (@has_lt.lt.{0} nat nat.has_lt j i),
j_pos : @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) j
⊢ @ge.{0} nat nat.has_le (@has_sub.sub.{0} nat nat.has_sub j (@has_one.one.{0} nat nat.has_one)) i'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : nat,
α : Type u_1,
a : α,
v : vector.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)),
remove_nth_insert_nth_ne :
  ∀ {i j : fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))}
  (h :
    @_root_.ne.{1}
      (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
      i
      j),
    @eq.{(max 1 (u_1+1))}
      (vector.{u_1} α
         (@has_sub.sub.{0} nat nat.has_sub
            (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
            (@has_one.one.{0} nat nat.has_one)))
      (@vector.remove_nth.{u_1} α
         (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
         i
         (@vector.insert_nth.{u_1} (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) α a j v))
      (@vector.insert_nth.{u_1} n α a
         (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) i j
            (@_root_.ne.symm.{1}
               (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
               i
               j
               h))
         (@vector.remove_nth.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
            (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) j i h)
            v)),
i : nat,
hi :
  @has_lt.lt.{0} nat nat.has_lt i
    (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))),
j : nat,
hj :
  @has_lt.lt.{0} nat nat.has_lt j
    (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))),
ne :
  @_root_.ne.{1}
    (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) i hi)
    (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) j hj),
this : @_root_.ne.{1} nat i j,
h :
  @has_lt.lt.{0} nat
    (@preorder.to_has_lt.{0} nat
       (@partial_order.to_preorder.{0} nat (@linear_order.to_partial_order.{0} nat nat.linear_order)))
    i
    j,
h_nji : not (@has_lt.lt.{0} nat nat.has_lt j i),
j_pos : @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) j
⊢ @has_lt.lt.{0} nat nat.has_lt i
    (@list.length.{u_1} α
       (@subtype.val.{u_1+1} (list.{u_1} α)
          (λ (l : list.{u_1} α),
             @eq.{1} nat (@list.length.{u_1} α l)
               (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
          v))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : nat,
α : Type u_1,
a : α,
v : vector.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)),
remove_nth_insert_nth_ne :
  ∀ {i j : fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))}
  (h :
    @_root_.ne.{1}
      (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
      i
      j),
    @eq.{(max 1 (u_1+1))}
      (vector.{u_1} α
         (@has_sub.sub.{0} nat nat.has_sub
            (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
            (@has_one.one.{0} nat nat.has_one)))
      (@vector.remove_nth.{u_1} α
         (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
         i
         (@vector.insert_nth.{u_1} (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) α a j v))
      (@vector.insert_nth.{u_1} n α a
         (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) i j
            (@_root_.ne.symm.{1}
               (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
               i
               j
               h))
         (@vector.remove_nth.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
            (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) j i h)
            v)),
i : nat,
hi :
  @has_lt.lt.{0} nat nat.has_lt i
    (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))),
j : nat,
hj :
  @has_lt.lt.{0} nat nat.has_lt j
    (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))),
ne :
  @_root_.ne.{1}
    (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) i hi)
    (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) j hj),
this : @_root_.ne.{1} nat i j,
h :
  @has_lt.lt.{0} nat
    (@preorder.to_has_lt.{0} nat
       (@partial_order.to_preorder.{0} nat (@linear_order.to_partial_order.{0} nat nat.linear_order)))
    i
    j,
h_nji : not (@has_lt.lt.{0} nat nat.has_lt j i),
j_pos : @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) j
⊢ @has_lt.lt.{0} nat nat.has_lt i (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : nat,
α : Type u_1,
a : α,
v : vector.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)),
remove_nth_insert_nth_ne :
  ∀ {i j : fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))}
  (h :
    @_root_.ne.{1}
      (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
      i
      j),
    @eq.{(max 1 (u_1+1))}
      (vector.{u_1} α
         (@has_sub.sub.{0} nat nat.has_sub
            (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
            (@has_one.one.{0} nat nat.has_one)))
      (@vector.remove_nth.{u_1} α
         (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
         i
         (@vector.insert_nth.{u_1} (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) α a j v))
      (@vector.insert_nth.{u_1} n α a
         (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) i j
            (@_root_.ne.symm.{1}
               (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
               i
               j
               h))
         (@vector.remove_nth.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
            (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) j i h)
            v)),
i : nat,
hi :
  @has_lt.lt.{0} nat nat.has_lt i
    (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))),
j : nat,
hj :
  @has_lt.lt.{0} nat nat.has_lt j
    (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))),
ne :
  @_root_.ne.{1}
    (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) i hi)
    (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) j hj),
this : @_root_.ne.{1} nat i j,
h :
  @has_lt.lt.{0} nat
    (@preorder.to_has_lt.{0} nat
       (@partial_order.to_preorder.{0} nat (@linear_order.to_partial_order.{0} nat nat.linear_order)))
    i
    j,
h_nji : not (@has_lt.lt.{0} nat nat.has_lt j i),
j_pos : @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) j
⊢ @ge.{0} nat nat.has_le (@has_sub.sub.{0} nat nat.has_sub j (@has_one.one.{0} nat nat.has_one)) i'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>175        { exact nat.le_sub_right_of_add_le h } },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='nat.le_sub_right_of_add_le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/nat/basic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 18}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {m n k : nat}, @has_le.le.{0} nat nat.has_le (@has_add.add.{0} nat nat.has_add m k) n → @has_le.le.{0} nat nat.has_le m (@has_sub.sub.{0} nat nat.has_sub n k)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_lt.lt.{0} nat (@preorder.to_has_lt.{0} nat (@partial_order.to_preorder.{0} nat (@linear_order.to_partial_order.{0} nat nat.linear_order))) i j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : nat,
α : Type u_1,
a : α,
v : vector.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)),
remove_nth_insert_nth_ne :
  ∀ {i j : fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))}
  (h :
    @_root_.ne.{1}
      (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
      i
      j),
    @eq.{(max 1 (u_1+1))}
      (vector.{u_1} α
         (@has_sub.sub.{0} nat nat.has_sub
            (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
            (@has_one.one.{0} nat nat.has_one)))
      (@vector.remove_nth.{u_1} α
         (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
         i
         (@vector.insert_nth.{u_1} (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) α a j v))
      (@vector.insert_nth.{u_1} n α a
         (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) i j
            (@_root_.ne.symm.{1}
               (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
               i
               j
               h))
         (@vector.remove_nth.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
            (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) j i h)
            v)),
i : nat,
hi :
  @has_lt.lt.{0} nat nat.has_lt i
    (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))),
j : nat,
hj :
  @has_lt.lt.{0} nat nat.has_lt j
    (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))),
ne :
  @_root_.ne.{1}
    (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) i hi)
    (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) j hj),
this : @_root_.ne.{1} nat i j,
h :
  @has_lt.lt.{0} nat
    (@preorder.to_has_lt.{0} nat
       (@partial_order.to_preorder.{0} nat (@linear_order.to_partial_order.{0} nat nat.linear_order)))
    i
    j,
h_nji : not (@has_lt.lt.{0} nat nat.has_lt j i),
j_pos : @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) j
⊢ @ge.{0} nat nat.has_le (@has_sub.sub.{0} nat nat.has_sub j (@has_one.one.{0} nat nat.has_one)) i'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
n : nat,
α : Type u_1,
a : α,
v : vector.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)),
remove_nth_insert_nth_ne :
  ∀ {i j : fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))}
  (h :
    @_root_.ne.{1}
      (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
      i
      j),
    @eq.{(max 1 (u_1+1))}
      (vector.{u_1} α
         (@has_sub.sub.{0} nat nat.has_sub
            (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
            (@has_one.one.{0} nat nat.has_one)))
      (@vector.remove_nth.{u_1} α
         (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
         i
         (@vector.insert_nth.{u_1} (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) α a j v))
      (@vector.insert_nth.{u_1} n α a
         (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) i j
            (@_root_.ne.symm.{1}
               (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
               i
               j
               h))
         (@vector.remove_nth.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
            (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) j i h)
            v)),
i : nat,
hi :
  @has_lt.lt.{0} nat nat.has_lt i
    (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))),
j : nat,
hj :
  @has_lt.lt.{0} nat nat.has_lt j
    (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))),
ne :
  @_root_.ne.{1}
    (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) i hi)
    (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) j hj),
this : @_root_.ne.{1} nat i j,
h : @eq.{1} nat i j
⊢ @eq.{u_1+1} (list.{u_1} α)
    (@list.remove_nth.{u_1} α
       (@list.insert_nth.{u_1} α j a
          (@subtype.val.{u_1+1} (list.{u_1} α)
             (λ (l : list.{u_1} α),
                @eq.{1} nat (@list.length.{u_1} α l)
                  (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
             v))
       i)
    (@list.insert_nth.{u_1} α
       (@fin.val (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
          (@dite.{1}
             (@has_lt.lt.{0}
                (fin
                   (@has_add.add.{0} nat nat.has_add
                      (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                      (@has_one.one.{0} nat nat.has_one)))
                (@fin.has_lt
                   (@has_add.add.{0} nat nat.has_add
                      (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                      (@has_one.one.{0} nat nat.has_one)))
                (@fin.mk
                   (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                   j
                   hj)
                (@fin.mk
                   (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                   i
                   hi))
             (@fin.decidable_lt
                (@has_add.add.{0} nat nat.has_add
                   (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                   (@has_one.one.{0} nat nat.has_one))
                (@fin.mk
                   (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                   j
                   hj)
                (@fin.mk
                   (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                   i
                   hi))
             (fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
             (λ
              (h :
                @has_lt.lt.{0}
                  (fin
                     (@has_add.add.{0} nat nat.has_add
                        (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                        (@has_one.one.{0} nat nat.has_one)))
                  (@fin.has_lt
                     (@has_add.add.{0} nat nat.has_add
                        (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                        (@has_one.one.{0} nat nat.has_one)))
                  (@fin.mk
                     (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                     j
                     hj)
                  (@fin.mk
                     (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                     i
                     hi)),
                @fin.mk (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) j
                  (@fin.pred_above._proof_1 (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        i
                        hi)
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        j
                        hj)
                     h))
             (λ
              (h :
                not
                  (@has_lt.lt.{0}
                     (fin
                        (@has_add.add.{0} nat nat.has_add
                           (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                           (@has_one.one.{0} nat nat.has_one)))
                     (@fin.has_lt
                        (@has_add.add.{0} nat nat.has_add
                           (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                           (@has_one.one.{0} nat nat.has_one)))
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        j
                        hj)
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        i
                        hi))),
                @fin.pred (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                  (@fin.mk
                     (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                     j
                     hj)
                  (@fin.pred_above._proof_2 (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        i
                        hi)
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        j
                        hj)
                     (@_root_.ne.symm.{1}
                        (fin
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           i
                           hi)
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           j
                           hj)
                        ne)
                     h))))
       a
       (@subtype.val.{u_1+1} (list.{u_1} α) (λ (l : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l) n)
          (@vector.remove_nth.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
             (@dite.{1}
                (@has_lt.lt.{0}
                   (fin
                      (@has_add.add.{0} nat nat.has_add
                         (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                         (@has_one.one.{0} nat nat.has_one)))
                   (@fin.has_lt
                      (@has_add.add.{0} nat nat.has_add
                         (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                         (@has_one.one.{0} nat nat.has_one)))
                   (@fin.mk
                      (@has_add.add.{0} nat nat.has_add n
                         (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                      i
                      hi)
                   (@fin.mk
                      (@has_add.add.{0} nat nat.has_add n
                         (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                      j
                      hj))
                (@fin.decidable_lt
                   (@has_add.add.{0} nat nat.has_add
                      (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                      (@has_one.one.{0} nat nat.has_one))
                   (@fin.mk
                      (@has_add.add.{0} nat nat.has_add n
                         (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                      i
                      hi)
                   (@fin.mk
                      (@has_add.add.{0} nat nat.has_add n
                         (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                      j
                      hj))
                (fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
                (λ
                 (h :
                   @has_lt.lt.{0}
                     (fin
                        (@has_add.add.{0} nat nat.has_add
                           (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                           (@has_one.one.{0} nat nat.has_one)))
                     (@fin.has_lt
                        (@has_add.add.{0} nat nat.has_add
                           (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                           (@has_one.one.{0} nat nat.has_one)))
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        i
                        hi)
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        j
                        hj)),
                   @fin.mk (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) i
                     (@fin.pred_above._proof_1 (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           j
                           hj)
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           i
                           hi)
                        h))
                (λ
                 (h :
                   not
                     (@has_lt.lt.{0}
                        (fin
                           (@has_add.add.{0} nat nat.has_add
                              (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                              (@has_one.one.{0} nat nat.has_one)))
                        (@fin.has_lt
                           (@has_add.add.{0} nat nat.has_add
                              (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                              (@has_one.one.{0} nat nat.has_one)))
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           i
                           hi)
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           j
                           hj))),
                   @fin.pred (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        i
                        hi)
                     (@fin.pred_above._proof_2 (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           j
                           hj)
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           i
                           hi)
                        ne
                        h)))
             v)))

n : nat,
α : Type u_1,
a : α,
v : vector.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)),
remove_nth_insert_nth_ne :
  ∀ {i j : fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))}
  (h :
    @_root_.ne.{1}
      (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
      i
      j),
    @eq.{(max 1 (u_1+1))}
      (vector.{u_1} α
         (@has_sub.sub.{0} nat nat.has_sub
            (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
            (@has_one.one.{0} nat nat.has_one)))
      (@vector.remove_nth.{u_1} α
         (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
         i
         (@vector.insert_nth.{u_1} (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) α a j v))
      (@vector.insert_nth.{u_1} n α a
         (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) i j
            (@_root_.ne.symm.{1}
               (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
               i
               j
               h))
         (@vector.remove_nth.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
            (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) j i h)
            v)),
i : nat,
hi :
  @has_lt.lt.{0} nat nat.has_lt i
    (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))),
j : nat,
hj :
  @has_lt.lt.{0} nat nat.has_lt j
    (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))),
ne :
  @_root_.ne.{1}
    (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) i hi)
    (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) j hj),
this : @_root_.ne.{1} nat i j,
h :
  @has_lt.lt.{0} nat
    (@preorder.to_has_lt.{0} nat
       (@partial_order.to_preorder.{0} nat (@linear_order.to_partial_order.{0} nat nat.linear_order)))
    j
    i
⊢ @eq.{u_1+1} (list.{u_1} α)
    (@list.remove_nth.{u_1} α
       (@list.insert_nth.{u_1} α j a
          (@subtype.val.{u_1+1} (list.{u_1} α)
             (λ (l : list.{u_1} α),
                @eq.{1} nat (@list.length.{u_1} α l)
                  (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
             v))
       i)
    (@list.insert_nth.{u_1} α
       (@fin.val (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
          (@dite.{1}
             (@has_lt.lt.{0}
                (fin
                   (@has_add.add.{0} nat nat.has_add
                      (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                      (@has_one.one.{0} nat nat.has_one)))
                (@fin.has_lt
                   (@has_add.add.{0} nat nat.has_add
                      (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                      (@has_one.one.{0} nat nat.has_one)))
                (@fin.mk
                   (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                   j
                   hj)
                (@fin.mk
                   (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                   i
                   hi))
             (@fin.decidable_lt
                (@has_add.add.{0} nat nat.has_add
                   (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                   (@has_one.one.{0} nat nat.has_one))
                (@fin.mk
                   (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                   j
                   hj)
                (@fin.mk
                   (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                   i
                   hi))
             (fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
             (λ
              (h :
                @has_lt.lt.{0}
                  (fin
                     (@has_add.add.{0} nat nat.has_add
                        (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                        (@has_one.one.{0} nat nat.has_one)))
                  (@fin.has_lt
                     (@has_add.add.{0} nat nat.has_add
                        (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                        (@has_one.one.{0} nat nat.has_one)))
                  (@fin.mk
                     (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                     j
                     hj)
                  (@fin.mk
                     (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                     i
                     hi)),
                @fin.mk (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) j
                  (@fin.pred_above._proof_1 (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        i
                        hi)
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        j
                        hj)
                     h))
             (λ
              (h :
                not
                  (@has_lt.lt.{0}
                     (fin
                        (@has_add.add.{0} nat nat.has_add
                           (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                           (@has_one.one.{0} nat nat.has_one)))
                     (@fin.has_lt
                        (@has_add.add.{0} nat nat.has_add
                           (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                           (@has_one.one.{0} nat nat.has_one)))
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        j
                        hj)
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        i
                        hi))),
                @fin.pred (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                  (@fin.mk
                     (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                     j
                     hj)
                  (@fin.pred_above._proof_2 (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        i
                        hi)
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        j
                        hj)
                     (@_root_.ne.symm.{1}
                        (fin
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           i
                           hi)
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           j
                           hj)
                        ne)
                     h))))
       a
       (@subtype.val.{u_1+1} (list.{u_1} α) (λ (l : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l) n)
          (@vector.remove_nth.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
             (@dite.{1}
                (@has_lt.lt.{0}
                   (fin
                      (@has_add.add.{0} nat nat.has_add
                         (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                         (@has_one.one.{0} nat nat.has_one)))
                   (@fin.has_lt
                      (@has_add.add.{0} nat nat.has_add
                         (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                         (@has_one.one.{0} nat nat.has_one)))
                   (@fin.mk
                      (@has_add.add.{0} nat nat.has_add n
                         (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                      i
                      hi)
                   (@fin.mk
                      (@has_add.add.{0} nat nat.has_add n
                         (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                      j
                      hj))
                (@fin.decidable_lt
                   (@has_add.add.{0} nat nat.has_add
                      (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                      (@has_one.one.{0} nat nat.has_one))
                   (@fin.mk
                      (@has_add.add.{0} nat nat.has_add n
                         (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                      i
                      hi)
                   (@fin.mk
                      (@has_add.add.{0} nat nat.has_add n
                         (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                      j
                      hj))
                (fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
                (λ
                 (h :
                   @has_lt.lt.{0}
                     (fin
                        (@has_add.add.{0} nat nat.has_add
                           (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                           (@has_one.one.{0} nat nat.has_one)))
                     (@fin.has_lt
                        (@has_add.add.{0} nat nat.has_add
                           (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                           (@has_one.one.{0} nat nat.has_one)))
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        i
                        hi)
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        j
                        hj)),
                   @fin.mk (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) i
                     (@fin.pred_above._proof_1 (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           j
                           hj)
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           i
                           hi)
                        h))
                (λ
                 (h :
                   not
                     (@has_lt.lt.{0}
                        (fin
                           (@has_add.add.{0} nat nat.has_add
                              (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                              (@has_one.one.{0} nat nat.has_one)))
                        (@fin.has_lt
                           (@has_add.add.{0} nat nat.has_add
                              (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                              (@has_one.one.{0} nat nat.has_one)))
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           i
                           hi)
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           j
                           hj))),
                   @fin.pred (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        i
                        hi)
                     (@fin.pred_above._proof_2 (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           j
                           hj)
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           i
                           hi)
                        ne
                        h)))
             v)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>176      { exact (this h).elim },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@ne.{1} nat i j'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{1} nat i j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
n : nat,
α : Type u_1,
a : α,
v : vector.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)),
remove_nth_insert_nth_ne :
  ∀ {i j : fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))}
  (h :
    @_root_.ne.{1}
      (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
      i
      j),
    @eq.{(max 1 (u_1+1))}
      (vector.{u_1} α
         (@has_sub.sub.{0} nat nat.has_sub
            (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
            (@has_one.one.{0} nat nat.has_one)))
      (@vector.remove_nth.{u_1} α
         (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
         i
         (@vector.insert_nth.{u_1} (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) α a j v))
      (@vector.insert_nth.{u_1} n α a
         (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) i j
            (@_root_.ne.symm.{1}
               (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
               i
               j
               h))
         (@vector.remove_nth.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
            (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) j i h)
            v)),
i : nat,
hi :
  @has_lt.lt.{0} nat nat.has_lt i
    (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))),
j : nat,
hj :
  @has_lt.lt.{0} nat nat.has_lt j
    (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))),
ne :
  @_root_.ne.{1}
    (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) i hi)
    (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) j hj),
this : @_root_.ne.{1} nat i j,
h : @eq.{1} nat i j
⊢ @eq.{u_1+1} (list.{u_1} α)
    (@list.remove_nth.{u_1} α
       (@list.insert_nth.{u_1} α j a
          (@subtype.val.{u_1+1} (list.{u_1} α)
             (λ (l : list.{u_1} α),
                @eq.{1} nat (@list.length.{u_1} α l)
                  (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
             v))
       i)
    (@list.insert_nth.{u_1} α
       (@fin.val (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
          (@dite.{1}
             (@has_lt.lt.{0}
                (fin
                   (@has_add.add.{0} nat nat.has_add
                      (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                      (@has_one.one.{0} nat nat.has_one)))
                (@fin.has_lt
                   (@has_add.add.{0} nat nat.has_add
                      (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                      (@has_one.one.{0} nat nat.has_one)))
                (@fin.mk
                   (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                   j
                   hj)
                (@fin.mk
                   (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                   i
                   hi))
             (@fin.decidable_lt
                (@has_add.add.{0} nat nat.has_add
                   (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                   (@has_one.one.{0} nat nat.has_one))
                (@fin.mk
                   (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                   j
                   hj)
                (@fin.mk
                   (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                   i
                   hi))
             (fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
             (λ
              (h :
                @has_lt.lt.{0}
                  (fin
                     (@has_add.add.{0} nat nat.has_add
                        (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                        (@has_one.one.{0} nat nat.has_one)))
                  (@fin.has_lt
                     (@has_add.add.{0} nat nat.has_add
                        (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                        (@has_one.one.{0} nat nat.has_one)))
                  (@fin.mk
                     (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                     j
                     hj)
                  (@fin.mk
                     (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                     i
                     hi)),
                @fin.mk (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) j
                  (@fin.pred_above._proof_1 (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        i
                        hi)
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        j
                        hj)
                     h))
             (λ
              (h :
                not
                  (@has_lt.lt.{0}
                     (fin
                        (@has_add.add.{0} nat nat.has_add
                           (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                           (@has_one.one.{0} nat nat.has_one)))
                     (@fin.has_lt
                        (@has_add.add.{0} nat nat.has_add
                           (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                           (@has_one.one.{0} nat nat.has_one)))
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        j
                        hj)
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        i
                        hi))),
                @fin.pred (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                  (@fin.mk
                     (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                     j
                     hj)
                  (@fin.pred_above._proof_2 (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        i
                        hi)
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        j
                        hj)
                     (@_root_.ne.symm.{1}
                        (fin
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           i
                           hi)
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           j
                           hj)
                        ne)
                     h))))
       a
       (@subtype.val.{u_1+1} (list.{u_1} α) (λ (l : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l) n)
          (@vector.remove_nth.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
             (@dite.{1}
                (@has_lt.lt.{0}
                   (fin
                      (@has_add.add.{0} nat nat.has_add
                         (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                         (@has_one.one.{0} nat nat.has_one)))
                   (@fin.has_lt
                      (@has_add.add.{0} nat nat.has_add
                         (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                         (@has_one.one.{0} nat nat.has_one)))
                   (@fin.mk
                      (@has_add.add.{0} nat nat.has_add n
                         (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                      i
                      hi)
                   (@fin.mk
                      (@has_add.add.{0} nat nat.has_add n
                         (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                      j
                      hj))
                (@fin.decidable_lt
                   (@has_add.add.{0} nat nat.has_add
                      (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                      (@has_one.one.{0} nat nat.has_one))
                   (@fin.mk
                      (@has_add.add.{0} nat nat.has_add n
                         (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                      i
                      hi)
                   (@fin.mk
                      (@has_add.add.{0} nat nat.has_add n
                         (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                      j
                      hj))
                (fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
                (λ
                 (h :
                   @has_lt.lt.{0}
                     (fin
                        (@has_add.add.{0} nat nat.has_add
                           (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                           (@has_one.one.{0} nat nat.has_one)))
                     (@fin.has_lt
                        (@has_add.add.{0} nat nat.has_add
                           (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                           (@has_one.one.{0} nat nat.has_one)))
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        i
                        hi)
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        j
                        hj)),
                   @fin.mk (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) i
                     (@fin.pred_above._proof_1 (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           j
                           hj)
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           i
                           hi)
                        h))
                (λ
                 (h :
                   not
                     (@has_lt.lt.{0}
                        (fin
                           (@has_add.add.{0} nat nat.has_add
                              (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                              (@has_one.one.{0} nat nat.has_one)))
                        (@fin.has_lt
                           (@has_add.add.{0} nat nat.has_add
                              (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                              (@has_one.one.{0} nat nat.has_one)))
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           i
                           hi)
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           j
                           hj))),
                   @fin.pred (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        i
                        hi)
                     (@fin.pred_above._proof_2 (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           j
                           hj)
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           i
                           hi)
                        ne
                        h)))
             v)))

n : nat,
α : Type u_1,
a : α,
v : vector.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)),
remove_nth_insert_nth_ne :
  ∀ {i j : fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))}
  (h :
    @_root_.ne.{1}
      (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
      i
      j),
    @eq.{(max 1 (u_1+1))}
      (vector.{u_1} α
         (@has_sub.sub.{0} nat nat.has_sub
            (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
            (@has_one.one.{0} nat nat.has_one)))
      (@vector.remove_nth.{u_1} α
         (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
         i
         (@vector.insert_nth.{u_1} (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) α a j v))
      (@vector.insert_nth.{u_1} n α a
         (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) i j
            (@_root_.ne.symm.{1}
               (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
               i
               j
               h))
         (@vector.remove_nth.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
            (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) j i h)
            v)),
i : nat,
hi :
  @has_lt.lt.{0} nat nat.has_lt i
    (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))),
j : nat,
hj :
  @has_lt.lt.{0} nat nat.has_lt j
    (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))),
ne :
  @_root_.ne.{1}
    (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) i hi)
    (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) j hj),
this : @_root_.ne.{1} nat i j,
h :
  @has_lt.lt.{0} nat
    (@preorder.to_has_lt.{0} nat
       (@partial_order.to_preorder.{0} nat (@linear_order.to_partial_order.{0} nat nat.linear_order)))
    j
    i
⊢ @eq.{u_1+1} (list.{u_1} α)
    (@list.remove_nth.{u_1} α
       (@list.insert_nth.{u_1} α j a
          (@subtype.val.{u_1+1} (list.{u_1} α)
             (λ (l : list.{u_1} α),
                @eq.{1} nat (@list.length.{u_1} α l)
                  (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
             v))
       i)
    (@list.insert_nth.{u_1} α
       (@fin.val (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
          (@dite.{1}
             (@has_lt.lt.{0}
                (fin
                   (@has_add.add.{0} nat nat.has_add
                      (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                      (@has_one.one.{0} nat nat.has_one)))
                (@fin.has_lt
                   (@has_add.add.{0} nat nat.has_add
                      (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                      (@has_one.one.{0} nat nat.has_one)))
                (@fin.mk
                   (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                   j
                   hj)
                (@fin.mk
                   (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                   i
                   hi))
             (@fin.decidable_lt
                (@has_add.add.{0} nat nat.has_add
                   (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                   (@has_one.one.{0} nat nat.has_one))
                (@fin.mk
                   (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                   j
                   hj)
                (@fin.mk
                   (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                   i
                   hi))
             (fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
             (λ
              (h :
                @has_lt.lt.{0}
                  (fin
                     (@has_add.add.{0} nat nat.has_add
                        (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                        (@has_one.one.{0} nat nat.has_one)))
                  (@fin.has_lt
                     (@has_add.add.{0} nat nat.has_add
                        (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                        (@has_one.one.{0} nat nat.has_one)))
                  (@fin.mk
                     (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                     j
                     hj)
                  (@fin.mk
                     (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                     i
                     hi)),
                @fin.mk (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) j
                  (@fin.pred_above._proof_1 (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        i
                        hi)
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        j
                        hj)
                     h))
             (λ
              (h :
                not
                  (@has_lt.lt.{0}
                     (fin
                        (@has_add.add.{0} nat nat.has_add
                           (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                           (@has_one.one.{0} nat nat.has_one)))
                     (@fin.has_lt
                        (@has_add.add.{0} nat nat.has_add
                           (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                           (@has_one.one.{0} nat nat.has_one)))
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        j
                        hj)
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        i
                        hi))),
                @fin.pred (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                  (@fin.mk
                     (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                     j
                     hj)
                  (@fin.pred_above._proof_2 (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        i
                        hi)
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        j
                        hj)
                     (@_root_.ne.symm.{1}
                        (fin
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           i
                           hi)
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           j
                           hj)
                        ne)
                     h))))
       a
       (@subtype.val.{u_1+1} (list.{u_1} α) (λ (l : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l) n)
          (@vector.remove_nth.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
             (@dite.{1}
                (@has_lt.lt.{0}
                   (fin
                      (@has_add.add.{0} nat nat.has_add
                         (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                         (@has_one.one.{0} nat nat.has_one)))
                   (@fin.has_lt
                      (@has_add.add.{0} nat nat.has_add
                         (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                         (@has_one.one.{0} nat nat.has_one)))
                   (@fin.mk
                      (@has_add.add.{0} nat nat.has_add n
                         (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                      i
                      hi)
                   (@fin.mk
                      (@has_add.add.{0} nat nat.has_add n
                         (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                      j
                      hj))
                (@fin.decidable_lt
                   (@has_add.add.{0} nat nat.has_add
                      (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                      (@has_one.one.{0} nat nat.has_one))
                   (@fin.mk
                      (@has_add.add.{0} nat nat.has_add n
                         (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                      i
                      hi)
                   (@fin.mk
                      (@has_add.add.{0} nat nat.has_add n
                         (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                      j
                      hj))
                (fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
                (λ
                 (h :
                   @has_lt.lt.{0}
                     (fin
                        (@has_add.add.{0} nat nat.has_add
                           (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                           (@has_one.one.{0} nat nat.has_one)))
                     (@fin.has_lt
                        (@has_add.add.{0} nat nat.has_add
                           (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                           (@has_one.one.{0} nat nat.has_one)))
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        i
                        hi)
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        j
                        hj)),
                   @fin.mk (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) i
                     (@fin.pred_above._proof_1 (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           j
                           hj)
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           i
                           hi)
                        h))
                (λ
                 (h :
                   not
                     (@has_lt.lt.{0}
                        (fin
                           (@has_add.add.{0} nat nat.has_add
                              (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                              (@has_one.one.{0} nat nat.has_one)))
                        (@fin.has_lt
                           (@has_add.add.{0} nat nat.has_add
                              (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                              (@has_one.one.{0} nat nat.has_one)))
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           i
                           hi)
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           j
                           hj))),
                   @fin.pred (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        i
                        hi)
                     (@fin.pred_above._proof_2 (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           j
                           hj)
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           i
                           hi)
                        ne
                        h)))
             v)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : nat,
α : Type u_1,
a : α,
v : vector.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)),
remove_nth_insert_nth_ne :
  ∀ {i j : fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))}
  (h :
    @_root_.ne.{1}
      (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
      i
      j),
    @eq.{(max 1 (u_1+1))}
      (vector.{u_1} α
         (@has_sub.sub.{0} nat nat.has_sub
            (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
            (@has_one.one.{0} nat nat.has_one)))
      (@vector.remove_nth.{u_1} α
         (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
         i
         (@vector.insert_nth.{u_1} (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) α a j v))
      (@vector.insert_nth.{u_1} n α a
         (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) i j
            (@_root_.ne.symm.{1}
               (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
               i
               j
               h))
         (@vector.remove_nth.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
            (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) j i h)
            v)),
i : nat,
hi :
  @has_lt.lt.{0} nat nat.has_lt i
    (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))),
j : nat,
hj :
  @has_lt.lt.{0} nat nat.has_lt j
    (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))),
ne :
  @_root_.ne.{1}
    (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) i hi)
    (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) j hj),
this : @_root_.ne.{1} nat i j,
h : @eq.{1} nat i j
⊢ @eq.{u_1+1} (list.{u_1} α)
    (@list.remove_nth.{u_1} α
       (@list.insert_nth.{u_1} α j a
          (@subtype.val.{u_1+1} (list.{u_1} α)
             (λ (l : list.{u_1} α),
                @eq.{1} nat (@list.length.{u_1} α l)
                  (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
             v))
       i)
    (@list.insert_nth.{u_1} α
       (@fin.val (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
          (@dite.{1}
             (@has_lt.lt.{0}
                (fin
                   (@has_add.add.{0} nat nat.has_add
                      (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                      (@has_one.one.{0} nat nat.has_one)))
                (@fin.has_lt
                   (@has_add.add.{0} nat nat.has_add
                      (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                      (@has_one.one.{0} nat nat.has_one)))
                (@fin.mk
                   (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                   j
                   hj)
                (@fin.mk
                   (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                   i
                   hi))
             (@fin.decidable_lt
                (@has_add.add.{0} nat nat.has_add
                   (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                   (@has_one.one.{0} nat nat.has_one))
                (@fin.mk
                   (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                   j
                   hj)
                (@fin.mk
                   (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                   i
                   hi))
             (fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
             (λ
              (h :
                @has_lt.lt.{0}
                  (fin
                     (@has_add.add.{0} nat nat.has_add
                        (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                        (@has_one.one.{0} nat nat.has_one)))
                  (@fin.has_lt
                     (@has_add.add.{0} nat nat.has_add
                        (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                        (@has_one.one.{0} nat nat.has_one)))
                  (@fin.mk
                     (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                     j
                     hj)
                  (@fin.mk
                     (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                     i
                     hi)),
                @fin.mk (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) j
                  (@fin.pred_above._proof_1 (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        i
                        hi)
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        j
                        hj)
                     h))
             (λ
              (h :
                not
                  (@has_lt.lt.{0}
                     (fin
                        (@has_add.add.{0} nat nat.has_add
                           (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                           (@has_one.one.{0} nat nat.has_one)))
                     (@fin.has_lt
                        (@has_add.add.{0} nat nat.has_add
                           (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                           (@has_one.one.{0} nat nat.has_one)))
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        j
                        hj)
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        i
                        hi))),
                @fin.pred (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                  (@fin.mk
                     (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                     j
                     hj)
                  (@fin.pred_above._proof_2 (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        i
                        hi)
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        j
                        hj)
                     (@_root_.ne.symm.{1}
                        (fin
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           i
                           hi)
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           j
                           hj)
                        ne)
                     h))))
       a
       (@subtype.val.{u_1+1} (list.{u_1} α) (λ (l : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l) n)
          (@vector.remove_nth.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
             (@dite.{1}
                (@has_lt.lt.{0}
                   (fin
                      (@has_add.add.{0} nat nat.has_add
                         (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                         (@has_one.one.{0} nat nat.has_one)))
                   (@fin.has_lt
                      (@has_add.add.{0} nat nat.has_add
                         (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                         (@has_one.one.{0} nat nat.has_one)))
                   (@fin.mk
                      (@has_add.add.{0} nat nat.has_add n
                         (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                      i
                      hi)
                   (@fin.mk
                      (@has_add.add.{0} nat nat.has_add n
                         (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                      j
                      hj))
                (@fin.decidable_lt
                   (@has_add.add.{0} nat nat.has_add
                      (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                      (@has_one.one.{0} nat nat.has_one))
                   (@fin.mk
                      (@has_add.add.{0} nat nat.has_add n
                         (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                      i
                      hi)
                   (@fin.mk
                      (@has_add.add.{0} nat nat.has_add n
                         (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                      j
                      hj))
                (fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
                (λ
                 (h :
                   @has_lt.lt.{0}
                     (fin
                        (@has_add.add.{0} nat nat.has_add
                           (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                           (@has_one.one.{0} nat nat.has_one)))
                     (@fin.has_lt
                        (@has_add.add.{0} nat nat.has_add
                           (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                           (@has_one.one.{0} nat nat.has_one)))
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        i
                        hi)
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        j
                        hj)),
                   @fin.mk (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) i
                     (@fin.pred_above._proof_1 (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           j
                           hj)
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           i
                           hi)
                        h))
                (λ
                 (h :
                   not
                     (@has_lt.lt.{0}
                        (fin
                           (@has_add.add.{0} nat nat.has_add
                              (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                              (@has_one.one.{0} nat nat.has_one)))
                        (@fin.has_lt
                           (@has_add.add.{0} nat nat.has_add
                              (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                              (@has_one.one.{0} nat nat.has_one)))
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           i
                           hi)
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           j
                           hj))),
                   @fin.pred (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        i
                        hi)
                     (@fin.pred_above._proof_2 (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           j
                           hj)
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           i
                           hi)
                        ne
                        h)))
             v)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : nat,
α : Type u_1,
a : α,
v : vector.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)),
remove_nth_insert_nth_ne :
  ∀ {i j : fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))}
  (h :
    @_root_.ne.{1}
      (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
      i
      j),
    @eq.{(max 1 (u_1+1))}
      (vector.{u_1} α
         (@has_sub.sub.{0} nat nat.has_sub
            (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
            (@has_one.one.{0} nat nat.has_one)))
      (@vector.remove_nth.{u_1} α
         (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
         i
         (@vector.insert_nth.{u_1} (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) α a j v))
      (@vector.insert_nth.{u_1} n α a
         (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) i j
            (@_root_.ne.symm.{1}
               (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
               i
               j
               h))
         (@vector.remove_nth.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
            (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) j i h)
            v)),
i : nat,
hi :
  @has_lt.lt.{0} nat nat.has_lt i
    (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))),
j : nat,
hj :
  @has_lt.lt.{0} nat nat.has_lt j
    (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))),
ne :
  @_root_.ne.{1}
    (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) i hi)
    (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) j hj),
this : @_root_.ne.{1} nat i j,
h :
  @has_lt.lt.{0} nat
    (@preorder.to_has_lt.{0} nat
       (@partial_order.to_preorder.{0} nat (@linear_order.to_partial_order.{0} nat nat.linear_order)))
    j
    i
⊢ @eq.{u_1+1} (list.{u_1} α)
    (@list.remove_nth.{u_1} α
       (@list.insert_nth.{u_1} α j a
          (@subtype.val.{u_1+1} (list.{u_1} α)
             (λ (l : list.{u_1} α),
                @eq.{1} nat (@list.length.{u_1} α l)
                  (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
             v))
       i)
    (@list.insert_nth.{u_1} α
       (@fin.val (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
          (@dite.{1}
             (@has_lt.lt.{0}
                (fin
                   (@has_add.add.{0} nat nat.has_add
                      (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                      (@has_one.one.{0} nat nat.has_one)))
                (@fin.has_lt
                   (@has_add.add.{0} nat nat.has_add
                      (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                      (@has_one.one.{0} nat nat.has_one)))
                (@fin.mk
                   (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                   j
                   hj)
                (@fin.mk
                   (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                   i
                   hi))
             (@fin.decidable_lt
                (@has_add.add.{0} nat nat.has_add
                   (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                   (@has_one.one.{0} nat nat.has_one))
                (@fin.mk
                   (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                   j
                   hj)
                (@fin.mk
                   (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                   i
                   hi))
             (fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
             (λ
              (h :
                @has_lt.lt.{0}
                  (fin
                     (@has_add.add.{0} nat nat.has_add
                        (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                        (@has_one.one.{0} nat nat.has_one)))
                  (@fin.has_lt
                     (@has_add.add.{0} nat nat.has_add
                        (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                        (@has_one.one.{0} nat nat.has_one)))
                  (@fin.mk
                     (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                     j
                     hj)
                  (@fin.mk
                     (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                     i
                     hi)),
                @fin.mk (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) j
                  (@fin.pred_above._proof_1 (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        i
                        hi)
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        j
                        hj)
                     h))
             (λ
              (h :
                not
                  (@has_lt.lt.{0}
                     (fin
                        (@has_add.add.{0} nat nat.has_add
                           (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                           (@has_one.one.{0} nat nat.has_one)))
                     (@fin.has_lt
                        (@has_add.add.{0} nat nat.has_add
                           (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                           (@has_one.one.{0} nat nat.has_one)))
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        j
                        hj)
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        i
                        hi))),
                @fin.pred (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                  (@fin.mk
                     (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                     j
                     hj)
                  (@fin.pred_above._proof_2 (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        i
                        hi)
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        j
                        hj)
                     (@_root_.ne.symm.{1}
                        (fin
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           i
                           hi)
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           j
                           hj)
                        ne)
                     h))))
       a
       (@subtype.val.{u_1+1} (list.{u_1} α) (λ (l : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l) n)
          (@vector.remove_nth.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
             (@dite.{1}
                (@has_lt.lt.{0}
                   (fin
                      (@has_add.add.{0} nat nat.has_add
                         (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                         (@has_one.one.{0} nat nat.has_one)))
                   (@fin.has_lt
                      (@has_add.add.{0} nat nat.has_add
                         (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                         (@has_one.one.{0} nat nat.has_one)))
                   (@fin.mk
                      (@has_add.add.{0} nat nat.has_add n
                         (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                      i
                      hi)
                   (@fin.mk
                      (@has_add.add.{0} nat nat.has_add n
                         (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                      j
                      hj))
                (@fin.decidable_lt
                   (@has_add.add.{0} nat nat.has_add
                      (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                      (@has_one.one.{0} nat nat.has_one))
                   (@fin.mk
                      (@has_add.add.{0} nat nat.has_add n
                         (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                      i
                      hi)
                   (@fin.mk
                      (@has_add.add.{0} nat nat.has_add n
                         (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                      j
                      hj))
                (fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
                (λ
                 (h :
                   @has_lt.lt.{0}
                     (fin
                        (@has_add.add.{0} nat nat.has_add
                           (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                           (@has_one.one.{0} nat nat.has_one)))
                     (@fin.has_lt
                        (@has_add.add.{0} nat nat.has_add
                           (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                           (@has_one.one.{0} nat nat.has_one)))
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        i
                        hi)
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        j
                        hj)),
                   @fin.mk (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) i
                     (@fin.pred_above._proof_1 (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           j
                           hj)
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           i
                           hi)
                        h))
                (λ
                 (h :
                   not
                     (@has_lt.lt.{0}
                        (fin
                           (@has_add.add.{0} nat nat.has_add
                              (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                              (@has_one.one.{0} nat nat.has_one)))
                        (@fin.has_lt
                           (@has_add.add.{0} nat nat.has_add
                              (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                              (@has_one.one.{0} nat nat.has_one)))
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           i
                           hi)
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           j
                           hj))),
                   @fin.pred (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        i
                        hi)
                     (@fin.pred_above._proof_2 (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           j
                           hj)
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           i
                           hi)
                        ne
                        h)))
             v)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>177      { have h_nij : ¬ i &lt; j := lt_asymm h,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='lt_asymm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 93, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : preorder.{0} α] {a b : α}, @has_lt.lt.{0} α (@preorder.to_has_lt.{0} α _inst_1) a b → not (@has_lt.lt.{0} α (@preorder.to_has_lt.{0} α _inst_1) b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_lt.lt.{0} nat (@preorder.to_has_lt.{0} nat (@partial_order.to_preorder.{0} nat (@linear_order.to_partial_order.{0} nat nat.linear_order))) j i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : nat,
α : Type u_1,
a : α,
v : vector.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)),
remove_nth_insert_nth_ne :
  ∀ {i j : fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))}
  (h :
    @_root_.ne.{1}
      (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
      i
      j),
    @eq.{(max 1 (u_1+1))}
      (vector.{u_1} α
         (@has_sub.sub.{0} nat nat.has_sub
            (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
            (@has_one.one.{0} nat nat.has_one)))
      (@vector.remove_nth.{u_1} α
         (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
         i
         (@vector.insert_nth.{u_1} (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) α a j v))
      (@vector.insert_nth.{u_1} n α a
         (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) i j
            (@_root_.ne.symm.{1}
               (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
               i
               j
               h))
         (@vector.remove_nth.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
            (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) j i h)
            v)),
i : nat,
hi :
  @has_lt.lt.{0} nat nat.has_lt i
    (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))),
j : nat,
hj :
  @has_lt.lt.{0} nat nat.has_lt j
    (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))),
ne :
  @_root_.ne.{1}
    (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) i hi)
    (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) j hj),
this : @_root_.ne.{1} nat i j,
h :
  @has_lt.lt.{0} nat
    (@preorder.to_has_lt.{0} nat
       (@partial_order.to_preorder.{0} nat (@linear_order.to_partial_order.{0} nat nat.linear_order)))
    j
    i
⊢ @eq.{u_1+1} (list.{u_1} α)
    (@list.remove_nth.{u_1} α
       (@list.insert_nth.{u_1} α j a
          (@subtype.val.{u_1+1} (list.{u_1} α)
             (λ (l : list.{u_1} α),
                @eq.{1} nat (@list.length.{u_1} α l)
                  (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
             v))
       i)
    (@list.insert_nth.{u_1} α
       (@fin.val (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
          (@dite.{1}
             (@has_lt.lt.{0}
                (fin
                   (@has_add.add.{0} nat nat.has_add
                      (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                      (@has_one.one.{0} nat nat.has_one)))
                (@fin.has_lt
                   (@has_add.add.{0} nat nat.has_add
                      (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                      (@has_one.one.{0} nat nat.has_one)))
                (@fin.mk
                   (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                   j
                   hj)
                (@fin.mk
                   (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                   i
                   hi))
             (@fin.decidable_lt
                (@has_add.add.{0} nat nat.has_add
                   (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                   (@has_one.one.{0} nat nat.has_one))
                (@fin.mk
                   (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                   j
                   hj)
                (@fin.mk
                   (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                   i
                   hi))
             (fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
             (λ
              (h :
                @has_lt.lt.{0}
                  (fin
                     (@has_add.add.{0} nat nat.has_add
                        (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                        (@has_one.one.{0} nat nat.has_one)))
                  (@fin.has_lt
                     (@has_add.add.{0} nat nat.has_add
                        (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                        (@has_one.one.{0} nat nat.has_one)))
                  (@fin.mk
                     (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                     j
                     hj)
                  (@fin.mk
                     (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                     i
                     hi)),
                @fin.mk (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) j
                  (@fin.pred_above._proof_1 (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        i
                        hi)
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        j
                        hj)
                     h))
             (λ
              (h :
                not
                  (@has_lt.lt.{0}
                     (fin
                        (@has_add.add.{0} nat nat.has_add
                           (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                           (@has_one.one.{0} nat nat.has_one)))
                     (@fin.has_lt
                        (@has_add.add.{0} nat nat.has_add
                           (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                           (@has_one.one.{0} nat nat.has_one)))
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        j
                        hj)
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        i
                        hi))),
                @fin.pred (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                  (@fin.mk
                     (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                     j
                     hj)
                  (@fin.pred_above._proof_2 (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        i
                        hi)
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        j
                        hj)
                     (@_root_.ne.symm.{1}
                        (fin
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           i
                           hi)
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           j
                           hj)
                        ne)
                     h))))
       a
       (@subtype.val.{u_1+1} (list.{u_1} α) (λ (l : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l) n)
          (@vector.remove_nth.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
             (@dite.{1}
                (@has_lt.lt.{0}
                   (fin
                      (@has_add.add.{0} nat nat.has_add
                         (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                         (@has_one.one.{0} nat nat.has_one)))
                   (@fin.has_lt
                      (@has_add.add.{0} nat nat.has_add
                         (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                         (@has_one.one.{0} nat nat.has_one)))
                   (@fin.mk
                      (@has_add.add.{0} nat nat.has_add n
                         (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                      i
                      hi)
                   (@fin.mk
                      (@has_add.add.{0} nat nat.has_add n
                         (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                      j
                      hj))
                (@fin.decidable_lt
                   (@has_add.add.{0} nat nat.has_add
                      (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                      (@has_one.one.{0} nat nat.has_one))
                   (@fin.mk
                      (@has_add.add.{0} nat nat.has_add n
                         (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                      i
                      hi)
                   (@fin.mk
                      (@has_add.add.{0} nat nat.has_add n
                         (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                      j
                      hj))
                (fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
                (λ
                 (h :
                   @has_lt.lt.{0}
                     (fin
                        (@has_add.add.{0} nat nat.has_add
                           (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                           (@has_one.one.{0} nat nat.has_one)))
                     (@fin.has_lt
                        (@has_add.add.{0} nat nat.has_add
                           (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                           (@has_one.one.{0} nat nat.has_one)))
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        i
                        hi)
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        j
                        hj)),
                   @fin.mk (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) i
                     (@fin.pred_above._proof_1 (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           j
                           hj)
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           i
                           hi)
                        h))
                (λ
                 (h :
                   not
                     (@has_lt.lt.{0}
                        (fin
                           (@has_add.add.{0} nat nat.has_add
                              (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                              (@has_one.one.{0} nat nat.has_one)))
                        (@fin.has_lt
                           (@has_add.add.{0} nat nat.has_add
                              (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                              (@has_one.one.{0} nat nat.has_one)))
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           i
                           hi)
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           j
                           hj))),
                   @fin.pred (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        i
                        hi)
                     (@fin.pred_above._proof_2 (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           j
                           hj)
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           i
                           hi)
                        ne
                        h)))
             v)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : nat,
α : Type u_1,
a : α,
v : vector.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)),
remove_nth_insert_nth_ne :
  ∀ {i j : fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))}
  (h :
    @_root_.ne.{1}
      (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
      i
      j),
    @eq.{(max 1 (u_1+1))}
      (vector.{u_1} α
         (@has_sub.sub.{0} nat nat.has_sub
            (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
            (@has_one.one.{0} nat nat.has_one)))
      (@vector.remove_nth.{u_1} α
         (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
         i
         (@vector.insert_nth.{u_1} (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) α a j v))
      (@vector.insert_nth.{u_1} n α a
         (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) i j
            (@_root_.ne.symm.{1}
               (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
               i
               j
               h))
         (@vector.remove_nth.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
            (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) j i h)
            v)),
i : nat,
hi :
  @has_lt.lt.{0} nat nat.has_lt i
    (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))),
j : nat,
hj :
  @has_lt.lt.{0} nat nat.has_lt j
    (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))),
ne :
  @_root_.ne.{1}
    (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) i hi)
    (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) j hj),
this : @_root_.ne.{1} nat i j,
h :
  @has_lt.lt.{0} nat
    (@preorder.to_has_lt.{0} nat
       (@partial_order.to_preorder.{0} nat (@linear_order.to_partial_order.{0} nat nat.linear_order)))
    j
    i,
h_nij : not (@has_lt.lt.{0} nat nat.has_lt i j)
⊢ @eq.{u_1+1} (list.{u_1} α)
    (@list.remove_nth.{u_1} α
       (@list.insert_nth.{u_1} α j a
          (@subtype.val.{u_1+1} (list.{u_1} α)
             (λ (l : list.{u_1} α),
                @eq.{1} nat (@list.length.{u_1} α l)
                  (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
             v))
       i)
    (@list.insert_nth.{u_1} α
       (@fin.val (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
          (@dite.{1}
             (@has_lt.lt.{0}
                (fin
                   (@has_add.add.{0} nat nat.has_add
                      (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                      (@has_one.one.{0} nat nat.has_one)))
                (@fin.has_lt
                   (@has_add.add.{0} nat nat.has_add
                      (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                      (@has_one.one.{0} nat nat.has_one)))
                (@fin.mk
                   (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                   j
                   hj)
                (@fin.mk
                   (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                   i
                   hi))
             (@fin.decidable_lt
                (@has_add.add.{0} nat nat.has_add
                   (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                   (@has_one.one.{0} nat nat.has_one))
                (@fin.mk
                   (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                   j
                   hj)
                (@fin.mk
                   (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                   i
                   hi))
             (fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
             (λ
              (h :
                @has_lt.lt.{0}
                  (fin
                     (@has_add.add.{0} nat nat.has_add
                        (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                        (@has_one.one.{0} nat nat.has_one)))
                  (@fin.has_lt
                     (@has_add.add.{0} nat nat.has_add
                        (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                        (@has_one.one.{0} nat nat.has_one)))
                  (@fin.mk
                     (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                     j
                     hj)
                  (@fin.mk
                     (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                     i
                     hi)),
                @fin.mk (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) j
                  (@fin.pred_above._proof_1 (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        i
                        hi)
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        j
                        hj)
                     h))
             (λ
              (h :
                not
                  (@has_lt.lt.{0}
                     (fin
                        (@has_add.add.{0} nat nat.has_add
                           (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                           (@has_one.one.{0} nat nat.has_one)))
                     (@fin.has_lt
                        (@has_add.add.{0} nat nat.has_add
                           (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                           (@has_one.one.{0} nat nat.has_one)))
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        j
                        hj)
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        i
                        hi))),
                @fin.pred (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                  (@fin.mk
                     (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                     j
                     hj)
                  (@fin.pred_above._proof_2 (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        i
                        hi)
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        j
                        hj)
                     (@_root_.ne.symm.{1}
                        (fin
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           i
                           hi)
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           j
                           hj)
                        ne)
                     h))))
       a
       (@subtype.val.{u_1+1} (list.{u_1} α) (λ (l : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l) n)
          (@vector.remove_nth.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
             (@dite.{1}
                (@has_lt.lt.{0}
                   (fin
                      (@has_add.add.{0} nat nat.has_add
                         (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                         (@has_one.one.{0} nat nat.has_one)))
                   (@fin.has_lt
                      (@has_add.add.{0} nat nat.has_add
                         (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                         (@has_one.one.{0} nat nat.has_one)))
                   (@fin.mk
                      (@has_add.add.{0} nat nat.has_add n
                         (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                      i
                      hi)
                   (@fin.mk
                      (@has_add.add.{0} nat nat.has_add n
                         (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                      j
                      hj))
                (@fin.decidable_lt
                   (@has_add.add.{0} nat nat.has_add
                      (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                      (@has_one.one.{0} nat nat.has_one))
                   (@fin.mk
                      (@has_add.add.{0} nat nat.has_add n
                         (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                      i
                      hi)
                   (@fin.mk
                      (@has_add.add.{0} nat nat.has_add n
                         (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                      j
                      hj))
                (fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
                (λ
                 (h :
                   @has_lt.lt.{0}
                     (fin
                        (@has_add.add.{0} nat nat.has_add
                           (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                           (@has_one.one.{0} nat nat.has_one)))
                     (@fin.has_lt
                        (@has_add.add.{0} nat nat.has_add
                           (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                           (@has_one.one.{0} nat nat.has_one)))
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        i
                        hi)
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        j
                        hj)),
                   @fin.mk (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) i
                     (@fin.pred_above._proof_1 (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           j
                           hj)
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           i
                           hi)
                        h))
                (λ
                 (h :
                   not
                     (@has_lt.lt.{0}
                        (fin
                           (@has_add.add.{0} nat nat.has_add
                              (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                              (@has_one.one.{0} nat nat.has_one)))
                        (@fin.has_lt
                           (@has_add.add.{0} nat nat.has_add
                              (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                              (@has_one.one.{0} nat nat.has_one)))
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           i
                           hi)
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           j
                           hj))),
                   @fin.pred (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        i
                        hi)
                     (@fin.pred_above._proof_2 (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           j
                           hj)
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           i
                           hi)
                        ne
                        h)))
             v)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>178        have i_pos : 0 &lt; i := lt_of_le_of_lt (zero_le j) h,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='lt_of_le_of_lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='zero_le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 107, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/ordered_group.lean&#x27;, &#x27;line&#x27;: 355, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : preorder.{0} α] {a b c : α}, @has_le.le.{0} α (@preorder.to_has_le.{0} α _inst_1) a b → @has_lt.lt.{0} α (@preorder.to_has_lt.{0} α _inst_1) b c → @has_lt.lt.{0} α (@preorder.to_has_lt.{0} α _inst_1) a c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type} [_inst_1 : canonically_ordered_monoid.{0} α] (a : α), @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@ordered_comm_monoid.to_partial_order.{0} α (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} α _inst_1)))) (@has_zero.zero.{0} α (@add_monoid.to_has_zero.{0} α (@add_comm_monoid.to_add_monoid.{0} α (@ordered_comm_monoid.to_add_comm_monoid.{0} α (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} α _inst_1))))) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_lt.lt.{0} nat (@preorder.to_has_lt.{0} nat (@partial_order.to_preorder.{0} nat (@linear_order.to_partial_order.{0} nat nat.linear_order))) j i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : nat,
α : Type u_1,
a : α,
v : vector.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)),
remove_nth_insert_nth_ne :
  ∀ {i j : fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))}
  (h :
    @_root_.ne.{1}
      (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
      i
      j),
    @eq.{(max 1 (u_1+1))}
      (vector.{u_1} α
         (@has_sub.sub.{0} nat nat.has_sub
            (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
            (@has_one.one.{0} nat nat.has_one)))
      (@vector.remove_nth.{u_1} α
         (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
         i
         (@vector.insert_nth.{u_1} (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) α a j v))
      (@vector.insert_nth.{u_1} n α a
         (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) i j
            (@_root_.ne.symm.{1}
               (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
               i
               j
               h))
         (@vector.remove_nth.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
            (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) j i h)
            v)),
i : nat,
hi :
  @has_lt.lt.{0} nat nat.has_lt i
    (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))),
j : nat,
hj :
  @has_lt.lt.{0} nat nat.has_lt j
    (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))),
ne :
  @_root_.ne.{1}
    (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) i hi)
    (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) j hj),
this : @_root_.ne.{1} nat i j,
h :
  @has_lt.lt.{0} nat
    (@preorder.to_has_lt.{0} nat
       (@partial_order.to_preorder.{0} nat (@linear_order.to_partial_order.{0} nat nat.linear_order)))
    j
    i,
h_nij : not (@has_lt.lt.{0} nat nat.has_lt i j)
⊢ @eq.{u_1+1} (list.{u_1} α)
    (@list.remove_nth.{u_1} α
       (@list.insert_nth.{u_1} α j a
          (@subtype.val.{u_1+1} (list.{u_1} α)
             (λ (l : list.{u_1} α),
                @eq.{1} nat (@list.length.{u_1} α l)
                  (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
             v))
       i)
    (@list.insert_nth.{u_1} α
       (@fin.val (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
          (@dite.{1}
             (@has_lt.lt.{0}
                (fin
                   (@has_add.add.{0} nat nat.has_add
                      (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                      (@has_one.one.{0} nat nat.has_one)))
                (@fin.has_lt
                   (@has_add.add.{0} nat nat.has_add
                      (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                      (@has_one.one.{0} nat nat.has_one)))
                (@fin.mk
                   (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                   j
                   hj)
                (@fin.mk
                   (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                   i
                   hi))
             (@fin.decidable_lt
                (@has_add.add.{0} nat nat.has_add
                   (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                   (@has_one.one.{0} nat nat.has_one))
                (@fin.mk
                   (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                   j
                   hj)
                (@fin.mk
                   (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                   i
                   hi))
             (fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
             (λ
              (h :
                @has_lt.lt.{0}
                  (fin
                     (@has_add.add.{0} nat nat.has_add
                        (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                        (@has_one.one.{0} nat nat.has_one)))
                  (@fin.has_lt
                     (@has_add.add.{0} nat nat.has_add
                        (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                        (@has_one.one.{0} nat nat.has_one)))
                  (@fin.mk
                     (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                     j
                     hj)
                  (@fin.mk
                     (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                     i
                     hi)),
                @fin.mk (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) j
                  (@fin.pred_above._proof_1 (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        i
                        hi)
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        j
                        hj)
                     h))
             (λ
              (h :
                not
                  (@has_lt.lt.{0}
                     (fin
                        (@has_add.add.{0} nat nat.has_add
                           (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                           (@has_one.one.{0} nat nat.has_one)))
                     (@fin.has_lt
                        (@has_add.add.{0} nat nat.has_add
                           (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                           (@has_one.one.{0} nat nat.has_one)))
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        j
                        hj)
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        i
                        hi))),
                @fin.pred (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                  (@fin.mk
                     (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                     j
                     hj)
                  (@fin.pred_above._proof_2 (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        i
                        hi)
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        j
                        hj)
                     (@_root_.ne.symm.{1}
                        (fin
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           i
                           hi)
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           j
                           hj)
                        ne)
                     h))))
       a
       (@subtype.val.{u_1+1} (list.{u_1} α) (λ (l : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l) n)
          (@vector.remove_nth.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
             (@dite.{1}
                (@has_lt.lt.{0}
                   (fin
                      (@has_add.add.{0} nat nat.has_add
                         (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                         (@has_one.one.{0} nat nat.has_one)))
                   (@fin.has_lt
                      (@has_add.add.{0} nat nat.has_add
                         (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                         (@has_one.one.{0} nat nat.has_one)))
                   (@fin.mk
                      (@has_add.add.{0} nat nat.has_add n
                         (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                      i
                      hi)
                   (@fin.mk
                      (@has_add.add.{0} nat nat.has_add n
                         (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                      j
                      hj))
                (@fin.decidable_lt
                   (@has_add.add.{0} nat nat.has_add
                      (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                      (@has_one.one.{0} nat nat.has_one))
                   (@fin.mk
                      (@has_add.add.{0} nat nat.has_add n
                         (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                      i
                      hi)
                   (@fin.mk
                      (@has_add.add.{0} nat nat.has_add n
                         (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                      j
                      hj))
                (fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
                (λ
                 (h :
                   @has_lt.lt.{0}
                     (fin
                        (@has_add.add.{0} nat nat.has_add
                           (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                           (@has_one.one.{0} nat nat.has_one)))
                     (@fin.has_lt
                        (@has_add.add.{0} nat nat.has_add
                           (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                           (@has_one.one.{0} nat nat.has_one)))
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        i
                        hi)
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        j
                        hj)),
                   @fin.mk (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) i
                     (@fin.pred_above._proof_1 (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           j
                           hj)
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           i
                           hi)
                        h))
                (λ
                 (h :
                   not
                     (@has_lt.lt.{0}
                        (fin
                           (@has_add.add.{0} nat nat.has_add
                              (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                              (@has_one.one.{0} nat nat.has_one)))
                        (@fin.has_lt
                           (@has_add.add.{0} nat nat.has_add
                              (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                              (@has_one.one.{0} nat nat.has_one)))
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           i
                           hi)
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           j
                           hj))),
                   @fin.pred (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        i
                        hi)
                     (@fin.pred_above._proof_2 (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           j
                           hj)
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           i
                           hi)
                        ne
                        h)))
             v)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : nat,
α : Type u_1,
a : α,
v : vector.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)),
remove_nth_insert_nth_ne :
  ∀ {i j : fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))}
  (h :
    @_root_.ne.{1}
      (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
      i
      j),
    @eq.{(max 1 (u_1+1))}
      (vector.{u_1} α
         (@has_sub.sub.{0} nat nat.has_sub
            (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
            (@has_one.one.{0} nat nat.has_one)))
      (@vector.remove_nth.{u_1} α
         (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
         i
         (@vector.insert_nth.{u_1} (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) α a j v))
      (@vector.insert_nth.{u_1} n α a
         (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) i j
            (@_root_.ne.symm.{1}
               (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
               i
               j
               h))
         (@vector.remove_nth.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
            (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) j i h)
            v)),
i : nat,
hi :
  @has_lt.lt.{0} nat nat.has_lt i
    (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))),
j : nat,
hj :
  @has_lt.lt.{0} nat nat.has_lt j
    (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))),
ne :
  @_root_.ne.{1}
    (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) i hi)
    (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) j hj),
this : @_root_.ne.{1} nat i j,
h :
  @has_lt.lt.{0} nat
    (@preorder.to_has_lt.{0} nat
       (@partial_order.to_preorder.{0} nat (@linear_order.to_partial_order.{0} nat nat.linear_order)))
    j
    i,
h_nij : not (@has_lt.lt.{0} nat nat.has_lt i j),
i_pos : @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) i
⊢ @eq.{u_1+1} (list.{u_1} α)
    (@list.remove_nth.{u_1} α
       (@list.insert_nth.{u_1} α j a
          (@subtype.val.{u_1+1} (list.{u_1} α)
             (λ (l : list.{u_1} α),
                @eq.{1} nat (@list.length.{u_1} α l)
                  (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
             v))
       i)
    (@list.insert_nth.{u_1} α
       (@fin.val (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
          (@dite.{1}
             (@has_lt.lt.{0}
                (fin
                   (@has_add.add.{0} nat nat.has_add
                      (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                      (@has_one.one.{0} nat nat.has_one)))
                (@fin.has_lt
                   (@has_add.add.{0} nat nat.has_add
                      (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                      (@has_one.one.{0} nat nat.has_one)))
                (@fin.mk
                   (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                   j
                   hj)
                (@fin.mk
                   (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                   i
                   hi))
             (@fin.decidable_lt
                (@has_add.add.{0} nat nat.has_add
                   (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                   (@has_one.one.{0} nat nat.has_one))
                (@fin.mk
                   (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                   j
                   hj)
                (@fin.mk
                   (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                   i
                   hi))
             (fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
             (λ
              (h :
                @has_lt.lt.{0}
                  (fin
                     (@has_add.add.{0} nat nat.has_add
                        (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                        (@has_one.one.{0} nat nat.has_one)))
                  (@fin.has_lt
                     (@has_add.add.{0} nat nat.has_add
                        (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                        (@has_one.one.{0} nat nat.has_one)))
                  (@fin.mk
                     (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                     j
                     hj)
                  (@fin.mk
                     (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                     i
                     hi)),
                @fin.mk (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) j
                  (@fin.pred_above._proof_1 (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        i
                        hi)
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        j
                        hj)
                     h))
             (λ
              (h :
                not
                  (@has_lt.lt.{0}
                     (fin
                        (@has_add.add.{0} nat nat.has_add
                           (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                           (@has_one.one.{0} nat nat.has_one)))
                     (@fin.has_lt
                        (@has_add.add.{0} nat nat.has_add
                           (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                           (@has_one.one.{0} nat nat.has_one)))
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        j
                        hj)
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        i
                        hi))),
                @fin.pred (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                  (@fin.mk
                     (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                     j
                     hj)
                  (@fin.pred_above._proof_2 (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        i
                        hi)
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        j
                        hj)
                     (@_root_.ne.symm.{1}
                        (fin
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           i
                           hi)
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           j
                           hj)
                        ne)
                     h))))
       a
       (@subtype.val.{u_1+1} (list.{u_1} α) (λ (l : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l) n)
          (@vector.remove_nth.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
             (@dite.{1}
                (@has_lt.lt.{0}
                   (fin
                      (@has_add.add.{0} nat nat.has_add
                         (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                         (@has_one.one.{0} nat nat.has_one)))
                   (@fin.has_lt
                      (@has_add.add.{0} nat nat.has_add
                         (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                         (@has_one.one.{0} nat nat.has_one)))
                   (@fin.mk
                      (@has_add.add.{0} nat nat.has_add n
                         (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                      i
                      hi)
                   (@fin.mk
                      (@has_add.add.{0} nat nat.has_add n
                         (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                      j
                      hj))
                (@fin.decidable_lt
                   (@has_add.add.{0} nat nat.has_add
                      (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                      (@has_one.one.{0} nat nat.has_one))
                   (@fin.mk
                      (@has_add.add.{0} nat nat.has_add n
                         (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                      i
                      hi)
                   (@fin.mk
                      (@has_add.add.{0} nat nat.has_add n
                         (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                      j
                      hj))
                (fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
                (λ
                 (h :
                   @has_lt.lt.{0}
                     (fin
                        (@has_add.add.{0} nat nat.has_add
                           (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                           (@has_one.one.{0} nat nat.has_one)))
                     (@fin.has_lt
                        (@has_add.add.{0} nat nat.has_add
                           (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                           (@has_one.one.{0} nat nat.has_one)))
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        i
                        hi)
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        j
                        hj)),
                   @fin.mk (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) i
                     (@fin.pred_above._proof_1 (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           j
                           hj)
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           i
                           hi)
                        h))
                (λ
                 (h :
                   not
                     (@has_lt.lt.{0}
                        (fin
                           (@has_add.add.{0} nat nat.has_add
                              (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                              (@has_one.one.{0} nat nat.has_one)))
                        (@fin.has_lt
                           (@has_add.add.{0} nat nat.has_add
                              (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                              (@has_one.one.{0} nat nat.has_one)))
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           i
                           hi)
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           j
                           hj))),
                   @fin.pred (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        i
                        hi)
                     (@fin.pred_above._proof_2 (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           j
                           hj)
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           i
                           hi)
                        ne
                        h)))
             v)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>179        simp [h, h_nij, fin.lt_iff_val_lt_val],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='h_nij'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='fin.lt_iff_val_lt_val'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/fin.lean&#x27;, &#x27;line&#x27;: 64, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_lt.lt.{0} nat (@preorder.to_has_lt.{0} nat (@partial_order.to_preorder.{0} nat (@linear_order.to_partial_order.{0} nat nat.linear_order))) j i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='not (@has_lt.lt.{0} nat nat.has_lt i j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {n : nat} {a b : fin n}, iff (@has_lt.lt.{0} (fin n) (@fin.has_lt n) a b) (@has_lt.lt.{0} nat nat.has_lt (@fin.val n a) (@fin.val n b))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : nat,
α : Type u_1,
a : α,
v : vector.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)),
remove_nth_insert_nth_ne :
  ∀ {i j : fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))}
  (h :
    @_root_.ne.{1}
      (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
      i
      j),
    @eq.{(max 1 (u_1+1))}
      (vector.{u_1} α
         (@has_sub.sub.{0} nat nat.has_sub
            (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
            (@has_one.one.{0} nat nat.has_one)))
      (@vector.remove_nth.{u_1} α
         (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
         i
         (@vector.insert_nth.{u_1} (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) α a j v))
      (@vector.insert_nth.{u_1} n α a
         (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) i j
            (@_root_.ne.symm.{1}
               (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
               i
               j
               h))
         (@vector.remove_nth.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
            (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) j i h)
            v)),
i : nat,
hi :
  @has_lt.lt.{0} nat nat.has_lt i
    (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))),
j : nat,
hj :
  @has_lt.lt.{0} nat nat.has_lt j
    (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))),
ne :
  @_root_.ne.{1}
    (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) i hi)
    (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) j hj),
this : @_root_.ne.{1} nat i j,
h :
  @has_lt.lt.{0} nat
    (@preorder.to_has_lt.{0} nat
       (@partial_order.to_preorder.{0} nat (@linear_order.to_partial_order.{0} nat nat.linear_order)))
    j
    i,
h_nij : not (@has_lt.lt.{0} nat nat.has_lt i j),
i_pos : @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) i
⊢ @eq.{u_1+1} (list.{u_1} α)
    (@list.remove_nth.{u_1} α
       (@list.insert_nth.{u_1} α j a
          (@subtype.val.{u_1+1} (list.{u_1} α)
             (λ (l : list.{u_1} α),
                @eq.{1} nat (@list.length.{u_1} α l)
                  (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
             v))
       i)
    (@list.insert_nth.{u_1} α
       (@fin.val (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
          (@dite.{1}
             (@has_lt.lt.{0}
                (fin
                   (@has_add.add.{0} nat nat.has_add
                      (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                      (@has_one.one.{0} nat nat.has_one)))
                (@fin.has_lt
                   (@has_add.add.{0} nat nat.has_add
                      (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                      (@has_one.one.{0} nat nat.has_one)))
                (@fin.mk
                   (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                   j
                   hj)
                (@fin.mk
                   (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                   i
                   hi))
             (@fin.decidable_lt
                (@has_add.add.{0} nat nat.has_add
                   (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                   (@has_one.one.{0} nat nat.has_one))
                (@fin.mk
                   (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                   j
                   hj)
                (@fin.mk
                   (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                   i
                   hi))
             (fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
             (λ
              (h :
                @has_lt.lt.{0}
                  (fin
                     (@has_add.add.{0} nat nat.has_add
                        (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                        (@has_one.one.{0} nat nat.has_one)))
                  (@fin.has_lt
                     (@has_add.add.{0} nat nat.has_add
                        (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                        (@has_one.one.{0} nat nat.has_one)))
                  (@fin.mk
                     (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                     j
                     hj)
                  (@fin.mk
                     (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                     i
                     hi)),
                @fin.mk (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) j
                  (@fin.pred_above._proof_1 (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        i
                        hi)
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        j
                        hj)
                     h))
             (λ
              (h :
                not
                  (@has_lt.lt.{0}
                     (fin
                        (@has_add.add.{0} nat nat.has_add
                           (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                           (@has_one.one.{0} nat nat.has_one)))
                     (@fin.has_lt
                        (@has_add.add.{0} nat nat.has_add
                           (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                           (@has_one.one.{0} nat nat.has_one)))
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        j
                        hj)
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        i
                        hi))),
                @fin.pred (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                  (@fin.mk
                     (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                     j
                     hj)
                  (@fin.pred_above._proof_2 (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        i
                        hi)
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        j
                        hj)
                     (@_root_.ne.symm.{1}
                        (fin
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           i
                           hi)
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           j
                           hj)
                        ne)
                     h))))
       a
       (@subtype.val.{u_1+1} (list.{u_1} α) (λ (l : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l) n)
          (@vector.remove_nth.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
             (@dite.{1}
                (@has_lt.lt.{0}
                   (fin
                      (@has_add.add.{0} nat nat.has_add
                         (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                         (@has_one.one.{0} nat nat.has_one)))
                   (@fin.has_lt
                      (@has_add.add.{0} nat nat.has_add
                         (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                         (@has_one.one.{0} nat nat.has_one)))
                   (@fin.mk
                      (@has_add.add.{0} nat nat.has_add n
                         (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                      i
                      hi)
                   (@fin.mk
                      (@has_add.add.{0} nat nat.has_add n
                         (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                      j
                      hj))
                (@fin.decidable_lt
                   (@has_add.add.{0} nat nat.has_add
                      (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                      (@has_one.one.{0} nat nat.has_one))
                   (@fin.mk
                      (@has_add.add.{0} nat nat.has_add n
                         (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                      i
                      hi)
                   (@fin.mk
                      (@has_add.add.{0} nat nat.has_add n
                         (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                      j
                      hj))
                (fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
                (λ
                 (h :
                   @has_lt.lt.{0}
                     (fin
                        (@has_add.add.{0} nat nat.has_add
                           (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                           (@has_one.one.{0} nat nat.has_one)))
                     (@fin.has_lt
                        (@has_add.add.{0} nat nat.has_add
                           (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                           (@has_one.one.{0} nat nat.has_one)))
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        i
                        hi)
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        j
                        hj)),
                   @fin.mk (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) i
                     (@fin.pred_above._proof_1 (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           j
                           hj)
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           i
                           hi)
                        h))
                (λ
                 (h :
                   not
                     (@has_lt.lt.{0}
                        (fin
                           (@has_add.add.{0} nat nat.has_add
                              (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                              (@has_one.one.{0} nat nat.has_one)))
                        (@fin.has_lt
                           (@has_add.add.{0} nat nat.has_add
                              (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                              (@has_one.one.{0} nat nat.has_one)))
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           i
                           hi)
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           j
                           hj))),
                   @fin.pred (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                     (@fin.mk
                        (@has_add.add.{0} nat nat.has_add n
                           (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                        i
                        hi)
                     (@fin.pred_above._proof_2 (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           j
                           hj)
                        (@fin.mk
                           (@has_add.add.{0} nat nat.has_add n
                              (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                           i
                           hi)
                        ne
                        h)))
             v)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : nat,
α : Type u_1,
a : α,
v : vector.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)),
remove_nth_insert_nth_ne :
  ∀ {i j : fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))}
  (h :
    @_root_.ne.{1}
      (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
      i
      j),
    @eq.{(max 1 (u_1+1))}
      (vector.{u_1} α
         (@has_sub.sub.{0} nat nat.has_sub
            (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
            (@has_one.one.{0} nat nat.has_one)))
      (@vector.remove_nth.{u_1} α
         (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
         i
         (@vector.insert_nth.{u_1} (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) α a j v))
      (@vector.insert_nth.{u_1} n α a
         (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) i j
            (@_root_.ne.symm.{1}
               (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
               i
               j
               h))
         (@vector.remove_nth.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
            (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) j i h)
            v)),
i : nat,
hi :
  @has_lt.lt.{0} nat nat.has_lt i
    (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))),
j : nat,
hj :
  @has_lt.lt.{0} nat nat.has_lt j
    (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))),
ne :
  @_root_.ne.{1}
    (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) i hi)
    (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) j hj),
this : @_root_.ne.{1} nat i j,
h :
  @has_lt.lt.{0} nat
    (@preorder.to_has_lt.{0} nat
       (@partial_order.to_preorder.{0} nat (@linear_order.to_partial_order.{0} nat nat.linear_order)))
    j
    i,
h_nij : not (@has_lt.lt.{0} nat nat.has_lt i j),
i_pos : @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) i
⊢ @eq.{u_1+1} (list.{u_1} α)
    (@list.remove_nth.{u_1} α
       (@list.insert_nth.{u_1} α j a
          (@subtype.val.{u_1+1} (list.{u_1} α)
             (λ (l : list.{u_1} α),
                @eq.{1} nat (@list.length.{u_1} α l)
                  (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
             v))
       i)
    (@list.insert_nth.{u_1} α j a
       (@list.remove_nth.{u_1} α
          (@subtype.val.{u_1+1} (list.{u_1} α)
             (λ (l : list.{u_1} α),
                @eq.{1} nat (@list.length.{u_1} α l)
                  (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
             v)
          (nat.pred i)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>180        rw [show i.pred = i - 1, from rfl, list.insert_nth_remove_nth_of_le, nat.sub_add_cancel i_pos],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='nat.pred'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='list.insert_nth_remove_nth_of_le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='nat.sub_add_cancel'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i_pos'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/nat/basic.lean&#x27;, &#x27;line&#x27;: 26, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/list/basic.lean&#x27;, &#x27;line&#x27;: 1058, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/nat/lemmas.lean&#x27;, &#x27;line&#x27;: 594, &#x27;column&#x27;: 18}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{1} nat (nat.pred i) (@has_sub.sub.{0} nat nat.has_sub i (@has_one.one.{0} nat nat.has_one))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} {a : α}, @eq.{1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {a : α} (n m : nat) (as : list.{u_1} α), @has_lt.lt.{0} nat nat.has_lt n (@list.length.{u_1} α as) → @has_le.le.{0} nat nat.has_le m n → @eq.{u_1+1} (list.{u_1} α) (@list.insert_nth.{u_1} α m a (@list.remove_nth.{u_1} α as n)) (@list.remove_nth.{u_1} α (@list.insert_nth.{u_1} α m a as) (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {n m : nat}, @ge.{0} nat nat.has_le n m → @eq.{1} nat (@has_add.add.{0} nat nat.has_add (@has_sub.sub.{0} nat nat.has_sub n m) m) n'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) i'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : nat,
α : Type u_1,
a : α,
v : vector.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)),
remove_nth_insert_nth_ne :
  ∀ {i j : fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))}
  (h :
    @_root_.ne.{1}
      (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
      i
      j),
    @eq.{(max 1 (u_1+1))}
      (vector.{u_1} α
         (@has_sub.sub.{0} nat nat.has_sub
            (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
            (@has_one.one.{0} nat nat.has_one)))
      (@vector.remove_nth.{u_1} α
         (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
         i
         (@vector.insert_nth.{u_1} (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) α a j v))
      (@vector.insert_nth.{u_1} n α a
         (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) i j
            (@_root_.ne.symm.{1}
               (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
               i
               j
               h))
         (@vector.remove_nth.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
            (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) j i h)
            v)),
i : nat,
hi :
  @has_lt.lt.{0} nat nat.has_lt i
    (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))),
j : nat,
hj :
  @has_lt.lt.{0} nat nat.has_lt j
    (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))),
ne :
  @_root_.ne.{1}
    (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) i hi)
    (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) j hj),
this : @_root_.ne.{1} nat i j,
h :
  @has_lt.lt.{0} nat
    (@preorder.to_has_lt.{0} nat
       (@partial_order.to_preorder.{0} nat (@linear_order.to_partial_order.{0} nat nat.linear_order)))
    j
    i,
h_nij : not (@has_lt.lt.{0} nat nat.has_lt i j),
i_pos : @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) i
⊢ @eq.{u_1+1} (list.{u_1} α)
    (@list.remove_nth.{u_1} α
       (@list.insert_nth.{u_1} α j a
          (@subtype.val.{u_1+1} (list.{u_1} α)
             (λ (l : list.{u_1} α),
                @eq.{1} nat (@list.length.{u_1} α l)
                  (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
             v))
       i)
    (@list.insert_nth.{u_1} α j a
       (@list.remove_nth.{u_1} α
          (@subtype.val.{u_1+1} (list.{u_1} α)
             (λ (l : list.{u_1} α),
                @eq.{1} nat (@list.length.{u_1} α l)
                  (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
             v)
          (nat.pred i)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : nat,
α : Type u_1,
a : α,
v : vector.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)),
remove_nth_insert_nth_ne :
  ∀ {i j : fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))}
  (h :
    @_root_.ne.{1}
      (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
      i
      j),
    @eq.{(max 1 (u_1+1))}
      (vector.{u_1} α
         (@has_sub.sub.{0} nat nat.has_sub
            (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
            (@has_one.one.{0} nat nat.has_one)))
      (@vector.remove_nth.{u_1} α
         (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
         i
         (@vector.insert_nth.{u_1} (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) α a j v))
      (@vector.insert_nth.{u_1} n α a
         (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) i j
            (@_root_.ne.symm.{1}
               (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
               i
               j
               h))
         (@vector.remove_nth.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
            (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) j i h)
            v)),
i : nat,
hi :
  @has_lt.lt.{0} nat nat.has_lt i
    (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))),
j : nat,
hj :
  @has_lt.lt.{0} nat nat.has_lt j
    (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))),
ne :
  @_root_.ne.{1}
    (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) i hi)
    (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) j hj),
this : @_root_.ne.{1} nat i j,
h :
  @has_lt.lt.{0} nat
    (@preorder.to_has_lt.{0} nat
       (@partial_order.to_preorder.{0} nat (@linear_order.to_partial_order.{0} nat nat.linear_order)))
    j
    i,
h_nij : not (@has_lt.lt.{0} nat nat.has_lt i j),
i_pos : @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) i
⊢ @eq.{u_1+1} (list.{u_1} α)
    (@list.remove_nth.{u_1} α
       (@list.insert_nth.{u_1} α j a
          (@subtype.val.{u_1+1} (list.{u_1} α)
             (λ (l : list.{u_1} α),
                @eq.{1} nat (@list.length.{u_1} α l)
                  (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
             v))
       i)
    (@list.insert_nth.{u_1} α j a
       (@list.remove_nth.{u_1} α
          (@subtype.val.{u_1+1} (list.{u_1} α)
             (λ (l : list.{u_1} α),
                @eq.{1} nat (@list.length.{u_1} α l)
                  (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
             v)
          (@has_sub.sub.{0} nat nat.has_sub i (@has_one.one.{0} nat nat.has_one))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
n : nat,
α : Type u_1,
a : α,
v : vector.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)),
remove_nth_insert_nth_ne :
  ∀ {i j : fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))}
  (h :
    @_root_.ne.{1}
      (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
      i
      j),
    @eq.{(max 1 (u_1+1))}
      (vector.{u_1} α
         (@has_sub.sub.{0} nat nat.has_sub
            (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
            (@has_one.one.{0} nat nat.has_one)))
      (@vector.remove_nth.{u_1} α
         (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
         i
         (@vector.insert_nth.{u_1} (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) α a j v))
      (@vector.insert_nth.{u_1} n α a
         (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) i j
            (@_root_.ne.symm.{1}
               (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
               i
               j
               h))
         (@vector.remove_nth.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
            (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) j i h)
            v)),
i : nat,
hi :
  @has_lt.lt.{0} nat nat.has_lt i
    (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))),
j : nat,
hj :
  @has_lt.lt.{0} nat nat.has_lt j
    (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))),
ne :
  @_root_.ne.{1}
    (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) i hi)
    (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) j hj),
this : @_root_.ne.{1} nat i j,
h :
  @has_lt.lt.{0} nat
    (@preorder.to_has_lt.{0} nat
       (@partial_order.to_preorder.{0} nat (@linear_order.to_partial_order.{0} nat nat.linear_order)))
    j
    i,
h_nij : not (@has_lt.lt.{0} nat nat.has_lt i j),
i_pos : @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) i
⊢ @eq.{u_1+1} (list.{u_1} α)
    (@list.remove_nth.{u_1} α
       (@list.insert_nth.{u_1} α j a
          (@subtype.val.{u_1+1} (list.{u_1} α)
             (λ (l : list.{u_1} α),
                @eq.{1} nat (@list.length.{u_1} α l)
                  (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
             v))
       i)
    (@list.remove_nth.{u_1} α
       (@list.insert_nth.{u_1} α j a
          (@subtype.val.{u_1+1} (list.{u_1} α)
             (λ (l : list.{u_1} α),
                @eq.{1} nat (@list.length.{u_1} α l)
                  (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
             v))
       (@has_add.add.{0} nat nat.has_add (@has_sub.sub.{0} nat nat.has_sub i (@has_one.one.{0} nat nat.has_one))
          (@has_one.one.{0} nat nat.has_one)))

n : nat,
α : Type u_1,
a : α,
v : vector.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)),
remove_nth_insert_nth_ne :
  ∀ {i j : fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))}
  (h :
    @_root_.ne.{1}
      (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
      i
      j),
    @eq.{(max 1 (u_1+1))}
      (vector.{u_1} α
         (@has_sub.sub.{0} nat nat.has_sub
            (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
            (@has_one.one.{0} nat nat.has_one)))
      (@vector.remove_nth.{u_1} α
         (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
         i
         (@vector.insert_nth.{u_1} (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) α a j v))
      (@vector.insert_nth.{u_1} n α a
         (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) i j
            (@_root_.ne.symm.{1}
               (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
               i
               j
               h))
         (@vector.remove_nth.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
            (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) j i h)
            v)),
i : nat,
hi :
  @has_lt.lt.{0} nat nat.has_lt i
    (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))),
j : nat,
hj :
  @has_lt.lt.{0} nat nat.has_lt j
    (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))),
ne :
  @_root_.ne.{1}
    (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) i hi)
    (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) j hj),
this : @_root_.ne.{1} nat i j,
h :
  @has_lt.lt.{0} nat
    (@preorder.to_has_lt.{0} nat
       (@partial_order.to_preorder.{0} nat (@linear_order.to_partial_order.{0} nat nat.linear_order)))
    j
    i,
h_nij : not (@has_lt.lt.{0} nat nat.has_lt i j),
i_pos : @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) i
⊢ @has_lt.lt.{0} nat nat.has_lt (@has_sub.sub.{0} nat nat.has_sub i (@has_one.one.{0} nat nat.has_one))
    (@list.length.{u_1} α
       (@subtype.val.{u_1+1} (list.{u_1} α)
          (λ (l : list.{u_1} α),
             @eq.{1} nat (@list.length.{u_1} α l)
               (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
          v))

n : nat,
α : Type u_1,
a : α,
v : vector.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)),
remove_nth_insert_nth_ne :
  ∀ {i j : fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))}
  (h :
    @_root_.ne.{1}
      (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
      i
      j),
    @eq.{(max 1 (u_1+1))}
      (vector.{u_1} α
         (@has_sub.sub.{0} nat nat.has_sub
            (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
            (@has_one.one.{0} nat nat.has_one)))
      (@vector.remove_nth.{u_1} α
         (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
         i
         (@vector.insert_nth.{u_1} (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) α a j v))
      (@vector.insert_nth.{u_1} n α a
         (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) i j
            (@_root_.ne.symm.{1}
               (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
               i
               j
               h))
         (@vector.remove_nth.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
            (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) j i h)
            v)),
i : nat,
hi :
  @has_lt.lt.{0} nat nat.has_lt i
    (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))),
j : nat,
hj :
  @has_lt.lt.{0} nat nat.has_lt j
    (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))),
ne :
  @_root_.ne.{1}
    (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) i hi)
    (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) j hj),
this : @_root_.ne.{1} nat i j,
h :
  @has_lt.lt.{0} nat
    (@preorder.to_has_lt.{0} nat
       (@partial_order.to_preorder.{0} nat (@linear_order.to_partial_order.{0} nat nat.linear_order)))
    j
    i,
h_nij : not (@has_lt.lt.{0} nat nat.has_lt i j),
i_pos : @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) i
⊢ @has_le.le.{0} nat nat.has_le j (@has_sub.sub.{0} nat nat.has_sub i (@has_one.one.{0} nat nat.has_one))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
n : nat,
α : Type u_1,
a : α,
v : vector.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)),
remove_nth_insert_nth_ne :
  ∀ {i j : fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))}
  (h :
    @_root_.ne.{1}
      (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
      i
      j),
    @eq.{(max 1 (u_1+1))}
      (vector.{u_1} α
         (@has_sub.sub.{0} nat nat.has_sub
            (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
            (@has_one.one.{0} nat nat.has_one)))
      (@vector.remove_nth.{u_1} α
         (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
         i
         (@vector.insert_nth.{u_1} (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) α a j v))
      (@vector.insert_nth.{u_1} n α a
         (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) i j
            (@_root_.ne.symm.{1}
               (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
               i
               j
               h))
         (@vector.remove_nth.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
            (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) j i h)
            v)),
i : nat,
hi :
  @has_lt.lt.{0} nat nat.has_lt i
    (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))),
j : nat,
hj :
  @has_lt.lt.{0} nat nat.has_lt j
    (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))),
ne :
  @_root_.ne.{1}
    (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) i hi)
    (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) j hj),
this : @_root_.ne.{1} nat i j,
h :
  @has_lt.lt.{0} nat
    (@preorder.to_has_lt.{0} nat
       (@partial_order.to_preorder.{0} nat (@linear_order.to_partial_order.{0} nat nat.linear_order)))
    j
    i,
h_nij : not (@has_lt.lt.{0} nat nat.has_lt i j),
i_pos : @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) i
⊢ @has_lt.lt.{0} nat nat.has_lt (@has_sub.sub.{0} nat nat.has_sub i (@has_one.one.{0} nat nat.has_one))
    (@list.length.{u_1} α
       (@subtype.val.{u_1+1} (list.{u_1} α)
          (λ (l : list.{u_1} α),
             @eq.{1} nat (@list.length.{u_1} α l)
               (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
          v))

n : nat,
α : Type u_1,
a : α,
v : vector.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)),
remove_nth_insert_nth_ne :
  ∀ {i j : fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))}
  (h :
    @_root_.ne.{1}
      (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
      i
      j),
    @eq.{(max 1 (u_1+1))}
      (vector.{u_1} α
         (@has_sub.sub.{0} nat nat.has_sub
            (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
            (@has_one.one.{0} nat nat.has_one)))
      (@vector.remove_nth.{u_1} α
         (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
         i
         (@vector.insert_nth.{u_1} (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) α a j v))
      (@vector.insert_nth.{u_1} n α a
         (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) i j
            (@_root_.ne.symm.{1}
               (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
               i
               j
               h))
         (@vector.remove_nth.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
            (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) j i h)
            v)),
i : nat,
hi :
  @has_lt.lt.{0} nat nat.has_lt i
    (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))),
j : nat,
hj :
  @has_lt.lt.{0} nat nat.has_lt j
    (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))),
ne :
  @_root_.ne.{1}
    (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) i hi)
    (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) j hj),
this : @_root_.ne.{1} nat i j,
h :
  @has_lt.lt.{0} nat
    (@preorder.to_has_lt.{0} nat
       (@partial_order.to_preorder.{0} nat (@linear_order.to_partial_order.{0} nat nat.linear_order)))
    j
    i,
h_nij : not (@has_lt.lt.{0} nat nat.has_lt i j),
i_pos : @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) i
⊢ @has_le.le.{0} nat nat.has_le j (@has_sub.sub.{0} nat nat.has_sub i (@has_one.one.{0} nat nat.has_one))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>181        { show i - 1 + 1 ≤ v.val.length,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='has_le.le'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 319, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} [c : has_add.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} [c : has_le.{0} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='vector.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
n : nat,
α : Type u_1,
a : α,
v : vector.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)),
remove_nth_insert_nth_ne :
  ∀ {i j : fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))}
  (h :
    @_root_.ne.{1}
      (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
      i
      j),
    @eq.{(max 1 (u_1+1))}
      (vector.{u_1} α
         (@has_sub.sub.{0} nat nat.has_sub
            (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
            (@has_one.one.{0} nat nat.has_one)))
      (@vector.remove_nth.{u_1} α
         (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
         i
         (@vector.insert_nth.{u_1} (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) α a j v))
      (@vector.insert_nth.{u_1} n α a
         (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) i j
            (@_root_.ne.symm.{1}
               (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
               i
               j
               h))
         (@vector.remove_nth.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
            (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) j i h)
            v)),
i : nat,
hi :
  @has_lt.lt.{0} nat nat.has_lt i
    (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))),
j : nat,
hj :
  @has_lt.lt.{0} nat nat.has_lt j
    (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))),
ne :
  @_root_.ne.{1}
    (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) i hi)
    (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) j hj),
this : @_root_.ne.{1} nat i j,
h :
  @has_lt.lt.{0} nat
    (@preorder.to_has_lt.{0} nat
       (@partial_order.to_preorder.{0} nat (@linear_order.to_partial_order.{0} nat nat.linear_order)))
    j
    i,
h_nij : not (@has_lt.lt.{0} nat nat.has_lt i j),
i_pos : @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) i
⊢ @has_lt.lt.{0} nat nat.has_lt (@has_sub.sub.{0} nat nat.has_sub i (@has_one.one.{0} nat nat.has_one))
    (@list.length.{u_1} α
       (@subtype.val.{u_1+1} (list.{u_1} α)
          (λ (l : list.{u_1} α),
             @eq.{1} nat (@list.length.{u_1} α l)
               (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
          v))

n : nat,
α : Type u_1,
a : α,
v : vector.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)),
remove_nth_insert_nth_ne :
  ∀ {i j : fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))}
  (h :
    @_root_.ne.{1}
      (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
      i
      j),
    @eq.{(max 1 (u_1+1))}
      (vector.{u_1} α
         (@has_sub.sub.{0} nat nat.has_sub
            (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
            (@has_one.one.{0} nat nat.has_one)))
      (@vector.remove_nth.{u_1} α
         (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
         i
         (@vector.insert_nth.{u_1} (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) α a j v))
      (@vector.insert_nth.{u_1} n α a
         (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) i j
            (@_root_.ne.symm.{1}
               (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
               i
               j
               h))
         (@vector.remove_nth.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
            (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) j i h)
            v)),
i : nat,
hi :
  @has_lt.lt.{0} nat nat.has_lt i
    (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))),
j : nat,
hj :
  @has_lt.lt.{0} nat nat.has_lt j
    (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))),
ne :
  @_root_.ne.{1}
    (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) i hi)
    (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) j hj),
this : @_root_.ne.{1} nat i j,
h :
  @has_lt.lt.{0} nat
    (@preorder.to_has_lt.{0} nat
       (@partial_order.to_preorder.{0} nat (@linear_order.to_partial_order.{0} nat nat.linear_order)))
    j
    i,
h_nij : not (@has_lt.lt.{0} nat nat.has_lt i j),
i_pos : @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) i
⊢ @has_le.le.{0} nat nat.has_le j (@has_sub.sub.{0} nat nat.has_sub i (@has_one.one.{0} nat nat.has_one))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : nat,
α : Type u_1,
a : α,
v : vector.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)),
remove_nth_insert_nth_ne :
  ∀ {i j : fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))}
  (h :
    @_root_.ne.{1}
      (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
      i
      j),
    @eq.{(max 1 (u_1+1))}
      (vector.{u_1} α
         (@has_sub.sub.{0} nat nat.has_sub
            (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
            (@has_one.one.{0} nat nat.has_one)))
      (@vector.remove_nth.{u_1} α
         (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
         i
         (@vector.insert_nth.{u_1} (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) α a j v))
      (@vector.insert_nth.{u_1} n α a
         (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) i j
            (@_root_.ne.symm.{1}
               (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
               i
               j
               h))
         (@vector.remove_nth.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
            (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) j i h)
            v)),
i : nat,
hi :
  @has_lt.lt.{0} nat nat.has_lt i
    (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))),
j : nat,
hj :
  @has_lt.lt.{0} nat nat.has_lt j
    (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))),
ne :
  @_root_.ne.{1}
    (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) i hi)
    (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) j hj),
this : @_root_.ne.{1} nat i j,
h :
  @has_lt.lt.{0} nat
    (@preorder.to_has_lt.{0} nat
       (@partial_order.to_preorder.{0} nat (@linear_order.to_partial_order.{0} nat nat.linear_order)))
    j
    i,
h_nij : not (@has_lt.lt.{0} nat nat.has_lt i j),
i_pos : @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) i
⊢ @has_lt.lt.{0} nat nat.has_lt (@has_sub.sub.{0} nat nat.has_sub i (@has_one.one.{0} nat nat.has_one))
    (@list.length.{u_1} α
       (@subtype.val.{u_1+1} (list.{u_1} α)
          (λ (l : list.{u_1} α),
             @eq.{1} nat (@list.length.{u_1} α l)
               (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
          v))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : nat,
α : Type u_1,
a : α,
v : vector.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)),
remove_nth_insert_nth_ne :
  ∀ {i j : fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))}
  (h :
    @_root_.ne.{1}
      (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
      i
      j),
    @eq.{(max 1 (u_1+1))}
      (vector.{u_1} α
         (@has_sub.sub.{0} nat nat.has_sub
            (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
            (@has_one.one.{0} nat nat.has_one)))
      (@vector.remove_nth.{u_1} α
         (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
         i
         (@vector.insert_nth.{u_1} (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) α a j v))
      (@vector.insert_nth.{u_1} n α a
         (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) i j
            (@_root_.ne.symm.{1}
               (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
               i
               j
               h))
         (@vector.remove_nth.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
            (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) j i h)
            v)),
i : nat,
hi :
  @has_lt.lt.{0} nat nat.has_lt i
    (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))),
j : nat,
hj :
  @has_lt.lt.{0} nat nat.has_lt j
    (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))),
ne :
  @_root_.ne.{1}
    (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) i hi)
    (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) j hj),
this : @_root_.ne.{1} nat i j,
h :
  @has_lt.lt.{0} nat
    (@preorder.to_has_lt.{0} nat
       (@partial_order.to_preorder.{0} nat (@linear_order.to_partial_order.{0} nat nat.linear_order)))
    j
    i,
h_nij : not (@has_lt.lt.{0} nat nat.has_lt i j),
i_pos : @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) i
⊢ @has_le.le.{0} nat nat.has_le
    (@has_add.add.{0} nat nat.has_add (@has_sub.sub.{0} nat nat.has_sub i (@has_one.one.{0} nat nat.has_one))
       (@has_one.one.{0} nat nat.has_one))
    (@list.length.{u_1} α
       (@subtype.val.{u_1+1} (list.{u_1} α)
          (λ (l : list.{u_1} α),
             @eq.{1} nat (@list.length.{u_1} α l)
               (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
          v))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>182          rw [v.2, nat.sub_add_cancel i_pos],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='nat.sub_add_cancel'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i_pos'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/nat/lemmas.lean&#x27;, &#x27;line&#x27;: 594, &#x27;column&#x27;: 18}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='vector.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {n m : nat}, @ge.{0} nat nat.has_le n m → @eq.{1} nat (@has_add.add.{0} nat nat.has_add (@has_sub.sub.{0} nat nat.has_sub n m) m) n'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) i'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : nat,
α : Type u_1,
a : α,
v : vector.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)),
remove_nth_insert_nth_ne :
  ∀ {i j : fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))}
  (h :
    @_root_.ne.{1}
      (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
      i
      j),
    @eq.{(max 1 (u_1+1))}
      (vector.{u_1} α
         (@has_sub.sub.{0} nat nat.has_sub
            (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
            (@has_one.one.{0} nat nat.has_one)))
      (@vector.remove_nth.{u_1} α
         (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
         i
         (@vector.insert_nth.{u_1} (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) α a j v))
      (@vector.insert_nth.{u_1} n α a
         (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) i j
            (@_root_.ne.symm.{1}
               (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
               i
               j
               h))
         (@vector.remove_nth.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
            (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) j i h)
            v)),
i : nat,
hi :
  @has_lt.lt.{0} nat nat.has_lt i
    (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))),
j : nat,
hj :
  @has_lt.lt.{0} nat nat.has_lt j
    (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))),
ne :
  @_root_.ne.{1}
    (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) i hi)
    (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) j hj),
this : @_root_.ne.{1} nat i j,
h :
  @has_lt.lt.{0} nat
    (@preorder.to_has_lt.{0} nat
       (@partial_order.to_preorder.{0} nat (@linear_order.to_partial_order.{0} nat nat.linear_order)))
    j
    i,
h_nij : not (@has_lt.lt.{0} nat nat.has_lt i j),
i_pos : @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) i
⊢ @has_le.le.{0} nat nat.has_le
    (@has_add.add.{0} nat nat.has_add (@has_sub.sub.{0} nat nat.has_sub i (@has_one.one.{0} nat nat.has_one))
       (@has_one.one.{0} nat nat.has_one))
    (@list.length.{u_1} α
       (@subtype.val.{u_1+1} (list.{u_1} α)
          (λ (l : list.{u_1} α),
             @eq.{1} nat (@list.length.{u_1} α l)
               (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
          v))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : nat,
α : Type u_1,
a : α,
v : vector.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)),
remove_nth_insert_nth_ne :
  ∀ {i j : fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))}
  (h :
    @_root_.ne.{1}
      (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
      i
      j),
    @eq.{(max 1 (u_1+1))}
      (vector.{u_1} α
         (@has_sub.sub.{0} nat nat.has_sub
            (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
            (@has_one.one.{0} nat nat.has_one)))
      (@vector.remove_nth.{u_1} α
         (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
         i
         (@vector.insert_nth.{u_1} (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) α a j v))
      (@vector.insert_nth.{u_1} n α a
         (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) i j
            (@_root_.ne.symm.{1}
               (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
               i
               j
               h))
         (@vector.remove_nth.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
            (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) j i h)
            v)),
i : nat,
hi :
  @has_lt.lt.{0} nat nat.has_lt i
    (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))),
j : nat,
hj :
  @has_lt.lt.{0} nat nat.has_lt j
    (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))),
ne :
  @_root_.ne.{1}
    (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) i hi)
    (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) j hj),
this : @_root_.ne.{1} nat i j,
h :
  @has_lt.lt.{0} nat
    (@preorder.to_has_lt.{0} nat
       (@partial_order.to_preorder.{0} nat (@linear_order.to_partial_order.{0} nat nat.linear_order)))
    j
    i,
h_nij : not (@has_lt.lt.{0} nat nat.has_lt i j),
i_pos : @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) i
⊢ @has_le.le.{0} nat nat.has_le
    (@has_add.add.{0} nat nat.has_add (@has_sub.sub.{0} nat nat.has_sub i (@has_one.one.{0} nat nat.has_one))
       (@has_one.one.{0} nat nat.has_one))
    (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : nat,
α : Type u_1,
a : α,
v : vector.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)),
remove_nth_insert_nth_ne :
  ∀ {i j : fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))}
  (h :
    @_root_.ne.{1}
      (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
      i
      j),
    @eq.{(max 1 (u_1+1))}
      (vector.{u_1} α
         (@has_sub.sub.{0} nat nat.has_sub
            (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
            (@has_one.one.{0} nat nat.has_one)))
      (@vector.remove_nth.{u_1} α
         (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
         i
         (@vector.insert_nth.{u_1} (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) α a j v))
      (@vector.insert_nth.{u_1} n α a
         (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) i j
            (@_root_.ne.symm.{1}
               (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
               i
               j
               h))
         (@vector.remove_nth.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
            (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) j i h)
            v)),
i : nat,
hi :
  @has_lt.lt.{0} nat nat.has_lt i
    (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))),
j : nat,
hj :
  @has_lt.lt.{0} nat nat.has_lt j
    (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))),
ne :
  @_root_.ne.{1}
    (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) i hi)
    (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) j hj),
this : @_root_.ne.{1} nat i j,
h :
  @has_lt.lt.{0} nat
    (@preorder.to_has_lt.{0} nat
       (@partial_order.to_preorder.{0} nat (@linear_order.to_partial_order.{0} nat nat.linear_order)))
    j
    i,
h_nij : not (@has_lt.lt.{0} nat nat.has_lt i j),
i_pos : @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) i
⊢ @has_le.le.{0} nat nat.has_le i (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>183          exact nat.le_of_lt_succ hi },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='nat.le_of_lt_succ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hi'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/nat/lemmas.lean&#x27;, &#x27;line&#x27;: 329, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {m n : nat}, @has_lt.lt.{0} nat nat.has_lt m (nat.succ n) → @has_le.le.{0} nat nat.has_le m n'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_lt.lt.{0} nat nat.has_lt i (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : nat,
α : Type u_1,
a : α,
v : vector.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)),
remove_nth_insert_nth_ne :
  ∀ {i j : fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))}
  (h :
    @_root_.ne.{1}
      (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
      i
      j),
    @eq.{(max 1 (u_1+1))}
      (vector.{u_1} α
         (@has_sub.sub.{0} nat nat.has_sub
            (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
            (@has_one.one.{0} nat nat.has_one)))
      (@vector.remove_nth.{u_1} α
         (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
         i
         (@vector.insert_nth.{u_1} (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) α a j v))
      (@vector.insert_nth.{u_1} n α a
         (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) i j
            (@_root_.ne.symm.{1}
               (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
               i
               j
               h))
         (@vector.remove_nth.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
            (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) j i h)
            v)),
i : nat,
hi :
  @has_lt.lt.{0} nat nat.has_lt i
    (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))),
j : nat,
hj :
  @has_lt.lt.{0} nat nat.has_lt j
    (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))),
ne :
  @_root_.ne.{1}
    (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) i hi)
    (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) j hj),
this : @_root_.ne.{1} nat i j,
h :
  @has_lt.lt.{0} nat
    (@preorder.to_has_lt.{0} nat
       (@partial_order.to_preorder.{0} nat (@linear_order.to_partial_order.{0} nat nat.linear_order)))
    j
    i,
h_nij : not (@has_lt.lt.{0} nat nat.has_lt i j),
i_pos : @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) i
⊢ @has_le.le.{0} nat nat.has_le i (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : nat,
α : Type u_1,
a : α,
v : vector.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)),
remove_nth_insert_nth_ne :
  ∀ {i j : fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))}
  (h :
    @_root_.ne.{1}
      (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
      i
      j),
    @eq.{(max 1 (u_1+1))}
      (vector.{u_1} α
         (@has_sub.sub.{0} nat nat.has_sub
            (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
            (@has_one.one.{0} nat nat.has_one)))
      (@vector.remove_nth.{u_1} α
         (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
         i
         (@vector.insert_nth.{u_1} (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) α a j v))
      (@vector.insert_nth.{u_1} n α a
         (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) i j
            (@_root_.ne.symm.{1}
               (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
               i
               j
               h))
         (@vector.remove_nth.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
            (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) j i h)
            v)),
i : nat,
hi :
  @has_lt.lt.{0} nat nat.has_lt i
    (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))),
j : nat,
hj :
  @has_lt.lt.{0} nat nat.has_lt j
    (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))),
ne :
  @_root_.ne.{1}
    (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) i hi)
    (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) j hj),
this : @_root_.ne.{1} nat i j,
h :
  @has_lt.lt.{0} nat
    (@preorder.to_has_lt.{0} nat
       (@partial_order.to_preorder.{0} nat (@linear_order.to_partial_order.{0} nat nat.linear_order)))
    j
    i,
h_nij : not (@has_lt.lt.{0} nat nat.has_lt i j),
i_pos : @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) i
⊢ @has_le.le.{0} nat nat.has_le j (@has_sub.sub.{0} nat nat.has_sub i (@has_one.one.{0} nat nat.has_one))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>184        { exact nat.le_sub_right_of_add_le h } }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='nat.le_sub_right_of_add_le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/nat/basic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 18}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {m n k : nat}, @has_le.le.{0} nat nat.has_le (@has_add.add.{0} nat nat.has_add m k) n → @has_le.le.{0} nat nat.has_le m (@has_sub.sub.{0} nat nat.has_sub n k)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_lt.lt.{0} nat (@preorder.to_has_lt.{0} nat (@partial_order.to_preorder.{0} nat (@linear_order.to_partial_order.{0} nat nat.linear_order))) j i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : nat,
α : Type u_1,
a : α,
v : vector.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)),
remove_nth_insert_nth_ne :
  ∀ {i j : fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))}
  (h :
    @_root_.ne.{1}
      (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
      i
      j),
    @eq.{(max 1 (u_1+1))}
      (vector.{u_1} α
         (@has_sub.sub.{0} nat nat.has_sub
            (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
            (@has_one.one.{0} nat nat.has_one)))
      (@vector.remove_nth.{u_1} α
         (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
         i
         (@vector.insert_nth.{u_1} (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) α a j v))
      (@vector.insert_nth.{u_1} n α a
         (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) i j
            (@_root_.ne.symm.{1}
               (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
               i
               j
               h))
         (@vector.remove_nth.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
            (@fin.pred_above (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) j i h)
            v)),
i : nat,
hi :
  @has_lt.lt.{0} nat nat.has_lt i
    (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))),
j : nat,
hj :
  @has_lt.lt.{0} nat nat.has_lt j
    (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))),
ne :
  @_root_.ne.{1}
    (fin (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))
    (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) i hi)
    (@fin.mk (@has_add.add.{0} nat nat.has_add n (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) j hj),
this : @_root_.ne.{1} nat i j,
h :
  @has_lt.lt.{0} nat
    (@preorder.to_has_lt.{0} nat
       (@partial_order.to_preorder.{0} nat (@linear_order.to_partial_order.{0} nat nat.linear_order)))
    j
    i,
h_nij : not (@has_lt.lt.{0} nat nat.has_lt i j),
i_pos : @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) i
⊢ @has_le.le.{0} nat nat.has_le j (@has_sub.sub.{0} nat nat.has_sub i (@has_one.one.{0} nat nat.has_one))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>185    end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>186  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>187  lemma insert_nth_comm (a b : α) (i j : fin (n+1)) (h : i ≤ j) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='fin'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_le.le'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/fin/basic.lean&#x27;, &#x27;line&#x27;: 9, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 319, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='nat → Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} [c : has_add.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_le.{0} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>188    ∀(v : vector α n), (v.insert_nth a i).insert_nth b j.succ = (v.insert_nth b j).insert_nth a i.cast_succ</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='insert_nth_comm'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='vector'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='vector.insert_nth'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='vector.insert_nth'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='fin.succ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='vector.insert_nth'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='vector.insert_nth'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='fin.cast_succ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 14, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;line&#x27;: 142, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 142, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/fin/ops.lean&#x27;, &#x27;line&#x27;: 13, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 142, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 142, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/fin.lean&#x27;, &#x27;line&#x27;: 115, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ (v : vector.{u_1} α n), @eq.{(max 1 (u_1+1))} (vector.{u_1} α (@has_add.add.{0} nat nat.has_add (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) (@has_one.one.{0} nat nat.has_one))) (@vector.insert_nth.{u_1} (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) α b (@fin.succ (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) j) (@vector.insert_nth.{u_1} n α a i v)) (@vector.insert_nth.{u_1} (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) α a (@fin.cast_succ (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) i) (@vector.insert_nth.{u_1} n α b j v))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type u_1 → nat → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='vector.{u_1} α n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {n : nat} {α : Type u_1}, α → fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → vector.{u_1} α n → vector.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {n : nat} {α : Type u_1}, α → fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → vector.{u_1} α n → vector.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {n : nat}, fin n → fin (nat.succ n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='vector.{u_1} α n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {n : nat} {α : Type u_1}, α → fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → vector.{u_1} α n → vector.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {n : nat} {α : Type u_1}, α → fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) → vector.{u_1} α n → vector.{u_1} α (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {n : nat}, fin n → fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                                               </code><font color='orange'><a title='`cast_succ i` embeds `i : fin n` in `fin (n+1)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>189  | ⟨l, hl⟩ :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='hl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@eq.{1} nat (@list.length.{u_1} α l) n'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>190    begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='n : nat,
α : Type u_1,
a b : α,
i j : fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)),
h :
  @has_le.le.{0} (fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
    (@fin.has_le (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
    i
    j,
insert_nth_comm :
  ∀ (v : vector.{u_1} α n),
    @eq.{(max 1 (u_1+1))}
      (vector.{u_1} α
         (@has_add.add.{0} nat nat.has_add (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
            (@has_one.one.{0} nat nat.has_one)))
      (@vector.insert_nth.{u_1} (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) α b
         (@fin.succ (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) j)
         (@vector.insert_nth.{u_1} n α a i v))
      (@vector.insert_nth.{u_1} (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) α a
         (@fin.cast_succ (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) i)
         (@vector.insert_nth.{u_1} n α b j v)),
l : list.{u_1} α,
hl : @eq.{1} nat (@list.length.{u_1} α l) n
⊢ @eq.{(max 1 (u_1+1))}
    (vector.{u_1} α
       (@has_add.add.{0} nat nat.has_add (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
          (@has_one.one.{0} nat nat.has_one)))
    (@vector.insert_nth.{u_1} (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) α b
       (@fin.succ (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) j)
       (@vector.insert_nth.{u_1} n α a i
          (@subtype.mk.{u_1+1} (list.{u_1} α) (λ (l : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l) n) l hl)))
    (@vector.insert_nth.{u_1} (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) α a
       (@fin.cast_succ (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) i)
       (@vector.insert_nth.{u_1} n α b j
          (@subtype.mk.{u_1+1} (list.{u_1} α) (λ (l : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l) n) l hl)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>191      refine subtype.eq _,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='subtype.eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/subtype/basic.lean&#x27;, &#x27;line&#x27;: 22, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {p : α → Prop} {a1 a2 : @subtype.{u_1+1} α (λ (x : α), p x)}, @eq.{u_1+1} α (@subtype.val.{u_1+1} α (λ (x : α), p x) a1) (@subtype.val.{u_1+1} α (λ (x : α), p x) a2) → @eq.{(max 1 (u_1+1))} (@subtype.{u_1+1} α (λ (x : α), p x)) a1 a2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : nat,
α : Type u_1,
a b : α,
i j : fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)),
h :
  @has_le.le.{0} (fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
    (@fin.has_le (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
    i
    j,
insert_nth_comm :
  ∀ (v : vector.{u_1} α n),
    @eq.{(max 1 (u_1+1))}
      (vector.{u_1} α
         (@has_add.add.{0} nat nat.has_add (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
            (@has_one.one.{0} nat nat.has_one)))
      (@vector.insert_nth.{u_1} (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) α b
         (@fin.succ (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) j)
         (@vector.insert_nth.{u_1} n α a i v))
      (@vector.insert_nth.{u_1} (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) α a
         (@fin.cast_succ (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) i)
         (@vector.insert_nth.{u_1} n α b j v)),
l : list.{u_1} α,
hl : @eq.{1} nat (@list.length.{u_1} α l) n
⊢ @eq.{(max 1 (u_1+1))}
    (vector.{u_1} α
       (@has_add.add.{0} nat nat.has_add (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
          (@has_one.one.{0} nat nat.has_one)))
    (@vector.insert_nth.{u_1} (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) α b
       (@fin.succ (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) j)
       (@vector.insert_nth.{u_1} n α a i
          (@subtype.mk.{u_1+1} (list.{u_1} α) (λ (l : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l) n) l hl)))
    (@vector.insert_nth.{u_1} (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) α a
       (@fin.cast_succ (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) i)
       (@vector.insert_nth.{u_1} n α b j
          (@subtype.mk.{u_1+1} (list.{u_1} α) (λ (l : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l) n) l hl)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : nat,
α : Type u_1,
a b : α,
i j : fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)),
h :
  @has_le.le.{0} (fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
    (@fin.has_le (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
    i
    j,
insert_nth_comm :
  ∀ (v : vector.{u_1} α n),
    @eq.{(max 1 (u_1+1))}
      (vector.{u_1} α
         (@has_add.add.{0} nat nat.has_add (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
            (@has_one.one.{0} nat nat.has_one)))
      (@vector.insert_nth.{u_1} (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) α b
         (@fin.succ (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) j)
         (@vector.insert_nth.{u_1} n α a i v))
      (@vector.insert_nth.{u_1} (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) α a
         (@fin.cast_succ (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) i)
         (@vector.insert_nth.{u_1} n α b j v)),
l : list.{u_1} α,
hl : @eq.{1} nat (@list.length.{u_1} α l) n
⊢ @eq.{u_1+1} (list.{u_1} α)
    (@subtype.val.{u_1+1} (list.{u_1} α)
       (λ (x : list.{u_1} α),
          @eq.{1} nat (@list.length.{u_1} α x)
            (@has_add.add.{0} nat nat.has_add (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
               (@has_one.one.{0} nat nat.has_one)))
       (@vector.insert_nth.{u_1} (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) α b
          (@fin.succ (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) j)
          (@vector.insert_nth.{u_1} n α a i
             (@subtype.mk.{u_1+1} (list.{u_1} α) (λ (l : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l) n) l
                hl))))
    (@subtype.val.{u_1+1} (list.{u_1} α)
       (λ (x : list.{u_1} α),
          @eq.{1} nat (@list.length.{u_1} α x)
            (@has_add.add.{0} nat nat.has_add (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
               (@has_one.one.{0} nat nat.has_one)))
       (@vector.insert_nth.{u_1} (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) α a
          (@fin.cast_succ (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) i)
          (@vector.insert_nth.{u_1} n α b j
             (@subtype.mk.{u_1+1} (list.{u_1} α) (λ (l : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l) n) l
                hl))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>192      simp [insert_nth_val, fin.succ_val, fin.cast_succ],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='vector.insert_nth_val'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='fin.succ_val'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='fin.cast_succ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 150, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/fin.lean&#x27;, &#x27;line&#x27;: 68, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/fin.lean&#x27;, &#x27;line&#x27;: 115, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {n : nat} {α : Type ?l_1} {a : α} {i : fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))} {v : vector.{?l_1} α n}, @eq.{?l_1+1} (list.{?l_1} α) (@subtype.val.{?l_1+1} (list.{?l_1} α) (λ (l : list.{?l_1} α), @eq.{1} nat (@list.length.{?l_1} α l) (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))) (@vector.insert_nth.{?l_1} n α a i v)) (@list.insert_nth.{?l_1} α (@fin.val (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) i) a (@subtype.val.{?l_1+1} (list.{?l_1} α) (λ (l : list.{?l_1} α), @eq.{1} nat (@list.length.{?l_1} α l) n) v))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {n : nat} (j : fin n), @eq.{1} nat (@fin.val (nat.succ n) (@fin.succ n j)) (nat.succ (@fin.val n j))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {n : nat}, fin n → fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`cast_succ i` embeds `i : fin n` in `fin (n+1)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : nat,
α : Type u_1,
a b : α,
i j : fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)),
h :
  @has_le.le.{0} (fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
    (@fin.has_le (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
    i
    j,
insert_nth_comm :
  ∀ (v : vector.{u_1} α n),
    @eq.{(max 1 (u_1+1))}
      (vector.{u_1} α
         (@has_add.add.{0} nat nat.has_add (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
            (@has_one.one.{0} nat nat.has_one)))
      (@vector.insert_nth.{u_1} (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) α b
         (@fin.succ (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) j)
         (@vector.insert_nth.{u_1} n α a i v))
      (@vector.insert_nth.{u_1} (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) α a
         (@fin.cast_succ (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) i)
         (@vector.insert_nth.{u_1} n α b j v)),
l : list.{u_1} α,
hl : @eq.{1} nat (@list.length.{u_1} α l) n
⊢ @eq.{u_1+1} (list.{u_1} α)
    (@subtype.val.{u_1+1} (list.{u_1} α)
       (λ (x : list.{u_1} α),
          @eq.{1} nat (@list.length.{u_1} α x)
            (@has_add.add.{0} nat nat.has_add (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
               (@has_one.one.{0} nat nat.has_one)))
       (@vector.insert_nth.{u_1} (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) α b
          (@fin.succ (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) j)
          (@vector.insert_nth.{u_1} n α a i
             (@subtype.mk.{u_1+1} (list.{u_1} α) (λ (l : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l) n) l
                hl))))
    (@subtype.val.{u_1+1} (list.{u_1} α)
       (λ (x : list.{u_1} α),
          @eq.{1} nat (@list.length.{u_1} α x)
            (@has_add.add.{0} nat nat.has_add (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
               (@has_one.one.{0} nat nat.has_one)))
       (@vector.insert_nth.{u_1} (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) α a
          (@fin.cast_succ (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) i)
          (@vector.insert_nth.{u_1} n α b j
             (@subtype.mk.{u_1+1} (list.{u_1} α) (λ (l : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l) n) l
                hl))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : nat,
α : Type u_1,
a b : α,
i j : fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)),
h :
  @has_le.le.{0} (fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
    (@fin.has_le (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
    i
    j,
insert_nth_comm :
  ∀ (v : vector.{u_1} α n),
    @eq.{(max 1 (u_1+1))}
      (vector.{u_1} α
         (@has_add.add.{0} nat nat.has_add (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
            (@has_one.one.{0} nat nat.has_one)))
      (@vector.insert_nth.{u_1} (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) α b
         (@fin.succ (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) j)
         (@vector.insert_nth.{u_1} n α a i v))
      (@vector.insert_nth.{u_1} (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) α a
         (@fin.cast_succ (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) i)
         (@vector.insert_nth.{u_1} n α b j v)),
l : list.{u_1} α,
hl : @eq.{1} nat (@list.length.{u_1} α l) n
⊢ @eq.{u_1+1} (list.{u_1} α)
    (@list.insert_nth.{u_1} α
       (nat.succ (@fin.val (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) j))
       b
       (@list.insert_nth.{u_1} α (@fin.val (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) i) a
          l))
    (@list.insert_nth.{u_1} α (@fin.val (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) i) a
       (@list.insert_nth.{u_1} α (@fin.val (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) j) b
          l))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>193      apply list.insert_nth_comm,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='list.insert_nth_comm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/list/basic.lean&#x27;, &#x27;line&#x27;: 1065, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} (a b : α) (i j : nat) (l : list.{u_1} α), @has_le.le.{0} nat nat.has_le i j → @has_le.le.{0} nat nat.has_le j (@list.length.{u_1} α l) → @eq.{u_1+1} (list.{u_1} α) (@list.insert_nth.{u_1} α (@has_add.add.{0} nat nat.has_add j (@has_one.one.{0} nat nat.has_one)) b (@list.insert_nth.{u_1} α i a l)) (@list.insert_nth.{u_1} α i a (@list.insert_nth.{u_1} α j b l))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : nat,
α : Type u_1,
a b : α,
i j : fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)),
h :
  @has_le.le.{0} (fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
    (@fin.has_le (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
    i
    j,
insert_nth_comm :
  ∀ (v : vector.{u_1} α n),
    @eq.{(max 1 (u_1+1))}
      (vector.{u_1} α
         (@has_add.add.{0} nat nat.has_add (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
            (@has_one.one.{0} nat nat.has_one)))
      (@vector.insert_nth.{u_1} (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) α b
         (@fin.succ (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) j)
         (@vector.insert_nth.{u_1} n α a i v))
      (@vector.insert_nth.{u_1} (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) α a
         (@fin.cast_succ (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) i)
         (@vector.insert_nth.{u_1} n α b j v)),
l : list.{u_1} α,
hl : @eq.{1} nat (@list.length.{u_1} α l) n
⊢ @eq.{u_1+1} (list.{u_1} α)
    (@list.insert_nth.{u_1} α
       (nat.succ (@fin.val (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) j))
       b
       (@list.insert_nth.{u_1} α (@fin.val (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) i) a
          l))
    (@list.insert_nth.{u_1} α (@fin.val (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) i) a
       (@list.insert_nth.{u_1} α (@fin.val (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) j) b
          l))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
n : nat,
α : Type u_1,
a b : α,
i j : fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)),
h :
  @has_le.le.{0} (fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
    (@fin.has_le (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
    i
    j,
insert_nth_comm :
  ∀ (v : vector.{u_1} α n),
    @eq.{(max 1 (u_1+1))}
      (vector.{u_1} α
         (@has_add.add.{0} nat nat.has_add (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
            (@has_one.one.{0} nat nat.has_one)))
      (@vector.insert_nth.{u_1} (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) α b
         (@fin.succ (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) j)
         (@vector.insert_nth.{u_1} n α a i v))
      (@vector.insert_nth.{u_1} (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) α a
         (@fin.cast_succ (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) i)
         (@vector.insert_nth.{u_1} n α b j v)),
l : list.{u_1} α,
hl : @eq.{1} nat (@list.length.{u_1} α l) n
⊢ @has_le.le.{0} nat nat.has_le (@fin.val (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) i)
    (@fin.val (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) j)

n : nat,
α : Type u_1,
a b : α,
i j : fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)),
h :
  @has_le.le.{0} (fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
    (@fin.has_le (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
    i
    j,
insert_nth_comm :
  ∀ (v : vector.{u_1} α n),
    @eq.{(max 1 (u_1+1))}
      (vector.{u_1} α
         (@has_add.add.{0} nat nat.has_add (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
            (@has_one.one.{0} nat nat.has_one)))
      (@vector.insert_nth.{u_1} (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) α b
         (@fin.succ (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) j)
         (@vector.insert_nth.{u_1} n α a i v))
      (@vector.insert_nth.{u_1} (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) α a
         (@fin.cast_succ (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) i)
         (@vector.insert_nth.{u_1} n α b j v)),
l : list.{u_1} α,
hl : @eq.{1} nat (@list.length.{u_1} α l) n
⊢ @has_le.le.{0} nat nat.has_le (@fin.val (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) j)
    (@list.length.{u_1} α l)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>194      { assumption },</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 227, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='This tactic looks in the local context for a hypothesis whose type is equal to the goal target. If it finds one, it uses it to prove the goal, and otherwise it fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='assumption'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
n : nat,
α : Type u_1,
a b : α,
i j : fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)),
h :
  @has_le.le.{0} (fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
    (@fin.has_le (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
    i
    j,
insert_nth_comm :
  ∀ (v : vector.{u_1} α n),
    @eq.{(max 1 (u_1+1))}
      (vector.{u_1} α
         (@has_add.add.{0} nat nat.has_add (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
            (@has_one.one.{0} nat nat.has_one)))
      (@vector.insert_nth.{u_1} (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) α b
         (@fin.succ (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) j)
         (@vector.insert_nth.{u_1} n α a i v))
      (@vector.insert_nth.{u_1} (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) α a
         (@fin.cast_succ (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) i)
         (@vector.insert_nth.{u_1} n α b j v)),
l : list.{u_1} α,
hl : @eq.{1} nat (@list.length.{u_1} α l) n
⊢ @has_le.le.{0} nat nat.has_le (@fin.val (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) i)
    (@fin.val (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) j)

n : nat,
α : Type u_1,
a b : α,
i j : fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)),
h :
  @has_le.le.{0} (fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
    (@fin.has_le (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
    i
    j,
insert_nth_comm :
  ∀ (v : vector.{u_1} α n),
    @eq.{(max 1 (u_1+1))}
      (vector.{u_1} α
         (@has_add.add.{0} nat nat.has_add (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
            (@has_one.one.{0} nat nat.has_one)))
      (@vector.insert_nth.{u_1} (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) α b
         (@fin.succ (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) j)
         (@vector.insert_nth.{u_1} n α a i v))
      (@vector.insert_nth.{u_1} (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) α a
         (@fin.cast_succ (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) i)
         (@vector.insert_nth.{u_1} n α b j v)),
l : list.{u_1} α,
hl : @eq.{1} nat (@list.length.{u_1} α l) n
⊢ @has_le.le.{0} nat nat.has_le (@fin.val (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) j)
    (@list.length.{u_1} α l)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : nat,
α : Type u_1,
a b : α,
i j : fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)),
h :
  @has_le.le.{0} (fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
    (@fin.has_le (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
    i
    j,
insert_nth_comm :
  ∀ (v : vector.{u_1} α n),
    @eq.{(max 1 (u_1+1))}
      (vector.{u_1} α
         (@has_add.add.{0} nat nat.has_add (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
            (@has_one.one.{0} nat nat.has_one)))
      (@vector.insert_nth.{u_1} (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) α b
         (@fin.succ (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) j)
         (@vector.insert_nth.{u_1} n α a i v))
      (@vector.insert_nth.{u_1} (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) α a
         (@fin.cast_succ (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) i)
         (@vector.insert_nth.{u_1} n α b j v)),
l : list.{u_1} α,
hl : @eq.{1} nat (@list.length.{u_1} α l) n
⊢ @has_le.le.{0} nat nat.has_le (@fin.val (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) i)
    (@fin.val (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : nat,
α : Type u_1,
a b : α,
i j : fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)),
h :
  @has_le.le.{0} (fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
    (@fin.has_le (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
    i
    j,
insert_nth_comm :
  ∀ (v : vector.{u_1} α n),
    @eq.{(max 1 (u_1+1))}
      (vector.{u_1} α
         (@has_add.add.{0} nat nat.has_add (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
            (@has_one.one.{0} nat nat.has_one)))
      (@vector.insert_nth.{u_1} (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) α b
         (@fin.succ (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) j)
         (@vector.insert_nth.{u_1} n α a i v))
      (@vector.insert_nth.{u_1} (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) α a
         (@fin.cast_succ (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) i)
         (@vector.insert_nth.{u_1} n α b j v)),
l : list.{u_1} α,
hl : @eq.{1} nat (@list.length.{u_1} α l) n
⊢ @has_le.le.{0} nat nat.has_le (@fin.val (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) j)
    (@list.length.{u_1} α l)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>195      { rw hl, exact nat.le_of_succ_le_succ j.2 }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='hl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='nat.le_of_succ_le_succ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/nat/basic.lean&#x27;, &#x27;line&#x27;: 94, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{1} nat (@list.length.{u_1} α l) n'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {n m : nat}, @has_le.le.{0} nat nat.has_le (nat.succ n) (nat.succ m) → @has_le.le.{0} nat nat.has_le n m'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : nat,
α : Type u_1,
a b : α,
i j : fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)),
h :
  @has_le.le.{0} (fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
    (@fin.has_le (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
    i
    j,
insert_nth_comm :
  ∀ (v : vector.{u_1} α n),
    @eq.{(max 1 (u_1+1))}
      (vector.{u_1} α
         (@has_add.add.{0} nat nat.has_add (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
            (@has_one.one.{0} nat nat.has_one)))
      (@vector.insert_nth.{u_1} (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) α b
         (@fin.succ (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) j)
         (@vector.insert_nth.{u_1} n α a i v))
      (@vector.insert_nth.{u_1} (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) α a
         (@fin.cast_succ (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) i)
         (@vector.insert_nth.{u_1} n α b j v)),
l : list.{u_1} α,
hl : @eq.{1} nat (@list.length.{u_1} α l) n
⊢ @has_le.le.{0} nat nat.has_le (@fin.val (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) j)
    (@list.length.{u_1} α l)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : nat,
α : Type u_1,
a b : α,
i j : fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)),
h :
  @has_le.le.{0} (fin (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
    (@fin.has_le (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)))
    i
    j,
insert_nth_comm :
  ∀ (v : vector.{u_1} α n),
    @eq.{(max 1 (u_1+1))}
      (vector.{u_1} α
         (@has_add.add.{0} nat nat.has_add (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one))
            (@has_one.one.{0} nat nat.has_one)))
      (@vector.insert_nth.{u_1} (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) α b
         (@fin.succ (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) j)
         (@vector.insert_nth.{u_1} n α a i v))
      (@vector.insert_nth.{u_1} (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) α a
         (@fin.cast_succ (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) i)
         (@vector.insert_nth.{u_1} n α b j v)),
l : list.{u_1} α,
hl : @eq.{1} nat (@list.length.{u_1} α l) n
⊢ @has_le.le.{0} nat nat.has_le (@fin.val (@has_add.add.{0} nat nat.has_add n (@has_one.one.{0} nat nat.has_one)) j) n'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>196    end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>197  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>198  end insert_nth</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>199  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>200  section update_nth</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>201  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>202  /-- `update_nth v n a` replaces the `n`th element of `v` with `a` -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>203  def update_nth (v : vector α n) (i : fin n) (a : α) : vector α n :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='blue'><a title='vector'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='fin'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='vector'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 14, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/fin/basic.lean&#x27;, &#x27;line&#x27;: 9, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 14, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='green'><a title='Type u → nat → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='nat → Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type u → nat → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>204  ⟨v.1.update_nth i.1 a, by rw [list.update_nth_length, v.2]⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='subtype.val'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='list.update_nth'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='fin.val'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='list.update_nth_length'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/list/basic.lean&#x27;, &#x27;line&#x27;: 156, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/fin/basic.lean&#x27;, &#x27;line&#x27;: 9, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/list/basic.lean&#x27;, &#x27;line&#x27;: 992, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='vector.{u_1} α n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} {p : α → Prop}, @subtype.{u_1+1} α p → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1}, list.{u_1} α → nat → α → list.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='fin n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {n : nat}, fin n → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} (l : list.{u_1} α) (n : nat) (a : α), @eq.{1} nat (@list.length.{u_1} α (@list.update_nth.{u_1} α l n a)) (@list.length.{u_1} α l)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='vector.{u_1} α n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='lime'><a title='n : nat,
α : Type u_1,
v : vector.{u_1} α n,
i : fin n,
a : α
⊢ @eq.{1} nat
    (@list.length.{u_1} α
       (@list.update_nth.{u_1} α
          (@subtype.val.{u_1+1} (list.{u_1} α) (λ (l : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l) n) v)
          (@fin.val n i)
          a))
    n'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : nat,
α : Type u_1,
v : vector.{u_1} α n,
i : fin n,
a : α
⊢ @eq.{1} nat
    (@list.length.{u_1} α
       (@subtype.val.{u_1+1} (list.{u_1} α) (λ (l : list.{u_1} α), @eq.{1} nat (@list.length.{u_1} α l) n) v))
    n'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>205  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>206  @[simp] lemma nth_update_nth_same (v : vector α n) (i : fin n) (a : α) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='blue'><a title='vector'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='fin'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 14, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/fin/basic.lean&#x27;, &#x27;line&#x27;: 9, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='green'><a title='Type u → nat → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='nat → Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>207    (v.update_nth i a).nth i = a :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='vector.update_nth'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='vector.nth'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 203, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 54, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='vector.{u_1} α n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {n : nat} {α : Type u_1}, vector.{u_1} α n → fin n → α → vector.{u_1} α n'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='fin n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} {n : nat}, vector.{u_1} α n → fin n → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='fin n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`update_nth v n a` replaces the `n`th element of `v` with `a`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>208  by cases v; cases i; simp [vector.update_nth, vector.nth_eq_nth_le]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='vector.update_nth'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='vector.nth_eq_nth_le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 203, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 35, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='vector.{u_1} α n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='fin n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {n : nat} {α : Type ?l_1}, vector.{?l_1} α n → fin n → α → vector.{?l_1} α n'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {n : nat} {α : Type ?l_1} (v : vector.{?l_1} α n) (i : fin n), @eq.{?l_1+1} α (@vector.nth.{?l_1} α n v i) (@list.nth_le.{?l_1} α (@vector.to_list.{?l_1} α n v) (@fin.val n i) (@eq.mpr.{0} (@has_lt.lt.{0} nat nat.has_lt (@fin.val n i) (@list.length.{?l_1} α (@vector.to_list.{?l_1} α n v))) (@has_lt.lt.{0} nat nat.has_lt (@fin.val n i) n) (@id.{0} (@eq.{1} Prop (@has_lt.lt.{0} nat nat.has_lt (@fin.val n i) (@list.length.{?l_1} α (@vector.to_list.{?l_1} α n v))) (@has_lt.lt.{0} nat nat.has_lt (@fin.val n i) n)) (@eq.rec.{0 1} nat (@list.length.{?l_1} α (@vector.to_list.{?l_1} α n v)) (λ (_a : nat), @eq.{1} Prop (@has_lt.lt.{0} nat nat.has_lt (@fin.val n i) (@list.length.{?l_1} α (@vector.to_list.{?l_1} α n v))) (@has_lt.lt.{0} nat nat.has_lt (@fin.val n i) _a)) (@eq.refl.{1} Prop (@has_lt.lt.{0} nat nat.has_lt (@fin.val n i) (@list.length.{?l_1} α (@vector.to_list.{?l_1} α n v)))) n (@vector.to_list_length.{?l_1} α n v))) (@fin.is_lt n i)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`update_nth v n a` replaces the `n`th element of `v` with `a`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='n : nat,
α : Type u_1,
v : vector.{u_1} α n,
i : fin n,
a : α
⊢ @eq.{u_1+1} α (@vector.nth.{u_1} α n (@vector.update_nth.{u_1} n α v i a) i) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>209  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : nat,
α : Type u_1,
v : vector.{u_1} α n,
i : fin n,
a : α
⊢ @eq.{u_1+1} α (@vector.nth.{u_1} α n (@vector.update_nth.{u_1} n α v i a) i) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>210  lemma nth_update_nth_of_ne {v : vector α n} {i j : fin n} (h : i ≠ j) (a : α) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='blue'><a title='vector'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='fin'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ne'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 14, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/fin/basic.lean&#x27;, &#x27;line&#x27;: 9, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 97, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='green'><a title='Type u → nat → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='nat → Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='fin n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='fin n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>211    (v.update_nth i a).nth j = v.nth j :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='vector.update_nth'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='vector.nth'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='vector.nth'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 203, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 54, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 54, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='vector.{u_1} α n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {n : nat} {α : Type u_1}, vector.{u_1} α n → fin n → α → vector.{u_1} α n'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='fin n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} {n : nat}, vector.{u_1} α n → fin n → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='fin n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='vector.{u_1} α n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} {n : nat}, vector.{u_1} α n → fin n → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='fin n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`update_nth v n a` replaces the `n`th element of `v` with `a`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>212  by cases v; cases i; cases j; simp [vector.update_nth, vector.nth_eq_nth_le,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='vector.update_nth'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='vector.nth_eq_nth_le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 203, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 35, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='vector.{u_1} α n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='fin n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='fin n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {n : nat} {α : Type ?l_1}, vector.{?l_1} α n → fin n → α → vector.{?l_1} α n'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {n : nat} {α : Type ?l_1} (v : vector.{?l_1} α n) (i : fin n), @eq.{?l_1+1} α (@vector.nth.{?l_1} α n v i) (@list.nth_le.{?l_1} α (@vector.to_list.{?l_1} α n v) (@fin.val n i) (@eq.mpr.{0} (@has_lt.lt.{0} nat nat.has_lt (@fin.val n i) (@list.length.{?l_1} α (@vector.to_list.{?l_1} α n v))) (@has_lt.lt.{0} nat nat.has_lt (@fin.val n i) n) (@id.{0} (@eq.{1} Prop (@has_lt.lt.{0} nat nat.has_lt (@fin.val n i) (@list.length.{?l_1} α (@vector.to_list.{?l_1} α n v))) (@has_lt.lt.{0} nat nat.has_lt (@fin.val n i) n)) (@eq.rec.{0 1} nat (@list.length.{?l_1} α (@vector.to_list.{?l_1} α n v)) (λ (_a : nat), @eq.{1} Prop (@has_lt.lt.{0} nat nat.has_lt (@fin.val n i) (@list.length.{?l_1} α (@vector.to_list.{?l_1} α n v))) (@has_lt.lt.{0} nat nat.has_lt (@fin.val n i) _a)) (@eq.refl.{1} Prop (@has_lt.lt.{0} nat nat.has_lt (@fin.val n i) (@list.length.{?l_1} α (@vector.to_list.{?l_1} α n v)))) n (@vector.to_list_length.{?l_1} α n v))) (@fin.is_lt n i)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`update_nth v n a` replaces the `n`th element of `v` with `a`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='n : nat,
α : Type u_1,
v : vector.{u_1} α n,
i j : fin n,
h : @ne.{1} (fin n) i j,
a : α
⊢ @eq.{u_1+1} α (@vector.nth.{u_1} α n (@vector.update_nth.{u_1} n α v i a) j) (@vector.nth.{u_1} α n v j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>213    list.nth_le_update_nth_of_ne (fin.vne_of_ne h)]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='list.nth_le_update_nth_of_ne'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='fin.vne_of_ne'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/list/basic.lean&#x27;, &#x27;line&#x27;: 1020, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/fin/basic.lean&#x27;, &#x27;line&#x27;: 44, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {l : list.{?l_1} α} {i j : nat}, @ne.{1} nat i j → ∀ (a : α) (hj : @has_lt.lt.{0} nat nat.has_lt j (@list.length.{?l_1} α (@list.update_nth.{?l_1} α l i a))), @eq.{?l_1+1} α (@list.nth_le.{?l_1} α (@list.update_nth.{?l_1} α l i a) j hj) (@list.nth_le.{?l_1} α l j (@eq.mp.{0} (@has_lt.lt.{0} nat nat.has_lt j (@list.length.{?l_1} α (@list.update_nth.{?l_1} α l i a))) (@has_lt.lt.{0} nat nat.has_lt j (@list.length.{?l_1} α l)) (@(λ [c : has_lt.{0} nat] (a a_1 : nat) (e_2 : @eq.{1} nat a a_1) (a_2 a_3 : nat) (e_3 : @eq.{1} nat a_2 a_3), @congr.{1 1} nat Prop (@has_lt.lt.{0} nat c a) (@has_lt.lt.{0} nat c a_1) a_2 a_3 (@congr_arg.{1 1} nat (nat → Prop) a a_1 (@has_lt.lt.{0} nat c) e_2) e_3) nat.has_lt j j (@eq.refl.{1} nat j) (@list.length.{?l_1} α (@list.update_nth.{?l_1} α l i a)) (@list.length.{?l_1} α l) (@list.update_nth_length.{?l_1} α l i a)) hj))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {n : nat} {i j : fin n}, @ne.{1} (fin n) i j → @ne.{1} nat (@fin.val n i) (@fin.val n j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@ne.{1} (fin n) (@fin.mk n i_val i_is_lt) (@fin.mk n j_val j_is_lt)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : nat,
α : Type u_1,
v : vector.{u_1} α n,
i j : fin n,
h : @ne.{1} (fin n) i j,
a : α
⊢ @eq.{u_1+1} α (@vector.nth.{u_1} α n (@vector.update_nth.{u_1} n α v i a) j) (@vector.nth.{u_1} α n v j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>214  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : nat,
α : Type u_1,
v : vector.{u_1} α n,
i j : fin n,
h : @ne.{1} (fin n) i j,
a : α
⊢ @eq.{u_1+1} α (@vector.nth.{u_1} α n (@vector.update_nth.{u_1} n α v i a) j) (@vector.nth.{u_1} α n v j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>215  lemma nth_update_nth_eq_if {v : vector α n} {i j : fin n} (a : α) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='blue'><a title='vector'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='fin'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 14, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/fin/basic.lean&#x27;, &#x27;line&#x27;: 9, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='green'><a title='Type u → nat → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='nat → Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>216    (v.update_nth i a).nth j = if i = j then a else v.nth j :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='vector.update_nth'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='vector.nth'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='vector.nth'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 203, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 54, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 54, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='vector.{u_1} α n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {n : nat} {α : Type u_1}, vector.{u_1} α n → fin n → α → vector.{u_1} α n'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='fin n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} {n : nat}, vector.{u_1} α n → fin n → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='fin n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='fin n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='fin n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='vector.{u_1} α n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} {n : nat}, vector.{u_1} α n → fin n → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='fin n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`update_nth v n a` replaces the `n`th element of `v` with `a`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>217  by split_ifs; try {simp *}; try {rw nth_update_nth_of_ne}; assumption</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='blue'><a title='vector.nth_update_nth_of_ne'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/split_ifs.lean&#x27;, &#x27;line&#x27;: 84, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 851, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 851, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 851, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 210, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 851, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 227, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {n : nat} {α : Type u_1} {v : vector.{u_1} α n} {i j : fin n}, @ne.{1} (fin n) i j → ∀ (a : α), @eq.{u_1+1} α (@vector.nth.{u_1} α n (@vector.update_nth.{u_1} n α v i a) j) (@vector.nth.{u_1} α n v j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title=' Splits all if-then-else-expressions into multiple goals.

Given a goal of the form `g (if p then x else y)`, `split_ifs` will produce
two goals: `p ⊢ g x` and `¬p ⊢ g y`.

If there are multiple ite-expressions, then `split_ifs` will split them all,
starting with a top-most one whose condition does not contain another
ite-expression.

`split_ifs at *` splits all ite-expressions in all hypotheses as well as the goal.

`split_ifs with h₁ h₂ h₃` overrides the default names for the hypotheses.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`try { t }` tries to apply tactic `t`, but succeeds whether or not `t` succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`try { t }` tries to apply tactic `t`, but succeeds whether or not `t` succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`try { t }` tries to apply tactic `t`, but succeeds whether or not `t` succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='`try { t }` tries to apply tactic `t`, but succeeds whether or not `t` succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic looks in the local context for a hypothesis whose type is equal to the goal target. If it finds one, it uses it to prove the goal, and otherwise it fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='split_ifs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='try'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='try'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='try'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='teal'><a title='try'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='assumption'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='n : nat,
α : Type u_1,
v : vector.{u_1} α n,
i j : fin n,
a : α
⊢ @eq.{u_1+1} α (@vector.nth.{u_1} α n (@vector.update_nth.{u_1} n α v i a) j)
    (@ite.{u_1+1} (@eq.{1} (fin n) i j) (fin.decidable_eq n i j) α a (@vector.nth.{u_1} α n v j))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : nat,
α : Type u_1,
v : vector.{u_1} α n,
i j : fin n,
a : α,
h : @eq.{1} (fin n) i j
⊢ @eq.{u_1+1} α (@vector.nth.{u_1} α n (@vector.update_nth.{u_1} n α v i a) j) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : nat,
α : Type u_1,
v : vector.{u_1} α n,
i j : fin n,
a : α
⊢ @eq.{u_1+1} α (@vector.nth.{u_1} α n (@vector.update_nth.{u_1} n α v i a) j)
    (@ite.{u_1+1} (@eq.{1} (fin n) i j) (fin.decidable_eq n i j) α a (@vector.nth.{u_1} α n v j))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : nat,
α : Type u_1,
v : vector.{u_1} α n,
i j : fin n,
a : α,
h : not (@eq.{1} (fin n) i j)
⊢ @eq.{u_1+1} α (@vector.nth.{u_1} α n (@vector.update_nth.{u_1} n α v i a) j) (@vector.nth.{u_1} α n v j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : nat,
α : Type u_1,
v : vector.{u_1} α n,
i j : fin n,
a : α,
h : not (@eq.{1} (fin n) i j)
⊢ @ne.{1} (fin n) i j'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : nat,
α : Type u_1,
v : vector.{u_1} α n,
i j : fin n,
a : α
⊢ @eq.{u_1+1} α (@vector.nth.{u_1} α n (@vector.update_nth.{u_1} n α v i a) j)
    (@ite.{u_1+1} (@eq.{1} (fin n) i j) (fin.decidable_eq n i j) α a (@vector.nth.{u_1} α n v j))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>218  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 227, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic looks in the local context for a hypothesis whose type is equal to the goal target. If it finds one, it uses it to prove the goal, and otherwise it fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='assumption'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : nat,
α : Type u_1,
v : vector.{u_1} α n,
i j : fin n,
a : α
⊢ @eq.{u_1+1} α (@vector.nth.{u_1} α n (@vector.update_nth.{u_1} n α v i a) j)
    (@ite.{u_1+1} (@eq.{1} (fin n) i j) (fin.decidable_eq n i j) α a (@vector.nth.{u_1} α n v j))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>219  end update_nth</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>220  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>221  end vector</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>222  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>223  namespace vector</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>224  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>225  section traverse</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>226  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>227  variables {F G : Type u → Type u}</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>228  variables [applicative F] [applicative G]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='applicative'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='applicative'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/applicative.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/applicative.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='(Type u → Type u) → Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='(Type u → Type u) → Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>229  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>230  open applicative functor</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>231  open list (cons) nat</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>232  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>233  private def traverse_aux {α β : Type u} (f : α → F β) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                             </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                             </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>234    Π (x : list α), F (vector β x.length)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='traverse_aux'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='list'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='vector'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='list.length'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 286, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 14, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/list/basic.lean&#x27;, &#x27;line&#x27;: 75, &#x27;column&#x27;: 12}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π (x : list.{u} α), F (vector.{u} β (@list.length.{u} α x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u → nat → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='list.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u}, list.{u} α → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>235  | []      := pure vector.nil</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='list.nil'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='has_pure.pure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='vector.nil'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 286, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/applicative.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 23, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {T : Type u}, list.{u} T'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Π {f : Type u → Type v} [c : has_pure.{u v} f] {α : Type u}, α → f α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, vector.{u} α (@has_zero.zero.{0} nat nat.has_zero)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>236  | (x::xs) := vector.cons &lt;$&gt; f x &lt;*&gt; traverse_aux xs</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='list.cons'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='xs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='vector.cons'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='has_seq.seq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='traverse_aux'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 286, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 25, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/functor.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/applicative.lean&#x27;, &#x27;line&#x27;: 16, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {T : Type u}, T → list.{u} T → list.{u} T'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='list.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {α : Type u} {n : nat}, α → vector.{u} α n → vector.{u} α (nat.succ n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {f : Type u → Type u} [c : functor.{u u} f] {α β : Type u}, (α → β) → f α → f β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → F β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {f : Type u → Type u} [c : has_seq.{u u} f] {α β : Type u}, f (α → β) → f α → f β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (x : list.{u} α), F (vector.{u} β (@list.length.{u} α x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>237  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>238  protected def traverse {α β : Type u} (f : α → F β) : vector α n → F (vector β n)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                           </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='vector'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='traverse'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='vector'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 14, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 14, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                           </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type u → nat → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='vector.{u} α n → F (vector.{u} β n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u → nat → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>239  | ⟨v, Hv⟩ := cast (by rw Hv) $ traverse_aux f v</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='cast'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='Hv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='_private.638173841.traverse_aux'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 88, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 233, &#x27;column&#x27;: 12}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='list.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Π {α β : Sort u}, @eq.{u+1} (Sort u) α β → α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{1} nat (@list.length.{u} α v) n'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {F : Type u → Type u} [_inst_1 : applicative.{u u} F] {α β : Type u}, (α → F β) → Π (x : list.{u} α), F (vector.{u} β (@list.length.{u} α x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → F β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='lime'><a title='n : nat,
F : Type u → Type u,
_inst_1 : applicative.{u u} F,
α β : Type u,
f : α → F β,
traverse : vector.{u} α n → F (vector.{u} β n),
v : list.{u} α,
Hv : @eq.{1} nat (@list.length.{u} α v) n
⊢ @eq.{u+2} (Type u) (F (vector.{u} β (@list.length.{u} α v))) (F (vector.{u} β n))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>240  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>241  variables [is_lawful_applicative F] [is_lawful_applicative G]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='is_lawful_applicative'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='is_lawful_applicative'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/lawful.lean&#x27;, &#x27;line&#x27;: 26, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/lawful.lean&#x27;, &#x27;line&#x27;: 26, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Π (f : Type u → Type u) [_inst_1 : applicative.{u u} f], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π (f : Type u → Type u) [_inst_1 : applicative.{u u} f], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>242  variables {α β γ : Type u}</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>243  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>244  @[simp] protected lemma traverse_def</code>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>245    (f : α → F β) (x : α) : ∀ (xs : vector α n),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='vector'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 14, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='Type u → nat → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>246    (x :: xs).traverse f = cons &lt;$&gt; f x &lt;*&gt; xs.traverse f :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='vector.cons'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='xs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='vector.traverse'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='vector.cons'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_seq.seq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='xs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='vector.traverse'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 25, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 238, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 25, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/functor.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/applicative.lean&#x27;, &#x27;line&#x27;: 16, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 238, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} {n : nat}, α → vector.{u} α n → vector.{u} α (nat.succ n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='vector.{u} α n'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {n : nat} {F : Type u → Type u} [_inst_1 : applicative.{u u} F] {α β : Type u}, (α → F β) → vector.{u} α n → F (vector.{u} β n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α → F β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} {n : nat}, α → vector.{u} α n → vector.{u} α (nat.succ n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {f : Type u → Type u} [c : functor.{u u} f] {α β : Type u}, (α → β) → f α → f β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → F β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {f : Type u → Type u} [c : has_seq.{u u} f] {α β : Type u}, f (α → β) → f α → f β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='vector.{u} α n'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {n : nat} {F : Type u → Type u} [_inst_1 : applicative.{u u} F] {α β : Type u}, (α → F β) → vector.{u} α n → F (vector.{u} β n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → F β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>247  by rintro ⟨xs, rfl⟩; refl</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 441, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1263, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat) (λ (a : sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat), @sum.has_reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) nat (λ (a : nat), nat.reflect a) `(tactic.list_Pi.{0} tactic.rcases_patt) `(nat) a) tactic.rintro_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The `rintro` tactic is a combination of the `intros` tactic with `rcases` to
allow for destructuring patterns while introducing variables. See `rcases` for
a description of supported patterns. For example, `rintro (a | ⟨b, c⟩) ⟨d, e⟩`
will introduce two variables, and then do case splits on both of them producing
two subgoals, one with variables `a d e` and the other with `b c d e`.

`rintro?` will introduce and case split on variables in the same way as
`rintro`, but will also print the `rintro` invocation that would have the same
result. Like `rcases?`, `rintro? : n` allows for modifying the
depth of splitting; the default is 5.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Shorter name for the tactic `reflexivity`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rintro'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; (: n)?) | patt_list&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='n : nat,
F : Type u → Type u,
_inst_1 : applicative.{u u} F,
_inst_3 : @is_lawful_applicative.{u u} F _inst_1,
α β : Type u,
f : α → F β,
x : α
⊢ ∀ (xs : vector.{u} α n),
    @eq.{u+1} (F (vector.{u} β (nat.succ n)))
      (@vector.traverse.{u} (nat.succ n) F _inst_1 α β f (@vector.cons.{u} α n x xs))
      (@has_seq.seq.{u u} F (@applicative.to_has_seq.{u u} F _inst_1) (vector.{u} β n) (vector.{u} β (nat.succ n))
         (@functor.map.{u u} F (@applicative.to_functor.{u u} F _inst_1) β
            (vector.{u} β n → vector.{u} β (nat.succ n))
            (@vector.cons.{u} β n)
            (f x))
         (@vector.traverse.{u} n F _inst_1 α β f xs))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>248  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1263, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Shorter name for the tactic `reflexivity`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : nat,
F : Type u → Type u,
_inst_1 : applicative.{u u} F,
_inst_3 : @is_lawful_applicative.{u u} F _inst_1,
α β : Type u,
f : α → F β,
x : α
⊢ ∀ (xs : vector.{u} α n),
    @eq.{u+1} (F (vector.{u} β (nat.succ n)))
      (@vector.traverse.{u} (nat.succ n) F _inst_1 α β f (@vector.cons.{u} α n x xs))
      (@has_seq.seq.{u u} F (@applicative.to_has_seq.{u u} F _inst_1) (vector.{u} β n) (vector.{u} β (nat.succ n))
         (@functor.map.{u u} F (@applicative.to_functor.{u u} F _inst_1) β
            (vector.{u} β n → vector.{u} β (nat.succ n))
            (@vector.cons.{u} β n)
            (f x))
         (@vector.traverse.{u} n F _inst_1 α β f xs))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>249  protected lemma id_traverse : ∀ (x : vector α n), x.traverse id.mk = x :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='blue'><a title='vector'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='vector.traverse'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='id.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 14, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;line&#x27;: 238, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category/functor.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='green'><a title='Type u → nat → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='vector.{u} α n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {n : nat} {F : Type u → Type u} [_inst_1 : applicative.{u u} F] {α β : Type u}, (α → F β) → vector.{u} α n → F (vector.{u} β n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Sort u}, α → @id.{u+1} (Sort u) α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='vector.{u} α n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>250  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : nat,
α : Type u
⊢ ∀ (x : vector.{u} α n),
    @eq.{u+1} (@id.{u+2} (Type u) (vector.{u} α n))
      (@vector.traverse.{u} n (@id.{u+2} (Type u)) (@monad.to_applicative.{u u} (@id.{u+2} (Type u)) id.monad.{u}) α α
         (@id.mk.{u+1} α)
         x)
      x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>251    rintro ⟨x, rfl⟩, dsimp [vector.traverse, cast],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='blue'><a title='vector.traverse'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='cast'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 441, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 238, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 88, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat) (λ (a : sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat), @sum.has_reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) nat (λ (a : nat), nat.reflect a) `(tactic.list_Pi.{0} tactic.rcases_patt) `(nat) a) tactic.rintro_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {n : nat} {F : Type ?l_1 → Type ?l_1} [_inst_1 : applicative.{?l_1 ?l_1} F] {α β : Type ?l_1}, (α → F β) → vector.{?l_1} α n → F (vector.{?l_1} β n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Sort ?l_1}, @eq.{?l_1+1} (Sort ?l_1) α β → α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `rintro` tactic is a combination of the `intros` tactic with `rcases` to
allow for destructuring patterns while introducing variables. See `rcases` for
a description of supported patterns. For example, `rintro (a | ⟨b, c⟩) ⟨d, e⟩`
will introduce two variables, and then do case splits on both of them producing
two subgoals, one with variables `a d e` and the other with `b c d e`.

`rintro?` will introduce and case split on variables in the same way as
`rintro`, but will also print the `rintro` invocation that would have the same
result. Like `rcases?`, `rintro? : n` allows for modifying the
depth of splitting; the default is 5.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rintro'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; (: n)?) | patt_list&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : nat,
α : Type u
⊢ ∀ (x : vector.{u} α n),
    @eq.{u+1} (@id.{u+2} (Type u) (vector.{u} α n))
      (@vector.traverse.{u} n (@id.{u+2} (Type u)) (@monad.to_applicative.{u u} (@id.{u+2} (Type u)) id.monad.{u}) α α
         (@id.mk.{u+1} α)
         x)
      x'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : list.{u} α
⊢ @eq.{u+1} (@id.{u+2} (Type u) (vector.{u} α (@list.length.{u} α x)))
    (@vector.traverse.{u} (@list.length.{u} α x) (@id.{u+2} (Type u))
       (@monad.to_applicative.{u u} (@id.{u+2} (Type u)) id.monad.{u})
       α
       α
       (@id.mk.{u+1} α)
       (@subtype.mk.{u+1} (list.{u} α)
          (λ (l : list.{u} α), @eq.{1} nat (@list.length.{u} α l) (@list.length.{u} α x))
          x
          (@eq.refl.{1} nat (@list.length.{u} α x))))
    (@subtype.mk.{u+1} (list.{u} α) (λ (l : list.{u} α), @eq.{1} nat (@list.length.{u} α l) (@list.length.{u} α x))
       x
       (@eq.refl.{1} nat (@list.length.{u} α x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : list.{u} α
⊢ @eq.{u+1} (vector.{u} α (@list.length.{u} α x))
    (@traverse_aux.{u} (@id.{u+2} (Type u)) (@monad.to_applicative.{u u} (@id.{u+2} (Type u)) id.monad.{u}) α α
       (@id.mk.{u+1} α)
       x)
    (@subtype.mk.{u+1} (list.{u} α) (λ (l : list.{u} α), @eq.{1} nat (@list.length.{u} α l) (@list.length.{u} α x))
       x
       (@eq.refl.{1} nat (@list.length.{u} α x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>252    induction x with x xs IH, {refl},</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 528, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 528, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1263, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.using_ident → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} (list.{0} name)) (λ (a : option.{0} (list.{0} name)), @option.has_reflect (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) `(list.{0} name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative (list.{0} name) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit (list.{0} name) (lean.parser.tk (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident))) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='list.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.using_ident → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} (list.{0} name)) (λ (a : option.{0} (list.{0} name)), @option.has_reflect (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) `(list.{0} name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative (list.{0} name) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit (list.{0} name) (lean.parser.tk (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident))) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor and an inductive hypothesis is added for each recursive argument to the constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the inductive hypothesis incorporates that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (nat.succ a)` and `ih₁ : P a → Q a` and target `Q (nat.succ a)`. Here the names `a` and `ih₁` ire chosen automatically.

`induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.

`induction e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors and inductive hypotheses, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically. Note that for long sequences of names, the `case` tactic provides a more convenient naming mechanism.

`induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables

`induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.

`induction h : t` will introduce an equality of the form `h : t = C x y`, asserting that the input term is equal to the current constructor case, to the context.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor and an inductive hypothesis is added for each recursive argument to the constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the inductive hypothesis incorporates that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (nat.succ a)` and `ih₁ : P a → Q a` and target `Q (nat.succ a)`. Here the names `a` and `ih₁` ire chosen automatically.

`induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.

`induction e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors and inductive hypotheses, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically. Note that for long sequences of names, the `case` tactic provides a more convenient naming mechanism.

`induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables

`induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.

`induction h : t` will introduce an equality of the form `h : t = C x y`, asserting that the input term is equal to the current constructor case, to the context.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='Shorter name for the tactic `reflexivity`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='induction'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='induction'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(using id)?&#x27;, &#x27;(with id*)?&#x27;, &#x27;(generalizing id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(using id)?&#x27;, &#x27;(with id*)?&#x27;, &#x27;(generalizing id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
x : list.{u} α
⊢ @eq.{u+1} (vector.{u} α (@list.length.{u} α x))
    (@traverse_aux.{u} (@id.{u+2} (Type u)) (@monad.to_applicative.{u u} (@id.{u+2} (Type u)) id.monad.{u}) α α
       (@id.mk.{u+1} α)
       x)
    (@subtype.mk.{u+1} (list.{u} α) (λ (l : list.{u} α), @eq.{1} nat (@list.length.{u} α l) (@list.length.{u} α x))
       x
       (@eq.refl.{1} nat (@list.length.{u} α x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
case list.nil
α : Type u
⊢ @eq.{u+1} (vector.{u} α (@list.length.{u} α (@list.nil.{u} α)))
    (@traverse_aux.{u} (@id.{u+2} (Type u)) (@monad.to_applicative.{u u} (@id.{u+2} (Type u)) id.monad.{u}) α α
       (@id.mk.{u+1} α)
       (@list.nil.{u} α))
    (@subtype.mk.{u+1} (list.{u} α)
       (λ (l : list.{u} α), @eq.{1} nat (@list.length.{u} α l) (@list.length.{u} α (@list.nil.{u} α)))
       (@list.nil.{u} α)
       (@eq.refl.{1} nat (@list.length.{u} α (@list.nil.{u} α))))

case list.cons
α : Type u,
x : α,
xs : list.{u} α,
IH :
  @eq.{u+1} (vector.{u} α (@list.length.{u} α xs))
    (@traverse_aux.{u} (@id.{u+2} (Type u)) (@monad.to_applicative.{u u} (@id.{u+2} (Type u)) id.monad.{u}) α α
       (@id.mk.{u+1} α)
       xs)
    (@subtype.mk.{u+1} (list.{u} α)
       (λ (l : list.{u} α), @eq.{1} nat (@list.length.{u} α l) (@list.length.{u} α xs))
       xs
       (@eq.refl.{1} nat (@list.length.{u} α xs)))
⊢ @eq.{u+1} (vector.{u} α (@list.length.{u} α (@list.cons.{u} α x xs)))
    (@traverse_aux.{u} (@id.{u+2} (Type u)) (@monad.to_applicative.{u u} (@id.{u+2} (Type u)) id.monad.{u}) α α
       (@id.mk.{u+1} α)
       (@list.cons.{u} α x xs))
    (@subtype.mk.{u+1} (list.{u} α)
       (λ (l : list.{u} α), @eq.{1} nat (@list.length.{u} α l) (@list.length.{u} α (@list.cons.{u} α x xs)))
       (@list.cons.{u} α x xs)
       (@eq.refl.{1} nat (@list.length.{u} α (@list.cons.{u} α x xs))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case list.cons
α : Type u,
x : α,
xs : list.{u} α,
IH :
  @eq.{u+1} (vector.{u} α (@list.length.{u} α xs))
    (@traverse_aux.{u} (@id.{u+2} (Type u)) (@monad.to_applicative.{u u} (@id.{u+2} (Type u)) id.monad.{u}) α α
       (@id.mk.{u+1} α)
       xs)
    (@subtype.mk.{u+1} (list.{u} α)
       (λ (l : list.{u} α), @eq.{1} nat (@list.length.{u} α l) (@list.length.{u} α xs))
       xs
       (@eq.refl.{1} nat (@list.length.{u} α xs)))
⊢ @eq.{u+1} (vector.{u} α (@list.length.{u} α (@list.cons.{u} α x xs)))
    (@traverse_aux.{u} (@id.{u+2} (Type u)) (@monad.to_applicative.{u u} (@id.{u+2} (Type u)) id.monad.{u}) α α
       (@id.mk.{u+1} α)
       (@list.cons.{u} α x xs))
    (@subtype.mk.{u+1} (list.{u} α)
       (λ (l : list.{u} α), @eq.{1} nat (@list.length.{u} α l) (@list.length.{u} α (@list.cons.{u} α x xs)))
       (@list.cons.{u} α x xs)
       (@eq.refl.{1} nat (@list.length.{u} α (@list.cons.{u} α x xs))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>253    simp! [IH], refl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='IH'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1263, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u+1} (vector.{u} α (@list.length.{u} α xs)) (@traverse_aux.{u} (@id.{u+2} (Type u)) (@monad.to_applicative.{u u} (@id.{u+2} (Type u)) id.monad.{u}) α α (@id.mk.{u+1} α) xs) (@subtype.mk.{u+1} (list.{u} α) (λ (l : list.{u} α), @eq.{1} nat (@list.length.{u} α l) (@list.length.{u} α xs)) xs (@eq.refl.{1} nat (@list.length.{u} α xs)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Shorter name for the tactic `reflexivity`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case list.cons
α : Type u,
x : α,
xs : list.{u} α,
IH :
  @eq.{u+1} (vector.{u} α (@list.length.{u} α xs))
    (@traverse_aux.{u} (@id.{u+2} (Type u)) (@monad.to_applicative.{u u} (@id.{u+2} (Type u)) id.monad.{u}) α α
       (@id.mk.{u+1} α)
       xs)
    (@subtype.mk.{u+1} (list.{u} α)
       (λ (l : list.{u} α), @eq.{1} nat (@list.length.{u} α l) (@list.length.{u} α xs))
       xs
       (@eq.refl.{1} nat (@list.length.{u} α xs)))
⊢ @eq.{u+1} (vector.{u} α (@list.length.{u} α (@list.cons.{u} α x xs)))
    (@traverse_aux.{u} (@id.{u+2} (Type u)) (@monad.to_applicative.{u u} (@id.{u+2} (Type u)) id.monad.{u}) α α
       (@id.mk.{u+1} α)
       (@list.cons.{u} α x xs))
    (@subtype.mk.{u+1} (list.{u} α)
       (λ (l : list.{u} α), @eq.{1} nat (@list.length.{u} α l) (@list.length.{u} α (@list.cons.{u} α x xs)))
       (@list.cons.{u} α x xs)
       (@eq.refl.{1} nat (@list.length.{u} α (@list.cons.{u} α x xs))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case list.cons
α : Type u,
x : α,
xs : list.{u} α,
IH :
  @eq.{u+1} (vector.{u} α (@list.length.{u} α xs))
    (@traverse_aux.{u} (@id.{u+2} (Type u)) (@monad.to_applicative.{u u} (@id.{u+2} (Type u)) id.monad.{u}) α α
       (@id.mk.{u+1} α)
       xs)
    (@subtype.mk.{u+1} (list.{u} α)
       (λ (l : list.{u} α), @eq.{1} nat (@list.length.{u} α l) (@list.length.{u} α xs))
       xs
       (@eq.refl.{1} nat (@list.length.{u} α xs)))
⊢ @eq.{u+1} (vector.{u} α (@list.length.{u} α (@list.cons.{u} α x xs)))
    (@has_seq.seq.{u u} (@id.{u+2} (Type u))
       (@applicative.to_has_seq.{u u} (@id.{u+2} (Type u))
          (@monad.to_applicative.{u u} (@id.{u+2} (Type u)) id.monad.{u}))
       (vector.{u} α (@list.length.{u} α xs))
       (vector.{u} α (@list.length.{u} α (@list.cons.{u} α x xs)))
       (@functor.map.{u u} (@id.{u+2} (Type u))
          (@applicative.to_functor.{u u} (@id.{u+2} (Type u))
             (@monad.to_applicative.{u u} (@id.{u+2} (Type u)) id.monad.{u}))
          α
          (vector.{u} α (@list.length.{u} α xs) → vector.{u} α (@list.length.{u} α (@list.cons.{u} α x xs)))
          (@vector.cons.{u} α (@list.length.{u} α xs))
          (@id.mk.{u+1} α x))
       (@subtype.mk.{u+1} (list.{u} α)
          (λ (l : list.{u} α), @eq.{1} nat (@list.length.{u} α l) (@list.length.{u} α xs))
          xs
          (@eq.refl.{1} nat (@list.length.{u} α xs))))
    (@subtype.mk.{u+1} (list.{u} α)
       (λ (l : list.{u} α), @eq.{1} nat (@list.length.{u} α l) (@list.length.{u} α (@list.cons.{u} α x xs)))
       (@list.cons.{u} α x xs)
       (@eq.refl.{1} nat (@list.length.{u} α (@list.cons.{u} α x xs))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>254  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>255  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>256  open function</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>257  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>258  protected lemma comp_traverse (f : β → F γ) (g : α → G β) : ∀ (x : vector α n),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='vector'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 14, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Type u → nat → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>259    vector.traverse (comp.mk ∘ functor.map f ∘ g) x =</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='vector.traverse'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='functor.comp.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='function.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='function.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 238, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category/functor.lean&#x27;, &#x27;line&#x27;: 86, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/function.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 25}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/functor.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/function.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 25}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {n : nat} {F : Type u → Type u} [_inst_1 : applicative.{u u} F] {α β : Type u}, (α → F β) → vector.{u} α n → F (vector.{u} β n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {F : Type u → Type w} {G : Type v → Type u} {α : Type v}, F (G α) → functor.comp.{u v w} F G α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α β φ : Type u}, (β → φ) → (α → β) → α → φ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {f : Type u → Type v} [c : functor.{u v} f] {α β : Type u}, (α → β) → f α → f β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β → F γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α β φ : Type u}, (β → φ) → (α → β) → α → φ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → G β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='vector.{u} α n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>260    comp.mk (vector.traverse f &lt;$&gt; vector.traverse g x) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='functor.comp.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='vector.traverse'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='vector.traverse'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category/functor.lean&#x27;, &#x27;line&#x27;: 86, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 238, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/functor.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 238, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {F : Type u → Type w} {G : Type v → Type u} {α : Type v}, F (G α) → functor.comp.{u v w} F G α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {n : nat} {F : Type u → Type u} [_inst_1 : applicative.{u u} F] {α β : Type u}, (α → F β) → vector.{u} α n → F (vector.{u} β n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β → F γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {f : Type u → Type u} [c : functor.{u u} f] {α β : Type u}, (α → β) → f α → f β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {n : nat} {F : Type u → Type u} [_inst_1 : applicative.{u u} F] {α β : Type u}, (α → F β) → vector.{u} α n → F (vector.{u} β n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → G β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='vector.{u} α n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>261  by rintro ⟨x, rfl⟩; dsimp [vector.traverse, cast];</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='blue'><a title='vector.traverse'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='cast'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 441, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 238, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 88, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat) (λ (a : sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat), @sum.has_reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) nat (λ (a : nat), nat.reflect a) `(tactic.list_Pi.{0} tactic.rcases_patt) `(nat) a) tactic.rintro_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {n : nat} {F : Type ?l_1 → Type ?l_1} [_inst_1 : applicative.{?l_1 ?l_1} F] {α β : Type ?l_1}, (α → F β) → vector.{?l_1} α n → F (vector.{?l_1} β n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Sort ?l_1}, @eq.{?l_1+1} (Sort ?l_1) α β → α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The `rintro` tactic is a combination of the `intros` tactic with `rcases` to
allow for destructuring patterns while introducing variables. See `rcases` for
a description of supported patterns. For example, `rintro (a | ⟨b, c⟩) ⟨d, e⟩`
will introduce two variables, and then do case splits on both of them producing
two subgoals, one with variables `a d e` and the other with `b c d e`.

`rintro?` will introduce and case split on variables in the same way as
`rintro`, but will also print the `rintro` invocation that would have the same
result. Like `rcases?`, `rintro? : n` allows for modifying the
depth of splitting; the default is 5.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rintro'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; (: n)?) | patt_list&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='n : nat,
F G : Type u → Type u,
_inst_1 : applicative.{u u} F,
_inst_2 : applicative.{u u} G,
_inst_3 : @is_lawful_applicative.{u u} F _inst_1,
_inst_4 : @is_lawful_applicative.{u u} G _inst_2,
α β γ : Type u,
f : β → F γ,
g : α → G β
⊢ ∀ (x : vector.{u} α n),
    @eq.{u+1} (functor.comp.{u u u} (λ {β : Type u}, G β) F (vector.{u} γ n))
      (@vector.traverse.{u} n (functor.comp.{u u u} (λ {β : Type u}, G β) F)
         (@comp.applicative.{u u u} (λ {β : Type u}, G β) F _inst_2 _inst_1)
         α
         γ
         (@function.comp.{u+1 u+1 u+1} α (G (F γ)) (functor.comp.{u u u} (λ {β : Type u}, G β) F γ)
            (@functor.comp.mk.{u u u} (λ {β : Type u}, G β) F γ)
            (@function.comp.{u+1 u+1 u+1} α (G β) (G (F γ))
               (@functor.map.{u u} (λ {β : Type u}, G β)
                  (@applicative.to_functor.{u u} (λ {β : Type u}, G β) _inst_2)
                  β
                  (F γ)
                  f)
               g))
         x)
      (@functor.comp.mk.{u u u} (λ {β : Type u}, G β) F (vector.{u} γ n)
         (@functor.map.{u u} G (@applicative.to_functor.{u u} G _inst_2) (vector.{u} β n) (F (vector.{u} γ n))
            (@vector.traverse.{u} n F _inst_1 β γ f)
            (@vector.traverse.{u} n G _inst_2 α β g x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>262     induction x with x xs; simp! [cast, *] with functor_norm;</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='blue'><a title='cast'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 528, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 528, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 88, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.using_ident → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} (list.{0} name)) (λ (a : option.{0} (list.{0} name)), @option.has_reflect (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) `(list.{0} name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative (list.{0} name) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit (list.{0} name) (lean.parser.tk (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident))) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='list.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.using_ident → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} (list.{0} name)) (λ (a : option.{0} (list.{0} name)), @option.has_reflect (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) `(list.{0} name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative (list.{0} name) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit (list.{0} name) (lean.parser.tk (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident))) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Sort ?l_1}, @eq.{?l_1+1} (Sort ?l_1) α β → α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor and an inductive hypothesis is added for each recursive argument to the constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the inductive hypothesis incorporates that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (nat.succ a)` and `ih₁ : P a → Q a` and target `Q (nat.succ a)`. Here the names `a` and `ih₁` ire chosen automatically.

`induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.

`induction e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors and inductive hypotheses, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically. Note that for long sequences of names, the `case` tactic provides a more convenient naming mechanism.

`induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables

`induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.

`induction h : t` will introduce an equality of the form `h : t = C x y`, asserting that the input term is equal to the current constructor case, to the context.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor and an inductive hypothesis is added for each recursive argument to the constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the inductive hypothesis incorporates that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (nat.succ a)` and `ih₁ : P a → Q a` and target `Q (nat.succ a)`. Here the names `a` and `ih₁` ire chosen automatically.

`induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.

`induction e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors and inductive hypotheses, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically. Note that for long sequences of names, the `case` tactic provides a more convenient naming mechanism.

`induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables

`induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.

`induction h : t` will introduce an equality of the form `h : t = C x y`, asserting that the input term is equal to the current constructor case, to the context.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='induction'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='induction'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(using id)?&#x27;, &#x27;(with id*)?&#x27;, &#x27;(generalizing id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(using id)?&#x27;, &#x27;(with id*)?&#x27;, &#x27;(generalizing id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : nat,
F G : Type u → Type u,
_inst_1 : applicative.{u u} F,
_inst_2 : applicative.{u u} G,
_inst_3 : @is_lawful_applicative.{u u} F _inst_1,
_inst_4 : @is_lawful_applicative.{u u} G _inst_2,
α β γ : Type u,
f : β → F γ,
g : α → G β
⊢ ∀ (x : vector.{u} α n),
    @eq.{u+1} (functor.comp.{u u u} (λ {β : Type u}, G β) F (vector.{u} γ n))
      (@vector.traverse.{u} n (functor.comp.{u u u} (λ {β : Type u}, G β) F)
         (@comp.applicative.{u u u} (λ {β : Type u}, G β) F _inst_2 _inst_1)
         α
         γ
         (@function.comp.{u+1 u+1 u+1} α (G (F γ)) (functor.comp.{u u u} (λ {β : Type u}, G β) F γ)
            (@functor.comp.mk.{u u u} (λ {β : Type u}, G β) F γ)
            (@function.comp.{u+1 u+1 u+1} α (G β) (G (F γ))
               (@functor.map.{u u} (λ {β : Type u}, G β)
                  (@applicative.to_functor.{u u} (λ {β : Type u}, G β) _inst_2)
                  β
                  (F γ)
                  f)
               g))
         x)
      (@functor.comp.mk.{u u u} (λ {β : Type u}, G β) F (vector.{u} γ n)
         (@functor.map.{u u} G (@applicative.to_functor.{u u} G _inst_2) (vector.{u} β n) (F (vector.{u} γ n))
            (@vector.traverse.{u} n F _inst_1 β γ f)
            (@vector.traverse.{u} n G _inst_2 α β g x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>263     [refl, simp [(∘)]]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='list.cons'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='function.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 286, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1263, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/function.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 25}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {T : Type}, T → list.{0} T → list.{0} T'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Sort ?l_1} {β : Sort ?l_2} {φ : Sort ?l_3}, (β → φ) → (α → β) → α → φ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Shorter name for the tactic `reflexivity`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : nat,
F G : Type u → Type u,
_inst_1 : applicative.{u u} F,
_inst_2 : applicative.{u u} G,
_inst_3 : @is_lawful_applicative.{u u} F _inst_1,
_inst_4 : @is_lawful_applicative.{u u} G _inst_2,
α β γ : Type u,
f : β → F γ,
g : α → G β
⊢ ∀ (x : vector.{u} α n),
    @eq.{u+1} (functor.comp.{u u u} (λ {β : Type u}, G β) F (vector.{u} γ n))
      (@vector.traverse.{u} n (functor.comp.{u u u} (λ {β : Type u}, G β) F)
         (@comp.applicative.{u u u} (λ {β : Type u}, G β) F _inst_2 _inst_1)
         α
         γ
         (@function.comp.{u+1 u+1 u+1} α (G (F γ)) (functor.comp.{u u u} (λ {β : Type u}, G β) F γ)
            (@functor.comp.mk.{u u u} (λ {β : Type u}, G β) F γ)
            (@function.comp.{u+1 u+1 u+1} α (G β) (G (F γ))
               (@functor.map.{u u} (λ {β : Type u}, G β)
                  (@applicative.to_functor.{u u} (λ {β : Type u}, G β) _inst_2)
                  β
                  (F γ)
                  f)
               g))
         x)
      (@functor.comp.mk.{u u u} (λ {β : Type u}, G β) F (vector.{u} γ n)
         (@functor.map.{u u} G (@applicative.to_functor.{u u} G _inst_2) (vector.{u} β n) (F (vector.{u} γ n))
            (@vector.traverse.{u} n F _inst_1 β γ f)
            (@vector.traverse.{u} n G _inst_2 α β g x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>264  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>265  protected lemma traverse_eq_map_id {α β} (f : α → β) : ∀ (x : vector α n),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                              </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='vector'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 14, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                              </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Type u → nat → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>266    x.traverse (id.mk ∘ f) = id.mk (map f x) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='vector.traverse'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='id.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='function.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='id.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='vector.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 238, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category/functor.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/function.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 25}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category/functor.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 65, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='vector.{u_1} α n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {n : nat} {F : Type u_1 → Type u_1} [_inst_1 : applicative.{u_1 u_1} F] {α β : Type u_1}, (α → F β) → vector.{u_1} α n → F (vector.{u_1} β n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Sort u}, α → @id.{u+1} (Sort u) α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α β φ : Type u_1}, (β → φ) → (α → β) → α → φ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Sort u}, α → @id.{u+1} (Sort u) α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} {β : Type v} {n : nat}, (α → β) → vector.{u} α n → vector.{v} β n'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='vector.{u_1} α n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>267  by rintro ⟨x, rfl⟩; simp!;</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 441, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat) (λ (a : sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat), @sum.has_reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) nat (λ (a : nat), nat.reflect a) `(tactic.list_Pi.{0} tactic.rcases_patt) `(nat) a) tactic.rintro_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The `rintro` tactic is a combination of the `intros` tactic with `rcases` to
allow for destructuring patterns while introducing variables. See `rcases` for
a description of supported patterns. For example, `rintro (a | ⟨b, c⟩) ⟨d, e⟩`
will introduce two variables, and then do case splits on both of them producing
two subgoals, one with variables `a d e` and the other with `b c d e`.

`rintro?` will introduce and case split on variables in the same way as
`rintro`, but will also print the `rintro` invocation that would have the same
result. Like `rcases?`, `rintro? : n` allows for modifying the
depth of splitting; the default is 5.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rintro'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; (: n)?) | patt_list&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='n : nat,
α β : Type u_1,
f : α → β
⊢ ∀ (x : vector.{u_1} α n),
    @eq.{u_1+1} (@id.{u_1+2} (Type u_1) (vector.{u_1} β n))
      (@vector.traverse.{u_1} n (@id.{u_1+2} (Type u_1))
         (@monad.to_applicative.{u_1 u_1} (@id.{u_1+2} (Type u_1)) id.monad.{u_1})
         α
         β
         (@function.comp.{u_1+1 u_1+1 u_1+1} α β (@id.{u_1+2} (Type u_1) β) (@id.mk.{u_1+1} β) f)
         x)
      (@id.mk.{(max 1 (u_1+1))} (vector.{u_1} β n) (@vector.map.{u_1 u_1} α β n f x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>268     induction x; simp! * with functor_norm; refl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 528, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1263, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.using_ident → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} (list.{0} name)) (λ (a : option.{0} (list.{0} name)), @option.has_reflect (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) `(list.{0} name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative (list.{0} name) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit (list.{0} name) (lean.parser.tk (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident))) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='list.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor and an inductive hypothesis is added for each recursive argument to the constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the inductive hypothesis incorporates that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (nat.succ a)` and `ih₁ : P a → Q a` and target `Q (nat.succ a)`. Here the names `a` and `ih₁` ire chosen automatically.

`induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.

`induction e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors and inductive hypotheses, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically. Note that for long sequences of names, the `case` tactic provides a more convenient naming mechanism.

`induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables

`induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.

`induction h : t` will introduce an equality of the form `h : t = C x y`, asserting that the input term is equal to the current constructor case, to the context.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Shorter name for the tactic `reflexivity`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='induction'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(using id)?&#x27;, &#x27;(with id*)?&#x27;, &#x27;(generalizing id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : nat,
α β : Type u_1,
f : α → β
⊢ ∀ (x : vector.{u_1} α n),
    @eq.{u_1+1} (@id.{u_1+2} (Type u_1) (vector.{u_1} β n))
      (@vector.traverse.{u_1} n (@id.{u_1+2} (Type u_1))
         (@monad.to_applicative.{u_1 u_1} (@id.{u_1+2} (Type u_1)) id.monad.{u_1})
         α
         β
         (@function.comp.{u_1+1 u_1+1 u_1+1} α β (@id.{u_1+2} (Type u_1) β) (@id.mk.{u_1+1} β) f)
         x)
      (@id.mk.{(max 1 (u_1+1))} (vector.{u_1} β n) (@vector.map.{u_1 u_1} α β n f x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>269  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1263, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Shorter name for the tactic `reflexivity`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : nat,
α β : Type u_1,
f : α → β
⊢ ∀ (x : vector.{u_1} α n),
    @eq.{u_1+1} (@id.{u_1+2} (Type u_1) (vector.{u_1} β n))
      (@vector.traverse.{u_1} n (@id.{u_1+2} (Type u_1))
         (@monad.to_applicative.{u_1 u_1} (@id.{u_1+2} (Type u_1)) id.monad.{u_1})
         α
         β
         (@function.comp.{u_1+1 u_1+1 u_1+1} α β (@id.{u_1+2} (Type u_1) β) (@id.mk.{u_1+1} β) f)
         x)
      (@id.mk.{(max 1 (u_1+1))} (vector.{u_1} β n) (@vector.map.{u_1 u_1} α β n f x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>270  variable (η : applicative_transformation F G)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='applicative_transformation'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category/traversable/basic.lean&#x27;, &#x27;line&#x27;: 61, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='Π (F : Type u → Type v) [_inst_1 : applicative.{u v} F] [_inst_2 : @is_lawful_applicative.{u v} F _inst_1] (G : Type u → Type w) [_inst_3 : applicative.{u w} G] [_inst_4 : @is_lawful_applicative.{u w} G _inst_3], Type (max (u+1) v w)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>271  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>272  protected lemma naturality {α β : Type*}</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>273    (f : α → F β) : ∀ (x : vector α n),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='vector'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 14, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Type u → nat → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>274    η (x.traverse f) = x.traverse (@η _ ∘ f) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='η'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='vector.traverse'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='vector.traverse'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='η'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='function.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 238, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 238, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/function.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 25}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@applicative_transformation.{u u u} F _inst_1 _inst_3 G _inst_2 _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='vector.{u} α n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {n : nat} {F : Type u → Type u} [_inst_1 : applicative.{u u} F] {α β : Type u}, (α → F β) → vector.{u} α n → F (vector.{u} β n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → F β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='vector.{u} α n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {n : nat} {F : Type u → Type u} [_inst_1 : applicative.{u u} F] {α β : Type u}, (α → F β) → vector.{u} α n → F (vector.{u} β n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@applicative_transformation.{u u u} F _inst_1 _inst_3 G _inst_2 _inst_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α β φ : Type u}, (β → φ) → (α → β) → α → φ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → F β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>275  by rintro ⟨x, rfl⟩; simp! [cast];</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='blue'><a title='cast'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 441, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 88, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat) (λ (a : sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat), @sum.has_reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) nat (λ (a : nat), nat.reflect a) `(tactic.list_Pi.{0} tactic.rcases_patt) `(nat) a) tactic.rintro_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Sort ?l_1}, @eq.{?l_1+1} (Sort ?l_1) α β → α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The `rintro` tactic is a combination of the `intros` tactic with `rcases` to
allow for destructuring patterns while introducing variables. See `rcases` for
a description of supported patterns. For example, `rintro (a | ⟨b, c⟩) ⟨d, e⟩`
will introduce two variables, and then do case splits on both of them producing
two subgoals, one with variables `a d e` and the other with `b c d e`.

`rintro?` will introduce and case split on variables in the same way as
`rintro`, but will also print the `rintro` invocation that would have the same
result. Like `rcases?`, `rintro? : n` allows for modifying the
depth of splitting; the default is 5.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rintro'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; (: n)?) | patt_list&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='n : nat,
F G : Type u → Type u,
_inst_1 : applicative.{u u} F,
_inst_2 : applicative.{u u} G,
_inst_3 : @is_lawful_applicative.{u u} F _inst_1,
_inst_4 : @is_lawful_applicative.{u u} G _inst_2,
η : @applicative_transformation.{u u u} F _inst_1 _inst_3 G _inst_2 _inst_4,
α β : Type u,
f : α → F β
⊢ ∀ (x : vector.{u} α n),
    @eq.{u+1} (G (vector.{u} β n))
      (@coe_fn.{u+2 u+2} (@applicative_transformation.{u u u} F _inst_1 _inst_3 G _inst_2 _inst_4)
         (@applicative_transformation.has_coe_to_fun.{u u u} F _inst_1 _inst_3 G _inst_2 _inst_4)
         η
         (vector.{u} β n)
         (@vector.traverse.{u} n F _inst_1 α β f x))
      (@vector.traverse.{u} n G _inst_2 α β
         (@function.comp.{u+1 u+1 u+1} α (F β) (G β)
            (@coe_fn.{u+2 u+2} (@applicative_transformation.{u u u} F _inst_1 _inst_3 G _inst_2 _inst_4)
               (@applicative_transformation.has_coe_to_fun.{u u u} F _inst_1 _inst_3 G _inst_2 _inst_4)
               η
               β)
            f)
         x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>276     induction x with x xs IH; simp! * with functor_norm</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 528, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 528, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.using_ident → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} (list.{0} name)) (λ (a : option.{0} (list.{0} name)), @option.has_reflect (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) `(list.{0} name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative (list.{0} name) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit (list.{0} name) (lean.parser.tk (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident))) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='list.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.using_ident → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} (list.{0} name)) (λ (a : option.{0} (list.{0} name)), @option.has_reflect (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) `(list.{0} name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative (list.{0} name) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit (list.{0} name) (lean.parser.tk (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident))) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor and an inductive hypothesis is added for each recursive argument to the constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the inductive hypothesis incorporates that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (nat.succ a)` and `ih₁ : P a → Q a` and target `Q (nat.succ a)`. Here the names `a` and `ih₁` ire chosen automatically.

`induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.

`induction e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors and inductive hypotheses, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically. Note that for long sequences of names, the `case` tactic provides a more convenient naming mechanism.

`induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables

`induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.

`induction h : t` will introduce an equality of the form `h : t = C x y`, asserting that the input term is equal to the current constructor case, to the context.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor and an inductive hypothesis is added for each recursive argument to the constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the inductive hypothesis incorporates that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (nat.succ a)` and `ih₁ : P a → Q a` and target `Q (nat.succ a)`. Here the names `a` and `ih₁` ire chosen automatically.

`induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.

`induction e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors and inductive hypotheses, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically. Note that for long sequences of names, the `case` tactic provides a more convenient naming mechanism.

`induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables

`induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context, generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.

`induction h : t` will introduce an equality of the form `h : t = C x y`, asserting that the input term is equal to the current constructor case, to the context.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='induction'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='induction'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(using id)?&#x27;, &#x27;(with id*)?&#x27;, &#x27;(generalizing id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(using id)?&#x27;, &#x27;(with id*)?&#x27;, &#x27;(generalizing id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : nat,
F G : Type u → Type u,
_inst_1 : applicative.{u u} F,
_inst_2 : applicative.{u u} G,
_inst_3 : @is_lawful_applicative.{u u} F _inst_1,
_inst_4 : @is_lawful_applicative.{u u} G _inst_2,
η : @applicative_transformation.{u u u} F _inst_1 _inst_3 G _inst_2 _inst_4,
α β : Type u,
f : α → F β
⊢ ∀ (x : vector.{u} α n),
    @eq.{u+1} (G (vector.{u} β n))
      (@coe_fn.{u+2 u+2} (@applicative_transformation.{u u u} F _inst_1 _inst_3 G _inst_2 _inst_4)
         (@applicative_transformation.has_coe_to_fun.{u u u} F _inst_1 _inst_3 G _inst_2 _inst_4)
         η
         (vector.{u} β n)
         (@vector.traverse.{u} n F _inst_1 α β f x))
      (@vector.traverse.{u} n G _inst_2 α β
         (@function.comp.{u+1 u+1 u+1} α (F β) (G β)
            (@coe_fn.{u+2 u+2} (@applicative_transformation.{u u u} F _inst_1 _inst_3 G _inst_2 _inst_4)
               (@applicative_transformation.has_coe_to_fun.{u u u} F _inst_1 _inst_3 G _inst_2 _inst_4)
               η
               β)
            f)
         x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>277  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : nat,
F G : Type u → Type u,
_inst_1 : applicative.{u u} F,
_inst_2 : applicative.{u u} G,
_inst_3 : @is_lawful_applicative.{u u} F _inst_1,
_inst_4 : @is_lawful_applicative.{u u} G _inst_2,
η : @applicative_transformation.{u u u} F _inst_1 _inst_3 G _inst_2 _inst_4,
α β : Type u,
f : α → F β
⊢ ∀ (x : vector.{u} α n),
    @eq.{u+1} (G (vector.{u} β n))
      (@coe_fn.{u+2 u+2} (@applicative_transformation.{u u u} F _inst_1 _inst_3 G _inst_2 _inst_4)
         (@applicative_transformation.has_coe_to_fun.{u u u} F _inst_1 _inst_3 G _inst_2 _inst_4)
         η
         (vector.{u} β n)
         (@vector.traverse.{u} n F _inst_1 α β f x))
      (@vector.traverse.{u} n G _inst_2 α β
         (@function.comp.{u+1 u+1 u+1} α (F β) (G β)
            (@coe_fn.{u+2 u+2} (@applicative_transformation.{u u u} F _inst_1 _inst_3 G _inst_2 _inst_4)
               (@applicative_transformation.has_coe_to_fun.{u u u} F _inst_1 _inst_3 G _inst_2 _inst_4)
               η
               β)
            f)
         x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>278  end traverse</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>279  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>280  instance : traversable.{u} (flip vector n) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='traversable'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='flip'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='vector'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category/traversable/basic.lean&#x27;, &#x27;line&#x27;: 98, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 16, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 14, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='(Type u → Type u) → Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Π {α : Sort u} {β : Sort v} {φ : Sort w}, (α → β → φ) → β → α → φ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u → nat → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>281  { traverse := @vector.traverse n,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='vector.traverse'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;line&#x27;: 238, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='Π {n : nat} {F : Type u → Type u} [_inst_1 : applicative.{u u} F] {α β : Type u}, (α → F β) → vector.{u} α n → F (vector.{u} β n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>282    map := λ α β, @vector.map.{u u} α β n }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='vector.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 65, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u} {β : Type v} {n : nat}, (α → β) → vector.{u} α n → vector.{v} β n'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>283  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>284  instance : is_lawful_traversable.{u} (flip vector n) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='is_lawful_traversable'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='flip'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='vector'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category/traversable/basic.lean&#x27;, &#x27;line&#x27;: 122, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 16, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/data/vector.lean&#x27;, &#x27;line&#x27;: 14, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Π (t : Type u → Type u) [_inst_1 : traversable.{u} t], Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Π {α : Sort u} {β : Sort v} {φ : Sort w}, (α → β → φ) → β → α → φ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u → nat → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>285  { id_traverse := @vector.id_traverse n,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='control_laws_tac'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='vector.id_traverse'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/lawful.lean&#x27;, &#x27;line&#x27;: 14, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;line&#x27;: 249, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='∀ {n : nat} {α : Type u} (x : vector.{u} α n), @eq.{u+1} (@id.{u+2} (Type u) (vector.{u} α n)) (@vector.traverse.{u} n (@id.{u+2} (Type u)) (@monad.to_applicative.{u u} (@id.{u+2} (Type u)) id.monad.{u}) α α (@id.mk.{u+1} α) x) x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>286    comp_traverse := @vector.comp_traverse n,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='blue'><a title='vector.comp_traverse'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='red'><a title='{&#x27;line&#x27;: 258, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='green'><a title='∀ {n : nat} {F G : Type u → Type u} [_inst_1 : applicative.{u u} F] [_inst_2 : applicative.{u u} G] [_inst_3 : @is_lawful_applicative.{u u} F _inst_1] [_inst_4 : @is_lawful_applicative.{u u} G _inst_2] {α β γ : Type u} (f : β → F γ) (g : α → G β) (x : vector.{u} α n), @eq.{u+1} (functor.comp.{u u u} (λ {β : Type u}, G β) F (vector.{u} γ n)) (@vector.traverse.{u} n (functor.comp.{u u u} (λ {β : Type u}, G β) F) (@comp.applicative.{u u u} (λ {β : Type u}, G β) F _inst_2 _inst_1) α γ (@function.comp.{u+1 u+1 u+1} α (G (F γ)) (functor.comp.{u u u} (λ {β : Type u}, G β) F γ) (@functor.comp.mk.{u u u} (λ {β : Type u}, G β) F γ) (@function.comp.{u+1 u+1 u+1} α (G β) (G (F γ)) (@functor.map.{u u} (λ {β : Type u}, G β) (@applicative.to_functor.{u u} (λ {β : Type u}, G β) _inst_2) β (F γ) f) g)) x) (@functor.comp.mk.{u u u} (λ {β : Type u}, G β) F (vector.{u} γ n) (@functor.map.{u u} G (@applicative.to_functor.{u u} G _inst_2) (vector.{u} β n) (F (vector.{u} γ n)) (@vector.traverse.{u} n F _inst_1 β γ f) (@vector.traverse.{u} n G _inst_2 α β g x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>287    traverse_eq_map_id := @vector.traverse_eq_map_id n,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='blue'><a title='vector.traverse_eq_map_id'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='red'><a title='{&#x27;line&#x27;: 265, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='green'><a title='∀ {n : nat} {α β : Type u_1} (f : α → β) (x : vector.{u_1} α n), @eq.{u_1+1} (@id.{u_1+2} (Type u_1) (vector.{u_1} β n)) (@vector.traverse.{u_1} n (@id.{u_1+2} (Type u_1)) (@monad.to_applicative.{u_1 u_1} (@id.{u_1+2} (Type u_1)) id.monad.{u_1}) α β (@function.comp.{u_1+1 u_1+1 u_1+1} α β (@id.{u_1+2} (Type u_1) β) (@id.mk.{u_1+1} β) f) x) (@id.mk.{(max 1 (u_1+1))} (vector.{u_1} β n) (@vector.map.{u_1 u_1} α β n f x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>288    naturality := @vector.naturality n,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='vector.naturality'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;line&#x27;: 272, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='∀ {n : nat} {F G : Type u → Type u} [_inst_1 : applicative.{u u} F] [_inst_2 : applicative.{u u} G] [_inst_3 : @is_lawful_applicative.{u u} F _inst_1] [_inst_4 : @is_lawful_applicative.{u u} G _inst_2] (η : @applicative_transformation.{u u u} F _inst_1 _inst_3 G _inst_2 _inst_4) {α β : Type u} (f : α → F β) (x : vector.{u} α n), @eq.{u+1} (G (vector.{u} β n)) (@coe_fn.{u+2 u+2} (@applicative_transformation.{u u u} F _inst_1 _inst_3 G _inst_2 _inst_4) (@applicative_transformation.has_coe_to_fun.{u u u} F _inst_1 _inst_3 G _inst_2 _inst_4) η (vector.{u} β n) (@vector.traverse.{u} n F _inst_1 α β f x)) (@vector.traverse.{u} n G _inst_2 α β (@function.comp.{u+1 u+1 u+1} α (F β) (G β) (@coe_fn.{u+2 u+2} (@applicative_transformation.{u u u} F _inst_1 _inst_3 G _inst_2 _inst_4) (@applicative_transformation.has_coe_to_fun.{u u u} F _inst_1 _inst_3 G _inst_2 _inst_4) η β) f) x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>289    id_map := by intros; cases x; simp! [(&lt;$&gt;)],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@flip.{u+2 1 u+2} (Type u) nat (Type u) vector.{u} n α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='lime'><a title='n : nat
⊢ ∀ {α : Type u} (x : @flip.{u+2 1 u+2} (Type u) nat (Type u) vector.{u} n α),
    @eq.{u+1} (@flip.{u+2 1 u+2} (Type u) nat (Type u) vector.{u} n α)
      (@functor.map.{u u} (@flip.{u+2 1 u+2} (Type u) nat (Type u) vector.{u} n)
         (@traversable.to_functor.{u} (@flip.{u+2 1 u+2} (Type u) nat (Type u) vector.{u} n)
            (@vector.traversable.{u} n))
         α
         α
         (@id.{u+1} α)
         x)
      x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>290    comp_map := by intros; cases x; simp! [(&lt;$&gt;)] }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@flip.{u+2 1 u+2} (Type u) nat (Type u) vector.{u} n α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='lime'><a title='n : nat
⊢ ∀ {α β γ : Type u} (g : α → β) (h : β → γ)
  (x : @flip.{u+2 1 u+2} (Type u) nat (Type u) vector.{u} n α),
    @eq.{u+1} (@flip.{u+2 1 u+2} (Type u) nat (Type u) vector.{u} n γ)
      (@functor.map.{u u} (λ {α : Type u}, @flip.{u+2 1 u+2} (Type u) nat (Type u) vector.{u} n α)
         (@traversable.to_functor.{u} (@flip.{u+2 1 u+2} (Type u) nat (Type u) vector.{u} n)
            (@vector.traversable.{u} n))
         α
         γ
         (@function.comp.{u+1 u+1 u+1} α β γ h g)
         x)
      (@functor.map.{u u} (@flip.{u+2 1 u+2} (Type u) nat (Type u) vector.{u} n)
         (@traversable.to_functor.{u} (@flip.{u+2 1 u+2} (Type u) nat (Type u) vector.{u} n)
            (@vector.traversable.{u} n))
         β
         γ
         h
         (@functor.map.{u u} (@flip.{u+2 1 u+2} (Type u) nat (Type u) vector.{u} n)
            (@traversable.to_functor.{u} (@flip.{u+2 1 u+2} (Type u) nat (Type u) vector.{u} n)
               (@vector.traversable.{u} n))
            α
            β
            g
            x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>291  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>292  end vector</code></pre>
</body>