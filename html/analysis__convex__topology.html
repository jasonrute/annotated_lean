<head>
<meta charset="UTF-8">
<link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro&display=swap" rel="stylesheet">
</head>

<body>
<pre>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  1  /-</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  2  Copyright (c) 2020 Yury Kudryashov. All rights reserved.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  3  Released under Apache 2.0 license as described in the file LICENSE.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  4  Authors: Alexander Bentkamp, Yury Kudriashov</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  5  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  6  import analysis.convex.basic analysis.normed_space.finite_dimension</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/convex/basic.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/finite_dimension.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  7  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  8  /-!</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  9  # Topological and metric properties of convex sets</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 10  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 11  We prove the following facts:</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 12  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 13  * `convex.interior` : interior of a convex set is convex;</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 14  * `convex.closure` : closure of a convex set is convex;</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 15  * `set.finite.compact_convex_hull` : convex hull of a finite set is compact;</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 16  * `set.finite.is_closed_convex_hull` : convex hull of a finite set is closed;</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 17  * `convex_on_dist` : distance to a fixed point is convex on any convex set;</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 18  * `convex_hull_ediam`, `convex_hull_diam` : convex hull of a set has the same (e)metric diameter</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 19    as the original set;</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 20  * `bounded_convex_hull` : convex hull of a set is bounded if and only if the original set</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 21    is bounded.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 22  * `bounded_std_simplex`, `is_closed_std_simplex`, `compact_std_simplex`: topological properties</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 23    of the standard simplex;</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 24  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 25  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 26  variables {ι : Type*} {E : Type*}</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 27  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 28  open set</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 29  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 30  /-! ### Standard simplex -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 31  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 32  section std_simplex</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 33  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 34  variables [fintype ι]</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 35  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 36  /-- Every vector in `std_simplex ι` has `max`-norm at most `1`. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 37  lemma std_simplex_subset_closed_ball :</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 38    std_simplex ι ⊆ metric.closed_ball 0 1 :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='blue'><a title='metric.closed_ball'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/metric_space/basic.lean&#x27;, &#x27;line&#x27;: 252, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='green'><a title='Π {α : Type u} [_inst_1 : metric_space.{u} α], α → real → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='orange'><a title='`closed_ball x ε` is the set of all points `y` with `dist y x ≤ ε`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 39  begin</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 40    assume f hf,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 905, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (sum.{0 0} pexpr (list.{0} pexpr)) (λ (a : sum.{0 0} pexpr (list.{0} pexpr)), @sum.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(pexpr) `(list.{0} pexpr) a) (@has_orelse.orelse.{0 0} lean.parser.{0} (@alternative.to_has_orelse.{0 0} lean.parser.{0} lean.parser.alternative) (sum.{0 0} pexpr (list.{0} pexpr)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) pexpr (sum.{0 0} pexpr (list.{0} pexpr)) (@sum.inl.{0 0} pexpr (list.{0} pexpr)) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) (list.{0} pexpr) (sum.{0 0} pexpr (list.{0} pexpr)) (@sum.inr.{0 0} pexpr (list.{0} pexpr)) (interactive.parse_binders interactive.types.tac_rbp))) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Assuming the target of the goal is a Pi or a let, `assume h : t` unifies the type of the binder with `t` and introduces it with name `h`, just like `intro h`. If `h` is absent, the tactic uses the name `this`. If `t` is omitted, it will be inferred.

`assume (h₁ : t₁) ... (hₙ : tₙ)` introduces multiple hypotheses. Any of the types may be omitted, but the names must be present.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='assume'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(: expr | &lt;binders&gt;)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='lime'><a title='ι : Type u_1,
_inst_1 : fintype.{u_1} ι
⊢ @has_subset.subset.{u_1} (set.{u_1} (ι → real)) (@set.has_subset.{u_1} (ι → real))
    (@std_simplex.{u_1} ι _inst_1)
    (@metric.closed_ball.{u_1} (ι → real)
       (@metric_space_pi.{u_1 0} ι (λ (a : ι), real) _inst_1 (λ (b : ι), real.metric_space))
       (@has_zero.zero.{u_1} (ι → real)
          (@pi.has_zero.{u_1 0} ι (λ (a : ι), real)
             (λ (i : ι), @no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))))
       (@has_one.one.{0} real
          (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
_inst_1 : fintype.{u_1} ι,
f : ι → real,
hf :
  @has_mem.mem.{u_1 u_1} (ι → real) (set.{u_1} (ι → real)) (@set.has_mem.{u_1} (ι → real)) f
    (@std_simplex.{u_1} ι _inst_1)
⊢ @has_mem.mem.{u_1 u_1} (ι → real) (set.{u_1} (ι → real)) (@set.has_mem.{u_1} (ι → real)) f
    (@metric.closed_ball.{u_1} (ι → real)
       (@metric_space_pi.{u_1 0} ι (λ (a : ι), real) _inst_1 (λ (b : ι), real.metric_space))
       (@has_zero.zero.{u_1} (ι → real)
          (@pi.has_zero.{u_1 0} ι (λ (a : ι), real)
             (λ (i : ι), @no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))))
       (@has_one.one.{0} real
          (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 41    rw [metric.mem_closed_ball, dist_zero_right],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='metric.mem_closed_ball'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='dist_zero_right'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/metric_space/basic.lean&#x27;, &#x27;line&#x27;: 254, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 85, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : metric_space.{u_1} α] {x y : α} {ε : real}, iff (@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) y (@metric.closed_ball.{u_1} α _inst_1 x ε)) (@has_le.le.{0} real real.has_le (@has_dist.dist.{u_1} α (@metric_space.to_has_dist.{u_1} α _inst_1) y x) ε)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : normed_group.{u_1} α] (g : α), @eq.{1} real (@has_dist.dist.{u_1} α (@metric_space.to_has_dist.{u_1} α (@normed_group.to_metric_space.{u_1} α _inst_1)) g (@has_zero.zero.{u_1} α (@add_monoid.to_has_zero.{u_1} α (@add_group.to_add_monoid.{u_1} α (@add_comm_group.to_add_group.{u_1} α (@normed_group.to_add_comm_group.{u_1} α _inst_1)))))) (@has_norm.norm.{u_1} α (@normed_group.to_has_norm.{u_1} α _inst_1) g)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
_inst_1 : fintype.{u_1} ι,
f : ι → real,
hf :
  @has_mem.mem.{u_1 u_1} (ι → real) (set.{u_1} (ι → real)) (@set.has_mem.{u_1} (ι → real)) f
    (@std_simplex.{u_1} ι _inst_1)
⊢ @has_mem.mem.{u_1 u_1} (ι → real) (set.{u_1} (ι → real)) (@set.has_mem.{u_1} (ι → real)) f
    (@metric.closed_ball.{u_1} (ι → real)
       (@metric_space_pi.{u_1 0} ι (λ (a : ι), real) _inst_1 (λ (b : ι), real.metric_space))
       (@has_zero.zero.{u_1} (ι → real)
          (@pi.has_zero.{u_1 0} ι (λ (a : ι), real)
             (λ (i : ι), @no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))))
       (@has_one.one.{0} real
          (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
_inst_1 : fintype.{u_1} ι,
f : ι → real,
hf :
  @has_mem.mem.{u_1 u_1} (ι → real) (set.{u_1} (ι → real)) (@set.has_mem.{u_1} (ι → real)) f
    (@std_simplex.{u_1} ι _inst_1)
⊢ @has_le.le.{0} real real.has_le
    (@has_dist.dist.{u_1} (ι → real)
       (@metric_space.to_has_dist.{u_1} (ι → real)
          (@metric_space_pi.{u_1 0} ι (λ (a : ι), real) _inst_1 (λ (b : ι), real.metric_space)))
       f
       (@has_zero.zero.{u_1} (ι → real)
          (@pi.has_zero.{u_1 0} ι (λ (a : ι), real)
             (λ (i : ι), @no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))))
    (@has_one.one.{0} real (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
_inst_1 : fintype.{u_1} ι,
f : ι → real,
hf :
  @has_mem.mem.{u_1 u_1} (ι → real) (set.{u_1} (ι → real)) (@set.has_mem.{u_1} (ι → real)) f
    (@std_simplex.{u_1} ι _inst_1)
⊢ @has_le.le.{0} real real.has_le
    (@has_norm.norm.{u_1} (ι → real)
       (@normed_group.to_has_norm.{u_1} (ι → real)
          (@pi.normed_group.{u_1 0} ι (λ (a : ι), real) _inst_1
             (λ (i : ι),
                @normed_ring.to_normed_group.{0} real
                  (@normed_field.to_normed_ring.{0} real normed_field.normed_field))))
       f)
    (@has_one.one.{0} real (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 42    refine (nnreal.coe_one ▸ nnreal.coe_le.2 $ finset.sup_le $ λ x hx, _),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='nnreal.coe_one'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq.subst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='nnreal.coe_le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='finset.sup_le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/nnreal.lean&#x27;, &#x27;line&#x27;: 54, &#x27;column&#x27;: 24}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 190, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/nnreal.lean&#x27;, &#x27;line&#x27;: 114, &#x27;column&#x27;: 29}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/finset.lean&#x27;, &#x27;line&#x27;: 1775, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@eq.{1} real (@coe.{1 1} nnreal real (@coe_to_lift.{1 1} nnreal real (@coe_base.{1 1} nnreal real nnreal.has_coe)) (@has_one.one.{0} nnreal nnreal.has_one)) (@has_one.one.{0} real (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} {P : α → Prop} {a b : α}, @eq.{1} α a b → P a → P b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {r₁ r₂ : nnreal}, iff (@has_le.le.{0} real real.has_le (@coe.{1 1} nnreal real (@coe_to_lift.{1 1} nnreal real (@coe_base.{1 1} nnreal real nnreal.has_coe)) r₁) (@coe.{1 1} nnreal real (@coe_to_lift.{1 1} nnreal real (@coe_base.{1 1} nnreal real nnreal.has_coe)) r₂)) (@has_le.le.{0} nnreal nnreal.has_le r₁ r₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} {β : Type u_1} [_inst_1 : lattice.semilattice_sup_bot.{0} α] {s : finset.{u_1} β} {f : β → α} {a : α}, (∀ (b : β), @has_mem.mem.{u_1 u_1} β (finset.{u_1} β) (@finset.has_mem.{u_1} β) b s → @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@lattice.order_bot.to_partial_order.{0} α (@lattice.semilattice_sup_bot.to_order_bot.{0} α _inst_1)))) (f b) a) → @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@lattice.order_bot.to_partial_order.{0} α (@lattice.semilattice_sup_bot.to_order_bot.{0} α _inst_1)))) (@finset.sup.{0 u_1} α β _inst_1 s f) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
_inst_1 : fintype.{u_1} ι,
f : ι → real,
hf :
  @has_mem.mem.{u_1 u_1} (ι → real) (set.{u_1} (ι → real)) (@set.has_mem.{u_1} (ι → real)) f
    (@std_simplex.{u_1} ι _inst_1)
⊢ @has_le.le.{0} real real.has_le
    (@has_norm.norm.{u_1} (ι → real)
       (@normed_group.to_has_norm.{u_1} (ι → real)
          (@pi.normed_group.{u_1 0} ι (λ (a : ι), real) _inst_1
             (λ (i : ι),
                @normed_ring.to_normed_group.{0} real
                  (@normed_field.to_normed_ring.{0} real normed_field.normed_field))))
       f)
    (@has_one.one.{0} real (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
_inst_1 : fintype.{u_1} ι,
f : ι → real,
hf :
  @has_mem.mem.{u_1 u_1} (ι → real) (set.{u_1} (ι → real)) (@set.has_mem.{u_1} (ι → real)) f
    (@std_simplex.{u_1} ι _inst_1),
x : ι,
hx : @has_mem.mem.{u_1 u_1} ι (finset.{u_1} ι) (@finset.has_mem.{u_1} ι) x (@finset.univ.{u_1} ι _inst_1)
⊢ @has_le.le.{0} nnreal
    (@preorder.to_has_le.{0} nnreal
       (@partial_order.to_preorder.{0} nnreal
          (@lattice.order_bot.to_partial_order.{0} nnreal
             (@lattice.semilattice_sup_bot.to_order_bot.{0} nnreal nnreal.lattice.semilattice_sup_bot))))
    (@nnnorm.{0} ((λ (a : ι), real) x)
       ((λ (i : ι),
           @normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
          x)
       (f x))
    (@has_one.one.{0} nnreal nnreal.has_one)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 43    change abs (f x) ≤ 1,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='abs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_le.le'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/functions.lean&#x27;, &#x27;line&#x27;: 13, &#x27;column&#x27;: 11}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 319, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} [_inst_1 : decidable_linear_ordered_comm_group.{0} α], α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} [c : has_le.{0} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
_inst_1 : fintype.{u_1} ι,
f : ι → real,
hf :
  @has_mem.mem.{u_1 u_1} (ι → real) (set.{u_1} (ι → real)) (@set.has_mem.{u_1} (ι → real)) f
    (@std_simplex.{u_1} ι _inst_1),
x : ι,
hx : @has_mem.mem.{u_1 u_1} ι (finset.{u_1} ι) (@finset.has_mem.{u_1} ι) x (@finset.univ.{u_1} ι _inst_1)
⊢ @has_le.le.{0} nnreal
    (@preorder.to_has_le.{0} nnreal
       (@partial_order.to_preorder.{0} nnreal
          (@lattice.order_bot.to_partial_order.{0} nnreal
             (@lattice.semilattice_sup_bot.to_order_bot.{0} nnreal nnreal.lattice.semilattice_sup_bot))))
    (@nnnorm.{0} ((λ (a : ι), real) x)
       ((λ (i : ι),
           @normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
          x)
       (f x))
    (@has_one.one.{0} nnreal nnreal.has_one)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
_inst_1 : fintype.{u_1} ι,
f : ι → real,
hf :
  @has_mem.mem.{u_1 u_1} (ι → real) (set.{u_1} (ι → real)) (@set.has_mem.{u_1} (ι → real)) f
    (@std_simplex.{u_1} ι _inst_1),
x : ι,
hx : @has_mem.mem.{u_1 u_1} ι (finset.{u_1} ι) (@finset.has_mem.{u_1} ι) x (@finset.univ.{u_1} ι _inst_1)
⊢ @has_le.le.{0} real real.has_le (@abs.{0} real real.decidable_linear_ordered_comm_group (f x))
    (@has_one.one.{0} real (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 44    rw [abs_of_nonneg $ hf.1 x],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='abs_of_nonneg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/functions.lean&#x27;, &#x27;line&#x27;: 192, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : decidable_linear_ordered_comm_group.{0} α] {a : α}, @ge.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@ordered_comm_group.to_partial_order.{0} α (@decidable_linear_ordered_comm_group.to_ordered_comm_group.{0} α _inst_1)))) a (@has_zero.zero.{0} α (@add_monoid.to_has_zero.{0} α (@add_group.to_add_monoid.{0} α (@add_comm_group.to_add_group.{0} α (@decidable_linear_ordered_comm_group.to_add_comm_group.{0} α _inst_1))))) → @eq.{1} α (@abs.{0} α _inst_1 a) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u_1 u_1} (ι → real) (set.{u_1} (ι → real)) (@set.has_mem.{u_1} (ι → real)) f (@std_simplex.{u_1} ι _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
_inst_1 : fintype.{u_1} ι,
f : ι → real,
hf :
  @has_mem.mem.{u_1 u_1} (ι → real) (set.{u_1} (ι → real)) (@set.has_mem.{u_1} (ι → real)) f
    (@std_simplex.{u_1} ι _inst_1),
x : ι,
hx : @has_mem.mem.{u_1 u_1} ι (finset.{u_1} ι) (@finset.has_mem.{u_1} ι) x (@finset.univ.{u_1} ι _inst_1)
⊢ @has_le.le.{0} real real.has_le (@abs.{0} real real.decidable_linear_ordered_comm_group (f x))
    (@has_one.one.{0} real (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
_inst_1 : fintype.{u_1} ι,
f : ι → real,
hf :
  @has_mem.mem.{u_1 u_1} (ι → real) (set.{u_1} (ι → real)) (@set.has_mem.{u_1} (ι → real)) f
    (@std_simplex.{u_1} ι _inst_1),
x : ι,
hx : @has_mem.mem.{u_1 u_1} ι (finset.{u_1} ι) (@finset.has_mem.{u_1} ι) x (@finset.univ.{u_1} ι _inst_1)
⊢ @has_le.le.{0} real real.has_le (f x)
    (@has_one.one.{0} real (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 45    exact (mem_Icc_of_mem_std_simplex hf x).2</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='mem_Icc_of_mem_std_simplex'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/convex/basic.lean&#x27;, &#x27;line&#x27;: 887, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {ι : Type u_1} [_inst_5 : fintype.{u_1} ι] {f : ι → real}, @has_mem.mem.{u_1 u_1} (ι → real) (set.{u_1} (ι → real)) (@set.has_mem.{u_1} (ι → real)) f (@std_simplex.{u_1} ι _inst_5) → ∀ (x : ι), @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) (f x) (@set.Icc.{0} real real.preorder (@has_zero.zero.{0} real (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))) (@has_one.one.{0} real (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u_1 u_1} (ι → real) (set.{u_1} (ι → real)) (@set.has_mem.{u_1} (ι → real)) f (@std_simplex.{u_1} ι _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='All values of a function `f ∈ std_simplex ι` belong to `[0, 1]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='ι : Type u_1,
_inst_1 : fintype.{u_1} ι,
f : ι → real,
hf :
  @has_mem.mem.{u_1 u_1} (ι → real) (set.{u_1} (ι → real)) (@set.has_mem.{u_1} (ι → real)) f
    (@std_simplex.{u_1} ι _inst_1),
x : ι,
hx : @has_mem.mem.{u_1 u_1} ι (finset.{u_1} ι) (@finset.has_mem.{u_1} ι) x (@finset.univ.{u_1} ι _inst_1)
⊢ @has_le.le.{0} real real.has_le (f x)
    (@has_one.one.{0} real (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 46  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 47  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 48  variable (ι)</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 49  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 50  /-- `std_simplex ι` is bounded. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 51  lemma bounded_std_simplex : metric.bounded (std_simplex ι) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='blue'><a title='metric.bounded'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='std_simplex'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/metric_space/basic.lean&#x27;, &#x27;line&#x27;: 1268, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/convex/basic.lean&#x27;, &#x27;line&#x27;: 832, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='green'><a title='Π {α : Type u} [_inst_1 : metric_space.{u} α], set.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (ι : Type u_1) [_inst_6 : fintype.{u_1} ι], set.{u_1} (ι → real)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='orange'><a title=' Boundedness of a subset of a metric space. We formulate the definition to work
even in the empty space.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title=' Standard simplex in the space of functions `ι → ℝ` is the set
of vectors with non-negative coordinates with total sum `1`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 52  (metric.bounded_iff_subset_ball 0).2 ⟨1, std_simplex_subset_closed_ball⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='metric.bounded_iff_subset_ball'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='iff.mpr'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='std_simplex_subset_closed_ball'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/metric_space/basic.lean&#x27;, &#x27;line&#x27;: 1300, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 37, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : metric_space.{u_1} α] {s : set.{u_1} α} (c : α), iff (@metric.bounded.{u_1} α _inst_1 s) (@Exists.{1} real (λ (r : real), @has_subset.subset.{u_1} (set.{u_1} α) (@set.has_subset.{u_1} α) s (@metric.closed_ball.{u_1} α _inst_1 c r)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {a b : Prop}, iff a b → b → a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='∀ {ι : Type u_1} [_inst_1 : fintype.{u_1} ι], @has_subset.subset.{u_1} (set.{u_1} (ι → real)) (@set.has_subset.{u_1} (ι → real)) (@std_simplex.{u_1} ι _inst_1) (@metric.closed_ball.{u_1} (ι → real) (@metric_space_pi.{u_1 0} ι (λ (a : ι), real) _inst_1 (λ (b : ι), real.metric_space)) (@has_zero.zero.{u_1} (ι → real) (@pi.has_zero.{u_1 0} ι (λ (a : ι), real) (λ (i : ι), @no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))) (@has_one.one.{0} real (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Given a point, a bounded subset is included in some ball around this point'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='Every vector in `std_simplex ι` has `max`-norm at most `1`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 53  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 54  /-- `std_simplex ι` is closed. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 55  lemma is_closed_std_simplex : is_closed (std_simplex ι) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='blue'><a title='is_closed'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='std_simplex'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 126, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/convex/basic.lean&#x27;, &#x27;line&#x27;: 832, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='green'><a title='Π {α : Type u} [_inst_1 : topological_space.{u} α], set.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (ι : Type u_1) [_inst_6 : fintype.{u_1} ι], set.{u_1} (ι → real)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='orange'><a title='A set is closed if its complement is open'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title=' Standard simplex in the space of functions `ι → ℝ` is the set
of vectors with non-negative coordinates with total sum `1`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 56  (std_simplex_eq_inter ι).symm ▸ is_closed_inter</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='std_simplex_eq_inter'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq.symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq.subst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='is_closed_inter'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/convex/basic.lean&#x27;, &#x27;line&#x27;: 835, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 198, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 190, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 151, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ (ι : Type u_1) [_inst_5 : fintype.{u_1} ι], @eq.{(max (u_1+1) 1)} (set.{u_1} (ι → real)) (@std_simplex.{u_1} ι _inst_5) (@has_inter.inter.{u_1} (set.{u_1} (ι → real)) (@set.has_inter.{u_1} (ι → real)) (@set.Inter.{u_1 u_1+1} (ι → real) ι (λ (x : ι), @set_of.{u_1} (ι → real) (λ (f : ι → real), @has_le.le.{0} real real.has_le (@has_zero.zero.{0} real (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))) (f x)))) (@set_of.{u_1} (ι → real) (λ (f : ι → real), @eq.{1} real (@finset.sum.{u_1 0} ι real real.add_comm_monoid (@finset.univ.{u_1} ι _inst_5) f) (@has_one.one.{0} real (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_1} {a b : α}, @eq.{(max (u_1+1) 1)} α a b → @eq.{(max (u_1+1) 1)} α b a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u_1} {P : α → Prop} {a b : α}, @eq.{(max (u_1+1) 1)} α a b → P a → P b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_1} {s₁ s₂ : set.{u_1} α} [_inst_1 : topological_space.{u_1} α], @is_closed.{u_1} α _inst_1 s₁ → @is_closed.{u_1} α _inst_1 s₂ → @is_closed.{u_1} α _inst_1 (@has_inter.inter.{u_1} (set.{u_1} α) (@set.has_inter.{u_1} α) s₁ s₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 57    (is_closed_Inter $ λ i, is_closed_le continuous_const (continuous_apply i))</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='is_closed_Inter'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='is_closed_le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='continuous_const'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='continuous_apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 140, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/algebra/ordered.lean&#x27;, &#x27;line&#x27;: 112, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 686, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/constructions.lean&#x27;, &#x27;line&#x27;: 494, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {α ι : Type u_1} [_inst_1 : topological_space.{u_1} α] {f : ι → set.{u_1} α}, (∀ (i : ι), @is_closed.{u_1} α _inst_1 (f i)) → @is_closed.{u_1} α _inst_1 (@set.Inter.{u_1 u_1+1} α ι (λ (i : ι), f i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type} {β : Type u_1} [_inst_1 : topological_space.{0} α] [_inst_2 : preorder.{0} α] [t : @order_closed_topology.{0} α _inst_1 _inst_2] [_inst_3 : topological_space.{u_1} β] {f g : β → α}, @continuous.{u_1 0} β α _inst_3 _inst_1 f → @continuous.{u_1 0} β α _inst_3 _inst_1 g → @is_closed.{u_1} β _inst_3 (@set_of.{u_1} β (λ (b : β), @has_le.le.{0} α (@preorder.to_has_le.{0} α _inst_2) (f b) (g b)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_1} {β : Type} [_inst_1 : topological_space.{u_1} α] [_inst_2 : topological_space.{0} β] {b : β}, @continuous.{u_1 0} α β _inst_1 _inst_2 (λ (a : α), b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {ι : Type u_1} {π : ι → Type} [_inst_1 : Π (i : ι), topological_space.{0} (π i)] (i : ι), @continuous.{u_1 0} (Π (i : ι), π i) (π i) (@Pi.topological_space.{u_1 0} ι (λ (i : ι), π i) (λ (a : ι), _inst_1 a)) (_inst_1 i) (λ (p : Π (i : ι), π i), p i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 58    (is_closed_eq (continuous_finset_sum _ $ λ x _, continuous_apply x) continuous_const)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='is_closed_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='continuous_finset_sum'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='continuous_apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='continuous_const'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/separation.lean&#x27;, &#x27;line&#x27;: 247, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/algebra/monoid.lean&#x27;, &#x27;line&#x27;: 143, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/constructions.lean&#x27;, &#x27;line&#x27;: 494, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 686, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {α : Type} {β : Type u_1} [_inst_1 : topological_space.{0} α] [_inst_2 : topological_space.{u_1} β] [_inst_3 : @t2_space.{0} α _inst_1] {f g : β → α}, @continuous.{u_1 0} β α _inst_2 _inst_1 f → @continuous.{u_1 0} β α _inst_2 _inst_1 g → @is_closed.{u_1} β _inst_2 (@set_of.{u_1} β (λ (x : β), @eq.{1} α (f x) (g x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type} {β γ : Type u_1} [_inst_1 : topological_space.{0} α] [_inst_2 : add_comm_monoid.{0} α] [_inst_3 : @topological_add_monoid.{0} α _inst_1 (@add_comm_monoid.to_add_monoid.{0} α _inst_2)] [_inst_4 : topological_space.{u_1} β] {f : γ → β → α} (s : finset.{u_1} γ), (∀ (c : γ), @has_mem.mem.{u_1 u_1} γ (finset.{u_1} γ) (@finset.has_mem.{u_1} γ) c s → @continuous.{u_1 0} β α _inst_4 _inst_1 (f c)) → @continuous.{u_1 0} β α _inst_4 _inst_1 (λ (a : β), @finset.sum.{u_1 0} γ α _inst_2 s (λ (c : γ), f c a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u_1 u_1} ι (finset.{u_1} ι) (@finset.has_mem.{u_1} ι) x (@finset.univ.{u_1} ι _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {ι : Type u_1} {π : ι → Type} [_inst_1 : Π (i : ι), topological_space.{0} (π i)] (i : ι), @continuous.{u_1 0} (Π (i : ι), π i) (π i) (@Pi.topological_space.{u_1 0} ι (λ (i : ι), π i) (λ (a : ι), _inst_1 a)) (_inst_1 i) (λ (p : Π (i : ι), π i), p i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u_1} {β : Type} [_inst_1 : topological_space.{u_1} α] [_inst_2 : topological_space.{0} β] {b : β}, @continuous.{u_1 0} α β _inst_1 _inst_2 (λ (a : α), b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 59  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 60  /-- `std_simplex ι` is compact. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 61  lemma compact_std_simplex : compact (std_simplex ι) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='blue'><a title='compact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='std_simplex'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/subset_properties.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/convex/basic.lean&#x27;, &#x27;line&#x27;: 832, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='green'><a title='Π {α : Type u} [_inst_1 : topological_space.{u} α], set.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (ι : Type u_1) [_inst_6 : fintype.{u_1} ι], set.{u_1} (ι → real)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='orange'><a title='A set `s` is compact if for every filter `f` that contains `s`,
   every set of `f` also meets every neighborhood of some `a ∈ s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title=' Standard simplex in the space of functions `ι → ℝ` is the set
of vectors with non-negative coordinates with total sum `1`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 62  metric.compact_iff_closed_bounded.2 ⟨is_closed_std_simplex ι, bounded_std_simplex ι⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='metric.compact_iff_closed_bounded'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='iff.mpr'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='is_closed_std_simplex'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='bounded_std_simplex'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/metric_space/basic.lean&#x27;, &#x27;line&#x27;: 1360, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 55, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 51, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : metric_space.{u_1} α] {s : set.{u_1} α} [_inst_2 : @proper_space.{u_1} α _inst_1], iff (@compact.{u_1} α (@uniform_space.to_topological_space.{u_1} α (@metric_space.to_uniform_space&#x27;.{u_1} α _inst_1)) s) (and (@is_closed.{u_1} α (@uniform_space.to_topological_space.{u_1} α (@metric_space.to_uniform_space&#x27;.{u_1} α _inst_1)) s) (@metric.bounded.{u_1} α _inst_1 s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, iff a b → b → a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ (ι : Type u_1) [_inst_1 : fintype.{u_1} ι], @is_closed.{u_1} (ι → real) (@Pi.topological_space.{u_1 0} ι (λ (a : ι), real) (λ (a : ι), @uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))) (@std_simplex.{u_1} ι _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ (ι : Type u_1) [_inst_1 : fintype.{u_1} ι], @metric.bounded.{u_1} (ι → real) (@metric_space_pi.{u_1 0} ι (λ (a : ι), real) _inst_1 (λ (b : ι), real.metric_space)) (@std_simplex.{u_1} ι _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='In a proper space, a set is compact if and only if it is closed and bounded'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`std_simplex ι` is closed.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`std_simplex ι` is bounded.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 63  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 64  end std_simplex</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 65  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 66  /-! ### Topological vector space -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 67  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 68  section topological_vector_space</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 69  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 70  variables [add_comm_group E] [vector_space ℝ E] [topological_space E]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='add_comm_group'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='vector_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='topological_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 206, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/module.lean&#x27;, &#x27;line&#x27;: 391, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/basic.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 44, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Type u_2 → Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π (α : Type) (β : Type u_2) [_inst_1 : discrete_field.{0} α] [_inst_2 : add_comm_group.{u_2} β], Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type u_2 → Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='orange'><a title='A vector space is the same as a module, except the scalar ring is actually
 a field. (This adds commutativity of the multiplication and existence of inverses.)
 This is the traditional generalization of spaces like `ℝ^n`, which have a natural
 addition operation and a way to multiply them by real numbers, but no multiplication
 operation between vectors.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='A topology on `α`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 71    [topological_add_group E] [topological_vector_space ℝ E]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='topological_add_group'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='topological_vector_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/algebra/group.lean&#x27;, &#x27;line&#x27;: 26, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/algebra/module.lean&#x27;, &#x27;line&#x27;: 76, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/basic.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (α : Type u_2) [_inst_1 : topological_space.{u_2} α] [_inst_2 : add_group.{u_2} α], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π (R : Type) (M : Type u_2) [_inst_1 : discrete_field.{0} R] [_inst_2 : topological_space.{0} R] [_inst_3 : topological_space.{u_2} M] [_inst_4 : add_comm_group.{u_2} M] [_inst_5 : @module.{0 u_2} R M (@domain.to_ring.{0} R (@division_ring.to_domain.{0} R (@field.to_division_ring.{0} R (@discrete_field.to_field.{0} R _inst_1)))) _inst_4], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title=' A topological (additive) group is a group in which the addition and negation operations are
continuous.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='A topological vector space is a topological module over a field.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 72  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 73  local attribute [instance] set.pointwise_add set.smul_set</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='blue'><a title='set.pointwise_add'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.smul_set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/pointwise.lean&#x27;, &#x27;line&#x27;: 53, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/pointwise.lean&#x27;, &#x27;line&#x27;: 193, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : has_add.{u_1} α], has_add.{u_1} (set.{u_1} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : has_scalar.{u_1 u_2} α β], has_scalar.{u_1 u_2} α (set.{u_2} β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                             </code><font color='orange'><a title='Scaling a set: multiplying every element by a scalar.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 74  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 75  /-- In a topological vector space, the interior of a convex set is convex. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 76  lemma convex.interior {s : set E} (hs : convex s) : convex (interior s) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='convex'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='convex'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='interior'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/convex/basic.lean&#x27;, &#x27;line&#x27;: 124, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/convex/basic.lean&#x27;, &#x27;line&#x27;: 124, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 180, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {E : Type u} [_inst_1 : add_comm_group.{u} E] [_inst_2 : @vector_space.{0 u} real E real.discrete_field _inst_1], set.{u} E → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_2} E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {E : Type u} [_inst_1 : add_comm_group.{u} E] [_inst_2 : @vector_space.{0 u} real E real.discrete_field _inst_1], set.{u} E → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [_inst_1 : topological_space.{u} α], set.{u} α → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_2} E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='orange'><a title='Convexity of sets'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Convexity of sets'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The interior of a set `s` is the largest open subset of `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 77  convex_iff_pointwise_add_subset.mpr $ λ a b ha hb hab,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='convex_iff_pointwise_add_subset'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='iff.mpr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ha'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hb'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hab'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/convex/basic.lean&#x27;, &#x27;line&#x27;: 136, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {E : Type u_2} [_inst_1 : add_comm_group.{u_2} E] [_inst_2 : @vector_space.{0 u_2} real E real.discrete_field _inst_1] {s : set.{u_2} E}, iff (@convex.{u_2} E _inst_1 _inst_2 s) (∀ ⦃a b : real⦄, @has_le.le.{0} real real.has_le (@has_zero.zero.{0} real (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))) a → @has_le.le.{0} real real.has_le (@has_zero.zero.{0} real (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))) b → @eq.{1} real (@has_add.add.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring)) a b) (@has_one.one.{0} real (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))) → @has_subset.subset.{u_2} (set.{u_2} E) (@set.has_subset.{u_2} E) (@has_add.add.{u_2} (set.{u_2} E) (@set.pointwise_add.{u_2} E (@add_semigroup.to_has_add.{u_2} E (@add_monoid.to_add_semigroup.{u_2} E (@add_group.to_add_monoid.{u_2} E (@add_comm_group.to_add_group.{u_2} E _inst_1))))) (@has_scalar.smul.{0 u_2} real (set.{u_2} E) (@set.smul_set.{0 u_2} real E (@mul_action.to_has_scalar.{0 u_2} real E real.monoid (@distrib_mul_action.to_mul_action.{0 u_2} real E real.monoid (@add_group.to_add_monoid.{u_2} E (@add_comm_group.to_add_group.{u_2} E _inst_1)) (@semimodule.to_distrib_mul_action.{0 u_2} real E real.semiring (@add_comm_group.to_add_comm_monoid.{u_2} E _inst_1) (@module.to_semimodule.{0 u_2} real E real.ring _inst_1 _inst_2))))) a s) (@has_scalar.smul.{0 u_2} real (set.{u_2} E) (@set.smul_set.{0 u_2} real E (@mul_action.to_has_scalar.{0 u_2} real E real.monoid (@distrib_mul_action.to_mul_action.{0 u_2} real E real.monoid (@add_group.to_add_monoid.{u_2} E (@add_comm_group.to_add_group.{u_2} E _inst_1)) (@semimodule.to_distrib_mul_action.{0 u_2} real E real.semiring (@add_comm_group.to_add_comm_monoid.{u_2} E _inst_1) (@module.to_semimodule.{0 u_2} real E real.ring _inst_1 _inst_2))))) b s)) s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, iff a b → b → a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_le.le.{0} real real.has_le (@has_zero.zero.{0} real (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_le.le.{0} real real.has_le (@has_zero.zero.{0} real (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))) b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@eq.{1} real (@has_add.add.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring)) a b) (@has_one.one.{0} real (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Alternative definition of set convexity, in terms of pointwise set operations.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 78    have h : is_open (a • interior s + b • interior s), from</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='is_open'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_scalar.smul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='interior'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_scalar.smul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='interior'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 65, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/group_action.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 180, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/group_action.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 180, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Π {α : Type u_2} [t : topological_space.{u_2} α], set.{u_2} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} {γ : Type u_2} [c : has_scalar.{0 u_2} α γ], α → γ → γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_2} [_inst_1 : topological_space.{u_2} α], set.{u_2} α → set.{u_2} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_2} E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_2} [c : has_add.{u_2} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} {γ : Type u_2} [c : has_scalar.{0 u_2} α γ], α → γ → γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_2} [_inst_1 : topological_space.{u_2} α], set.{u_2} α → set.{u_2} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_2} E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='`is_open s` means that `s` is open in the ambient topological space on `α`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='The interior of a set `s` is the largest open subset of `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='The interior of a set `s` is the largest open subset of `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 79    or.elim (classical.em (a = 0))</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='or.elim'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='classical.em'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 202, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/classical.lean&#x27;, &#x27;line&#x27;: 69, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {a b c : Prop}, or a b → (a → c) → (b → c) → c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ (p : Prop), or p (not p)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 80    (λ heq,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='heq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 163, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@eq.{1} real a (@has_zero.zero.{0} real (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 81      have hne : b ≠ 0, by { rw [heq, zero_add] at hab, rw hab, exact one_ne_zero },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ne'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='heq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='zero_add'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='hab'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='one_ne_zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 97, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 163, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 226, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/ring.lean&#x27;, &#x27;line&#x27;: 51, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{1} real a (@has_zero.zero.{0} real (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : add_monoid.{0} α] (a : α), @eq.{1} α (@has_add.add.{0} α (@add_semigroup.to_has_add.{0} α (@add_monoid.to_add_semigroup.{0} α _inst_1)) (@has_zero.zero.{0} α (@add_monoid.to_has_zero.{0} α _inst_1)) a) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{1} real b (@has_one.one.{0} real (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [s : zero_ne_one_class.{0} α], @ne.{1} α (@has_one.one.{0} α (@zero_ne_one_class.to_has_one.{0} α s)) (@has_zero.zero.{0} α (@zero_ne_one_class.to_has_zero.{0} α s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='lime'><a title='E : Type u_2,
_inst_1 : add_comm_group.{u_2} E,
_inst_2 : @vector_space.{0 u_2} real E real.discrete_field _inst_1,
_inst_3 : topological_space.{u_2} E,
_inst_4 : @topological_add_group.{u_2} E _inst_3 (@add_comm_group.to_add_group.{u_2} E _inst_1),
_inst_5 :
  @topological_vector_space.{0 u_2} real E real.discrete_field
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    _inst_3
    _inst_1
    _inst_2,
s : set.{u_2} E,
hs : @convex.{u_2} E _inst_1 _inst_2 s,
a b : real,
ha :
  @has_le.le.{0} real real.has_le
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    a,
hb :
  @has_le.le.{0} real real.has_le
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    b,
hab :
  @eq.{1} real (@has_add.add.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring)) a b)
    (@has_one.one.{0} real
       (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))),
heq :
  @eq.{1} real a
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
⊢ @ne.{1} real b
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='E : Type u_2,
_inst_1 : add_comm_group.{u_2} E,
_inst_2 : @vector_space.{0 u_2} real E real.discrete_field _inst_1,
_inst_3 : topological_space.{u_2} E,
_inst_4 : @topological_add_group.{u_2} E _inst_3 (@add_comm_group.to_add_group.{u_2} E _inst_1),
_inst_5 :
  @topological_vector_space.{0 u_2} real E real.discrete_field
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    _inst_3
    _inst_1
    _inst_2,
s : set.{u_2} E,
hs : @convex.{u_2} E _inst_1 _inst_2 s,
a b : real,
ha :
  @has_le.le.{0} real real.has_le
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    a,
hb :
  @has_le.le.{0} real real.has_le
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    b,
heq :
  @eq.{1} real a
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
hab :
  @eq.{1} real
    (@has_add.add.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
       (@has_zero.zero.{0} real
          (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
       b)
    (@has_one.one.{0} real (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain)))
⊢ @ne.{1} real b
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='E : Type u_2,
_inst_1 : add_comm_group.{u_2} E,
_inst_2 : @vector_space.{0 u_2} real E real.discrete_field _inst_1,
_inst_3 : topological_space.{u_2} E,
_inst_4 : @topological_add_group.{u_2} E _inst_3 (@add_comm_group.to_add_group.{u_2} E _inst_1),
_inst_5 :
  @topological_vector_space.{0 u_2} real E real.discrete_field
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    _inst_3
    _inst_1
    _inst_2,
s : set.{u_2} E,
hs : @convex.{u_2} E _inst_1 _inst_2 s,
a b : real,
ha :
  @has_le.le.{0} real real.has_le
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    a,
hb :
  @has_le.le.{0} real real.has_le
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    b,
heq :
  @eq.{1} real a
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
hab :
  @eq.{1} real b
    (@has_one.one.{0} real (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain)))
⊢ @ne.{1} real b
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='E : Type u_2,
_inst_1 : add_comm_group.{u_2} E,
_inst_2 : @vector_space.{0 u_2} real E real.discrete_field _inst_1,
_inst_3 : topological_space.{u_2} E,
_inst_4 : @topological_add_group.{u_2} E _inst_3 (@add_comm_group.to_add_group.{u_2} E _inst_1),
_inst_5 :
  @topological_vector_space.{0 u_2} real E real.discrete_field
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    _inst_3
    _inst_1
    _inst_2,
s : set.{u_2} E,
hs : @convex.{u_2} E _inst_1 _inst_2 s,
a b : real,
ha :
  @has_le.le.{0} real real.has_le
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    a,
hb :
  @has_le.le.{0} real real.has_le
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    b,
hab :
  @eq.{1} real (@has_add.add.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring)) a b)
    (@has_one.one.{0} real
       (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))),
heq :
  @eq.{1} real a
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
⊢ @ne.{1} real b
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='E : Type u_2,
_inst_1 : add_comm_group.{u_2} E,
_inst_2 : @vector_space.{0 u_2} real E real.discrete_field _inst_1,
_inst_3 : topological_space.{u_2} E,
_inst_4 : @topological_add_group.{u_2} E _inst_3 (@add_comm_group.to_add_group.{u_2} E _inst_1),
_inst_5 :
  @topological_vector_space.{0 u_2} real E real.discrete_field
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    _inst_3
    _inst_1
    _inst_2,
s : set.{u_2} E,
hs : @convex.{u_2} E _inst_1 _inst_2 s,
a b : real,
ha :
  @has_le.le.{0} real real.has_le
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    a,
hb :
  @has_le.le.{0} real real.has_le
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    b,
heq :
  @eq.{1} real a
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
hab :
  @eq.{1} real b
    (@has_one.one.{0} real (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain)))
⊢ @ne.{1} real b
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='E : Type u_2,
_inst_1 : add_comm_group.{u_2} E,
_inst_2 : @vector_space.{0 u_2} real E real.discrete_field _inst_1,
_inst_3 : topological_space.{u_2} E,
_inst_4 : @topological_add_group.{u_2} E _inst_3 (@add_comm_group.to_add_group.{u_2} E _inst_1),
_inst_5 :
  @topological_vector_space.{0 u_2} real E real.discrete_field
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    _inst_3
    _inst_1
    _inst_2,
s : set.{u_2} E,
hs : @convex.{u_2} E _inst_1 _inst_2 s,
a b : real,
ha :
  @has_le.le.{0} real real.has_le
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    a,
hb :
  @has_le.le.{0} real real.has_le
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    b,
heq :
  @eq.{1} real a
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
hab :
  @eq.{1} real b
    (@has_one.one.{0} real (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain)))
⊢ @ne.{1} real
    (@has_one.one.{0} real (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain)))
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 82      (smul_set_eq_image b (interior s)).symm ▸</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='set.smul_set_eq_image'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='interior'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq.symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq.subst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/pointwise.lean&#x27;, &#x27;line&#x27;: 201, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 180, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 198, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 190, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='∀ {α : Type} {β : Type u_2} [_inst_1 : has_scalar.{0 u_2} α β] (a : α) (s : set.{u_2} β), @eq.{u_2+1} (set.{u_2} β) (@has_scalar.smul.{0 u_2} α (set.{u_2} β) (@set.smul_set.{0 u_2} α β _inst_1) a s) (@set.image.{u_2 u_2} β β (λ (x : β), @has_scalar.smul.{0 u_2} α β _inst_1 a x) s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_2} [_inst_1 : topological_space.{u_2} α], set.{u_2} α → set.{u_2} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_2} E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u_2} {a b : α}, @eq.{u_2+1} α a b → @eq.{u_2+1} α b a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u_2} {P : α → Prop} {a b : α}, @eq.{u_2+1} α a b → P a → P b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='orange'><a title='The interior of a set `s` is the largest open subset of `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 83      (is_open_pointwise_add_left ((is_open_map_smul_of_ne_zero hne _) is_open_interior)))</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='is_open_pointwise_add_left'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='is_open_map_smul_of_ne_zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hne'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='is_open_interior'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/algebra/group.lean&#x27;, &#x27;line&#x27;: 358, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/algebra/module.lean&#x27;, &#x27;line&#x27;: 123, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 186, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='∀ {α : Type u_2} [_inst_1 : topological_space.{u_2} α] [_inst_2 : add_group.{u_2} α] [_inst_3 : @topological_add_group.{u_2} α _inst_1 _inst_2] {s t : set.{u_2} α}, @is_open.{u_2} α _inst_1 t → @is_open.{u_2} α _inst_1 (@has_add.add.{u_2} (set.{u_2} α) (@set.pointwise_add.{u_2} α (@add_semigroup.to_has_add.{u_2} α (@add_monoid.to_add_semigroup.{u_2} α (@add_group.to_add_monoid.{u_2} α _inst_2)))) s t)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {R : Type} {M : Type u_2} {a : R} [_inst_1 : discrete_field.{0} R] [_inst_2 : topological_space.{0} R] [_inst_3 : topological_space.{u_2} M] [_inst_4 : add_comm_group.{u_2} M] [_inst_5 : @vector_space.{0 u_2} R M _inst_1 _inst_4] [_inst_6 : @topological_vector_space.{0 u_2} R M _inst_1 _inst_2 _inst_3 _inst_4 _inst_5], @ne.{1} R a (@has_zero.zero.{0} R (@no_zero_divisors.to_has_zero.{0} R (@domain.to_no_zero_divisors.{0} R (@division_ring.to_domain.{0} R (@field.to_division_ring.{0} R (@discrete_field.to_field.{0} R _inst_1)))))) → @is_open_map.{u_2 u_2} M M _inst_3 _inst_3 (λ (x : M), @has_scalar.smul.{0 u_2} R M (@mul_action.to_has_scalar.{0 u_2} R M (@ring.to_monoid.{0} R (@domain.to_ring.{0} R (@division_ring.to_domain.{0} R (@field.to_division_ring.{0} R (@discrete_field.to_field.{0} R _inst_1))))) (@distrib_mul_action.to_mul_action.{0 u_2} R M (@ring.to_monoid.{0} R (@domain.to_ring.{0} R (@division_ring.to_domain.{0} R (@field.to_division_ring.{0} R (@discrete_field.to_field.{0} R _inst_1))))) (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_4)) (@semimodule.to_distrib_mul_action.{0 u_2} R M (@ring.to_semiring.{0} R (@domain.to_ring.{0} R (@division_ring.to_domain.{0} R (@field.to_division_ring.{0} R (@discrete_field.to_field.{0} R _inst_1))))) (@add_comm_group.to_add_comm_monoid.{u_2} M _inst_4) (@module.to_semimodule.{0 u_2} R M (@domain.to_ring.{0} R (@division_ring.to_domain.{0} R (@field.to_division_ring.{0} R (@discrete_field.to_field.{0} R _inst_1)))) _inst_4 _inst_5)))) a x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@ne.{1} real b (@has_zero.zero.{0} real (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Type u_2} [_inst_1 : topological_space.{u_2} α] {s : set.{u_2} α}, @is_open.{u_2} α _inst_1 (@interior.{u_2} α _inst_1 s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 84    (λ hne,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='hne'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='not (@eq.{1} real a (@has_zero.zero.{0} real (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 85      (smul_set_eq_image a (interior s)).symm ▸</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='set.smul_set_eq_image'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='interior'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq.symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq.subst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/pointwise.lean&#x27;, &#x27;line&#x27;: 201, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 180, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 198, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 190, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='∀ {α : Type} {β : Type u_2} [_inst_1 : has_scalar.{0 u_2} α β] (a : α) (s : set.{u_2} β), @eq.{u_2+1} (set.{u_2} β) (@has_scalar.smul.{0 u_2} α (set.{u_2} β) (@set.smul_set.{0 u_2} α β _inst_1) a s) (@set.image.{u_2 u_2} β β (λ (x : β), @has_scalar.smul.{0 u_2} α β _inst_1 a x) s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_2} [_inst_1 : topological_space.{u_2} α], set.{u_2} α → set.{u_2} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_2} E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u_2} {a b : α}, @eq.{u_2+1} α a b → @eq.{u_2+1} α b a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u_2} {P : α → Prop} {a b : α}, @eq.{u_2+1} α a b → P a → P b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='orange'><a title='The interior of a set `s` is the largest open subset of `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 86      (is_open_pointwise_add_right ((is_open_map_smul_of_ne_zero hne _) is_open_interior))),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='is_open_pointwise_add_right'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='is_open_map_smul_of_ne_zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hne'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='is_open_interior'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/algebra/group.lean&#x27;, &#x27;line&#x27;: 367, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/algebra/module.lean&#x27;, &#x27;line&#x27;: 123, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 186, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='∀ {α : Type u_2} [_inst_1 : topological_space.{u_2} α] [_inst_2 : add_group.{u_2} α] [_inst_3 : @topological_add_group.{u_2} α _inst_1 _inst_2] {s t : set.{u_2} α}, @is_open.{u_2} α _inst_1 s → @is_open.{u_2} α _inst_1 (@has_add.add.{u_2} (set.{u_2} α) (@set.pointwise_add.{u_2} α (@add_semigroup.to_has_add.{u_2} α (@add_monoid.to_add_semigroup.{u_2} α (@add_group.to_add_monoid.{u_2} α _inst_2)))) s t)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {R : Type} {M : Type u_2} {a : R} [_inst_1 : discrete_field.{0} R] [_inst_2 : topological_space.{0} R] [_inst_3 : topological_space.{u_2} M] [_inst_4 : add_comm_group.{u_2} M] [_inst_5 : @vector_space.{0 u_2} R M _inst_1 _inst_4] [_inst_6 : @topological_vector_space.{0 u_2} R M _inst_1 _inst_2 _inst_3 _inst_4 _inst_5], @ne.{1} R a (@has_zero.zero.{0} R (@no_zero_divisors.to_has_zero.{0} R (@domain.to_no_zero_divisors.{0} R (@division_ring.to_domain.{0} R (@field.to_division_ring.{0} R (@discrete_field.to_field.{0} R _inst_1)))))) → @is_open_map.{u_2 u_2} M M _inst_3 _inst_3 (λ (x : M), @has_scalar.smul.{0 u_2} R M (@mul_action.to_has_scalar.{0 u_2} R M (@ring.to_monoid.{0} R (@domain.to_ring.{0} R (@division_ring.to_domain.{0} R (@field.to_division_ring.{0} R (@discrete_field.to_field.{0} R _inst_1))))) (@distrib_mul_action.to_mul_action.{0 u_2} R M (@ring.to_monoid.{0} R (@domain.to_ring.{0} R (@division_ring.to_domain.{0} R (@field.to_division_ring.{0} R (@discrete_field.to_field.{0} R _inst_1))))) (@add_group.to_add_monoid.{u_2} M (@add_comm_group.to_add_group.{u_2} M _inst_4)) (@semimodule.to_distrib_mul_action.{0 u_2} R M (@ring.to_semiring.{0} R (@domain.to_ring.{0} R (@division_ring.to_domain.{0} R (@field.to_division_ring.{0} R (@discrete_field.to_field.{0} R _inst_1))))) (@add_comm_group.to_add_comm_monoid.{u_2} M _inst_4) (@module.to_semimodule.{0 u_2} R M (@domain.to_ring.{0} R (@division_ring.to_domain.{0} R (@field.to_division_ring.{0} R (@discrete_field.to_field.{0} R _inst_1)))) _inst_4 _inst_5)))) a x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='not (@eq.{1} real a (@has_zero.zero.{0} real (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Type u_2} [_inst_1 : topological_space.{u_2} α] {s : set.{u_2} α}, @is_open.{u_2} α _inst_1 (@interior.{u_2} α _inst_1 s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 87    (subset_interior_iff_subset_of_open h).mpr $ subset.trans</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='subset_interior_iff_subset_of_open'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='iff.mpr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='set.subset.trans'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 204, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 94, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {α : Type u_2} [_inst_1 : topological_space.{u_2} α] {s t : set.{u_2} α}, @is_open.{u_2} α _inst_1 s → iff (@has_subset.subset.{u_2} (set.{u_2} α) (@set.has_subset.{u_2} α) s (@interior.{u_2} α _inst_1 t)) (@has_subset.subset.{u_2} (set.{u_2} α) (@set.has_subset.{u_2} α) s t)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@is_open.{u_2} E _inst_3 (@has_add.add.{u_2} (set.{u_2} E) (@set.pointwise_add.{u_2} E (@add_semigroup.to_has_add.{u_2} E (@add_monoid.to_add_semigroup.{u_2} E (@add_group.to_add_monoid.{u_2} E (@add_comm_group.to_add_group.{u_2} E _inst_1))))) (@has_scalar.smul.{0 u_2} real (set.{u_2} E) (@set.smul_set.{0 u_2} real E (@mul_action.to_has_scalar.{0 u_2} real E real.monoid (@distrib_mul_action.to_mul_action.{0 u_2} real E real.monoid (@add_group.to_add_monoid.{u_2} E (@add_comm_group.to_add_group.{u_2} E _inst_1)) (@semimodule.to_distrib_mul_action.{0 u_2} real E real.semiring (@add_comm_group.to_add_comm_monoid.{u_2} E _inst_1) (@module.to_semimodule.{0 u_2} real E real.ring _inst_1 _inst_2))))) a (@interior.{u_2} E _inst_3 s)) (@has_scalar.smul.{0 u_2} real (set.{u_2} E) (@set.smul_set.{0 u_2} real E (@mul_action.to_has_scalar.{0 u_2} real E real.monoid (@distrib_mul_action.to_mul_action.{0 u_2} real E real.monoid (@add_group.to_add_monoid.{u_2} E (@add_comm_group.to_add_group.{u_2} E _inst_1)) (@semimodule.to_distrib_mul_action.{0 u_2} real E real.semiring (@add_comm_group.to_add_comm_monoid.{u_2} E _inst_1) (@module.to_semimodule.{0 u_2} real E real.ring _inst_1 _inst_2))))) b (@interior.{u_2} E _inst_3 s)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {a b : Prop}, iff a b → b → a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Type u_2} {a b c : set.{u_2} α}, @has_subset.subset.{u_2} (set.{u_2} α) (@set.has_subset.{u_2} α) a b → @has_subset.subset.{u_2} (set.{u_2} α) (@set.has_subset.{u_2} α) b c → @has_subset.subset.{u_2} (set.{u_2} α) (@set.has_subset.{u_2} α) a c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 88      begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='lime'><a title='E : Type u_2,
_inst_1 : add_comm_group.{u_2} E,
_inst_2 : @vector_space.{0 u_2} real E real.discrete_field _inst_1,
_inst_3 : topological_space.{u_2} E,
_inst_4 : @topological_add_group.{u_2} E _inst_3 (@add_comm_group.to_add_group.{u_2} E _inst_1),
_inst_5 :
  @topological_vector_space.{0 u_2} real E real.discrete_field
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    _inst_3
    _inst_1
    _inst_2,
s : set.{u_2} E,
hs : @convex.{u_2} E _inst_1 _inst_2 s,
a b : real,
ha :
  @has_le.le.{0} real real.has_le
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    a,
hb :
  @has_le.le.{0} real real.has_le
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    b,
hab :
  @eq.{1} real (@has_add.add.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring)) a b)
    (@has_one.one.{0} real
       (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))),
h :
  @is_open.{u_2} E _inst_3
    (@has_add.add.{u_2} (set.{u_2} E)
       (@set.pointwise_add.{u_2} E
          (@add_semigroup.to_has_add.{u_2} E
             (@add_monoid.to_add_semigroup.{u_2} E
                (@add_group.to_add_monoid.{u_2} E (@add_comm_group.to_add_group.{u_2} E _inst_1)))))
       (@has_scalar.smul.{0 u_2} real (set.{u_2} E)
          (@set.smul_set.{0 u_2} real E
             (@mul_action.to_has_scalar.{0 u_2} real E real.monoid
                (@distrib_mul_action.to_mul_action.{0 u_2} real E real.monoid
                   (@add_group.to_add_monoid.{u_2} E (@add_comm_group.to_add_group.{u_2} E _inst_1))
                   (@semimodule.to_distrib_mul_action.{0 u_2} real E real.semiring
                      (@add_comm_group.to_add_comm_monoid.{u_2} E _inst_1)
                      (@module.to_semimodule.{0 u_2} real E real.ring _inst_1 _inst_2)))))
          a
          (@interior.{u_2} E _inst_3 s))
       (@has_scalar.smul.{0 u_2} real (set.{u_2} E)
          (@set.smul_set.{0 u_2} real E
             (@mul_action.to_has_scalar.{0 u_2} real E real.monoid
                (@distrib_mul_action.to_mul_action.{0 u_2} real E real.monoid
                   (@add_group.to_add_monoid.{u_2} E (@add_comm_group.to_add_group.{u_2} E _inst_1))
                   (@semimodule.to_distrib_mul_action.{0 u_2} real E real.semiring
                      (@add_comm_group.to_add_comm_monoid.{u_2} E _inst_1)
                      (@module.to_semimodule.{0 u_2} real E real.ring _inst_1 _inst_2)))))
          b
          (@interior.{u_2} E _inst_3 s)))
⊢ @has_subset.subset.{u_2} (set.{u_2} E) (@set.has_subset.{u_2} E)
    (@has_add.add.{u_2} (set.{u_2} E)
       (@set.pointwise_add.{u_2} E
          (@add_semigroup.to_has_add.{u_2} E
             (@add_monoid.to_add_semigroup.{u_2} E
                (@add_group.to_add_monoid.{u_2} E (@add_comm_group.to_add_group.{u_2} E _inst_1)))))
       (@has_scalar.smul.{0 u_2} real (set.{u_2} E)
          (@set.smul_set.{0 u_2} real E
             (@mul_action.to_has_scalar.{0 u_2} real E real.monoid
                (@distrib_mul_action.to_mul_action.{0 u_2} real E real.monoid
                   (@add_group.to_add_monoid.{u_2} E (@add_comm_group.to_add_group.{u_2} E _inst_1))
                   (@semimodule.to_distrib_mul_action.{0 u_2} real E real.semiring
                      (@add_comm_group.to_add_comm_monoid.{u_2} E _inst_1)
                      (@module.to_semimodule.{0 u_2} real E real.ring _inst_1 _inst_2)))))
          a
          (@interior.{u_2} E _inst_3 s))
       (@has_scalar.smul.{0 u_2} real (set.{u_2} E)
          (@set.smul_set.{0 u_2} real E
             (@mul_action.to_has_scalar.{0 u_2} real E real.monoid
                (@distrib_mul_action.to_mul_action.{0 u_2} real E real.monoid
                   (@add_group.to_add_monoid.{u_2} E (@add_comm_group.to_add_group.{u_2} E _inst_1))
                   (@semimodule.to_distrib_mul_action.{0 u_2} real E real.semiring
                      (@add_comm_group.to_add_comm_monoid.{u_2} E _inst_1)
                      (@module.to_semimodule.{0 u_2} real E real.ring _inst_1 _inst_2)))))
          b
          (@interior.{u_2} E _inst_3 s)))
    (@has_add.add.{u_2} (set.{u_2} E)
       (@set.pointwise_add.{u_2} E
          (@add_semigroup.to_has_add.{u_2} E
             (@add_monoid.to_add_semigroup.{u_2} E
                (@add_group.to_add_monoid.{u_2} E (@add_comm_group.to_add_group.{u_2} E _inst_1)))))
       (@has_scalar.smul.{0 u_2} real (set.{u_2} E)
          (@set.smul_set.{0 u_2} real E
             (@mul_action.to_has_scalar.{0 u_2} real E real.monoid
                (@distrib_mul_action.to_mul_action.{0 u_2} real E real.monoid
                   (@add_group.to_add_monoid.{u_2} E (@add_comm_group.to_add_group.{u_2} E _inst_1))
                   (@semimodule.to_distrib_mul_action.{0 u_2} real E real.semiring
                      (@add_comm_group.to_add_comm_monoid.{u_2} E _inst_1)
                      (@module.to_semimodule.{0 u_2} real E real.ring _inst_1 _inst_2)))))
          a
          s)
       (@has_scalar.smul.{0 u_2} real (set.{u_2} E)
          (@set.smul_set.{0 u_2} real E
             (@mul_action.to_has_scalar.{0 u_2} real E real.monoid
                (@distrib_mul_action.to_mul_action.{0 u_2} real E real.monoid
                   (@add_group.to_add_monoid.{u_2} E (@add_comm_group.to_add_group.{u_2} E _inst_1))
                   (@semimodule.to_distrib_mul_action.{0 u_2} real E real.semiring
                      (@add_comm_group.to_add_comm_monoid.{u_2} E _inst_1)
                      (@module.to_semimodule.{0 u_2} real E real.ring _inst_1 _inst_2)))))
          b
          s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 89        apply pointwise_add_subset_add;</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='set.pointwise_add_subset_add'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/pointwise.lean&#x27;, &#x27;line&#x27;: 126, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_2} [_inst_1 : has_add.{u_2} α] {s₁ s₂ t₁ t₂ : set.{u_2} α}, @has_subset.subset.{u_2} (set.{u_2} α) (@set.has_subset.{u_2} α) s₁ t₁ → @has_subset.subset.{u_2} (set.{u_2} α) (@set.has_subset.{u_2} α) s₂ t₂ → @has_subset.subset.{u_2} (set.{u_2} α) (@set.has_subset.{u_2} α) (@has_add.add.{u_2} (set.{u_2} α) (@set.pointwise_add.{u_2} α _inst_1) s₁ s₂) (@has_add.add.{u_2} (set.{u_2} α) (@set.pointwise_add.{u_2} α _inst_1) t₁ t₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='E : Type u_2,
_inst_1 : add_comm_group.{u_2} E,
_inst_2 : @vector_space.{0 u_2} real E real.discrete_field _inst_1,
_inst_3 : topological_space.{u_2} E,
_inst_4 : @topological_add_group.{u_2} E _inst_3 (@add_comm_group.to_add_group.{u_2} E _inst_1),
_inst_5 :
  @topological_vector_space.{0 u_2} real E real.discrete_field
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    _inst_3
    _inst_1
    _inst_2,
s : set.{u_2} E,
hs : @convex.{u_2} E _inst_1 _inst_2 s,
a b : real,
ha :
  @has_le.le.{0} real real.has_le
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    a,
hb :
  @has_le.le.{0} real real.has_le
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    b,
hab :
  @eq.{1} real (@has_add.add.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring)) a b)
    (@has_one.one.{0} real
       (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))),
h :
  @is_open.{u_2} E _inst_3
    (@has_add.add.{u_2} (set.{u_2} E)
       (@set.pointwise_add.{u_2} E
          (@add_semigroup.to_has_add.{u_2} E
             (@add_monoid.to_add_semigroup.{u_2} E
                (@add_group.to_add_monoid.{u_2} E (@add_comm_group.to_add_group.{u_2} E _inst_1)))))
       (@has_scalar.smul.{0 u_2} real (set.{u_2} E)
          (@set.smul_set.{0 u_2} real E
             (@mul_action.to_has_scalar.{0 u_2} real E real.monoid
                (@distrib_mul_action.to_mul_action.{0 u_2} real E real.monoid
                   (@add_group.to_add_monoid.{u_2} E (@add_comm_group.to_add_group.{u_2} E _inst_1))
                   (@semimodule.to_distrib_mul_action.{0 u_2} real E real.semiring
                      (@add_comm_group.to_add_comm_monoid.{u_2} E _inst_1)
                      (@module.to_semimodule.{0 u_2} real E real.ring _inst_1 _inst_2)))))
          a
          (@interior.{u_2} E _inst_3 s))
       (@has_scalar.smul.{0 u_2} real (set.{u_2} E)
          (@set.smul_set.{0 u_2} real E
             (@mul_action.to_has_scalar.{0 u_2} real E real.monoid
                (@distrib_mul_action.to_mul_action.{0 u_2} real E real.monoid
                   (@add_group.to_add_monoid.{u_2} E (@add_comm_group.to_add_group.{u_2} E _inst_1))
                   (@semimodule.to_distrib_mul_action.{0 u_2} real E real.semiring
                      (@add_comm_group.to_add_comm_monoid.{u_2} E _inst_1)
                      (@module.to_semimodule.{0 u_2} real E real.ring _inst_1 _inst_2)))))
          b
          (@interior.{u_2} E _inst_3 s)))
⊢ @has_subset.subset.{u_2} (set.{u_2} E) (@set.has_subset.{u_2} E)
    (@has_add.add.{u_2} (set.{u_2} E)
       (@set.pointwise_add.{u_2} E
          (@add_semigroup.to_has_add.{u_2} E
             (@add_monoid.to_add_semigroup.{u_2} E
                (@add_group.to_add_monoid.{u_2} E (@add_comm_group.to_add_group.{u_2} E _inst_1)))))
       (@has_scalar.smul.{0 u_2} real (set.{u_2} E)
          (@set.smul_set.{0 u_2} real E
             (@mul_action.to_has_scalar.{0 u_2} real E real.monoid
                (@distrib_mul_action.to_mul_action.{0 u_2} real E real.monoid
                   (@add_group.to_add_monoid.{u_2} E (@add_comm_group.to_add_group.{u_2} E _inst_1))
                   (@semimodule.to_distrib_mul_action.{0 u_2} real E real.semiring
                      (@add_comm_group.to_add_comm_monoid.{u_2} E _inst_1)
                      (@module.to_semimodule.{0 u_2} real E real.ring _inst_1 _inst_2)))))
          a
          (@interior.{u_2} E _inst_3 s))
       (@has_scalar.smul.{0 u_2} real (set.{u_2} E)
          (@set.smul_set.{0 u_2} real E
             (@mul_action.to_has_scalar.{0 u_2} real E real.monoid
                (@distrib_mul_action.to_mul_action.{0 u_2} real E real.monoid
                   (@add_group.to_add_monoid.{u_2} E (@add_comm_group.to_add_group.{u_2} E _inst_1))
                   (@semimodule.to_distrib_mul_action.{0 u_2} real E real.semiring
                      (@add_comm_group.to_add_comm_monoid.{u_2} E _inst_1)
                      (@module.to_semimodule.{0 u_2} real E real.ring _inst_1 _inst_2)))))
          b
          (@interior.{u_2} E _inst_3 s)))
    (@has_add.add.{u_2} (set.{u_2} E)
       (@set.pointwise_add.{u_2} E
          (@add_semigroup.to_has_add.{u_2} E
             (@add_monoid.to_add_semigroup.{u_2} E
                (@add_group.to_add_monoid.{u_2} E (@add_comm_group.to_add_group.{u_2} E _inst_1)))))
       (@has_scalar.smul.{0 u_2} real (set.{u_2} E)
          (@set.smul_set.{0 u_2} real E
             (@mul_action.to_has_scalar.{0 u_2} real E real.monoid
                (@distrib_mul_action.to_mul_action.{0 u_2} real E real.monoid
                   (@add_group.to_add_monoid.{u_2} E (@add_comm_group.to_add_group.{u_2} E _inst_1))
                   (@semimodule.to_distrib_mul_action.{0 u_2} real E real.semiring
                      (@add_comm_group.to_add_comm_monoid.{u_2} E _inst_1)
                      (@module.to_semimodule.{0 u_2} real E real.ring _inst_1 _inst_2)))))
          a
          s)
       (@has_scalar.smul.{0 u_2} real (set.{u_2} E)
          (@set.smul_set.{0 u_2} real E
             (@mul_action.to_has_scalar.{0 u_2} real E real.monoid
                (@distrib_mul_action.to_mul_action.{0 u_2} real E real.monoid
                   (@add_group.to_add_monoid.{u_2} E (@add_comm_group.to_add_group.{u_2} E _inst_1))
                   (@semimodule.to_distrib_mul_action.{0 u_2} real E real.semiring
                      (@add_comm_group.to_add_comm_monoid.{u_2} E _inst_1)
                      (@module.to_semimodule.{0 u_2} real E real.ring _inst_1 _inst_2)))))
          b
          s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 90        rw [smul_set_eq_image, smul_set_eq_image];</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='set.smul_set_eq_image'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.smul_set_eq_image'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/pointwise.lean&#x27;, &#x27;line&#x27;: 201, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/pointwise.lean&#x27;, &#x27;line&#x27;: 201, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} {β : Type u_2} [_inst_1 : has_scalar.{0 u_2} α β] (a : α) (s : set.{u_2} β), @eq.{u_2+1} (set.{u_2} β) (@has_scalar.smul.{0 u_2} α (set.{u_2} β) (@set.smul_set.{0 u_2} α β _inst_1) a s) (@set.image.{u_2 u_2} β β (λ (x : β), @has_scalar.smul.{0 u_2} α β _inst_1 a x) s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} {β : Type u_2} [_inst_1 : has_scalar.{0 u_2} α β] (a : α) (s : set.{u_2} β), @eq.{u_2+1} (set.{u_2} β) (@has_scalar.smul.{0 u_2} α (set.{u_2} β) (@set.smul_set.{0 u_2} α β _inst_1) a s) (@set.image.{u_2 u_2} β β (λ (x : β), @has_scalar.smul.{0 u_2} α β _inst_1 a x) s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='E : Type u_2,
_inst_1 : add_comm_group.{u_2} E,
_inst_2 : @vector_space.{0 u_2} real E real.discrete_field _inst_1,
_inst_3 : topological_space.{u_2} E,
_inst_4 : @topological_add_group.{u_2} E _inst_3 (@add_comm_group.to_add_group.{u_2} E _inst_1),
_inst_5 :
  @topological_vector_space.{0 u_2} real E real.discrete_field
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    _inst_3
    _inst_1
    _inst_2,
s : set.{u_2} E,
hs : @convex.{u_2} E _inst_1 _inst_2 s,
a b : real,
ha :
  @has_le.le.{0} real real.has_le
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    a,
hb :
  @has_le.le.{0} real real.has_le
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    b,
hab :
  @eq.{1} real (@has_add.add.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring)) a b)
    (@has_one.one.{0} real
       (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))),
h :
  @is_open.{u_2} E _inst_3
    (@has_add.add.{u_2} (set.{u_2} E)
       (@set.pointwise_add.{u_2} E
          (@add_semigroup.to_has_add.{u_2} E
             (@add_monoid.to_add_semigroup.{u_2} E
                (@add_group.to_add_monoid.{u_2} E (@add_comm_group.to_add_group.{u_2} E _inst_1)))))
       (@has_scalar.smul.{0 u_2} real (set.{u_2} E)
          (@set.smul_set.{0 u_2} real E
             (@mul_action.to_has_scalar.{0 u_2} real E real.monoid
                (@distrib_mul_action.to_mul_action.{0 u_2} real E real.monoid
                   (@add_group.to_add_monoid.{u_2} E (@add_comm_group.to_add_group.{u_2} E _inst_1))
                   (@semimodule.to_distrib_mul_action.{0 u_2} real E real.semiring
                      (@add_comm_group.to_add_comm_monoid.{u_2} E _inst_1)
                      (@module.to_semimodule.{0 u_2} real E real.ring _inst_1 _inst_2)))))
          a
          (@interior.{u_2} E _inst_3 s))
       (@has_scalar.smul.{0 u_2} real (set.{u_2} E)
          (@set.smul_set.{0 u_2} real E
             (@mul_action.to_has_scalar.{0 u_2} real E real.monoid
                (@distrib_mul_action.to_mul_action.{0 u_2} real E real.monoid
                   (@add_group.to_add_monoid.{u_2} E (@add_comm_group.to_add_group.{u_2} E _inst_1))
                   (@semimodule.to_distrib_mul_action.{0 u_2} real E real.semiring
                      (@add_comm_group.to_add_comm_monoid.{u_2} E _inst_1)
                      (@module.to_semimodule.{0 u_2} real E real.ring _inst_1 _inst_2)))))
          b
          (@interior.{u_2} E _inst_3 s)))
⊢ @has_subset.subset.{u_2} (set.{u_2} E) (@set.has_subset.{u_2} E)
    (@has_add.add.{u_2} (set.{u_2} E)
       (@set.pointwise_add.{u_2} E
          (@add_semigroup.to_has_add.{u_2} E
             (@add_monoid.to_add_semigroup.{u_2} E
                (@add_group.to_add_monoid.{u_2} E (@add_comm_group.to_add_group.{u_2} E _inst_1)))))
       (@has_scalar.smul.{0 u_2} real (set.{u_2} E)
          (@set.smul_set.{0 u_2} real E
             (@mul_action.to_has_scalar.{0 u_2} real E real.monoid
                (@distrib_mul_action.to_mul_action.{0 u_2} real E real.monoid
                   (@add_group.to_add_monoid.{u_2} E (@add_comm_group.to_add_group.{u_2} E _inst_1))
                   (@semimodule.to_distrib_mul_action.{0 u_2} real E real.semiring
                      (@add_comm_group.to_add_comm_monoid.{u_2} E _inst_1)
                      (@module.to_semimodule.{0 u_2} real E real.ring _inst_1 _inst_2)))))
          a
          (@interior.{u_2} E _inst_3 s))
       (@has_scalar.smul.{0 u_2} real (set.{u_2} E)
          (@set.smul_set.{0 u_2} real E
             (@mul_action.to_has_scalar.{0 u_2} real E real.monoid
                (@distrib_mul_action.to_mul_action.{0 u_2} real E real.monoid
                   (@add_group.to_add_monoid.{u_2} E (@add_comm_group.to_add_group.{u_2} E _inst_1))
                   (@semimodule.to_distrib_mul_action.{0 u_2} real E real.semiring
                      (@add_comm_group.to_add_comm_monoid.{u_2} E _inst_1)
                      (@module.to_semimodule.{0 u_2} real E real.ring _inst_1 _inst_2)))))
          b
          (@interior.{u_2} E _inst_3 s)))
    (@has_add.add.{u_2} (set.{u_2} E)
       (@set.pointwise_add.{u_2} E
          (@add_semigroup.to_has_add.{u_2} E
             (@add_monoid.to_add_semigroup.{u_2} E
                (@add_group.to_add_monoid.{u_2} E (@add_comm_group.to_add_group.{u_2} E _inst_1)))))
       (@has_scalar.smul.{0 u_2} real (set.{u_2} E)
          (@set.smul_set.{0 u_2} real E
             (@mul_action.to_has_scalar.{0 u_2} real E real.monoid
                (@distrib_mul_action.to_mul_action.{0 u_2} real E real.monoid
                   (@add_group.to_add_monoid.{u_2} E (@add_comm_group.to_add_group.{u_2} E _inst_1))
                   (@semimodule.to_distrib_mul_action.{0 u_2} real E real.semiring
                      (@add_comm_group.to_add_comm_monoid.{u_2} E _inst_1)
                      (@module.to_semimodule.{0 u_2} real E real.ring _inst_1 _inst_2)))))
          a
          s)
       (@has_scalar.smul.{0 u_2} real (set.{u_2} E)
          (@set.smul_set.{0 u_2} real E
             (@mul_action.to_has_scalar.{0 u_2} real E real.monoid
                (@distrib_mul_action.to_mul_action.{0 u_2} real E real.monoid
                   (@add_group.to_add_monoid.{u_2} E (@add_comm_group.to_add_group.{u_2} E _inst_1))
                   (@semimodule.to_distrib_mul_action.{0 u_2} real E real.semiring
                      (@add_comm_group.to_add_comm_monoid.{u_2} E _inst_1)
                      (@module.to_semimodule.{0 u_2} real E real.ring _inst_1 _inst_2)))))
          b
          s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='E : Type u_2,
_inst_1 : add_comm_group.{u_2} E,
_inst_2 : @vector_space.{0 u_2} real E real.discrete_field _inst_1,
_inst_3 : topological_space.{u_2} E,
_inst_4 : @topological_add_group.{u_2} E _inst_3 (@add_comm_group.to_add_group.{u_2} E _inst_1),
_inst_5 :
  @topological_vector_space.{0 u_2} real E real.discrete_field
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    _inst_3
    _inst_1
    _inst_2,
s : set.{u_2} E,
hs : @convex.{u_2} E _inst_1 _inst_2 s,
a b : real,
ha :
  @has_le.le.{0} real real.has_le
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    a,
hb :
  @has_le.le.{0} real real.has_le
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    b,
hab :
  @eq.{1} real (@has_add.add.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring)) a b)
    (@has_one.one.{0} real
       (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))),
h :
  @is_open.{u_2} E _inst_3
    (@has_add.add.{u_2} (set.{u_2} E)
       (@set.pointwise_add.{u_2} E
          (@add_semigroup.to_has_add.{u_2} E
             (@add_monoid.to_add_semigroup.{u_2} E
                (@add_group.to_add_monoid.{u_2} E (@add_comm_group.to_add_group.{u_2} E _inst_1)))))
       (@has_scalar.smul.{0 u_2} real (set.{u_2} E)
          (@set.smul_set.{0 u_2} real E
             (@mul_action.to_has_scalar.{0 u_2} real E real.monoid
                (@distrib_mul_action.to_mul_action.{0 u_2} real E real.monoid
                   (@add_group.to_add_monoid.{u_2} E (@add_comm_group.to_add_group.{u_2} E _inst_1))
                   (@semimodule.to_distrib_mul_action.{0 u_2} real E real.semiring
                      (@add_comm_group.to_add_comm_monoid.{u_2} E _inst_1)
                      (@module.to_semimodule.{0 u_2} real E real.ring _inst_1 _inst_2)))))
          a
          (@interior.{u_2} E _inst_3 s))
       (@has_scalar.smul.{0 u_2} real (set.{u_2} E)
          (@set.smul_set.{0 u_2} real E
             (@mul_action.to_has_scalar.{0 u_2} real E real.monoid
                (@distrib_mul_action.to_mul_action.{0 u_2} real E real.monoid
                   (@add_group.to_add_monoid.{u_2} E (@add_comm_group.to_add_group.{u_2} E _inst_1))
                   (@semimodule.to_distrib_mul_action.{0 u_2} real E real.semiring
                      (@add_comm_group.to_add_comm_monoid.{u_2} E _inst_1)
                      (@module.to_semimodule.{0 u_2} real E real.ring _inst_1 _inst_2)))))
          b
          (@interior.{u_2} E _inst_3 s)))
⊢ @has_subset.subset.{u_2} (set.{u_2} E) (@set.has_subset.{u_2} E)
    (@has_scalar.smul.{0 u_2} real (set.{u_2} E)
       (@set.smul_set.{0 u_2} real E
          (@mul_action.to_has_scalar.{0 u_2} real E real.monoid
             (@distrib_mul_action.to_mul_action.{0 u_2} real E real.monoid
                (@add_group.to_add_monoid.{u_2} E (@add_comm_group.to_add_group.{u_2} E _inst_1))
                (@semimodule.to_distrib_mul_action.{0 u_2} real E real.semiring
                   (@add_comm_group.to_add_comm_monoid.{u_2} E _inst_1)
                   (@module.to_semimodule.{0 u_2} real E real.ring _inst_1 _inst_2)))))
       a
       (@interior.{u_2} E _inst_3 s))
    (@has_scalar.smul.{0 u_2} real (set.{u_2} E)
       (@set.smul_set.{0 u_2} real E
          (@mul_action.to_has_scalar.{0 u_2} real E real.monoid
             (@distrib_mul_action.to_mul_action.{0 u_2} real E real.monoid
                (@add_group.to_add_monoid.{u_2} E (@add_comm_group.to_add_group.{u_2} E _inst_1))
                (@semimodule.to_distrib_mul_action.{0 u_2} real E real.semiring
                   (@add_comm_group.to_add_comm_monoid.{u_2} E _inst_1)
                   (@module.to_semimodule.{0 u_2} real E real.ring _inst_1 _inst_2)))))
       a
       s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='E : Type u_2,
_inst_1 : add_comm_group.{u_2} E,
_inst_2 : @vector_space.{0 u_2} real E real.discrete_field _inst_1,
_inst_3 : topological_space.{u_2} E,
_inst_4 : @topological_add_group.{u_2} E _inst_3 (@add_comm_group.to_add_group.{u_2} E _inst_1),
_inst_5 :
  @topological_vector_space.{0 u_2} real E real.discrete_field
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    _inst_3
    _inst_1
    _inst_2,
s : set.{u_2} E,
hs : @convex.{u_2} E _inst_1 _inst_2 s,
a b : real,
ha :
  @has_le.le.{0} real real.has_le
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    a,
hb :
  @has_le.le.{0} real real.has_le
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    b,
hab :
  @eq.{1} real (@has_add.add.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring)) a b)
    (@has_one.one.{0} real
       (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))),
h :
  @is_open.{u_2} E _inst_3
    (@has_add.add.{u_2} (set.{u_2} E)
       (@set.pointwise_add.{u_2} E
          (@add_semigroup.to_has_add.{u_2} E
             (@add_monoid.to_add_semigroup.{u_2} E
                (@add_group.to_add_monoid.{u_2} E (@add_comm_group.to_add_group.{u_2} E _inst_1)))))
       (@has_scalar.smul.{0 u_2} real (set.{u_2} E)
          (@set.smul_set.{0 u_2} real E
             (@mul_action.to_has_scalar.{0 u_2} real E real.monoid
                (@distrib_mul_action.to_mul_action.{0 u_2} real E real.monoid
                   (@add_group.to_add_monoid.{u_2} E (@add_comm_group.to_add_group.{u_2} E _inst_1))
                   (@semimodule.to_distrib_mul_action.{0 u_2} real E real.semiring
                      (@add_comm_group.to_add_comm_monoid.{u_2} E _inst_1)
                      (@module.to_semimodule.{0 u_2} real E real.ring _inst_1 _inst_2)))))
          a
          (@interior.{u_2} E _inst_3 s))
       (@has_scalar.smul.{0 u_2} real (set.{u_2} E)
          (@set.smul_set.{0 u_2} real E
             (@mul_action.to_has_scalar.{0 u_2} real E real.monoid
                (@distrib_mul_action.to_mul_action.{0 u_2} real E real.monoid
                   (@add_group.to_add_monoid.{u_2} E (@add_comm_group.to_add_group.{u_2} E _inst_1))
                   (@semimodule.to_distrib_mul_action.{0 u_2} real E real.semiring
                      (@add_comm_group.to_add_comm_monoid.{u_2} E _inst_1)
                      (@module.to_semimodule.{0 u_2} real E real.ring _inst_1 _inst_2)))))
          b
          (@interior.{u_2} E _inst_3 s)))
⊢ @has_subset.subset.{u_2} (set.{u_2} E) (@set.has_subset.{u_2} E)
    (@set.image.{u_2 u_2} E E
       (λ (x : E),
          @has_scalar.smul.{0 u_2} real E
            (@mul_action.to_has_scalar.{0 u_2} real E real.monoid
               (@distrib_mul_action.to_mul_action.{0 u_2} real E real.monoid
                  (@add_group.to_add_monoid.{u_2} E (@add_comm_group.to_add_group.{u_2} E _inst_1))
                  (@semimodule.to_distrib_mul_action.{0 u_2} real E real.semiring
                     (@add_comm_group.to_add_comm_monoid.{u_2} E _inst_1)
                     (@module.to_semimodule.{0 u_2} real E real.ring _inst_1 _inst_2))))
            a
            x)
       (@interior.{u_2} E _inst_3 s))
    (@has_scalar.smul.{0 u_2} real (set.{u_2} E)
       (@set.smul_set.{0 u_2} real E
          (@mul_action.to_has_scalar.{0 u_2} real E real.monoid
             (@distrib_mul_action.to_mul_action.{0 u_2} real E real.monoid
                (@add_group.to_add_monoid.{u_2} E (@add_comm_group.to_add_group.{u_2} E _inst_1))
                (@semimodule.to_distrib_mul_action.{0 u_2} real E real.semiring
                   (@add_comm_group.to_add_comm_monoid.{u_2} E _inst_1)
                   (@module.to_semimodule.{0 u_2} real E real.ring _inst_1 _inst_2)))))
       a
       s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='E : Type u_2,
_inst_1 : add_comm_group.{u_2} E,
_inst_2 : @vector_space.{0 u_2} real E real.discrete_field _inst_1,
_inst_3 : topological_space.{u_2} E,
_inst_4 : @topological_add_group.{u_2} E _inst_3 (@add_comm_group.to_add_group.{u_2} E _inst_1),
_inst_5 :
  @topological_vector_space.{0 u_2} real E real.discrete_field
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    _inst_3
    _inst_1
    _inst_2,
s : set.{u_2} E,
hs : @convex.{u_2} E _inst_1 _inst_2 s,
a b : real,
ha :
  @has_le.le.{0} real real.has_le
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    a,
hb :
  @has_le.le.{0} real real.has_le
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    b,
hab :
  @eq.{1} real (@has_add.add.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring)) a b)
    (@has_one.one.{0} real
       (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))),
h :
  @is_open.{u_2} E _inst_3
    (@has_add.add.{u_2} (set.{u_2} E)
       (@set.pointwise_add.{u_2} E
          (@add_semigroup.to_has_add.{u_2} E
             (@add_monoid.to_add_semigroup.{u_2} E
                (@add_group.to_add_monoid.{u_2} E (@add_comm_group.to_add_group.{u_2} E _inst_1)))))
       (@has_scalar.smul.{0 u_2} real (set.{u_2} E)
          (@set.smul_set.{0 u_2} real E
             (@mul_action.to_has_scalar.{0 u_2} real E real.monoid
                (@distrib_mul_action.to_mul_action.{0 u_2} real E real.monoid
                   (@add_group.to_add_monoid.{u_2} E (@add_comm_group.to_add_group.{u_2} E _inst_1))
                   (@semimodule.to_distrib_mul_action.{0 u_2} real E real.semiring
                      (@add_comm_group.to_add_comm_monoid.{u_2} E _inst_1)
                      (@module.to_semimodule.{0 u_2} real E real.ring _inst_1 _inst_2)))))
          a
          (@interior.{u_2} E _inst_3 s))
       (@has_scalar.smul.{0 u_2} real (set.{u_2} E)
          (@set.smul_set.{0 u_2} real E
             (@mul_action.to_has_scalar.{0 u_2} real E real.monoid
                (@distrib_mul_action.to_mul_action.{0 u_2} real E real.monoid
                   (@add_group.to_add_monoid.{u_2} E (@add_comm_group.to_add_group.{u_2} E _inst_1))
                   (@semimodule.to_distrib_mul_action.{0 u_2} real E real.semiring
                      (@add_comm_group.to_add_comm_monoid.{u_2} E _inst_1)
                      (@module.to_semimodule.{0 u_2} real E real.ring _inst_1 _inst_2)))))
          b
          (@interior.{u_2} E _inst_3 s)))
⊢ @has_subset.subset.{u_2} (set.{u_2} E) (@set.has_subset.{u_2} E)
    (@set.image.{u_2 u_2} E E
       (λ (x : E),
          @has_scalar.smul.{0 u_2} real E
            (@mul_action.to_has_scalar.{0 u_2} real E real.monoid
               (@distrib_mul_action.to_mul_action.{0 u_2} real E real.monoid
                  (@add_group.to_add_monoid.{u_2} E (@add_comm_group.to_add_group.{u_2} E _inst_1))
                  (@semimodule.to_distrib_mul_action.{0 u_2} real E real.semiring
                     (@add_comm_group.to_add_comm_monoid.{u_2} E _inst_1)
                     (@module.to_semimodule.{0 u_2} real E real.ring _inst_1 _inst_2))))
            a
            x)
       (@interior.{u_2} E _inst_3 s))
    (@set.image.{u_2 u_2} E E
       (λ (x : E),
          @has_scalar.smul.{0 u_2} real E
            (@mul_action.to_has_scalar.{0 u_2} real E real.monoid
               (@distrib_mul_action.to_mul_action.{0 u_2} real E real.monoid
                  (@add_group.to_add_monoid.{u_2} E (@add_comm_group.to_add_group.{u_2} E _inst_1))
                  (@semimodule.to_distrib_mul_action.{0 u_2} real E real.semiring
                     (@add_comm_group.to_add_comm_monoid.{u_2} E _inst_1)
                     (@module.to_semimodule.{0 u_2} real E real.ring _inst_1 _inst_2))))
            a
            x)
       s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='E : Type u_2,
_inst_1 : add_comm_group.{u_2} E,
_inst_2 : @vector_space.{0 u_2} real E real.discrete_field _inst_1,
_inst_3 : topological_space.{u_2} E,
_inst_4 : @topological_add_group.{u_2} E _inst_3 (@add_comm_group.to_add_group.{u_2} E _inst_1),
_inst_5 :
  @topological_vector_space.{0 u_2} real E real.discrete_field
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    _inst_3
    _inst_1
    _inst_2,
s : set.{u_2} E,
hs : @convex.{u_2} E _inst_1 _inst_2 s,
a b : real,
ha :
  @has_le.le.{0} real real.has_le
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    a,
hb :
  @has_le.le.{0} real real.has_le
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    b,
hab :
  @eq.{1} real (@has_add.add.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring)) a b)
    (@has_one.one.{0} real
       (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))),
h :
  @is_open.{u_2} E _inst_3
    (@has_add.add.{u_2} (set.{u_2} E)
       (@set.pointwise_add.{u_2} E
          (@add_semigroup.to_has_add.{u_2} E
             (@add_monoid.to_add_semigroup.{u_2} E
                (@add_group.to_add_monoid.{u_2} E (@add_comm_group.to_add_group.{u_2} E _inst_1)))))
       (@has_scalar.smul.{0 u_2} real (set.{u_2} E)
          (@set.smul_set.{0 u_2} real E
             (@mul_action.to_has_scalar.{0 u_2} real E real.monoid
                (@distrib_mul_action.to_mul_action.{0 u_2} real E real.monoid
                   (@add_group.to_add_monoid.{u_2} E (@add_comm_group.to_add_group.{u_2} E _inst_1))
                   (@semimodule.to_distrib_mul_action.{0 u_2} real E real.semiring
                      (@add_comm_group.to_add_comm_monoid.{u_2} E _inst_1)
                      (@module.to_semimodule.{0 u_2} real E real.ring _inst_1 _inst_2)))))
          a
          (@interior.{u_2} E _inst_3 s))
       (@has_scalar.smul.{0 u_2} real (set.{u_2} E)
          (@set.smul_set.{0 u_2} real E
             (@mul_action.to_has_scalar.{0 u_2} real E real.monoid
                (@distrib_mul_action.to_mul_action.{0 u_2} real E real.monoid
                   (@add_group.to_add_monoid.{u_2} E (@add_comm_group.to_add_group.{u_2} E _inst_1))
                   (@semimodule.to_distrib_mul_action.{0 u_2} real E real.semiring
                      (@add_comm_group.to_add_comm_monoid.{u_2} E _inst_1)
                      (@module.to_semimodule.{0 u_2} real E real.ring _inst_1 _inst_2)))))
          b
          (@interior.{u_2} E _inst_3 s)))
⊢ @has_subset.subset.{u_2} (set.{u_2} E) (@set.has_subset.{u_2} E)
    (@has_add.add.{u_2} (set.{u_2} E)
       (@set.pointwise_add.{u_2} E
          (@add_semigroup.to_has_add.{u_2} E
             (@add_monoid.to_add_semigroup.{u_2} E
                (@add_group.to_add_monoid.{u_2} E (@add_comm_group.to_add_group.{u_2} E _inst_1)))))
       (@has_scalar.smul.{0 u_2} real (set.{u_2} E)
          (@set.smul_set.{0 u_2} real E
             (@mul_action.to_has_scalar.{0 u_2} real E real.monoid
                (@distrib_mul_action.to_mul_action.{0 u_2} real E real.monoid
                   (@add_group.to_add_monoid.{u_2} E (@add_comm_group.to_add_group.{u_2} E _inst_1))
                   (@semimodule.to_distrib_mul_action.{0 u_2} real E real.semiring
                      (@add_comm_group.to_add_comm_monoid.{u_2} E _inst_1)
                      (@module.to_semimodule.{0 u_2} real E real.ring _inst_1 _inst_2)))))
          a
          (@interior.{u_2} E _inst_3 s))
       (@has_scalar.smul.{0 u_2} real (set.{u_2} E)
          (@set.smul_set.{0 u_2} real E
             (@mul_action.to_has_scalar.{0 u_2} real E real.monoid
                (@distrib_mul_action.to_mul_action.{0 u_2} real E real.monoid
                   (@add_group.to_add_monoid.{u_2} E (@add_comm_group.to_add_group.{u_2} E _inst_1))
                   (@semimodule.to_distrib_mul_action.{0 u_2} real E real.semiring
                      (@add_comm_group.to_add_comm_monoid.{u_2} E _inst_1)
                      (@module.to_semimodule.{0 u_2} real E real.ring _inst_1 _inst_2)))))
          b
          (@interior.{u_2} E _inst_3 s)))
    (@has_add.add.{u_2} (set.{u_2} E)
       (@set.pointwise_add.{u_2} E
          (@add_semigroup.to_has_add.{u_2} E
             (@add_monoid.to_add_semigroup.{u_2} E
                (@add_group.to_add_monoid.{u_2} E (@add_comm_group.to_add_group.{u_2} E _inst_1)))))
       (@has_scalar.smul.{0 u_2} real (set.{u_2} E)
          (@set.smul_set.{0 u_2} real E
             (@mul_action.to_has_scalar.{0 u_2} real E real.monoid
                (@distrib_mul_action.to_mul_action.{0 u_2} real E real.monoid
                   (@add_group.to_add_monoid.{u_2} E (@add_comm_group.to_add_group.{u_2} E _inst_1))
                   (@semimodule.to_distrib_mul_action.{0 u_2} real E real.semiring
                      (@add_comm_group.to_add_comm_monoid.{u_2} E _inst_1)
                      (@module.to_semimodule.{0 u_2} real E real.ring _inst_1 _inst_2)))))
          a
          s)
       (@has_scalar.smul.{0 u_2} real (set.{u_2} E)
          (@set.smul_set.{0 u_2} real E
             (@mul_action.to_has_scalar.{0 u_2} real E real.monoid
                (@distrib_mul_action.to_mul_action.{0 u_2} real E real.monoid
                   (@add_group.to_add_monoid.{u_2} E (@add_comm_group.to_add_group.{u_2} E _inst_1))
                   (@semimodule.to_distrib_mul_action.{0 u_2} real E real.semiring
                      (@add_comm_group.to_add_comm_monoid.{u_2} E _inst_1)
                      (@module.to_semimodule.{0 u_2} real E real.ring _inst_1 _inst_2)))))
          b
          s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 91        exact image_subset _ interior_subset</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='set.image_subset'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='interior_subset'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 958, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 189, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u_2} {a b : set.{u_2} α} (f : α → β), @has_subset.subset.{u_2} (set.{u_2} α) (@set.has_subset.{u_2} α) a b → @has_subset.subset.{u_2} (set.{u_2} β) (@set.has_subset.{u_2} β) (@set.image.{u_2 u_2} α β f a) (@set.image.{u_2 u_2} α β f b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_2} [_inst_1 : topological_space.{u_2} α] {s : set.{u_2} α}, @has_subset.subset.{u_2} (set.{u_2} α) (@set.has_subset.{u_2} α) (@interior.{u_2} α _inst_1 s) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='E : Type u_2,
_inst_1 : add_comm_group.{u_2} E,
_inst_2 : @vector_space.{0 u_2} real E real.discrete_field _inst_1,
_inst_3 : topological_space.{u_2} E,
_inst_4 : @topological_add_group.{u_2} E _inst_3 (@add_comm_group.to_add_group.{u_2} E _inst_1),
_inst_5 :
  @topological_vector_space.{0 u_2} real E real.discrete_field
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    _inst_3
    _inst_1
    _inst_2,
s : set.{u_2} E,
hs : @convex.{u_2} E _inst_1 _inst_2 s,
a b : real,
ha :
  @has_le.le.{0} real real.has_le
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    a,
hb :
  @has_le.le.{0} real real.has_le
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    b,
hab :
  @eq.{1} real (@has_add.add.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring)) a b)
    (@has_one.one.{0} real
       (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))),
h :
  @is_open.{u_2} E _inst_3
    (@has_add.add.{u_2} (set.{u_2} E)
       (@set.pointwise_add.{u_2} E
          (@add_semigroup.to_has_add.{u_2} E
             (@add_monoid.to_add_semigroup.{u_2} E
                (@add_group.to_add_monoid.{u_2} E (@add_comm_group.to_add_group.{u_2} E _inst_1)))))
       (@has_scalar.smul.{0 u_2} real (set.{u_2} E)
          (@set.smul_set.{0 u_2} real E
             (@mul_action.to_has_scalar.{0 u_2} real E real.monoid
                (@distrib_mul_action.to_mul_action.{0 u_2} real E real.monoid
                   (@add_group.to_add_monoid.{u_2} E (@add_comm_group.to_add_group.{u_2} E _inst_1))
                   (@semimodule.to_distrib_mul_action.{0 u_2} real E real.semiring
                      (@add_comm_group.to_add_comm_monoid.{u_2} E _inst_1)
                      (@module.to_semimodule.{0 u_2} real E real.ring _inst_1 _inst_2)))))
          a
          (@interior.{u_2} E _inst_3 s))
       (@has_scalar.smul.{0 u_2} real (set.{u_2} E)
          (@set.smul_set.{0 u_2} real E
             (@mul_action.to_has_scalar.{0 u_2} real E real.monoid
                (@distrib_mul_action.to_mul_action.{0 u_2} real E real.monoid
                   (@add_group.to_add_monoid.{u_2} E (@add_comm_group.to_add_group.{u_2} E _inst_1))
                   (@semimodule.to_distrib_mul_action.{0 u_2} real E real.semiring
                      (@add_comm_group.to_add_comm_monoid.{u_2} E _inst_1)
                      (@module.to_semimodule.{0 u_2} real E real.ring _inst_1 _inst_2)))))
          b
          (@interior.{u_2} E _inst_3 s)))
⊢ @has_subset.subset.{u_2} (set.{u_2} E) (@set.has_subset.{u_2} E)
    (@has_add.add.{u_2} (set.{u_2} E)
       (@set.pointwise_add.{u_2} E
          (@add_semigroup.to_has_add.{u_2} E
             (@add_monoid.to_add_semigroup.{u_2} E
                (@add_group.to_add_monoid.{u_2} E (@add_comm_group.to_add_group.{u_2} E _inst_1)))))
       (@has_scalar.smul.{0 u_2} real (set.{u_2} E)
          (@set.smul_set.{0 u_2} real E
             (@mul_action.to_has_scalar.{0 u_2} real E real.monoid
                (@distrib_mul_action.to_mul_action.{0 u_2} real E real.monoid
                   (@add_group.to_add_monoid.{u_2} E (@add_comm_group.to_add_group.{u_2} E _inst_1))
                   (@semimodule.to_distrib_mul_action.{0 u_2} real E real.semiring
                      (@add_comm_group.to_add_comm_monoid.{u_2} E _inst_1)
                      (@module.to_semimodule.{0 u_2} real E real.ring _inst_1 _inst_2)))))
          a
          (@interior.{u_2} E _inst_3 s))
       (@has_scalar.smul.{0 u_2} real (set.{u_2} E)
          (@set.smul_set.{0 u_2} real E
             (@mul_action.to_has_scalar.{0 u_2} real E real.monoid
                (@distrib_mul_action.to_mul_action.{0 u_2} real E real.monoid
                   (@add_group.to_add_monoid.{u_2} E (@add_comm_group.to_add_group.{u_2} E _inst_1))
                   (@semimodule.to_distrib_mul_action.{0 u_2} real E real.semiring
                      (@add_comm_group.to_add_comm_monoid.{u_2} E _inst_1)
                      (@module.to_semimodule.{0 u_2} real E real.ring _inst_1 _inst_2)))))
          b
          (@interior.{u_2} E _inst_3 s)))
    (@has_add.add.{u_2} (set.{u_2} E)
       (@set.pointwise_add.{u_2} E
          (@add_semigroup.to_has_add.{u_2} E
             (@add_monoid.to_add_semigroup.{u_2} E
                (@add_group.to_add_monoid.{u_2} E (@add_comm_group.to_add_group.{u_2} E _inst_1)))))
       (@has_scalar.smul.{0 u_2} real (set.{u_2} E)
          (@set.smul_set.{0 u_2} real E
             (@mul_action.to_has_scalar.{0 u_2} real E real.monoid
                (@distrib_mul_action.to_mul_action.{0 u_2} real E real.monoid
                   (@add_group.to_add_monoid.{u_2} E (@add_comm_group.to_add_group.{u_2} E _inst_1))
                   (@semimodule.to_distrib_mul_action.{0 u_2} real E real.semiring
                      (@add_comm_group.to_add_comm_monoid.{u_2} E _inst_1)
                      (@module.to_semimodule.{0 u_2} real E real.ring _inst_1 _inst_2)))))
          a
          s)
       (@has_scalar.smul.{0 u_2} real (set.{u_2} E)
          (@set.smul_set.{0 u_2} real E
             (@mul_action.to_has_scalar.{0 u_2} real E real.monoid
                (@distrib_mul_action.to_mul_action.{0 u_2} real E real.monoid
                   (@add_group.to_add_monoid.{u_2} E (@add_comm_group.to_add_group.{u_2} E _inst_1))
                   (@semimodule.to_distrib_mul_action.{0 u_2} real E real.semiring
                      (@add_comm_group.to_add_comm_monoid.{u_2} E _inst_1)
                      (@module.to_semimodule.{0 u_2} real E real.ring _inst_1 _inst_2)))))
          b
          s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 92      end</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='E : Type u_2,
_inst_1 : add_comm_group.{u_2} E,
_inst_2 : @vector_space.{0 u_2} real E real.discrete_field _inst_1,
_inst_3 : topological_space.{u_2} E,
_inst_4 : @topological_add_group.{u_2} E _inst_3 (@add_comm_group.to_add_group.{u_2} E _inst_1),
_inst_5 :
  @topological_vector_space.{0 u_2} real E real.discrete_field
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    _inst_3
    _inst_1
    _inst_2,
s : set.{u_2} E,
hs : @convex.{u_2} E _inst_1 _inst_2 s,
a b : real,
ha :
  @has_le.le.{0} real real.has_le
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    a,
hb :
  @has_le.le.{0} real real.has_le
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    b,
hab :
  @eq.{1} real (@has_add.add.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring)) a b)
    (@has_one.one.{0} real
       (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))),
h :
  @is_open.{u_2} E _inst_3
    (@has_add.add.{u_2} (set.{u_2} E)
       (@set.pointwise_add.{u_2} E
          (@add_semigroup.to_has_add.{u_2} E
             (@add_monoid.to_add_semigroup.{u_2} E
                (@add_group.to_add_monoid.{u_2} E (@add_comm_group.to_add_group.{u_2} E _inst_1)))))
       (@has_scalar.smul.{0 u_2} real (set.{u_2} E)
          (@set.smul_set.{0 u_2} real E
             (@mul_action.to_has_scalar.{0 u_2} real E real.monoid
                (@distrib_mul_action.to_mul_action.{0 u_2} real E real.monoid
                   (@add_group.to_add_monoid.{u_2} E (@add_comm_group.to_add_group.{u_2} E _inst_1))
                   (@semimodule.to_distrib_mul_action.{0 u_2} real E real.semiring
                      (@add_comm_group.to_add_comm_monoid.{u_2} E _inst_1)
                      (@module.to_semimodule.{0 u_2} real E real.ring _inst_1 _inst_2)))))
          a
          (@interior.{u_2} E _inst_3 s))
       (@has_scalar.smul.{0 u_2} real (set.{u_2} E)
          (@set.smul_set.{0 u_2} real E
             (@mul_action.to_has_scalar.{0 u_2} real E real.monoid
                (@distrib_mul_action.to_mul_action.{0 u_2} real E real.monoid
                   (@add_group.to_add_monoid.{u_2} E (@add_comm_group.to_add_group.{u_2} E _inst_1))
                   (@semimodule.to_distrib_mul_action.{0 u_2} real E real.semiring
                      (@add_comm_group.to_add_comm_monoid.{u_2} E _inst_1)
                      (@module.to_semimodule.{0 u_2} real E real.ring _inst_1 _inst_2)))))
          b
          (@interior.{u_2} E _inst_3 s)))
⊢ @has_subset.subset.{u_2} (set.{u_2} E) (@set.has_subset.{u_2} E)
    (@has_add.add.{u_2} (set.{u_2} E)
       (@set.pointwise_add.{u_2} E
          (@add_semigroup.to_has_add.{u_2} E
             (@add_monoid.to_add_semigroup.{u_2} E
                (@add_group.to_add_monoid.{u_2} E (@add_comm_group.to_add_group.{u_2} E _inst_1)))))
       (@has_scalar.smul.{0 u_2} real (set.{u_2} E)
          (@set.smul_set.{0 u_2} real E
             (@mul_action.to_has_scalar.{0 u_2} real E real.monoid
                (@distrib_mul_action.to_mul_action.{0 u_2} real E real.monoid
                   (@add_group.to_add_monoid.{u_2} E (@add_comm_group.to_add_group.{u_2} E _inst_1))
                   (@semimodule.to_distrib_mul_action.{0 u_2} real E real.semiring
                      (@add_comm_group.to_add_comm_monoid.{u_2} E _inst_1)
                      (@module.to_semimodule.{0 u_2} real E real.ring _inst_1 _inst_2)))))
          a
          (@interior.{u_2} E _inst_3 s))
       (@has_scalar.smul.{0 u_2} real (set.{u_2} E)
          (@set.smul_set.{0 u_2} real E
             (@mul_action.to_has_scalar.{0 u_2} real E real.monoid
                (@distrib_mul_action.to_mul_action.{0 u_2} real E real.monoid
                   (@add_group.to_add_monoid.{u_2} E (@add_comm_group.to_add_group.{u_2} E _inst_1))
                   (@semimodule.to_distrib_mul_action.{0 u_2} real E real.semiring
                      (@add_comm_group.to_add_comm_monoid.{u_2} E _inst_1)
                      (@module.to_semimodule.{0 u_2} real E real.ring _inst_1 _inst_2)))))
          b
          (@interior.{u_2} E _inst_3 s)))
    (@has_add.add.{u_2} (set.{u_2} E)
       (@set.pointwise_add.{u_2} E
          (@add_semigroup.to_has_add.{u_2} E
             (@add_monoid.to_add_semigroup.{u_2} E
                (@add_group.to_add_monoid.{u_2} E (@add_comm_group.to_add_group.{u_2} E _inst_1)))))
       (@has_scalar.smul.{0 u_2} real (set.{u_2} E)
          (@set.smul_set.{0 u_2} real E
             (@mul_action.to_has_scalar.{0 u_2} real E real.monoid
                (@distrib_mul_action.to_mul_action.{0 u_2} real E real.monoid
                   (@add_group.to_add_monoid.{u_2} E (@add_comm_group.to_add_group.{u_2} E _inst_1))
                   (@semimodule.to_distrib_mul_action.{0 u_2} real E real.semiring
                      (@add_comm_group.to_add_comm_monoid.{u_2} E _inst_1)
                      (@module.to_semimodule.{0 u_2} real E real.ring _inst_1 _inst_2)))))
          a
          s)
       (@has_scalar.smul.{0 u_2} real (set.{u_2} E)
          (@set.smul_set.{0 u_2} real E
             (@mul_action.to_has_scalar.{0 u_2} real E real.monoid
                (@distrib_mul_action.to_mul_action.{0 u_2} real E real.monoid
                   (@add_group.to_add_monoid.{u_2} E (@add_comm_group.to_add_group.{u_2} E _inst_1))
                   (@semimodule.to_distrib_mul_action.{0 u_2} real E real.semiring
                      (@add_comm_group.to_add_comm_monoid.{u_2} E _inst_1)
                      (@module.to_semimodule.{0 u_2} real E real.ring _inst_1 _inst_2)))))
          b
          s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 93      (convex_iff_pointwise_add_subset.mp hs ha hb hab)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='convex_iff_pointwise_add_subset'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='iff.mp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ha'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hb'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hab'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/convex/basic.lean&#x27;, &#x27;line&#x27;: 136, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='∀ {E : Type u_2} [_inst_1 : add_comm_group.{u_2} E] [_inst_2 : @vector_space.{0 u_2} real E real.discrete_field _inst_1] {s : set.{u_2} E}, iff (@convex.{u_2} E _inst_1 _inst_2 s) (∀ ⦃a b : real⦄, @has_le.le.{0} real real.has_le (@has_zero.zero.{0} real (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))) a → @has_le.le.{0} real real.has_le (@has_zero.zero.{0} real (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))) b → @eq.{1} real (@has_add.add.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring)) a b) (@has_one.one.{0} real (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))) → @has_subset.subset.{u_2} (set.{u_2} E) (@set.has_subset.{u_2} E) (@has_add.add.{u_2} (set.{u_2} E) (@set.pointwise_add.{u_2} E (@add_semigroup.to_has_add.{u_2} E (@add_monoid.to_add_semigroup.{u_2} E (@add_group.to_add_monoid.{u_2} E (@add_comm_group.to_add_group.{u_2} E _inst_1))))) (@has_scalar.smul.{0 u_2} real (set.{u_2} E) (@set.smul_set.{0 u_2} real E (@mul_action.to_has_scalar.{0 u_2} real E real.monoid (@distrib_mul_action.to_mul_action.{0 u_2} real E real.monoid (@add_group.to_add_monoid.{u_2} E (@add_comm_group.to_add_group.{u_2} E _inst_1)) (@semimodule.to_distrib_mul_action.{0 u_2} real E real.semiring (@add_comm_group.to_add_comm_monoid.{u_2} E _inst_1) (@module.to_semimodule.{0 u_2} real E real.ring _inst_1 _inst_2))))) a s) (@has_scalar.smul.{0 u_2} real (set.{u_2} E) (@set.smul_set.{0 u_2} real E (@mul_action.to_has_scalar.{0 u_2} real E real.monoid (@distrib_mul_action.to_mul_action.{0 u_2} real E real.monoid (@add_group.to_add_monoid.{u_2} E (@add_comm_group.to_add_group.{u_2} E _inst_1)) (@semimodule.to_distrib_mul_action.{0 u_2} real E real.semiring (@add_comm_group.to_add_comm_monoid.{u_2} E _inst_1) (@module.to_semimodule.{0 u_2} real E real.ring _inst_1 _inst_2))))) b s)) s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, iff a b → a → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@convex.{u_2} E _inst_1 _inst_2 s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_le.le.{0} real real.has_le (@has_zero.zero.{0} real (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_le.le.{0} real real.has_le (@has_zero.zero.{0} real (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))) b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@eq.{1} real (@has_add.add.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring)) a b) (@has_one.one.{0} real (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='Alternative definition of set convexity, in terms of pointwise set operations.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 94  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 95  /-- In a topological vector space, the closure of a convex set is convex. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 96  lemma convex.closure {s : set E} (hs : convex s) : convex (closure s) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='convex'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='convex'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='closure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/convex/basic.lean&#x27;, &#x27;line&#x27;: 124, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/convex/basic.lean&#x27;, &#x27;line&#x27;: 124, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 245, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {E : Type u} [_inst_1 : add_comm_group.{u} E] [_inst_2 : @vector_space.{0 u} real E real.discrete_field _inst_1], set.{u} E → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_2} E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {E : Type u} [_inst_1 : add_comm_group.{u} E] [_inst_2 : @vector_space.{0 u} real E real.discrete_field _inst_1], set.{u} E → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [_inst_1 : topological_space.{u} α], set.{u} α → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_2} E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='orange'><a title='Convexity of sets'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Convexity of sets'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The closure of `s` is the smallest closed set containing `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 97  λ x y hx hy a b ha hb hab,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hx'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ha'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hb'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hab'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x (@closure.{u_2} E _inst_3 s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y (@closure.{u_2} E _inst_3 s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_le.le.{0} real real.has_le (@has_zero.zero.{0} real (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_le.le.{0} real real.has_le (@has_zero.zero.{0} real (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))) b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@eq.{1} real (@has_add.add.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring)) a b) (@has_one.one.{0} real (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 98  let f : E → E → E := λ x&#x27; y&#x27;, a • x&#x27; + b • y&#x27; in</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='x&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_scalar.smul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_scalar.smul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/group_action.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/group_action.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E → E → E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} {γ : Type u_2} [c : has_scalar.{0 u_2} α γ], α → γ → γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_2} [c : has_add.{u_2} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} {γ : Type u_2} [c : has_scalar.{0 u_2} α γ], α → γ → γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 99  have hf : continuous (λ p : E × E, f p.1 p.2), from</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='continuous'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.snd'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 644, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='Π {α β : Type u_2} [_inst_1 : topological_space.{u_2} α] [_inst_2 : topological_space.{u_2} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2 → Type u_2 → Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='E → E → E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='prod.{u_2 u_2} E E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Type u_2}, prod.{u_2 u_2} α β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='prod.{u_2 u_2} E E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Type u_2}, prod.{u_2 u_2} α β → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='A function between topological spaces is continuous if the preimage
 of every open set is open.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>100    (continuous_const.smul continuous_fst).add (continuous_const.smul continuous_snd),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='continuous_const'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='continuous.smul'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='continuous_fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='continuous.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='continuous_const'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='continuous.smul'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='continuous_snd'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 686, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/algebra/module.lean&#x27;, &#x27;line&#x27;: 58, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/constructions.lean&#x27;, &#x27;line&#x27;: 115, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/algebra/monoid.lean&#x27;, &#x27;line&#x27;: 42, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 686, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/algebra/module.lean&#x27;, &#x27;line&#x27;: 58, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/constructions.lean&#x27;, &#x27;line&#x27;: 118, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {α : Type u_2} {β : Type} [_inst_1 : topological_space.{u_2} α] [_inst_2 : topological_space.{0} β] {b : β}, @continuous.{u_2 0} α β _inst_1 _inst_2 (λ (a : α), b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {R : Type} {M : Type u_2} [_inst_1 : semiring.{0} R] [_inst_2 : topological_space.{0} R] [_inst_3 : topological_space.{u_2} M] [_inst_4 : add_comm_monoid.{u_2} M] [_inst_5 : @semimodule.{0 u_2} R M _inst_1 _inst_4] [_inst_6 : @topological_semimodule.{0 u_2} R M _inst_1 _inst_2 _inst_3 _inst_4 _inst_5] {M₂ : Type u_2} [_inst_7 : topological_space.{u_2} M₂] {f : M₂ → R} {g : M₂ → M}, @continuous.{u_2 0} M₂ R _inst_7 _inst_2 f → @continuous.{u_2 u_2} M₂ M _inst_7 _inst_3 g → @continuous.{u_2 u_2} M₂ M _inst_7 _inst_3 (λ (p : M₂), @has_scalar.smul.{0 u_2} R M (@mul_action.to_has_scalar.{0 u_2} R M (@semiring.to_monoid.{0} R _inst_1) (@distrib_mul_action.to_mul_action.{0 u_2} R M (@semiring.to_monoid.{0} R _inst_1) (@add_comm_monoid.to_add_monoid.{u_2} M _inst_4) (@semimodule.to_distrib_mul_action.{0 u_2} R M _inst_1 _inst_4 _inst_5))) (f p) (g p))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α β : Type u_2} [_inst_1 : topological_space.{u_2} α] [_inst_2 : topological_space.{u_2} β], @continuous.{u_2 u_2} (prod.{u_2 u_2} α β) α (@prod.topological_space.{u_2 u_2} α β _inst_1 _inst_2) _inst_1 (@prod.fst.{u_2 u_2} α β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α β : Type u_2} [_inst_1 : topological_space.{u_2} α] [_inst_2 : add_monoid.{u_2} α] [_inst_3 : @topological_add_monoid.{u_2} α _inst_1 _inst_2] [_inst_4 : topological_space.{u_2} β] {f g : β → α}, @continuous.{u_2 u_2} β α _inst_4 _inst_1 f → @continuous.{u_2 u_2} β α _inst_4 _inst_1 g → @continuous.{u_2 u_2} β α _inst_4 _inst_1 (λ (x : β), @has_add.add.{u_2} α (@add_semigroup.to_has_add.{u_2} α (@add_monoid.to_add_semigroup.{u_2} α _inst_2)) (f x) (g x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {α : Type u_2} {β : Type} [_inst_1 : topological_space.{u_2} α] [_inst_2 : topological_space.{0} β] {b : β}, @continuous.{u_2 0} α β _inst_1 _inst_2 (λ (a : α), b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {R : Type} {M : Type u_2} [_inst_1 : semiring.{0} R] [_inst_2 : topological_space.{0} R] [_inst_3 : topological_space.{u_2} M] [_inst_4 : add_comm_monoid.{u_2} M] [_inst_5 : @semimodule.{0 u_2} R M _inst_1 _inst_4] [_inst_6 : @topological_semimodule.{0 u_2} R M _inst_1 _inst_2 _inst_3 _inst_4 _inst_5] {M₂ : Type u_2} [_inst_7 : topological_space.{u_2} M₂] {f : M₂ → R} {g : M₂ → M}, @continuous.{u_2 0} M₂ R _inst_7 _inst_2 f → @continuous.{u_2 u_2} M₂ M _inst_7 _inst_3 g → @continuous.{u_2 u_2} M₂ M _inst_7 _inst_3 (λ (p : M₂), @has_scalar.smul.{0 u_2} R M (@mul_action.to_has_scalar.{0 u_2} R M (@semiring.to_monoid.{0} R _inst_1) (@distrib_mul_action.to_mul_action.{0 u_2} R M (@semiring.to_monoid.{0} R _inst_1) (@add_comm_monoid.to_add_monoid.{u_2} M _inst_4) (@semimodule.to_distrib_mul_action.{0 u_2} R M _inst_1 _inst_4 _inst_5))) (f p) (g p))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α β : Type u_2} [_inst_1 : topological_space.{u_2} α] [_inst_2 : topological_space.{u_2} β], @continuous.{u_2 u_2} (prod.{u_2 u_2} α β) β (@prod.topological_space.{u_2 u_2} α β _inst_1 _inst_2) _inst_2 (@prod.snd.{u_2 u_2} α β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>101  show f x y ∈ closure s, from</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='closure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 245, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='E → E → E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u_2} [c : has_mem.{u_2 u_2} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_2} [_inst_1 : topological_space.{u_2} α], set.{u_2} α → set.{u_2} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_2} E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='The closure of `s` is the smallest closed set containing `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>102    mem_closure_of_continuous2 hf hx hy (λ x&#x27; hx&#x27; y&#x27; hy&#x27;, subset_closure</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='mem_closure_of_continuous2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hx'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='x&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hx&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hy&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='subset_closure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/constructions.lean&#x27;, &#x27;line&#x27;: 703, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 250, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α β γ : Type u_2} [_inst_1 : topological_space.{u_2} α] [_inst_2 : topological_space.{u_2} β] [_inst_3 : topological_space.{u_2} γ] {f : α → β → γ} {a : α} {b : β} {s : set.{u_2} α} {t : set.{u_2} β} {u : set.{u_2} γ}, @continuous.{u_2 u_2} (prod.{u_2 u_2} α β) γ (@prod.topological_space.{u_2 u_2} α β _inst_1 _inst_2) _inst_3 (λ (p : prod.{u_2 u_2} α β), f (@prod.fst.{u_2 u_2} α β p) (@prod.snd.{u_2 u_2} α β p)) → @has_mem.mem.{u_2 u_2} α (set.{u_2} α) (@set.has_mem.{u_2} α) a (@closure.{u_2} α _inst_1 s) → @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) b (@closure.{u_2} β _inst_2 t) → (∀ (a : α), @has_mem.mem.{u_2 u_2} α (set.{u_2} α) (@set.has_mem.{u_2} α) a s → ∀ (b : β), @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) b t → @has_mem.mem.{u_2 u_2} γ (set.{u_2} γ) (@set.has_mem.{u_2} γ) (f a b) (@closure.{u_2} γ _inst_3 u)) → @has_mem.mem.{u_2 u_2} γ (set.{u_2} γ) (@set.has_mem.{u_2} γ) (f a b) (@closure.{u_2} γ _inst_3 u)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@continuous.{u_2 u_2} (prod.{u_2 u_2} E E) E (@prod.topological_space.{u_2 u_2} E E _inst_3 _inst_3) _inst_3 (λ (p : prod.{u_2 u_2} E E), f (@prod.fst.{u_2 u_2} E E p) (@prod.snd.{u_2 u_2} E E p))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x (@closure.{u_2} E _inst_3 s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y (@closure.{u_2} E _inst_3 s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x&#x27; s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y&#x27; s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u_2} [_inst_1 : topological_space.{u_2} α] {s : set.{u_2} α}, @has_subset.subset.{u_2} (set.{u_2} α) (@set.has_subset.{u_2} α) s (@closure.{u_2} α _inst_1 s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>103    (hs hx&#x27; hy&#x27; ha hb hab))</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='hs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hx&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hy&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ha'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hb'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hab'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@convex.{u_2} E _inst_1 _inst_2 s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x&#x27; s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y&#x27; s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_le.le.{0} real real.has_le (@has_zero.zero.{0} real (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_le.le.{0} real real.has_le (@has_zero.zero.{0} real (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))) b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@eq.{1} real (@has_add.add.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring)) a b) (@has_one.one.{0} real (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>104  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>105  /-- Convex hull of a finite set is compact. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>106  lemma set.finite.compact_convex_hull {s : set E} (hs : finite s) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                          </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='set.finite'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/finite.lean&#x27;, &#x27;line&#x27;: 20, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                          </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {α : Type u}, set.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_2} E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                       </code><font color='orange'><a title='A set is finite if the subtype is a fintype, i.e. there is a
 list that enumerates its members.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>107    compact (convex_hull s) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='compact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='convex_hull'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/subset_properties.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/convex/basic.lean&#x27;, &#x27;line&#x27;: 703, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [_inst_1 : topological_space.{u} α], set.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {E : Type u} [_inst_1 : add_comm_group.{u} E] [_inst_2 : @vector_space.{0 u} real E real.discrete_field _inst_1], set.{u} E → set.{u} E'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_2} E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='A set `s` is compact if for every filter `f` that contains `s`,
   every set of `f` also meets every neighborhood of some `a ∈ s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Convex hull of a set `s` is the minimal convex set that includes `s`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>108  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='E : Type u_2,
_inst_1 : add_comm_group.{u_2} E,
_inst_2 : @vector_space.{0 u_2} real E real.discrete_field _inst_1,
_inst_3 : topological_space.{u_2} E,
_inst_4 : @topological_add_group.{u_2} E _inst_3 (@add_comm_group.to_add_group.{u_2} E _inst_1),
_inst_5 :
  @topological_vector_space.{0 u_2} real E real.discrete_field
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    _inst_3
    _inst_1
    _inst_2,
s : set.{u_2} E,
hs : @set.finite.{u_2} E s
⊢ @compact.{u_2} E _inst_3 (@convex_hull.{u_2} E _inst_1 _inst_2 s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>109    rw [hs.convex_hull_eq_image],</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{(max (u_2+1) 1)} (set.{u_2} E) (@convex_hull.{u_2} E _inst_1 _inst_2 s) (@set.image.{u_2 u_2} (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s → real) E (@coe_fn.{u_2+1 u_2+1} (@linear_map.{0 u_2 u_2} real (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s → real) E real.ring (@pi.add_comm_group.{u_2 0} (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s) (λ (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s), real) (λ (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s), real.add_comm_group)) _inst_1 (@pi.module.{u_2 0 0} (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s) (λ (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s), real) real real.ring (λ (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s), real.add_comm_group) (λ (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s), @ring.to_module.{0} real real.ring)) _inst_2) (@linear_map.has_coe_to_fun.{0 u_2 u_2} real (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s → real) E real.ring (@pi.add_comm_group.{u_2 0} (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s) (λ (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s), real) (λ (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s), real.add_comm_group)) _inst_1 (@pi.module.{u_2 0 0} (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s) (λ (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s), real) real real.ring (λ (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s), real.add_comm_group) (λ (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s), @ring.to_module.{0} real real.ring)) _inst_2) (@finset.sum.{u_2 u_2} (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s) (@linear_map.{0 u_2 u_2} real (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s → real) E real.ring (@pi.add_comm_group.{u_2 0} (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s) (λ (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s), real) (λ (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s), real.add_comm_group)) _inst_1 (@pi.module.{u_2 0 0} (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s) (λ (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s), real) real real.ring (λ (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s), real.add_comm_group) (λ (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s), @ring.to_module.{0} real real.ring)) _inst_2) (@add_comm_group.to_add_comm_monoid.{u_2} (@linear_map.{0 u_2 u_2} real (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s → real) E real.ring (@pi.add_comm_group.{u_2 0} (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s) (λ (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s), real) (λ (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s), real.add_comm_group)) _inst_1 (@pi.module.{u_2 0 0} (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s) (λ (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s), real) real real.ring (λ (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s), real.add_comm_group) (λ (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s), @ring.to_module.{0} real real.ring)) _inst_2) (@linear_map.add_comm_group.{0 u_2 u_2} real (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s → real) E real.ring (@pi.add_comm_group.{u_2 0} (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s) (λ (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s), real) (λ (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s), real.add_comm_group)) _inst_1 (@pi.module.{u_2 0 0} (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s) (λ (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s), real) real real.ring (λ (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s), real.add_comm_group) (λ (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s), @ring.to_module.{0} real real.ring)) _inst_2)) (@finset.univ.{u_2} (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s) (@set.finite.fintype.{u_2} E s hs)) (λ (x : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s), @linear_map.smul_right.{0 u_2 u_2} real E (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s → real) real.ring _inst_1 (@pi.add_comm_group.{u_2 0} (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s) (λ (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s), real) (λ (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s), real.add_comm_group)) _inst_2 (@pi.module.{u_2 0 0} (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s) (λ (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s), real) real real.ring (λ (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s), real.add_comm_group) (λ (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s), @ring.to_module.{0} real real.ring)) (@linear_map.proj.{0 u_2 0} real (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s) real.ring (λ (a : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s), real) (λ (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s), real.add_comm_group) (λ (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s), @ring.to_module.{0} real real.ring) x) (@subtype.val.{u_2+1} E (λ (x : E), @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x s) x)))) (@std_simplex.{u_2} (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s) (@set.finite.fintype.{u_2} E s hs)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='E : Type u_2,
_inst_1 : add_comm_group.{u_2} E,
_inst_2 : @vector_space.{0 u_2} real E real.discrete_field _inst_1,
_inst_3 : topological_space.{u_2} E,
_inst_4 : @topological_add_group.{u_2} E _inst_3 (@add_comm_group.to_add_group.{u_2} E _inst_1),
_inst_5 :
  @topological_vector_space.{0 u_2} real E real.discrete_field
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    _inst_3
    _inst_1
    _inst_2,
s : set.{u_2} E,
hs : @set.finite.{u_2} E s
⊢ @compact.{u_2} E _inst_3 (@convex_hull.{u_2} E _inst_1 _inst_2 s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='E : Type u_2,
_inst_1 : add_comm_group.{u_2} E,
_inst_2 : @vector_space.{0 u_2} real E real.discrete_field _inst_1,
_inst_3 : topological_space.{u_2} E,
_inst_4 : @topological_add_group.{u_2} E _inst_3 (@add_comm_group.to_add_group.{u_2} E _inst_1),
_inst_5 :
  @topological_vector_space.{0 u_2} real E real.discrete_field
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    _inst_3
    _inst_1
    _inst_2,
s : set.{u_2} E,
hs : @set.finite.{u_2} E s
⊢ @compact.{u_2} E _inst_3
    (@set.image.{u_2 u_2}
       (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s → real)
       E
       (@coe_fn.{u_2+1 u_2+1}
          (@linear_map.{0 u_2 u_2} real
             (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s → real)
             E
             real.ring
             (@pi.add_comm_group.{u_2 0}
                (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s)
                (λ (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                   real)
                (λ (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                   real.add_comm_group))
             _inst_1
             (@pi.module.{u_2 0 0}
                (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s)
                (λ (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                   real)
                real
                real.ring
                (λ (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                   real.add_comm_group)
                (λ (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                   @ring.to_module.{0} real real.ring))
             _inst_2)
          (@linear_map.has_coe_to_fun.{0 u_2 u_2} real
             (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s → real)
             E
             real.ring
             (@pi.add_comm_group.{u_2 0}
                (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s)
                (λ (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                   real)
                (λ (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                   real.add_comm_group))
             _inst_1
             (@pi.module.{u_2 0 0}
                (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s)
                (λ (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                   real)
                real
                real.ring
                (λ (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                   real.add_comm_group)
                (λ (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                   @ring.to_module.{0} real real.ring))
             _inst_2)
          (@finset.sum.{u_2 u_2}
             (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s)
             (@linear_map.{0 u_2 u_2} real
                (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s → real)
                E
                real.ring
                (@pi.add_comm_group.{u_2 0}
                   (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s)
                   (λ
                    (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                      real)
                   (λ
                    (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                      real.add_comm_group))
                _inst_1
                (@pi.module.{u_2 0 0}
                   (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s)
                   (λ
                    (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                      real)
                   real
                   real.ring
                   (λ
                    (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                      real.add_comm_group)
                   (λ
                    (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                      @ring.to_module.{0} real real.ring))
                _inst_2)
             (@add_comm_group.to_add_comm_monoid.{u_2}
                (@linear_map.{0 u_2 u_2} real
                   (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s →
                    real)
                   E
                   real.ring
                   (@pi.add_comm_group.{u_2 0}
                      (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s)
                      (λ
                       (i :
                         @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                         real)
                      (λ
                       (i :
                         @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                         real.add_comm_group))
                   _inst_1
                   (@pi.module.{u_2 0 0}
                      (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s)
                      (λ
                       (i :
                         @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                         real)
                      real
                      real.ring
                      (λ
                       (i :
                         @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                         real.add_comm_group)
                      (λ
                       (i :
                         @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                         @ring.to_module.{0} real real.ring))
                   _inst_2)
                (@linear_map.add_comm_group.{0 u_2 u_2} real
                   (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s →
                    real)
                   E
                   real.ring
                   (@pi.add_comm_group.{u_2 0}
                      (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s)
                      (λ
                       (i :
                         @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                         real)
                      (λ
                       (i :
                         @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                         real.add_comm_group))
                   _inst_1
                   (@pi.module.{u_2 0 0}
                      (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s)
                      (λ
                       (i :
                         @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                         real)
                      real
                      real.ring
                      (λ
                       (i :
                         @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                         real.add_comm_group)
                      (λ
                       (i :
                         @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                         @ring.to_module.{0} real real.ring))
                   _inst_2))
             (@finset.univ.{u_2}
                (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s)
                (@set.finite.fintype.{u_2} E s hs))
             (λ (x : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                @linear_map.smul_right.{0 u_2 u_2} real E
                  (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s →
                   real)
                  real.ring
                  _inst_1
                  (@pi.add_comm_group.{u_2 0}
                     (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s)
                     (λ
                      (i :
                        @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                        real)
                     (λ
                      (i :
                        @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                        real.add_comm_group))
                  _inst_2
                  (@pi.module.{u_2 0 0}
                     (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s)
                     (λ
                      (i :
                        @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                        real)
                     real
                     real.ring
                     (λ
                      (i :
                        @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                        real.add_comm_group)
                     (λ
                      (i :
                        @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                        @ring.to_module.{0} real real.ring))
                  (@linear_map.proj.{0 u_2 0} real
                     (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s)
                     real.ring
                     (λ
                      (a :
                        @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                        real)
                     (λ
                      (i :
                        @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                        real.add_comm_group)
                     (λ
                      (i :
                        @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                        @ring.to_module.{0} real real.ring)
                     x)
                  (@subtype.val.{u_2+1} E
                     (λ (x : E), @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x s)
                     x))))
       (@std_simplex.{u_2}
          (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s)
          (@set.finite.fintype.{u_2} E s hs)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>110    apply (compact_std_simplex _).image,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='compact_std_simplex'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 61, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ (ι : Type u_2) [_inst_1 : fintype.{u_2} ι], @compact.{u_2} (ι → real) (@Pi.topological_space.{u_2 0} ι (λ (a : ι), real) (λ (a : ι), @uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))) (@std_simplex.{u_2} ι _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`std_simplex ι` is compact.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='E : Type u_2,
_inst_1 : add_comm_group.{u_2} E,
_inst_2 : @vector_space.{0 u_2} real E real.discrete_field _inst_1,
_inst_3 : topological_space.{u_2} E,
_inst_4 : @topological_add_group.{u_2} E _inst_3 (@add_comm_group.to_add_group.{u_2} E _inst_1),
_inst_5 :
  @topological_vector_space.{0 u_2} real E real.discrete_field
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    _inst_3
    _inst_1
    _inst_2,
s : set.{u_2} E,
hs : @set.finite.{u_2} E s
⊢ @compact.{u_2} E _inst_3
    (@set.image.{u_2 u_2}
       (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s → real)
       E
       (@coe_fn.{u_2+1 u_2+1}
          (@linear_map.{0 u_2 u_2} real
             (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s → real)
             E
             real.ring
             (@pi.add_comm_group.{u_2 0}
                (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s)
                (λ (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                   real)
                (λ (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                   real.add_comm_group))
             _inst_1
             (@pi.module.{u_2 0 0}
                (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s)
                (λ (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                   real)
                real
                real.ring
                (λ (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                   real.add_comm_group)
                (λ (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                   @ring.to_module.{0} real real.ring))
             _inst_2)
          (@linear_map.has_coe_to_fun.{0 u_2 u_2} real
             (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s → real)
             E
             real.ring
             (@pi.add_comm_group.{u_2 0}
                (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s)
                (λ (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                   real)
                (λ (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                   real.add_comm_group))
             _inst_1
             (@pi.module.{u_2 0 0}
                (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s)
                (λ (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                   real)
                real
                real.ring
                (λ (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                   real.add_comm_group)
                (λ (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                   @ring.to_module.{0} real real.ring))
             _inst_2)
          (@finset.sum.{u_2 u_2}
             (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s)
             (@linear_map.{0 u_2 u_2} real
                (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s → real)
                E
                real.ring
                (@pi.add_comm_group.{u_2 0}
                   (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s)
                   (λ
                    (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                      real)
                   (λ
                    (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                      real.add_comm_group))
                _inst_1
                (@pi.module.{u_2 0 0}
                   (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s)
                   (λ
                    (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                      real)
                   real
                   real.ring
                   (λ
                    (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                      real.add_comm_group)
                   (λ
                    (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                      @ring.to_module.{0} real real.ring))
                _inst_2)
             (@add_comm_group.to_add_comm_monoid.{u_2}
                (@linear_map.{0 u_2 u_2} real
                   (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s →
                    real)
                   E
                   real.ring
                   (@pi.add_comm_group.{u_2 0}
                      (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s)
                      (λ
                       (i :
                         @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                         real)
                      (λ
                       (i :
                         @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                         real.add_comm_group))
                   _inst_1
                   (@pi.module.{u_2 0 0}
                      (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s)
                      (λ
                       (i :
                         @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                         real)
                      real
                      real.ring
                      (λ
                       (i :
                         @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                         real.add_comm_group)
                      (λ
                       (i :
                         @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                         @ring.to_module.{0} real real.ring))
                   _inst_2)
                (@linear_map.add_comm_group.{0 u_2 u_2} real
                   (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s →
                    real)
                   E
                   real.ring
                   (@pi.add_comm_group.{u_2 0}
                      (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s)
                      (λ
                       (i :
                         @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                         real)
                      (λ
                       (i :
                         @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                         real.add_comm_group))
                   _inst_1
                   (@pi.module.{u_2 0 0}
                      (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s)
                      (λ
                       (i :
                         @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                         real)
                      real
                      real.ring
                      (λ
                       (i :
                         @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                         real.add_comm_group)
                      (λ
                       (i :
                         @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                         @ring.to_module.{0} real real.ring))
                   _inst_2))
             (@finset.univ.{u_2}
                (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s)
                (@set.finite.fintype.{u_2} E s hs))
             (λ (x : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                @linear_map.smul_right.{0 u_2 u_2} real E
                  (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s →
                   real)
                  real.ring
                  _inst_1
                  (@pi.add_comm_group.{u_2 0}
                     (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s)
                     (λ
                      (i :
                        @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                        real)
                     (λ
                      (i :
                        @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                        real.add_comm_group))
                  _inst_2
                  (@pi.module.{u_2 0 0}
                     (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s)
                     (λ
                      (i :
                        @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                        real)
                     real
                     real.ring
                     (λ
                      (i :
                        @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                        real.add_comm_group)
                     (λ
                      (i :
                        @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                        @ring.to_module.{0} real real.ring))
                  (@linear_map.proj.{0 u_2 0} real
                     (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s)
                     real.ring
                     (λ
                      (a :
                        @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                        real)
                     (λ
                      (i :
                        @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                        real.add_comm_group)
                     (λ
                      (i :
                        @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                        @ring.to_module.{0} real real.ring)
                     x)
                  (@subtype.val.{u_2+1} E
                     (λ (x : E), @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x s)
                     x))))
       (@std_simplex.{u_2}
          (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s)
          (@set.finite.fintype.{u_2} E s hs)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='E : Type u_2,
_inst_1 : add_comm_group.{u_2} E,
_inst_2 : @vector_space.{0 u_2} real E real.discrete_field _inst_1,
_inst_3 : topological_space.{u_2} E,
_inst_4 : @topological_add_group.{u_2} E _inst_3 (@add_comm_group.to_add_group.{u_2} E _inst_1),
_inst_5 :
  @topological_vector_space.{0 u_2} real E real.discrete_field
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    _inst_3
    _inst_1
    _inst_2,
s : set.{u_2} E,
hs : @set.finite.{u_2} E s
⊢ @continuous.{u_2 u_2}
    (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s → real)
    E
    (@Pi.topological_space.{u_2 0}
       (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s)
       (λ (a : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s), real)
       (λ (a : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
          @uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)))
    _inst_3
    (@coe_fn.{u_2+1 u_2+1}
       (@linear_map.{0 u_2 u_2} real
          (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s → real)
          E
          real.ring
          (@pi.add_comm_group.{u_2 0}
             (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s)
             (λ (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                real)
             (λ (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                real.add_comm_group))
          _inst_1
          (@pi.module.{u_2 0 0}
             (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s)
             (λ (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                real)
             real
             real.ring
             (λ (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                real.add_comm_group)
             (λ (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                @ring.to_module.{0} real real.ring))
          _inst_2)
       (@linear_map.has_coe_to_fun.{0 u_2 u_2} real
          (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s → real)
          E
          real.ring
          (@pi.add_comm_group.{u_2 0}
             (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s)
             (λ (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                real)
             (λ (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                real.add_comm_group))
          _inst_1
          (@pi.module.{u_2 0 0}
             (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s)
             (λ (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                real)
             real
             real.ring
             (λ (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                real.add_comm_group)
             (λ (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                @ring.to_module.{0} real real.ring))
          _inst_2)
       (@finset.sum.{u_2 u_2}
          (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s)
          (@linear_map.{0 u_2 u_2} real
             (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s → real)
             E
             real.ring
             (@pi.add_comm_group.{u_2 0}
                (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s)
                (λ (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                   real)
                (λ (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                   real.add_comm_group))
             _inst_1
             (@pi.module.{u_2 0 0}
                (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s)
                (λ (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                   real)
                real
                real.ring
                (λ (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                   real.add_comm_group)
                (λ (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                   @ring.to_module.{0} real real.ring))
             _inst_2)
          (@add_comm_group.to_add_comm_monoid.{u_2}
             (@linear_map.{0 u_2 u_2} real
                (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s → real)
                E
                real.ring
                (@pi.add_comm_group.{u_2 0}
                   (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s)
                   (λ
                    (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                      real)
                   (λ
                    (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                      real.add_comm_group))
                _inst_1
                (@pi.module.{u_2 0 0}
                   (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s)
                   (λ
                    (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                      real)
                   real
                   real.ring
                   (λ
                    (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                      real.add_comm_group)
                   (λ
                    (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                      @ring.to_module.{0} real real.ring))
                _inst_2)
             (@linear_map.add_comm_group.{0 u_2 u_2} real
                (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s → real)
                E
                real.ring
                (@pi.add_comm_group.{u_2 0}
                   (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s)
                   (λ
                    (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                      real)
                   (λ
                    (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                      real.add_comm_group))
                _inst_1
                (@pi.module.{u_2 0 0}
                   (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s)
                   (λ
                    (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                      real)
                   real
                   real.ring
                   (λ
                    (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                      real.add_comm_group)
                   (λ
                    (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                      @ring.to_module.{0} real real.ring))
                _inst_2))
          (@finset.univ.{u_2}
             (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s)
             (@set.finite.fintype.{u_2} E s hs))
          (λ (x : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
             @linear_map.smul_right.{0 u_2 u_2} real E
               (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s → real)
               real.ring
               _inst_1
               (@pi.add_comm_group.{u_2 0}
                  (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s)
                  (λ
                   (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                     real)
                  (λ
                   (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                     real.add_comm_group))
               _inst_2
               (@pi.module.{u_2 0 0}
                  (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s)
                  (λ
                   (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                     real)
                  real
                  real.ring
                  (λ
                   (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                     real.add_comm_group)
                  (λ
                   (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                     @ring.to_module.{0} real real.ring))
               (@linear_map.proj.{0 u_2 0} real
                  (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s)
                  real.ring
                  (λ
                   (a : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                     real)
                  (λ
                   (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                     real.add_comm_group)
                  (λ
                   (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                     @ring.to_module.{0} real real.ring)
                  x)
               (@subtype.val.{u_2+1} E (λ (x : E), @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x s)
                  x))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>111    haveI := hs.fintype,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='hs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/finite.lean&#x27;, &#x27;line&#x27;: 28, &#x27;column&#x27;: 18}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@set.finite.{u_2} E s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Used to add typeclasses to the context so that they can
 be used in typeclass inference. The syntax is the same as `have`,
 but the proof-omitted version is not supported. For
 this one must write `have : t, { &lt;proof&gt; }, resetI, &lt;proof&gt;`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title=' The subtype corresponding to a finite set is a finite type. Note
that because `finite` isn&#x27;t a typeclass, this will not fire if it
is made into an instance'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='haveI'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;:= expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='E : Type u_2,
_inst_1 : add_comm_group.{u_2} E,
_inst_2 : @vector_space.{0 u_2} real E real.discrete_field _inst_1,
_inst_3 : topological_space.{u_2} E,
_inst_4 : @topological_add_group.{u_2} E _inst_3 (@add_comm_group.to_add_group.{u_2} E _inst_1),
_inst_5 :
  @topological_vector_space.{0 u_2} real E real.discrete_field
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    _inst_3
    _inst_1
    _inst_2,
s : set.{u_2} E,
hs : @set.finite.{u_2} E s
⊢ @continuous.{u_2 u_2}
    (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s → real)
    E
    (@Pi.topological_space.{u_2 0}
       (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s)
       (λ (a : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s), real)
       (λ (a : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
          @uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)))
    _inst_3
    (@coe_fn.{u_2+1 u_2+1}
       (@linear_map.{0 u_2 u_2} real
          (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s → real)
          E
          real.ring
          (@pi.add_comm_group.{u_2 0}
             (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s)
             (λ (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                real)
             (λ (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                real.add_comm_group))
          _inst_1
          (@pi.module.{u_2 0 0}
             (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s)
             (λ (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                real)
             real
             real.ring
             (λ (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                real.add_comm_group)
             (λ (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                @ring.to_module.{0} real real.ring))
          _inst_2)
       (@linear_map.has_coe_to_fun.{0 u_2 u_2} real
          (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s → real)
          E
          real.ring
          (@pi.add_comm_group.{u_2 0}
             (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s)
             (λ (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                real)
             (λ (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                real.add_comm_group))
          _inst_1
          (@pi.module.{u_2 0 0}
             (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s)
             (λ (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                real)
             real
             real.ring
             (λ (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                real.add_comm_group)
             (λ (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                @ring.to_module.{0} real real.ring))
          _inst_2)
       (@finset.sum.{u_2 u_2}
          (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s)
          (@linear_map.{0 u_2 u_2} real
             (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s → real)
             E
             real.ring
             (@pi.add_comm_group.{u_2 0}
                (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s)
                (λ (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                   real)
                (λ (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                   real.add_comm_group))
             _inst_1
             (@pi.module.{u_2 0 0}
                (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s)
                (λ (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                   real)
                real
                real.ring
                (λ (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                   real.add_comm_group)
                (λ (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                   @ring.to_module.{0} real real.ring))
             _inst_2)
          (@add_comm_group.to_add_comm_monoid.{u_2}
             (@linear_map.{0 u_2 u_2} real
                (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s → real)
                E
                real.ring
                (@pi.add_comm_group.{u_2 0}
                   (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s)
                   (λ
                    (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                      real)
                   (λ
                    (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                      real.add_comm_group))
                _inst_1
                (@pi.module.{u_2 0 0}
                   (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s)
                   (λ
                    (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                      real)
                   real
                   real.ring
                   (λ
                    (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                      real.add_comm_group)
                   (λ
                    (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                      @ring.to_module.{0} real real.ring))
                _inst_2)
             (@linear_map.add_comm_group.{0 u_2 u_2} real
                (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s → real)
                E
                real.ring
                (@pi.add_comm_group.{u_2 0}
                   (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s)
                   (λ
                    (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                      real)
                   (λ
                    (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                      real.add_comm_group))
                _inst_1
                (@pi.module.{u_2 0 0}
                   (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s)
                   (λ
                    (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                      real)
                   real
                   real.ring
                   (λ
                    (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                      real.add_comm_group)
                   (λ
                    (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                      @ring.to_module.{0} real real.ring))
                _inst_2))
          (@finset.univ.{u_2}
             (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s)
             (@set.finite.fintype.{u_2} E s hs))
          (λ (x : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
             @linear_map.smul_right.{0 u_2 u_2} real E
               (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s → real)
               real.ring
               _inst_1
               (@pi.add_comm_group.{u_2 0}
                  (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s)
                  (λ
                   (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                     real)
                  (λ
                   (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                     real.add_comm_group))
               _inst_2
               (@pi.module.{u_2 0 0}
                  (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s)
                  (λ
                   (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                     real)
                  real
                  real.ring
                  (λ
                   (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                     real.add_comm_group)
                  (λ
                   (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                     @ring.to_module.{0} real real.ring))
               (@linear_map.proj.{0 u_2 0} real
                  (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s)
                  real.ring
                  (λ
                   (a : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                     real)
                  (λ
                   (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                     real.add_comm_group)
                  (λ
                   (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                     @ring.to_module.{0} real real.ring)
                  x)
               (@subtype.val.{u_2+1} E (λ (x : E), @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x s)
                  x))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='E : Type u_2,
_inst_1 : add_comm_group.{u_2} E,
_inst_2 : @vector_space.{0 u_2} real E real.discrete_field _inst_1,
_inst_3 : topological_space.{u_2} E,
_inst_4 : @topological_add_group.{u_2} E _inst_3 (@add_comm_group.to_add_group.{u_2} E _inst_1),
_inst_5 :
  @topological_vector_space.{0 u_2} real E real.discrete_field
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    _inst_3
    _inst_1
    _inst_2,
s : set.{u_2} E,
hs : @set.finite.{u_2} E s,
_inst : fintype.{u_2} (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s)
⊢ @continuous.{u_2 u_2}
    (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s → real)
    E
    (@Pi.topological_space.{u_2 0}
       (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s)
       (λ (a : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s), real)
       (λ (a : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
          @uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)))
    _inst_3
    (@coe_fn.{u_2+1 u_2+1}
       (@linear_map.{0 u_2 u_2} real
          (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s → real)
          E
          real.ring
          (@pi.add_comm_group.{u_2 0}
             (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s)
             (λ (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                real)
             (λ (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                real.add_comm_group))
          _inst_1
          (@pi.module.{u_2 0 0}
             (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s)
             (λ (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                real)
             real
             real.ring
             (λ (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                real.add_comm_group)
             (λ (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                @ring.to_module.{0} real real.ring))
          _inst_2)
       (@linear_map.has_coe_to_fun.{0 u_2 u_2} real
          (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s → real)
          E
          real.ring
          (@pi.add_comm_group.{u_2 0}
             (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s)
             (λ (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                real)
             (λ (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                real.add_comm_group))
          _inst_1
          (@pi.module.{u_2 0 0}
             (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s)
             (λ (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                real)
             real
             real.ring
             (λ (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                real.add_comm_group)
             (λ (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                @ring.to_module.{0} real real.ring))
          _inst_2)
       (@finset.sum.{u_2 u_2}
          (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s)
          (@linear_map.{0 u_2 u_2} real
             (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s → real)
             E
             real.ring
             (@pi.add_comm_group.{u_2 0}
                (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s)
                (λ (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                   real)
                (λ (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                   real.add_comm_group))
             _inst_1
             (@pi.module.{u_2 0 0}
                (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s)
                (λ (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                   real)
                real
                real.ring
                (λ (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                   real.add_comm_group)
                (λ (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                   @ring.to_module.{0} real real.ring))
             _inst_2)
          (@add_comm_group.to_add_comm_monoid.{u_2}
             (@linear_map.{0 u_2 u_2} real
                (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s → real)
                E
                real.ring
                (@pi.add_comm_group.{u_2 0}
                   (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s)
                   (λ
                    (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                      real)
                   (λ
                    (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                      real.add_comm_group))
                _inst_1
                (@pi.module.{u_2 0 0}
                   (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s)
                   (λ
                    (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                      real)
                   real
                   real.ring
                   (λ
                    (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                      real.add_comm_group)
                   (λ
                    (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                      @ring.to_module.{0} real real.ring))
                _inst_2)
             (@linear_map.add_comm_group.{0 u_2 u_2} real
                (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s → real)
                E
                real.ring
                (@pi.add_comm_group.{u_2 0}
                   (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s)
                   (λ
                    (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                      real)
                   (λ
                    (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                      real.add_comm_group))
                _inst_1
                (@pi.module.{u_2 0 0}
                   (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s)
                   (λ
                    (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                      real)
                   real
                   real.ring
                   (λ
                    (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                      real.add_comm_group)
                   (λ
                    (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                      @ring.to_module.{0} real real.ring))
                _inst_2))
          (@finset.univ.{u_2}
             (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s)
             (@set.finite.fintype.{u_2} E s hs))
          (λ (x : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
             @linear_map.smul_right.{0 u_2 u_2} real E
               (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s → real)
               real.ring
               _inst_1
               (@pi.add_comm_group.{u_2 0}
                  (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s)
                  (λ
                   (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                     real)
                  (λ
                   (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                     real.add_comm_group))
               _inst_2
               (@pi.module.{u_2 0 0}
                  (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s)
                  (λ
                   (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                     real)
                  real
                  real.ring
                  (λ
                   (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                     real.add_comm_group)
                  (λ
                   (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                     @ring.to_module.{0} real real.ring))
               (@linear_map.proj.{0 u_2 0} real
                  (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s)
                  real.ring
                  (λ
                   (a : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                     real)
                  (λ
                   (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                     real.add_comm_group)
                  (λ
                   (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                     @ring.to_module.{0} real real.ring)
                  x)
               (@subtype.val.{u_2+1} E (λ (x : E), @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x s)
                  x))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>112    apply linear_map.continuous_on_pi</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='linear_map.continuous_on_pi'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/finite_dimension.lean&#x27;, &#x27;line&#x27;: 53, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {ι : Type u_2} [_inst_1 : fintype.{u_2} ι] {𝕜 : Type} [_inst_2 : normed_field.{0} 𝕜] {E : Type u_2} [_inst_3 : add_comm_group.{u_2} E] [_inst_4 : @vector_space.{0 u_2} 𝕜 E (@normed_field.to_discrete_field.{0} 𝕜 _inst_2) _inst_3] [_inst_5 : topological_space.{u_2} E] [_inst_6 : @topological_add_group.{u_2} E _inst_5 (@add_comm_group.to_add_group.{u_2} E _inst_3)] [_inst_7 : @topological_vector_space.{0 u_2} 𝕜 E (@normed_field.to_discrete_field.{0} 𝕜 _inst_2) (@uniform_space.to_topological_space.{0} 𝕜 (@metric_space.to_uniform_space&#x27;.{0} 𝕜 (@normed_field.to_metric_space.{0} 𝕜 _inst_2))) _inst_5 _inst_3 _inst_4] (f : @linear_map.{0 u_2 u_2} 𝕜 (ι → 𝕜) E (@normed_ring.to_ring.{0} 𝕜 (@normed_field.to_normed_ring.{0} 𝕜 _inst_2)) (@pi.add_comm_group.{u_2 0} ι (λ (a : ι), 𝕜) (λ (i : ι), @normed_group.to_add_comm_group.{0} 𝕜 (@normed_ring.to_normed_group.{0} 𝕜 (@normed_field.to_normed_ring.{0} 𝕜 _inst_2)))) _inst_3 (@normed_space.to_module.{0 u_2} 𝕜 (ι → 𝕜) _inst_2 (@pi.normed_group.{u_2 0} ι (λ (a : ι), 𝕜) _inst_1 (λ (i : ι), @normed_ring.to_normed_group.{0} 𝕜 (@normed_field.to_normed_ring.{0} 𝕜 _inst_2))) (@pi.normed_space.{0 u_2 0} 𝕜 ι _inst_2 (λ (a : ι), 𝕜) _inst_1 (λ (i : ι), @normed_ring.to_normed_group.{0} 𝕜 (@normed_field.to_normed_ring.{0} 𝕜 _inst_2)) (λ (i : ι), @normed_field.to_normed_space.{0} 𝕜 _inst_2))) _inst_4), @continuous.{u_2 u_2} (ι → 𝕜) E (@Pi.topological_space.{u_2 0} ι (λ (a : ι), 𝕜) (λ (a : ι), @uniform_space.to_topological_space.{0} 𝕜 (@metric_space.to_uniform_space&#x27;.{0} 𝕜 (@normed_field.to_metric_space.{0} 𝕜 _inst_2)))) _inst_5 (@coe_fn.{u_2+1 u_2+1} (@linear_map.{0 u_2 u_2} 𝕜 (ι → 𝕜) E (@normed_ring.to_ring.{0} 𝕜 (@normed_field.to_normed_ring.{0} 𝕜 _inst_2)) (@pi.add_comm_group.{u_2 0} ι (λ (a : ι), 𝕜) (λ (i : ι), @normed_group.to_add_comm_group.{0} 𝕜 (@normed_ring.to_normed_group.{0} 𝕜 (@normed_field.to_normed_ring.{0} 𝕜 _inst_2)))) _inst_3 (@normed_space.to_module.{0 u_2} 𝕜 (ι → 𝕜) _inst_2 (@pi.normed_group.{u_2 0} ι (λ (a : ι), 𝕜) _inst_1 (λ (i : ι), @normed_ring.to_normed_group.{0} 𝕜 (@normed_field.to_normed_ring.{0} 𝕜 _inst_2))) (@pi.normed_space.{0 u_2 0} 𝕜 ι _inst_2 (λ (a : ι), 𝕜) _inst_1 (λ (i : ι), @normed_ring.to_normed_group.{0} 𝕜 (@normed_field.to_normed_ring.{0} 𝕜 _inst_2)) (λ (i : ι), @normed_field.to_normed_space.{0} 𝕜 _inst_2))) _inst_4) (@linear_map.has_coe_to_fun.{0 u_2 u_2} 𝕜 (ι → 𝕜) E (@normed_ring.to_ring.{0} 𝕜 (@normed_field.to_normed_ring.{0} 𝕜 _inst_2)) (@pi.add_comm_group.{u_2 0} ι (λ (a : ι), 𝕜) (λ (i : ι), @normed_group.to_add_comm_group.{0} 𝕜 (@normed_ring.to_normed_group.{0} 𝕜 (@normed_field.to_normed_ring.{0} 𝕜 _inst_2)))) _inst_3 (@normed_space.to_module.{0 u_2} 𝕜 (ι → 𝕜) _inst_2 (@pi.normed_group.{u_2 0} ι (λ (a : ι), 𝕜) _inst_1 (λ (i : ι), @normed_ring.to_normed_group.{0} 𝕜 (@normed_field.to_normed_ring.{0} 𝕜 _inst_2))) (@pi.normed_space.{0 u_2 0} 𝕜 ι _inst_2 (λ (a : ι), 𝕜) _inst_1 (λ (i : ι), @normed_ring.to_normed_group.{0} 𝕜 (@normed_field.to_normed_ring.{0} 𝕜 _inst_2)) (λ (i : ι), @normed_field.to_normed_space.{0} 𝕜 _inst_2))) _inst_4) f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='A linear map on `ι → 𝕜` (where `ι` is a fintype) is continuous'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='E : Type u_2,
_inst_1 : add_comm_group.{u_2} E,
_inst_2 : @vector_space.{0 u_2} real E real.discrete_field _inst_1,
_inst_3 : topological_space.{u_2} E,
_inst_4 : @topological_add_group.{u_2} E _inst_3 (@add_comm_group.to_add_group.{u_2} E _inst_1),
_inst_5 :
  @topological_vector_space.{0 u_2} real E real.discrete_field
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    _inst_3
    _inst_1
    _inst_2,
s : set.{u_2} E,
hs : @set.finite.{u_2} E s,
_inst : fintype.{u_2} (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s)
⊢ @continuous.{u_2 u_2}
    (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s → real)
    E
    (@Pi.topological_space.{u_2 0}
       (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s)
       (λ (a : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s), real)
       (λ (a : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
          @uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)))
    _inst_3
    (@coe_fn.{u_2+1 u_2+1}
       (@linear_map.{0 u_2 u_2} real
          (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s → real)
          E
          real.ring
          (@pi.add_comm_group.{u_2 0}
             (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s)
             (λ (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                real)
             (λ (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                real.add_comm_group))
          _inst_1
          (@pi.module.{u_2 0 0}
             (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s)
             (λ (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                real)
             real
             real.ring
             (λ (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                real.add_comm_group)
             (λ (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                @ring.to_module.{0} real real.ring))
          _inst_2)
       (@linear_map.has_coe_to_fun.{0 u_2 u_2} real
          (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s → real)
          E
          real.ring
          (@pi.add_comm_group.{u_2 0}
             (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s)
             (λ (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                real)
             (λ (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                real.add_comm_group))
          _inst_1
          (@pi.module.{u_2 0 0}
             (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s)
             (λ (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                real)
             real
             real.ring
             (λ (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                real.add_comm_group)
             (λ (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                @ring.to_module.{0} real real.ring))
          _inst_2)
       (@finset.sum.{u_2 u_2}
          (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s)
          (@linear_map.{0 u_2 u_2} real
             (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s → real)
             E
             real.ring
             (@pi.add_comm_group.{u_2 0}
                (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s)
                (λ (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                   real)
                (λ (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                   real.add_comm_group))
             _inst_1
             (@pi.module.{u_2 0 0}
                (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s)
                (λ (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                   real)
                real
                real.ring
                (λ (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                   real.add_comm_group)
                (λ (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                   @ring.to_module.{0} real real.ring))
             _inst_2)
          (@add_comm_group.to_add_comm_monoid.{u_2}
             (@linear_map.{0 u_2 u_2} real
                (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s → real)
                E
                real.ring
                (@pi.add_comm_group.{u_2 0}
                   (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s)
                   (λ
                    (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                      real)
                   (λ
                    (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                      real.add_comm_group))
                _inst_1
                (@pi.module.{u_2 0 0}
                   (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s)
                   (λ
                    (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                      real)
                   real
                   real.ring
                   (λ
                    (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                      real.add_comm_group)
                   (λ
                    (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                      @ring.to_module.{0} real real.ring))
                _inst_2)
             (@linear_map.add_comm_group.{0 u_2 u_2} real
                (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s → real)
                E
                real.ring
                (@pi.add_comm_group.{u_2 0}
                   (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s)
                   (λ
                    (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                      real)
                   (λ
                    (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                      real.add_comm_group))
                _inst_1
                (@pi.module.{u_2 0 0}
                   (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s)
                   (λ
                    (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                      real)
                   real
                   real.ring
                   (λ
                    (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                      real.add_comm_group)
                   (λ
                    (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                      @ring.to_module.{0} real real.ring))
                _inst_2))
          (@finset.univ.{u_2}
             (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s)
             (@set.finite.fintype.{u_2} E s hs))
          (λ (x : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
             @linear_map.smul_right.{0 u_2 u_2} real E
               (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s → real)
               real.ring
               _inst_1
               (@pi.add_comm_group.{u_2 0}
                  (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s)
                  (λ
                   (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                     real)
                  (λ
                   (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                     real.add_comm_group))
               _inst_2
               (@pi.module.{u_2 0 0}
                  (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s)
                  (λ
                   (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                     real)
                  real
                  real.ring
                  (λ
                   (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                     real.add_comm_group)
                  (λ
                   (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                     @ring.to_module.{0} real real.ring))
               (@linear_map.proj.{0 u_2 0} real
                  (@coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s)
                  real.ring
                  (λ
                   (a : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                     real)
                  (λ
                   (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                     real.add_comm_group)
                  (λ
                   (i : @coe_sort.{(max (u_2+1) 1) (max 1 (u_2+1))+1} (set.{u_2} E) (@set.has_coe_to_sort.{u_2} E) s),
                     @ring.to_module.{0} real real.ring)
                  x)
               (@subtype.val.{u_2+1} E (λ (x : E), @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x s)
                  x))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>113  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>114  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>115  /-- Convex hull of a finite set is closed. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>116  lemma set.finite.is_closed_convex_hull [t2_space E] {s : set E} (hs : finite s) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='blue'><a title='t2_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='set.finite'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/separation.lean&#x27;, &#x27;line&#x27;: 139, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/finite.lean&#x27;, &#x27;line&#x27;: 20, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='green'><a title='Π (α : Type u_2) [_inst_2 : topological_space.{u_2} α], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {α : Type u}, set.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_2} E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='orange'><a title='A T₂ space, also known as a Hausdorff space, is one in which for every
 `x ≠ y` there exists disjoint open sets around `x` and `y`. This is
 the most widely used of the separation axioms.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='orange'><a title='A set is finite if the subtype is a fintype, i.e. there is a
 list that enumerates its members.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>117    is_closed (convex_hull s) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='is_closed'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='convex_hull'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 126, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/convex/basic.lean&#x27;, &#x27;line&#x27;: 703, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [_inst_1 : topological_space.{u} α], set.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {E : Type u} [_inst_1 : add_comm_group.{u} E] [_inst_2 : @vector_space.{0 u} real E real.discrete_field _inst_1], set.{u} E → set.{u} E'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_2} E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='A set is closed if its complement is open'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Convex hull of a set `s` is the minimal convex set that includes `s`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>118  closed_of_compact _ hs.compact_convex_hull</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='closed_of_compact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='hs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='set.finite.compact_convex_hull'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/separation.lean&#x27;, &#x27;line&#x27;: 267, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 106, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_2} [_inst_1 : topological_space.{u_2} α] [_inst_3 : @t2_space.{u_2} α _inst_1] (s : set.{u_2} α), @compact.{u_2} α _inst_1 s → @is_closed.{u_2} α _inst_1 s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@set.finite.{u_2} E s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {E : Type u_2} [_inst_1 : add_comm_group.{u_2} E] [_inst_2 : @vector_space.{0 u_2} real E real.discrete_field _inst_1] [_inst_3 : topological_space.{u_2} E] [_inst_4 : @topological_add_group.{u_2} E _inst_3 (@add_comm_group.to_add_group.{u_2} E _inst_1)] [_inst_5 : @topological_vector_space.{0 u_2} real E real.discrete_field (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)) _inst_3 _inst_1 _inst_2] {s : set.{u_2} E}, @set.finite.{u_2} E s → @compact.{u_2} E _inst_3 (@convex_hull.{u_2} E _inst_1 _inst_2 s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='orange'><a title='Convex hull of a finite set is compact.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>119  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>120  end topological_vector_space</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>121  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>122  /-! ### Normed vector space -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>123  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>124  section normed_space</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>125  variables [normed_group E] [normed_space ℝ E]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='normed_group'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='normed_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 33, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 600, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/basic.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Type u_2 → Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π (α : Type) (β : Type u_2) [_inst_1 : normed_field.{0} α] [_inst_2 : normed_group.{u_2} β], Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title=' A normed group is an additive group endowed with a norm for which `dist x y = ∥x - y∥` defines
a metric space structure.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title=' A normed space over a normed field is a vector space endowed with a norm which satisfies the
equality `∥c • x∥ = ∥c∥ ∥x∥`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>126  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>127  lemma convex_on_dist (z : E) (s : set E) (hs : convex s) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='blue'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='convex'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/convex/basic.lean&#x27;, &#x27;line&#x27;: 124, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {E : Type u} [_inst_1 : add_comm_group.{u} E] [_inst_2 : @vector_space.{0 u} real E real.discrete_field _inst_1], set.{u} E → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_2} E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                               </code><font color='orange'><a title='Convexity of sets'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>128    convex_on s (λz&#x27;, dist z&#x27; z) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='convex_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='z&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_dist.dist'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='z&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/convex/basic.lean&#x27;, &#x27;line&#x27;: 368, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/metric_space/basic.lean&#x27;, &#x27;line&#x27;: 45, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {E : Type u} [_inst_1 : add_comm_group.{u} E] [_inst_2 : @vector_space.{0 u} real E real.discrete_field _inst_1], set.{u} E → (E → real) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_2} E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} [c : has_dist.{u_1} α], α → α → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Convexity of functions'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>129  and.intro hs $</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='and.intro'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, a → b → and a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@convex.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1) (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>130  assume x y hx hy a b ha hb hab,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hx'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ha'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hb'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hab'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_le.le.{0} real real.has_le (@has_zero.zero.{0} real (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_le.le.{0} real real.has_le (@has_zero.zero.{0} real (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))) b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@eq.{1} real (@has_add.add.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring)) a b) (@has_one.one.{0} real (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>131  calc</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>132    dist (a • x + b • y) z = ∥ (a • x + b • y) - (a + b) • z ∥ :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_dist.dist'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_scalar.smul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_scalar.smul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='has_norm.norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_scalar.smul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_scalar.smul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_sub.sub'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_scalar.smul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_norm.norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/metric_space/basic.lean&#x27;, &#x27;line&#x27;: 45, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/group_action.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/group_action.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 23, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/group_action.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/group_action.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 315, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/group_action.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 23, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_2} [c : has_dist.{u_2} α], α → α → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} {γ : Type u_2} [c : has_scalar.{0 u_2} α γ], α → γ → γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_2} [c : has_add.{u_2} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} {γ : Type u_2} [c : has_scalar.{0 u_2} α γ], α → γ → γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u_2} [c : has_norm.{u_2} α], α → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} {γ : Type u_2} [c : has_scalar.{0 u_2} α γ], α → γ → γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_2} [c : has_add.{u_2} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} {γ : Type u_2} [c : has_scalar.{0 u_2} α γ], α → γ → γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_2} [c : has_sub.{u_2} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_add.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type} {γ : Type u_2} [c : has_scalar.{0 u_2} α γ], α → γ → γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_2} [c : has_norm.{u_2} α], α → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>133      by rw [hab, one_smul, normed_group.dist_eq]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='hab'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='one_smul'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='normed_group.dist_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/group_action.lean&#x27;, &#x27;line&#x27;: 32, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 33, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{1} real (@has_add.add.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring)) a b) (@has_one.one.{0} real (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (α : Type) {β : Type u_2} [_inst_1 : monoid.{0} α] [_inst_2 : @mul_action.{0 u_2} α β _inst_1] (b : β), @eq.{u_2+1} β (@has_scalar.smul.{0 u_2} α β (@mul_action.to_has_scalar.{0 u_2} α β _inst_1 _inst_2) (@has_one.one.{0} α (@monoid.to_has_one.{0} α _inst_1)) b) b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_2} [c : normed_group.{u_2} α] (x y : α), @eq.{1} real (@has_dist.dist.{u_2} α (@metric_space.to_has_dist.{u_2} α (@normed_group.to_metric_space.{u_2} α c)) x y) (@has_norm.norm.{u_2} α (@normed_group.to_has_norm.{u_2} α c) (@has_sub.sub.{u_2} α (@add_group_has_sub.{u_2} α (@add_comm_group.to_add_group.{u_2} α (@normed_group.to_add_comm_group.{u_2} α c))) x y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='lime'><a title='E : Type u_2,
_inst_1 : normed_group.{u_2} E,
_inst_2 : @normed_space.{0 u_2} real E normed_field.normed_field _inst_1,
z : E,
s : set.{u_2} E,
hs :
  @convex.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)
    (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2)
    s,
x y : E,
hx : @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x s,
hy : @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y s,
a b : real,
ha :
  @has_le.le.{0} real real.has_le
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    a,
hb :
  @has_le.le.{0} real real.has_le
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    b,
hab :
  @eq.{1} real (@has_add.add.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring)) a b)
    (@has_one.one.{0} real (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain)))
⊢ @eq.{1} real
    (@has_dist.dist.{u_2} E (@metric_space.to_has_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_1))
       (@has_add.add.{u_2} E
          (@add_semigroup.to_has_add.{u_2} E
             (@add_monoid.to_add_semigroup.{u_2} E
                (@add_group.to_add_monoid.{u_2} E
                   (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)))))
          (@has_scalar.smul.{0 u_2} real E
             (@mul_action.to_has_scalar.{0 u_2} real E real.monoid
                (@distrib_mul_action.to_mul_action.{0 u_2} real E real.monoid
                   (@add_group.to_add_monoid.{u_2} E
                      (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)))
                   (@semimodule.to_distrib_mul_action.{0 u_2} real E real.semiring
                      (@add_comm_group.to_add_comm_monoid.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1))
                      (@module.to_semimodule.{0 u_2} real E real.ring (@normed_group.to_add_comm_group.{u_2} E _inst_1)
                         (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2)))))
             a
             x)
          (@has_scalar.smul.{0 u_2} real E
             (@mul_action.to_has_scalar.{0 u_2} real E real.monoid
                (@distrib_mul_action.to_mul_action.{0 u_2} real E real.monoid
                   (@add_group.to_add_monoid.{u_2} E
                      (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)))
                   (@semimodule.to_distrib_mul_action.{0 u_2} real E real.semiring
                      (@add_comm_group.to_add_comm_monoid.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1))
                      (@module.to_semimodule.{0 u_2} real E real.ring (@normed_group.to_add_comm_group.{u_2} E _inst_1)
                         (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2)))))
             b
             y))
       z)
    (@has_norm.norm.{u_2} E (@normed_group.to_has_norm.{u_2} E _inst_1)
       (@has_sub.sub.{u_2} E
          (@add_group_has_sub.{u_2} E
             (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)))
          (@has_add.add.{u_2} E
             (@add_semigroup.to_has_add.{u_2} E
                (@add_monoid.to_add_semigroup.{u_2} E
                   (@add_group.to_add_monoid.{u_2} E
                      (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)))))
             (@has_scalar.smul.{0 u_2} real E
                (@mul_action.to_has_scalar.{0 u_2} real E real.monoid
                   (@distrib_mul_action.to_mul_action.{0 u_2} real E real.monoid
                      (@add_group.to_add_monoid.{u_2} E
                         (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)))
                      (@semimodule.to_distrib_mul_action.{0 u_2} real E real.semiring
                         (@add_comm_group.to_add_comm_monoid.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1))
                         (@module.to_semimodule.{0 u_2} real E real.ring
                            (@normed_group.to_add_comm_group.{u_2} E _inst_1)
                            (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2)))))
                a
                x)
             (@has_scalar.smul.{0 u_2} real E
                (@mul_action.to_has_scalar.{0 u_2} real E real.monoid
                   (@distrib_mul_action.to_mul_action.{0 u_2} real E real.monoid
                      (@add_group.to_add_monoid.{u_2} E
                         (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)))
                      (@semimodule.to_distrib_mul_action.{0 u_2} real E real.semiring
                         (@add_comm_group.to_add_comm_monoid.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1))
                         (@module.to_semimodule.{0 u_2} real E real.ring
                            (@normed_group.to_add_comm_group.{u_2} E _inst_1)
                            (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2)))))
                b
                y))
          (@has_scalar.smul.{0 u_2} real E
             (@mul_action.to_has_scalar.{0 u_2} real E real.monoid
                (@distrib_mul_action.to_mul_action.{0 u_2} real E real.monoid
                   (@add_group.to_add_monoid.{u_2} E
                      (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)))
                   (@semimodule.to_distrib_mul_action.{0 u_2} real E real.semiring
                      (@add_comm_group.to_add_comm_monoid.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1))
                      (@module.to_semimodule.{0 u_2} real E real.ring (@normed_group.to_add_comm_group.{u_2} E _inst_1)
                         (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2)))))
             (@has_add.add.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring)) a b)
             z)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='E : Type u_2,
_inst_1 : normed_group.{u_2} E,
_inst_2 : @normed_space.{0 u_2} real E normed_field.normed_field _inst_1,
z : E,
s : set.{u_2} E,
hs :
  @convex.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)
    (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2)
    s,
x y : E,
hx : @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x s,
hy : @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y s,
a b : real,
ha :
  @has_le.le.{0} real real.has_le
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    a,
hb :
  @has_le.le.{0} real real.has_le
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    b,
hab :
  @eq.{1} real (@has_add.add.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring)) a b)
    (@has_one.one.{0} real (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain)))
⊢ @eq.{1} real
    (@has_dist.dist.{u_2} E (@metric_space.to_has_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_1))
       (@has_add.add.{u_2} E
          (@add_semigroup.to_has_add.{u_2} E
             (@add_monoid.to_add_semigroup.{u_2} E
                (@add_group.to_add_monoid.{u_2} E
                   (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)))))
          (@has_scalar.smul.{0 u_2} real E
             (@mul_action.to_has_scalar.{0 u_2} real E real.monoid
                (@distrib_mul_action.to_mul_action.{0 u_2} real E real.monoid
                   (@add_group.to_add_monoid.{u_2} E
                      (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)))
                   (@semimodule.to_distrib_mul_action.{0 u_2} real E real.semiring
                      (@add_comm_group.to_add_comm_monoid.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1))
                      (@module.to_semimodule.{0 u_2} real E real.ring (@normed_group.to_add_comm_group.{u_2} E _inst_1)
                         (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2)))))
             a
             x)
          (@has_scalar.smul.{0 u_2} real E
             (@mul_action.to_has_scalar.{0 u_2} real E real.monoid
                (@distrib_mul_action.to_mul_action.{0 u_2} real E real.monoid
                   (@add_group.to_add_monoid.{u_2} E
                      (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)))
                   (@semimodule.to_distrib_mul_action.{0 u_2} real E real.semiring
                      (@add_comm_group.to_add_comm_monoid.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1))
                      (@module.to_semimodule.{0 u_2} real E real.ring (@normed_group.to_add_comm_group.{u_2} E _inst_1)
                         (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2)))))
             b
             y))
       z)
    (@has_norm.norm.{u_2} E (@normed_group.to_has_norm.{u_2} E _inst_1)
       (@has_sub.sub.{u_2} E
          (@add_group_has_sub.{u_2} E
             (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)))
          (@has_add.add.{u_2} E
             (@add_semigroup.to_has_add.{u_2} E
                (@add_monoid.to_add_semigroup.{u_2} E
                   (@add_group.to_add_monoid.{u_2} E
                      (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)))))
             (@has_scalar.smul.{0 u_2} real E
                (@mul_action.to_has_scalar.{0 u_2} real E real.monoid
                   (@distrib_mul_action.to_mul_action.{0 u_2} real E real.monoid
                      (@add_group.to_add_monoid.{u_2} E
                         (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)))
                      (@semimodule.to_distrib_mul_action.{0 u_2} real E real.semiring
                         (@add_comm_group.to_add_comm_monoid.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1))
                         (@module.to_semimodule.{0 u_2} real E real.ring
                            (@normed_group.to_add_comm_group.{u_2} E _inst_1)
                            (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2)))))
                a
                x)
             (@has_scalar.smul.{0 u_2} real E
                (@mul_action.to_has_scalar.{0 u_2} real E real.monoid
                   (@distrib_mul_action.to_mul_action.{0 u_2} real E real.monoid
                      (@add_group.to_add_monoid.{u_2} E
                         (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)))
                      (@semimodule.to_distrib_mul_action.{0 u_2} real E real.semiring
                         (@add_comm_group.to_add_comm_monoid.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1))
                         (@module.to_semimodule.{0 u_2} real E real.ring
                            (@normed_group.to_add_comm_group.{u_2} E _inst_1)
                            (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2)))))
                b
                y))
          (@has_scalar.smul.{0 u_2} real E
             (@mul_action.to_has_scalar.{0 u_2} real E real.monoid
                (@distrib_mul_action.to_mul_action.{0 u_2} real E real.monoid
                   (@add_group.to_add_monoid.{u_2} E
                      (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)))
                   (@semimodule.to_distrib_mul_action.{0 u_2} real E real.semiring
                      (@add_comm_group.to_add_comm_monoid.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1))
                      (@module.to_semimodule.{0 u_2} real E real.ring (@normed_group.to_add_comm_group.{u_2} E _inst_1)
                         (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2)))))
             (@has_one.one.{0} real
                (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain)))
             z)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='E : Type u_2,
_inst_1 : normed_group.{u_2} E,
_inst_2 : @normed_space.{0 u_2} real E normed_field.normed_field _inst_1,
z : E,
s : set.{u_2} E,
hs :
  @convex.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)
    (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2)
    s,
x y : E,
hx : @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x s,
hy : @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y s,
a b : real,
ha :
  @has_le.le.{0} real real.has_le
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    a,
hb :
  @has_le.le.{0} real real.has_le
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    b,
hab :
  @eq.{1} real (@has_add.add.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring)) a b)
    (@has_one.one.{0} real (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain)))
⊢ @eq.{1} real
    (@has_dist.dist.{u_2} E (@metric_space.to_has_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_1))
       (@has_add.add.{u_2} E
          (@add_semigroup.to_has_add.{u_2} E
             (@add_monoid.to_add_semigroup.{u_2} E
                (@add_group.to_add_monoid.{u_2} E
                   (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)))))
          (@has_scalar.smul.{0 u_2} real E
             (@mul_action.to_has_scalar.{0 u_2} real E real.monoid
                (@distrib_mul_action.to_mul_action.{0 u_2} real E real.monoid
                   (@add_group.to_add_monoid.{u_2} E
                      (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)))
                   (@semimodule.to_distrib_mul_action.{0 u_2} real E real.semiring
                      (@add_comm_group.to_add_comm_monoid.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1))
                      (@module.to_semimodule.{0 u_2} real E real.ring (@normed_group.to_add_comm_group.{u_2} E _inst_1)
                         (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2)))))
             a
             x)
          (@has_scalar.smul.{0 u_2} real E
             (@mul_action.to_has_scalar.{0 u_2} real E real.monoid
                (@distrib_mul_action.to_mul_action.{0 u_2} real E real.monoid
                   (@add_group.to_add_monoid.{u_2} E
                      (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)))
                   (@semimodule.to_distrib_mul_action.{0 u_2} real E real.semiring
                      (@add_comm_group.to_add_comm_monoid.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1))
                      (@module.to_semimodule.{0 u_2} real E real.ring (@normed_group.to_add_comm_group.{u_2} E _inst_1)
                         (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2)))))
             b
             y))
       z)
    (@has_norm.norm.{u_2} E (@normed_group.to_has_norm.{u_2} E _inst_1)
       (@has_sub.sub.{u_2} E
          (@add_group_has_sub.{u_2} E
             (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)))
          (@has_add.add.{u_2} E
             (@add_semigroup.to_has_add.{u_2} E
                (@add_monoid.to_add_semigroup.{u_2} E
                   (@add_group.to_add_monoid.{u_2} E
                      (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)))))
             (@has_scalar.smul.{0 u_2} real E
                (@mul_action.to_has_scalar.{0 u_2} real E real.monoid
                   (@distrib_mul_action.to_mul_action.{0 u_2} real E real.monoid
                      (@add_group.to_add_monoid.{u_2} E
                         (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)))
                      (@semimodule.to_distrib_mul_action.{0 u_2} real E real.semiring
                         (@add_comm_group.to_add_comm_monoid.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1))
                         (@module.to_semimodule.{0 u_2} real E real.ring
                            (@normed_group.to_add_comm_group.{u_2} E _inst_1)
                            (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2)))))
                a
                x)
             (@has_scalar.smul.{0 u_2} real E
                (@mul_action.to_has_scalar.{0 u_2} real E real.monoid
                   (@distrib_mul_action.to_mul_action.{0 u_2} real E real.monoid
                      (@add_group.to_add_monoid.{u_2} E
                         (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)))
                      (@semimodule.to_distrib_mul_action.{0 u_2} real E real.semiring
                         (@add_comm_group.to_add_comm_monoid.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1))
                         (@module.to_semimodule.{0 u_2} real E real.ring
                            (@normed_group.to_add_comm_group.{u_2} E _inst_1)
                            (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2)))))
                b
                y))
          z))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='E : Type u_2,
_inst_1 : normed_group.{u_2} E,
_inst_2 : @normed_space.{0 u_2} real E normed_field.normed_field _inst_1,
z : E,
s : set.{u_2} E,
hs :
  @convex.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)
    (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2)
    s,
x y : E,
hx : @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x s,
hy : @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y s,
a b : real,
ha :
  @has_le.le.{0} real real.has_le
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    a,
hb :
  @has_le.le.{0} real real.has_le
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    b,
hab :
  @eq.{1} real (@has_add.add.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring)) a b)
    (@has_one.one.{0} real (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain)))
⊢ @eq.{1} real
    (@has_dist.dist.{u_2} E (@metric_space.to_has_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_1))
       (@has_add.add.{u_2} E
          (@add_semigroup.to_has_add.{u_2} E
             (@add_monoid.to_add_semigroup.{u_2} E
                (@add_group.to_add_monoid.{u_2} E
                   (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)))))
          (@has_scalar.smul.{0 u_2} real E
             (@mul_action.to_has_scalar.{0 u_2} real E real.monoid
                (@distrib_mul_action.to_mul_action.{0 u_2} real E real.monoid
                   (@add_group.to_add_monoid.{u_2} E
                      (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)))
                   (@semimodule.to_distrib_mul_action.{0 u_2} real E real.semiring
                      (@add_comm_group.to_add_comm_monoid.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1))
                      (@module.to_semimodule.{0 u_2} real E real.ring (@normed_group.to_add_comm_group.{u_2} E _inst_1)
                         (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2)))))
             a
             x)
          (@has_scalar.smul.{0 u_2} real E
             (@mul_action.to_has_scalar.{0 u_2} real E real.monoid
                (@distrib_mul_action.to_mul_action.{0 u_2} real E real.monoid
                   (@add_group.to_add_monoid.{u_2} E
                      (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)))
                   (@semimodule.to_distrib_mul_action.{0 u_2} real E real.semiring
                      (@add_comm_group.to_add_comm_monoid.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1))
                      (@module.to_semimodule.{0 u_2} real E real.ring (@normed_group.to_add_comm_group.{u_2} E _inst_1)
                         (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2)))))
             b
             y))
       z)
    (@has_norm.norm.{u_2} E (@normed_group.to_has_norm.{u_2} E _inst_1)
       (@has_sub.sub.{u_2} E
          (@add_group_has_sub.{u_2} E
             (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)))
          (@has_add.add.{u_2} E
             (@add_semigroup.to_has_add.{u_2} E
                (@add_monoid.to_add_semigroup.{u_2} E
                   (@add_group.to_add_monoid.{u_2} E
                      (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)))))
             (@has_scalar.smul.{0 u_2} real E
                (@mul_action.to_has_scalar.{0 u_2} real E real.monoid
                   (@distrib_mul_action.to_mul_action.{0 u_2} real E real.monoid
                      (@add_group.to_add_monoid.{u_2} E
                         (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)))
                      (@semimodule.to_distrib_mul_action.{0 u_2} real E real.semiring
                         (@add_comm_group.to_add_comm_monoid.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1))
                         (@module.to_semimodule.{0 u_2} real E real.ring
                            (@normed_group.to_add_comm_group.{u_2} E _inst_1)
                            (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2)))))
                a
                x)
             (@has_scalar.smul.{0 u_2} real E
                (@mul_action.to_has_scalar.{0 u_2} real E real.monoid
                   (@distrib_mul_action.to_mul_action.{0 u_2} real E real.monoid
                      (@add_group.to_add_monoid.{u_2} E
                         (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)))
                      (@semimodule.to_distrib_mul_action.{0 u_2} real E real.semiring
                         (@add_comm_group.to_add_comm_monoid.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1))
                         (@module.to_semimodule.{0 u_2} real E real.ring
                            (@normed_group.to_add_comm_group.{u_2} E _inst_1)
                            (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2)))))
                b
                y))
          (@has_scalar.smul.{0 u_2} real E
             (@mul_action.to_has_scalar.{0 u_2} real E real.monoid
                (@distrib_mul_action.to_mul_action.{0 u_2} real E real.monoid
                   (@add_group.to_add_monoid.{u_2} E
                      (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)))
                   (@semimodule.to_distrib_mul_action.{0 u_2} real E real.semiring
                      (@add_comm_group.to_add_comm_monoid.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1))
                      (@module.to_semimodule.{0 u_2} real E real.ring (@normed_group.to_add_comm_group.{u_2} E _inst_1)
                         (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2)))))
             (@has_add.add.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring)) a b)
             z)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>134    ... = ∥a • (x - z) + b • (y - z)∥ :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='has_norm.norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_scalar.smul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_sub.sub'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_scalar.smul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_sub.sub'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_norm.norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 23, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/group_action.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 315, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/group_action.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 315, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 23, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Π {α : Type u_2} [c : has_norm.{u_2} α], α → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} {γ : Type u_2} [c : has_scalar.{0 u_2} α γ], α → γ → γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_2} [c : has_sub.{u_2} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_2} [c : has_add.{u_2} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} {γ : Type u_2} [c : has_scalar.{0 u_2} α γ], α → γ → γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_2} [c : has_sub.{u_2} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_2} [c : has_norm.{u_2} α], α → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='E : Type u_2,
_inst_1 : normed_group.{u_2} E,
_inst_2 : @normed_space.{0 u_2} real E normed_field.normed_field _inst_1,
z : E,
s : set.{u_2} E,
hs :
  @convex.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)
    (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2)
    s,
x y : E,
hx : @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x s,
hy : @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y s,
a b : real,
ha :
  @has_le.le.{0} real real.has_le
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    a,
hb :
  @has_le.le.{0} real real.has_le
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    b,
hab :
  @eq.{1} real (@has_add.add.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring)) a b)
    (@has_one.one.{0} real (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain)))
⊢ @eq.{1} real
    (@has_dist.dist.{u_2} E (@metric_space.to_has_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_1))
       (@has_add.add.{u_2} E
          (@add_semigroup.to_has_add.{u_2} E
             (@add_monoid.to_add_semigroup.{u_2} E
                (@add_group.to_add_monoid.{u_2} E
                   (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)))))
          (@has_scalar.smul.{0 u_2} real E
             (@mul_action.to_has_scalar.{0 u_2} real E real.monoid
                (@distrib_mul_action.to_mul_action.{0 u_2} real E real.monoid
                   (@add_group.to_add_monoid.{u_2} E
                      (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)))
                   (@semimodule.to_distrib_mul_action.{0 u_2} real E real.semiring
                      (@add_comm_group.to_add_comm_monoid.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1))
                      (@module.to_semimodule.{0 u_2} real E real.ring (@normed_group.to_add_comm_group.{u_2} E _inst_1)
                         (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2)))))
             a
             x)
          (@has_scalar.smul.{0 u_2} real E
             (@mul_action.to_has_scalar.{0 u_2} real E real.monoid
                (@distrib_mul_action.to_mul_action.{0 u_2} real E real.monoid
                   (@add_group.to_add_monoid.{u_2} E
                      (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)))
                   (@semimodule.to_distrib_mul_action.{0 u_2} real E real.semiring
                      (@add_comm_group.to_add_comm_monoid.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1))
                      (@module.to_semimodule.{0 u_2} real E real.ring (@normed_group.to_add_comm_group.{u_2} E _inst_1)
                         (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2)))))
             b
             y))
       z)
    (@has_norm.norm.{u_2} E (@normed_group.to_has_norm.{u_2} E _inst_1)
       (@has_sub.sub.{u_2} E
          (@add_group_has_sub.{u_2} E
             (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)))
          (@has_add.add.{u_2} E
             (@add_semigroup.to_has_add.{u_2} E
                (@add_monoid.to_add_semigroup.{u_2} E
                   (@add_group.to_add_monoid.{u_2} E
                      (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)))))
             (@has_scalar.smul.{0 u_2} real E
                (@mul_action.to_has_scalar.{0 u_2} real E real.monoid
                   (@distrib_mul_action.to_mul_action.{0 u_2} real E real.monoid
                      (@add_group.to_add_monoid.{u_2} E
                         (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)))
                      (@semimodule.to_distrib_mul_action.{0 u_2} real E real.semiring
                         (@add_comm_group.to_add_comm_monoid.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1))
                         (@module.to_semimodule.{0 u_2} real E real.ring
                            (@normed_group.to_add_comm_group.{u_2} E _inst_1)
                            (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2)))))
                a
                x)
             (@has_scalar.smul.{0 u_2} real E
                (@mul_action.to_has_scalar.{0 u_2} real E real.monoid
                   (@distrib_mul_action.to_mul_action.{0 u_2} real E real.monoid
                      (@add_group.to_add_monoid.{u_2} E
                         (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)))
                      (@semimodule.to_distrib_mul_action.{0 u_2} real E real.semiring
                         (@add_comm_group.to_add_comm_monoid.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1))
                         (@module.to_semimodule.{0 u_2} real E real.ring
                            (@normed_group.to_add_comm_group.{u_2} E _inst_1)
                            (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2)))))
                b
                y))
          (@has_scalar.smul.{0 u_2} real E
             (@mul_action.to_has_scalar.{0 u_2} real E real.monoid
                (@distrib_mul_action.to_mul_action.{0 u_2} real E real.monoid
                   (@add_group.to_add_monoid.{u_2} E
                      (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)))
                   (@semimodule.to_distrib_mul_action.{0 u_2} real E real.semiring
                      (@add_comm_group.to_add_comm_monoid.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1))
                      (@module.to_semimodule.{0 u_2} real E real.ring (@normed_group.to_add_comm_group.{u_2} E _inst_1)
                         (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2)))))
             (@has_add.add.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring)) a b)
             z)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>135      by rw [add_smul, smul_sub, smul_sub]; simp</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='add_smul'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='smul_sub'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='smul_sub'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/module.lean&#x27;, &#x27;line&#x27;: 45, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/module.lean&#x27;, &#x27;line&#x27;: 112, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/module.lean&#x27;, &#x27;line&#x27;: 112, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} {β : Type u_2} [R : semiring.{0} α] [_inst_1 : add_comm_monoid.{u_2} β] [_inst_2 : @semimodule.{0 u_2} α β R _inst_1] (r s : α) (x : β), @eq.{u_2+1} β (@has_scalar.smul.{0 u_2} α β (@mul_action.to_has_scalar.{0 u_2} α β (@semiring.to_monoid.{0} α R) (@distrib_mul_action.to_mul_action.{0 u_2} α β (@semiring.to_monoid.{0} α R) (@add_comm_monoid.to_add_monoid.{u_2} β _inst_1) (@semimodule.to_distrib_mul_action.{0 u_2} α β R _inst_1 _inst_2))) (@has_add.add.{0} α (@distrib.to_has_add.{0} α (@semiring.to_distrib.{0} α R)) r s) x) (@has_add.add.{u_2} β (@add_semigroup.to_has_add.{u_2} β (@add_monoid.to_add_semigroup.{u_2} β (@add_comm_monoid.to_add_monoid.{u_2} β _inst_1))) (@has_scalar.smul.{0 u_2} α β (@mul_action.to_has_scalar.{0 u_2} α β (@semiring.to_monoid.{0} α R) (@distrib_mul_action.to_mul_action.{0 u_2} α β (@semiring.to_monoid.{0} α R) (@add_comm_monoid.to_add_monoid.{u_2} β _inst_1) (@semimodule.to_distrib_mul_action.{0 u_2} α β R _inst_1 _inst_2))) r x) (@has_scalar.smul.{0 u_2} α β (@mul_action.to_has_scalar.{0 u_2} α β (@semiring.to_monoid.{0} α R) (@distrib_mul_action.to_mul_action.{0 u_2} α β (@semiring.to_monoid.{0} α R) (@add_comm_monoid.to_add_monoid.{u_2} β _inst_1) (@semimodule.to_distrib_mul_action.{0 u_2} α β R _inst_1 _inst_2))) s x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} {β : Type u_2} [_inst_1 : ring.{0} α] [_inst_2 : add_comm_group.{u_2} β] [_inst_3 : @module.{0 u_2} α β _inst_1 _inst_2] (r : α) (x y : β), @eq.{u_2+1} β (@has_scalar.smul.{0 u_2} α β (@mul_action.to_has_scalar.{0 u_2} α β (@ring.to_monoid.{0} α _inst_1) (@distrib_mul_action.to_mul_action.{0 u_2} α β (@ring.to_monoid.{0} α _inst_1) (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_2)) (@semimodule.to_distrib_mul_action.{0 u_2} α β (@ring.to_semiring.{0} α _inst_1) (@add_comm_group.to_add_comm_monoid.{u_2} β _inst_2) (@module.to_semimodule.{0 u_2} α β _inst_1 _inst_2 _inst_3)))) r (@has_sub.sub.{u_2} β (@add_group_has_sub.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_2)) x y)) (@has_sub.sub.{u_2} β (@add_group_has_sub.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_2)) (@has_scalar.smul.{0 u_2} α β (@mul_action.to_has_scalar.{0 u_2} α β (@ring.to_monoid.{0} α _inst_1) (@distrib_mul_action.to_mul_action.{0 u_2} α β (@ring.to_monoid.{0} α _inst_1) (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_2)) (@semimodule.to_distrib_mul_action.{0 u_2} α β (@ring.to_semiring.{0} α _inst_1) (@add_comm_group.to_add_comm_monoid.{u_2} β _inst_2) (@module.to_semimodule.{0 u_2} α β _inst_1 _inst_2 _inst_3)))) r x) (@has_scalar.smul.{0 u_2} α β (@mul_action.to_has_scalar.{0 u_2} α β (@ring.to_monoid.{0} α _inst_1) (@distrib_mul_action.to_mul_action.{0 u_2} α β (@ring.to_monoid.{0} α _inst_1) (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_2)) (@semimodule.to_distrib_mul_action.{0 u_2} α β (@ring.to_semiring.{0} α _inst_1) (@add_comm_group.to_add_comm_monoid.{u_2} β _inst_2) (@module.to_semimodule.{0 u_2} α β _inst_1 _inst_2 _inst_3)))) r y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} {β : Type u_2} [_inst_1 : ring.{0} α] [_inst_2 : add_comm_group.{u_2} β] [_inst_3 : @module.{0 u_2} α β _inst_1 _inst_2] (r : α) (x y : β), @eq.{u_2+1} β (@has_scalar.smul.{0 u_2} α β (@mul_action.to_has_scalar.{0 u_2} α β (@ring.to_monoid.{0} α _inst_1) (@distrib_mul_action.to_mul_action.{0 u_2} α β (@ring.to_monoid.{0} α _inst_1) (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_2)) (@semimodule.to_distrib_mul_action.{0 u_2} α β (@ring.to_semiring.{0} α _inst_1) (@add_comm_group.to_add_comm_monoid.{u_2} β _inst_2) (@module.to_semimodule.{0 u_2} α β _inst_1 _inst_2 _inst_3)))) r (@has_sub.sub.{u_2} β (@add_group_has_sub.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_2)) x y)) (@has_sub.sub.{u_2} β (@add_group_has_sub.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_2)) (@has_scalar.smul.{0 u_2} α β (@mul_action.to_has_scalar.{0 u_2} α β (@ring.to_monoid.{0} α _inst_1) (@distrib_mul_action.to_mul_action.{0 u_2} α β (@ring.to_monoid.{0} α _inst_1) (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_2)) (@semimodule.to_distrib_mul_action.{0 u_2} α β (@ring.to_semiring.{0} α _inst_1) (@add_comm_group.to_add_comm_monoid.{u_2} β _inst_2) (@module.to_semimodule.{0 u_2} α β _inst_1 _inst_2 _inst_3)))) r x) (@has_scalar.smul.{0 u_2} α β (@mul_action.to_has_scalar.{0 u_2} α β (@ring.to_monoid.{0} α _inst_1) (@distrib_mul_action.to_mul_action.{0 u_2} α β (@ring.to_monoid.{0} α _inst_1) (@add_group.to_add_monoid.{u_2} β (@add_comm_group.to_add_group.{u_2} β _inst_2)) (@semimodule.to_distrib_mul_action.{0 u_2} α β (@ring.to_semiring.{0} α _inst_1) (@add_comm_group.to_add_comm_monoid.{u_2} β _inst_2) (@module.to_semimodule.{0 u_2} α β _inst_1 _inst_2 _inst_3)))) r y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='lime'><a title='E : Type u_2,
_inst_1 : normed_group.{u_2} E,
_inst_2 : @normed_space.{0 u_2} real E normed_field.normed_field _inst_1,
z : E,
s : set.{u_2} E,
hs :
  @convex.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)
    (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2)
    s,
x y : E,
hx : @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x s,
hy : @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y s,
a b : real,
ha :
  @has_le.le.{0} real real.has_le
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    a,
hb :
  @has_le.le.{0} real real.has_le
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    b,
hab :
  @eq.{1} real (@has_add.add.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring)) a b)
    (@has_one.one.{0} real (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain)))
⊢ @eq.{1} real
    (@has_norm.norm.{u_2} E (@normed_group.to_has_norm.{u_2} E _inst_1)
       (@has_sub.sub.{u_2} E
          (@add_group_has_sub.{u_2} E
             (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)))
          (@has_add.add.{u_2} E
             (@add_semigroup.to_has_add.{u_2} E
                (@add_monoid.to_add_semigroup.{u_2} E
                   (@add_group.to_add_monoid.{u_2} E
                      (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)))))
             (@has_scalar.smul.{0 u_2} real E
                (@mul_action.to_has_scalar.{0 u_2} real E real.monoid
                   (@distrib_mul_action.to_mul_action.{0 u_2} real E real.monoid
                      (@add_group.to_add_monoid.{u_2} E
                         (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)))
                      (@semimodule.to_distrib_mul_action.{0 u_2} real E real.semiring
                         (@add_comm_group.to_add_comm_monoid.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1))
                         (@module.to_semimodule.{0 u_2} real E real.ring
                            (@normed_group.to_add_comm_group.{u_2} E _inst_1)
                            (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2)))))
                a
                x)
             (@has_scalar.smul.{0 u_2} real E
                (@mul_action.to_has_scalar.{0 u_2} real E real.monoid
                   (@distrib_mul_action.to_mul_action.{0 u_2} real E real.monoid
                      (@add_group.to_add_monoid.{u_2} E
                         (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)))
                      (@semimodule.to_distrib_mul_action.{0 u_2} real E real.semiring
                         (@add_comm_group.to_add_comm_monoid.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1))
                         (@module.to_semimodule.{0 u_2} real E real.ring
                            (@normed_group.to_add_comm_group.{u_2} E _inst_1)
                            (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2)))))
                b
                y))
          (@has_scalar.smul.{0 u_2} real E
             (@mul_action.to_has_scalar.{0 u_2} real E real.monoid
                (@distrib_mul_action.to_mul_action.{0 u_2} real E real.monoid
                   (@add_group.to_add_monoid.{u_2} E
                      (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)))
                   (@semimodule.to_distrib_mul_action.{0 u_2} real E real.semiring
                      (@add_comm_group.to_add_comm_monoid.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1))
                      (@module.to_semimodule.{0 u_2} real E real.ring (@normed_group.to_add_comm_group.{u_2} E _inst_1)
                         (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2)))))
             (@has_add.add.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring)) a b)
             z)))
    (@has_norm.norm.{u_2} E (@normed_group.to_has_norm.{u_2} E _inst_1)
       (@has_add.add.{u_2} E
          (@add_semigroup.to_has_add.{u_2} E
             (@add_monoid.to_add_semigroup.{u_2} E
                (@add_group.to_add_monoid.{u_2} E
                   (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)))))
          (@has_scalar.smul.{0 u_2} real E
             (@mul_action.to_has_scalar.{0 u_2} real E real.monoid
                (@distrib_mul_action.to_mul_action.{0 u_2} real E real.monoid
                   (@add_group.to_add_monoid.{u_2} E
                      (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)))
                   (@semimodule.to_distrib_mul_action.{0 u_2} real E real.semiring
                      (@add_comm_group.to_add_comm_monoid.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1))
                      (@module.to_semimodule.{0 u_2} real E real.ring (@normed_group.to_add_comm_group.{u_2} E _inst_1)
                         (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2)))))
             a
             (@has_sub.sub.{u_2} E
                (@add_group_has_sub.{u_2} E
                   (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)))
                x
                z))
          (@has_scalar.smul.{0 u_2} real E
             (@mul_action.to_has_scalar.{0 u_2} real E real.monoid
                (@distrib_mul_action.to_mul_action.{0 u_2} real E real.monoid
                   (@add_group.to_add_monoid.{u_2} E
                      (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)))
                   (@semimodule.to_distrib_mul_action.{0 u_2} real E real.semiring
                      (@add_comm_group.to_add_comm_monoid.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1))
                      (@module.to_semimodule.{0 u_2} real E real.ring (@normed_group.to_add_comm_group.{u_2} E _inst_1)
                         (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2)))))
             b
             (@has_sub.sub.{u_2} E
                (@add_group_has_sub.{u_2} E
                   (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)))
                y
                z))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='E : Type u_2,
_inst_1 : normed_group.{u_2} E,
_inst_2 : @normed_space.{0 u_2} real E normed_field.normed_field _inst_1,
z : E,
s : set.{u_2} E,
hs :
  @convex.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)
    (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2)
    s,
x y : E,
hx : @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x s,
hy : @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y s,
a b : real,
ha :
  @has_le.le.{0} real real.has_le
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    a,
hb :
  @has_le.le.{0} real real.has_le
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    b,
hab :
  @eq.{1} real (@has_add.add.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring)) a b)
    (@has_one.one.{0} real (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain)))
⊢ @eq.{1} real
    (@has_norm.norm.{u_2} E (@normed_group.to_has_norm.{u_2} E _inst_1)
       (@has_sub.sub.{u_2} E
          (@add_group_has_sub.{u_2} E
             (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)))
          (@has_add.add.{u_2} E
             (@add_semigroup.to_has_add.{u_2} E
                (@add_monoid.to_add_semigroup.{u_2} E
                   (@add_group.to_add_monoid.{u_2} E
                      (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)))))
             (@has_scalar.smul.{0 u_2} real E
                (@mul_action.to_has_scalar.{0 u_2} real E real.monoid
                   (@distrib_mul_action.to_mul_action.{0 u_2} real E real.monoid
                      (@add_group.to_add_monoid.{u_2} E
                         (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)))
                      (@semimodule.to_distrib_mul_action.{0 u_2} real E real.semiring
                         (@add_comm_group.to_add_comm_monoid.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1))
                         (@module.to_semimodule.{0 u_2} real E real.ring
                            (@normed_group.to_add_comm_group.{u_2} E _inst_1)
                            (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2)))))
                a
                x)
             (@has_scalar.smul.{0 u_2} real E
                (@mul_action.to_has_scalar.{0 u_2} real E real.monoid
                   (@distrib_mul_action.to_mul_action.{0 u_2} real E real.monoid
                      (@add_group.to_add_monoid.{u_2} E
                         (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)))
                      (@semimodule.to_distrib_mul_action.{0 u_2} real E real.semiring
                         (@add_comm_group.to_add_comm_monoid.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1))
                         (@module.to_semimodule.{0 u_2} real E real.ring
                            (@normed_group.to_add_comm_group.{u_2} E _inst_1)
                            (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2)))))
                b
                y))
          (@has_add.add.{u_2} E
             (@add_semigroup.to_has_add.{u_2} E
                (@add_monoid.to_add_semigroup.{u_2} E
                   (@add_comm_monoid.to_add_monoid.{u_2} E
                      (@add_comm_group.to_add_comm_monoid.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)))))
             (@has_scalar.smul.{0 u_2} real E
                (@mul_action.to_has_scalar.{0 u_2} real E (@semiring.to_monoid.{0} real real.semiring)
                   (@distrib_mul_action.to_mul_action.{0 u_2} real E (@semiring.to_monoid.{0} real real.semiring)
                      (@add_comm_monoid.to_add_monoid.{u_2} E
                         (@add_comm_group.to_add_comm_monoid.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)))
                      (@semimodule.to_distrib_mul_action.{0 u_2} real E real.semiring
                         (@add_comm_group.to_add_comm_monoid.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1))
                         (@module.to_semimodule.{0 u_2} real E real.ring
                            (@normed_group.to_add_comm_group.{u_2} E _inst_1)
                            (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2)))))
                a
                z)
             (@has_scalar.smul.{0 u_2} real E
                (@mul_action.to_has_scalar.{0 u_2} real E (@semiring.to_monoid.{0} real real.semiring)
                   (@distrib_mul_action.to_mul_action.{0 u_2} real E (@semiring.to_monoid.{0} real real.semiring)
                      (@add_comm_monoid.to_add_monoid.{u_2} E
                         (@add_comm_group.to_add_comm_monoid.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)))
                      (@semimodule.to_distrib_mul_action.{0 u_2} real E real.semiring
                         (@add_comm_group.to_add_comm_monoid.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1))
                         (@module.to_semimodule.{0 u_2} real E real.ring
                            (@normed_group.to_add_comm_group.{u_2} E _inst_1)
                            (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2)))))
                b
                z))))
    (@has_norm.norm.{u_2} E (@normed_group.to_has_norm.{u_2} E _inst_1)
       (@has_add.add.{u_2} E
          (@add_semigroup.to_has_add.{u_2} E
             (@add_monoid.to_add_semigroup.{u_2} E
                (@add_group.to_add_monoid.{u_2} E
                   (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)))))
          (@has_scalar.smul.{0 u_2} real E
             (@mul_action.to_has_scalar.{0 u_2} real E real.monoid
                (@distrib_mul_action.to_mul_action.{0 u_2} real E real.monoid
                   (@add_group.to_add_monoid.{u_2} E
                      (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)))
                   (@semimodule.to_distrib_mul_action.{0 u_2} real E real.semiring
                      (@add_comm_group.to_add_comm_monoid.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1))
                      (@module.to_semimodule.{0 u_2} real E real.ring (@normed_group.to_add_comm_group.{u_2} E _inst_1)
                         (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2)))))
             a
             (@has_sub.sub.{u_2} E
                (@add_group_has_sub.{u_2} E
                   (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)))
                x
                z))
          (@has_scalar.smul.{0 u_2} real E
             (@mul_action.to_has_scalar.{0 u_2} real E real.monoid
                (@distrib_mul_action.to_mul_action.{0 u_2} real E real.monoid
                   (@add_group.to_add_monoid.{u_2} E
                      (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)))
                   (@semimodule.to_distrib_mul_action.{0 u_2} real E real.semiring
                      (@add_comm_group.to_add_comm_monoid.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1))
                      (@module.to_semimodule.{0 u_2} real E real.ring (@normed_group.to_add_comm_group.{u_2} E _inst_1)
                         (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2)))))
             b
             (@has_sub.sub.{u_2} E
                (@add_group_has_sub.{u_2} E
                   (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)))
                y
                z))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='E : Type u_2,
_inst_1 : normed_group.{u_2} E,
_inst_2 : @normed_space.{0 u_2} real E normed_field.normed_field _inst_1,
z : E,
s : set.{u_2} E,
hs :
  @convex.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)
    (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2)
    s,
x y : E,
hx : @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x s,
hy : @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y s,
a b : real,
ha :
  @has_le.le.{0} real real.has_le
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    a,
hb :
  @has_le.le.{0} real real.has_le
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    b,
hab :
  @eq.{1} real (@has_add.add.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring)) a b)
    (@has_one.one.{0} real (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain)))
⊢ @eq.{1} real
    (@has_norm.norm.{u_2} E (@normed_group.to_has_norm.{u_2} E _inst_1)
       (@has_sub.sub.{u_2} E
          (@add_group_has_sub.{u_2} E
             (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)))
          (@has_add.add.{u_2} E
             (@add_semigroup.to_has_add.{u_2} E
                (@add_monoid.to_add_semigroup.{u_2} E
                   (@add_group.to_add_monoid.{u_2} E
                      (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)))))
             (@has_scalar.smul.{0 u_2} real E
                (@mul_action.to_has_scalar.{0 u_2} real E real.monoid
                   (@distrib_mul_action.to_mul_action.{0 u_2} real E real.monoid
                      (@add_group.to_add_monoid.{u_2} E
                         (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)))
                      (@semimodule.to_distrib_mul_action.{0 u_2} real E real.semiring
                         (@add_comm_group.to_add_comm_monoid.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1))
                         (@module.to_semimodule.{0 u_2} real E real.ring
                            (@normed_group.to_add_comm_group.{u_2} E _inst_1)
                            (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2)))))
                a
                x)
             (@has_scalar.smul.{0 u_2} real E
                (@mul_action.to_has_scalar.{0 u_2} real E real.monoid
                   (@distrib_mul_action.to_mul_action.{0 u_2} real E real.monoid
                      (@add_group.to_add_monoid.{u_2} E
                         (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)))
                      (@semimodule.to_distrib_mul_action.{0 u_2} real E real.semiring
                         (@add_comm_group.to_add_comm_monoid.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1))
                         (@module.to_semimodule.{0 u_2} real E real.ring
                            (@normed_group.to_add_comm_group.{u_2} E _inst_1)
                            (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2)))))
                b
                y))
          (@has_add.add.{u_2} E
             (@add_semigroup.to_has_add.{u_2} E
                (@add_monoid.to_add_semigroup.{u_2} E
                   (@add_comm_monoid.to_add_monoid.{u_2} E
                      (@add_comm_group.to_add_comm_monoid.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)))))
             (@has_scalar.smul.{0 u_2} real E
                (@mul_action.to_has_scalar.{0 u_2} real E (@semiring.to_monoid.{0} real real.semiring)
                   (@distrib_mul_action.to_mul_action.{0 u_2} real E (@semiring.to_monoid.{0} real real.semiring)
                      (@add_comm_monoid.to_add_monoid.{u_2} E
                         (@add_comm_group.to_add_comm_monoid.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)))
                      (@semimodule.to_distrib_mul_action.{0 u_2} real E real.semiring
                         (@add_comm_group.to_add_comm_monoid.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1))
                         (@module.to_semimodule.{0 u_2} real E real.ring
                            (@normed_group.to_add_comm_group.{u_2} E _inst_1)
                            (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2)))))
                a
                z)
             (@has_scalar.smul.{0 u_2} real E
                (@mul_action.to_has_scalar.{0 u_2} real E (@semiring.to_monoid.{0} real real.semiring)
                   (@distrib_mul_action.to_mul_action.{0 u_2} real E (@semiring.to_monoid.{0} real real.semiring)
                      (@add_comm_monoid.to_add_monoid.{u_2} E
                         (@add_comm_group.to_add_comm_monoid.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)))
                      (@semimodule.to_distrib_mul_action.{0 u_2} real E real.semiring
                         (@add_comm_group.to_add_comm_monoid.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1))
                         (@module.to_semimodule.{0 u_2} real E real.ring
                            (@normed_group.to_add_comm_group.{u_2} E _inst_1)
                            (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2)))))
                b
                z))))
    (@has_norm.norm.{u_2} E (@normed_group.to_has_norm.{u_2} E _inst_1)
       (@has_add.add.{u_2} E
          (@add_semigroup.to_has_add.{u_2} E
             (@add_monoid.to_add_semigroup.{u_2} E
                (@add_group.to_add_monoid.{u_2} E
                   (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)))))
          (@has_sub.sub.{u_2} E
             (@add_group_has_sub.{u_2} E
                (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)))
             (@has_scalar.smul.{0 u_2} real E
                (@mul_action.to_has_scalar.{0 u_2} real E (@ring.to_monoid.{0} real real.ring)
                   (@distrib_mul_action.to_mul_action.{0 u_2} real E (@ring.to_monoid.{0} real real.ring)
                      (@add_group.to_add_monoid.{u_2} E
                         (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)))
                      (@semimodule.to_distrib_mul_action.{0 u_2} real E (@ring.to_semiring.{0} real real.ring)
                         (@add_comm_group.to_add_comm_monoid.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1))
                         (@module.to_semimodule.{0 u_2} real E real.ring
                            (@normed_group.to_add_comm_group.{u_2} E _inst_1)
                            (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2)))))
                a
                x)
             (@has_scalar.smul.{0 u_2} real E
                (@mul_action.to_has_scalar.{0 u_2} real E (@ring.to_monoid.{0} real real.ring)
                   (@distrib_mul_action.to_mul_action.{0 u_2} real E (@ring.to_monoid.{0} real real.ring)
                      (@add_group.to_add_monoid.{u_2} E
                         (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)))
                      (@semimodule.to_distrib_mul_action.{0 u_2} real E (@ring.to_semiring.{0} real real.ring)
                         (@add_comm_group.to_add_comm_monoid.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1))
                         (@module.to_semimodule.{0 u_2} real E real.ring
                            (@normed_group.to_add_comm_group.{u_2} E _inst_1)
                            (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2)))))
                a
                z))
          (@has_scalar.smul.{0 u_2} real E
             (@mul_action.to_has_scalar.{0 u_2} real E real.monoid
                (@distrib_mul_action.to_mul_action.{0 u_2} real E real.monoid
                   (@add_group.to_add_monoid.{u_2} E
                      (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)))
                   (@semimodule.to_distrib_mul_action.{0 u_2} real E real.semiring
                      (@add_comm_group.to_add_comm_monoid.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1))
                      (@module.to_semimodule.{0 u_2} real E real.ring (@normed_group.to_add_comm_group.{u_2} E _inst_1)
                         (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2)))))
             b
             (@has_sub.sub.{u_2} E
                (@add_group_has_sub.{u_2} E
                   (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)))
                y
                z))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='E : Type u_2,
_inst_1 : normed_group.{u_2} E,
_inst_2 : @normed_space.{0 u_2} real E normed_field.normed_field _inst_1,
z : E,
s : set.{u_2} E,
hs :
  @convex.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)
    (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2)
    s,
x y : E,
hx : @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x s,
hy : @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y s,
a b : real,
ha :
  @has_le.le.{0} real real.has_le
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    a,
hb :
  @has_le.le.{0} real real.has_le
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    b,
hab :
  @eq.{1} real (@has_add.add.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring)) a b)
    (@has_one.one.{0} real (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain)))
⊢ @eq.{1} real
    (@has_norm.norm.{u_2} E (@normed_group.to_has_norm.{u_2} E _inst_1)
       (@has_sub.sub.{u_2} E
          (@add_group_has_sub.{u_2} E
             (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)))
          (@has_add.add.{u_2} E
             (@add_semigroup.to_has_add.{u_2} E
                (@add_monoid.to_add_semigroup.{u_2} E
                   (@add_group.to_add_monoid.{u_2} E
                      (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)))))
             (@has_scalar.smul.{0 u_2} real E
                (@mul_action.to_has_scalar.{0 u_2} real E real.monoid
                   (@distrib_mul_action.to_mul_action.{0 u_2} real E real.monoid
                      (@add_group.to_add_monoid.{u_2} E
                         (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)))
                      (@semimodule.to_distrib_mul_action.{0 u_2} real E real.semiring
                         (@add_comm_group.to_add_comm_monoid.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1))
                         (@module.to_semimodule.{0 u_2} real E real.ring
                            (@normed_group.to_add_comm_group.{u_2} E _inst_1)
                            (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2)))))
                a
                x)
             (@has_scalar.smul.{0 u_2} real E
                (@mul_action.to_has_scalar.{0 u_2} real E real.monoid
                   (@distrib_mul_action.to_mul_action.{0 u_2} real E real.monoid
                      (@add_group.to_add_monoid.{u_2} E
                         (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)))
                      (@semimodule.to_distrib_mul_action.{0 u_2} real E real.semiring
                         (@add_comm_group.to_add_comm_monoid.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1))
                         (@module.to_semimodule.{0 u_2} real E real.ring
                            (@normed_group.to_add_comm_group.{u_2} E _inst_1)
                            (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2)))))
                b
                y))
          (@has_add.add.{u_2} E
             (@add_semigroup.to_has_add.{u_2} E
                (@add_monoid.to_add_semigroup.{u_2} E
                   (@add_comm_monoid.to_add_monoid.{u_2} E
                      (@add_comm_group.to_add_comm_monoid.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)))))
             (@has_scalar.smul.{0 u_2} real E
                (@mul_action.to_has_scalar.{0 u_2} real E (@semiring.to_monoid.{0} real real.semiring)
                   (@distrib_mul_action.to_mul_action.{0 u_2} real E (@semiring.to_monoid.{0} real real.semiring)
                      (@add_comm_monoid.to_add_monoid.{u_2} E
                         (@add_comm_group.to_add_comm_monoid.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)))
                      (@semimodule.to_distrib_mul_action.{0 u_2} real E real.semiring
                         (@add_comm_group.to_add_comm_monoid.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1))
                         (@module.to_semimodule.{0 u_2} real E real.ring
                            (@normed_group.to_add_comm_group.{u_2} E _inst_1)
                            (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2)))))
                a
                z)
             (@has_scalar.smul.{0 u_2} real E
                (@mul_action.to_has_scalar.{0 u_2} real E (@semiring.to_monoid.{0} real real.semiring)
                   (@distrib_mul_action.to_mul_action.{0 u_2} real E (@semiring.to_monoid.{0} real real.semiring)
                      (@add_comm_monoid.to_add_monoid.{u_2} E
                         (@add_comm_group.to_add_comm_monoid.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)))
                      (@semimodule.to_distrib_mul_action.{0 u_2} real E real.semiring
                         (@add_comm_group.to_add_comm_monoid.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1))
                         (@module.to_semimodule.{0 u_2} real E real.ring
                            (@normed_group.to_add_comm_group.{u_2} E _inst_1)
                            (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2)))))
                b
                z))))
    (@has_norm.norm.{u_2} E (@normed_group.to_has_norm.{u_2} E _inst_1)
       (@has_add.add.{u_2} E
          (@add_semigroup.to_has_add.{u_2} E
             (@add_monoid.to_add_semigroup.{u_2} E
                (@add_group.to_add_monoid.{u_2} E
                   (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)))))
          (@has_sub.sub.{u_2} E
             (@add_group_has_sub.{u_2} E
                (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)))
             (@has_scalar.smul.{0 u_2} real E
                (@mul_action.to_has_scalar.{0 u_2} real E (@ring.to_monoid.{0} real real.ring)
                   (@distrib_mul_action.to_mul_action.{0 u_2} real E (@ring.to_monoid.{0} real real.ring)
                      (@add_group.to_add_monoid.{u_2} E
                         (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)))
                      (@semimodule.to_distrib_mul_action.{0 u_2} real E (@ring.to_semiring.{0} real real.ring)
                         (@add_comm_group.to_add_comm_monoid.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1))
                         (@module.to_semimodule.{0 u_2} real E real.ring
                            (@normed_group.to_add_comm_group.{u_2} E _inst_1)
                            (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2)))))
                a
                x)
             (@has_scalar.smul.{0 u_2} real E
                (@mul_action.to_has_scalar.{0 u_2} real E (@ring.to_monoid.{0} real real.ring)
                   (@distrib_mul_action.to_mul_action.{0 u_2} real E (@ring.to_monoid.{0} real real.ring)
                      (@add_group.to_add_monoid.{u_2} E
                         (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)))
                      (@semimodule.to_distrib_mul_action.{0 u_2} real E (@ring.to_semiring.{0} real real.ring)
                         (@add_comm_group.to_add_comm_monoid.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1))
                         (@module.to_semimodule.{0 u_2} real E real.ring
                            (@normed_group.to_add_comm_group.{u_2} E _inst_1)
                            (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2)))))
                a
                z))
          (@has_sub.sub.{u_2} E
             (@add_group_has_sub.{u_2} E
                (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)))
             (@has_scalar.smul.{0 u_2} real E
                (@mul_action.to_has_scalar.{0 u_2} real E (@ring.to_monoid.{0} real real.ring)
                   (@distrib_mul_action.to_mul_action.{0 u_2} real E (@ring.to_monoid.{0} real real.ring)
                      (@add_group.to_add_monoid.{u_2} E
                         (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)))
                      (@semimodule.to_distrib_mul_action.{0 u_2} real E (@ring.to_semiring.{0} real real.ring)
                         (@add_comm_group.to_add_comm_monoid.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1))
                         (@module.to_semimodule.{0 u_2} real E real.ring
                            (@normed_group.to_add_comm_group.{u_2} E _inst_1)
                            (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2)))))
                b
                y)
             (@has_scalar.smul.{0 u_2} real E
                (@mul_action.to_has_scalar.{0 u_2} real E (@ring.to_monoid.{0} real real.ring)
                   (@distrib_mul_action.to_mul_action.{0 u_2} real E (@ring.to_monoid.{0} real real.ring)
                      (@add_group.to_add_monoid.{u_2} E
                         (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)))
                      (@semimodule.to_distrib_mul_action.{0 u_2} real E (@ring.to_semiring.{0} real real.ring)
                         (@add_comm_group.to_add_comm_monoid.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1))
                         (@module.to_semimodule.{0 u_2} real E real.ring
                            (@normed_group.to_add_comm_group.{u_2} E _inst_1)
                            (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2)))))
                b
                z))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='E : Type u_2,
_inst_1 : normed_group.{u_2} E,
_inst_2 : @normed_space.{0 u_2} real E normed_field.normed_field _inst_1,
z : E,
s : set.{u_2} E,
hs :
  @convex.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)
    (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2)
    s,
x y : E,
hx : @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x s,
hy : @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y s,
a b : real,
ha :
  @has_le.le.{0} real real.has_le
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    a,
hb :
  @has_le.le.{0} real real.has_le
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    b,
hab :
  @eq.{1} real (@has_add.add.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring)) a b)
    (@has_one.one.{0} real (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain)))
⊢ @eq.{1} real
    (@has_norm.norm.{u_2} E (@normed_group.to_has_norm.{u_2} E _inst_1)
       (@has_sub.sub.{u_2} E
          (@add_group_has_sub.{u_2} E
             (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)))
          (@has_add.add.{u_2} E
             (@add_semigroup.to_has_add.{u_2} E
                (@add_monoid.to_add_semigroup.{u_2} E
                   (@add_group.to_add_monoid.{u_2} E
                      (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)))))
             (@has_scalar.smul.{0 u_2} real E
                (@mul_action.to_has_scalar.{0 u_2} real E real.monoid
                   (@distrib_mul_action.to_mul_action.{0 u_2} real E real.monoid
                      (@add_group.to_add_monoid.{u_2} E
                         (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)))
                      (@semimodule.to_distrib_mul_action.{0 u_2} real E real.semiring
                         (@add_comm_group.to_add_comm_monoid.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1))
                         (@module.to_semimodule.{0 u_2} real E real.ring
                            (@normed_group.to_add_comm_group.{u_2} E _inst_1)
                            (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2)))))
                a
                x)
             (@has_scalar.smul.{0 u_2} real E
                (@mul_action.to_has_scalar.{0 u_2} real E real.monoid
                   (@distrib_mul_action.to_mul_action.{0 u_2} real E real.monoid
                      (@add_group.to_add_monoid.{u_2} E
                         (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)))
                      (@semimodule.to_distrib_mul_action.{0 u_2} real E real.semiring
                         (@add_comm_group.to_add_comm_monoid.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1))
                         (@module.to_semimodule.{0 u_2} real E real.ring
                            (@normed_group.to_add_comm_group.{u_2} E _inst_1)
                            (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2)))))
                b
                y))
          (@has_scalar.smul.{0 u_2} real E
             (@mul_action.to_has_scalar.{0 u_2} real E real.monoid
                (@distrib_mul_action.to_mul_action.{0 u_2} real E real.monoid
                   (@add_group.to_add_monoid.{u_2} E
                      (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)))
                   (@semimodule.to_distrib_mul_action.{0 u_2} real E real.semiring
                      (@add_comm_group.to_add_comm_monoid.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1))
                      (@module.to_semimodule.{0 u_2} real E real.ring (@normed_group.to_add_comm_group.{u_2} E _inst_1)
                         (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2)))))
             (@has_add.add.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring)) a b)
             z)))
    (@has_norm.norm.{u_2} E (@normed_group.to_has_norm.{u_2} E _inst_1)
       (@has_add.add.{u_2} E
          (@add_semigroup.to_has_add.{u_2} E
             (@add_monoid.to_add_semigroup.{u_2} E
                (@add_group.to_add_monoid.{u_2} E
                   (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)))))
          (@has_scalar.smul.{0 u_2} real E
             (@mul_action.to_has_scalar.{0 u_2} real E real.monoid
                (@distrib_mul_action.to_mul_action.{0 u_2} real E real.monoid
                   (@add_group.to_add_monoid.{u_2} E
                      (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)))
                   (@semimodule.to_distrib_mul_action.{0 u_2} real E real.semiring
                      (@add_comm_group.to_add_comm_monoid.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1))
                      (@module.to_semimodule.{0 u_2} real E real.ring (@normed_group.to_add_comm_group.{u_2} E _inst_1)
                         (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2)))))
             a
             (@has_sub.sub.{u_2} E
                (@add_group_has_sub.{u_2} E
                   (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)))
                x
                z))
          (@has_scalar.smul.{0 u_2} real E
             (@mul_action.to_has_scalar.{0 u_2} real E real.monoid
                (@distrib_mul_action.to_mul_action.{0 u_2} real E real.monoid
                   (@add_group.to_add_monoid.{u_2} E
                      (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)))
                   (@semimodule.to_distrib_mul_action.{0 u_2} real E real.semiring
                      (@add_comm_group.to_add_comm_monoid.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1))
                      (@module.to_semimodule.{0 u_2} real E real.ring (@normed_group.to_add_comm_group.{u_2} E _inst_1)
                         (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2)))))
             b
             (@has_sub.sub.{u_2} E
                (@add_group_has_sub.{u_2} E
                   (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)))
                y
                z))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>136    ... ≤ ∥a • (x - z)∥ + ∥b • (y - z)∥ :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='has_norm.norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_scalar.smul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_sub.sub'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_norm.norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_norm.norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_scalar.smul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_sub.sub'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_norm.norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 23, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/group_action.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 315, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 23, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 23, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/group_action.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 315, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 23, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Π {α : Type u_2} [c : has_norm.{u_2} α], α → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} {γ : Type u_2} [c : has_scalar.{0 u_2} α γ], α → γ → γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_2} [c : has_sub.{u_2} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_2} [c : has_norm.{u_2} α], α → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_add.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_2} [c : has_norm.{u_2} α], α → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} {γ : Type u_2} [c : has_scalar.{0 u_2} α γ], α → γ → γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_2} [c : has_sub.{u_2} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_2} [c : has_norm.{u_2} α], α → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='E : Type u_2,
_inst_1 : normed_group.{u_2} E,
_inst_2 : @normed_space.{0 u_2} real E normed_field.normed_field _inst_1,
z : E,
s : set.{u_2} E,
hs :
  @convex.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)
    (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2)
    s,
x y : E,
hx : @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x s,
hy : @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y s,
a b : real,
ha :
  @has_le.le.{0} real real.has_le
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    a,
hb :
  @has_le.le.{0} real real.has_le
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    b,
hab :
  @eq.{1} real (@has_add.add.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring)) a b)
    (@has_one.one.{0} real (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain)))
⊢ @eq.{1} real
    (@has_norm.norm.{u_2} E (@normed_group.to_has_norm.{u_2} E _inst_1)
       (@has_sub.sub.{u_2} E
          (@add_group_has_sub.{u_2} E
             (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)))
          (@has_add.add.{u_2} E
             (@add_semigroup.to_has_add.{u_2} E
                (@add_monoid.to_add_semigroup.{u_2} E
                   (@add_group.to_add_monoid.{u_2} E
                      (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)))))
             (@has_scalar.smul.{0 u_2} real E
                (@mul_action.to_has_scalar.{0 u_2} real E real.monoid
                   (@distrib_mul_action.to_mul_action.{0 u_2} real E real.monoid
                      (@add_group.to_add_monoid.{u_2} E
                         (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)))
                      (@semimodule.to_distrib_mul_action.{0 u_2} real E real.semiring
                         (@add_comm_group.to_add_comm_monoid.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1))
                         (@module.to_semimodule.{0 u_2} real E real.ring
                            (@normed_group.to_add_comm_group.{u_2} E _inst_1)
                            (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2)))))
                a
                x)
             (@has_scalar.smul.{0 u_2} real E
                (@mul_action.to_has_scalar.{0 u_2} real E real.monoid
                   (@distrib_mul_action.to_mul_action.{0 u_2} real E real.monoid
                      (@add_group.to_add_monoid.{u_2} E
                         (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)))
                      (@semimodule.to_distrib_mul_action.{0 u_2} real E real.semiring
                         (@add_comm_group.to_add_comm_monoid.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1))
                         (@module.to_semimodule.{0 u_2} real E real.ring
                            (@normed_group.to_add_comm_group.{u_2} E _inst_1)
                            (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2)))))
                b
                y))
          (@has_scalar.smul.{0 u_2} real E
             (@mul_action.to_has_scalar.{0 u_2} real E real.monoid
                (@distrib_mul_action.to_mul_action.{0 u_2} real E real.monoid
                   (@add_group.to_add_monoid.{u_2} E
                      (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)))
                   (@semimodule.to_distrib_mul_action.{0 u_2} real E real.semiring
                      (@add_comm_group.to_add_comm_monoid.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1))
                      (@module.to_semimodule.{0 u_2} real E real.ring (@normed_group.to_add_comm_group.{u_2} E _inst_1)
                         (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2)))))
             (@has_add.add.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring)) a b)
             z)))
    (@has_norm.norm.{u_2} E (@normed_group.to_has_norm.{u_2} E _inst_1)
       (@has_add.add.{u_2} E
          (@add_semigroup.to_has_add.{u_2} E
             (@add_monoid.to_add_semigroup.{u_2} E
                (@add_group.to_add_monoid.{u_2} E
                   (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)))))
          (@has_scalar.smul.{0 u_2} real E
             (@mul_action.to_has_scalar.{0 u_2} real E real.monoid
                (@distrib_mul_action.to_mul_action.{0 u_2} real E real.monoid
                   (@add_group.to_add_monoid.{u_2} E
                      (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)))
                   (@semimodule.to_distrib_mul_action.{0 u_2} real E real.semiring
                      (@add_comm_group.to_add_comm_monoid.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1))
                      (@module.to_semimodule.{0 u_2} real E real.ring (@normed_group.to_add_comm_group.{u_2} E _inst_1)
                         (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2)))))
             a
             (@has_sub.sub.{u_2} E
                (@add_group_has_sub.{u_2} E
                   (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)))
                x
                z))
          (@has_scalar.smul.{0 u_2} real E
             (@mul_action.to_has_scalar.{0 u_2} real E real.monoid
                (@distrib_mul_action.to_mul_action.{0 u_2} real E real.monoid
                   (@add_group.to_add_monoid.{u_2} E
                      (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)))
                   (@semimodule.to_distrib_mul_action.{0 u_2} real E real.semiring
                      (@add_comm_group.to_add_comm_monoid.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1))
                      (@module.to_semimodule.{0 u_2} real E real.ring (@normed_group.to_add_comm_group.{u_2} E _inst_1)
                         (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2)))))
             b
             (@has_sub.sub.{u_2} E
                (@add_group_has_sub.{u_2} E
                   (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)))
                y
                z))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>137      norm_add_le (a • (x - z)) (b • (y - z))</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='norm_add_le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_scalar.smul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_sub.sub'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_scalar.smul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_sub.sub'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 110, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/group_action.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 315, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/group_action.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 315, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Type u_2} [_inst_1 : normed_group.{u_2} α] (g h : α), @has_le.le.{0} real real.has_le (@has_norm.norm.{u_2} α (@normed_group.to_has_norm.{u_2} α _inst_1) (@has_add.add.{u_2} α (@add_semigroup.to_has_add.{u_2} α (@add_monoid.to_add_semigroup.{u_2} α (@add_group.to_add_monoid.{u_2} α (@add_comm_group.to_add_group.{u_2} α (@normed_group.to_add_comm_group.{u_2} α _inst_1))))) g h)) (@has_add.add.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring)) (@has_norm.norm.{u_2} α (@normed_group.to_has_norm.{u_2} α _inst_1) g) (@has_norm.norm.{u_2} α (@normed_group.to_has_norm.{u_2} α _inst_1) h))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} {γ : Type u_2} [c : has_scalar.{0 u_2} α γ], α → γ → γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_2} [c : has_sub.{u_2} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} {γ : Type u_2} [c : has_scalar.{0 u_2} α γ], α → γ → γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_2} [c : has_sub.{u_2} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Triangle inequality for the norm.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>138    ... = a * dist x z + b * dist y z :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mul.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_dist.dist'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mul.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_dist.dist'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/metric_space/basic.lean&#x27;, &#x27;line&#x27;: 45, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/metric_space/basic.lean&#x27;, &#x27;line&#x27;: 45, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_mul.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_2} [c : has_dist.{u_2} α], α → α → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_add.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_mul.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_2} [c : has_dist.{u_2} α], α → α → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>139      by simp [norm_smul, normed_group.dist_eq, real.norm_eq_abs, abs_of_nonneg ha, abs_of_nonneg hb]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='norm_smul'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='normed_group.dist_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='real.norm_eq_abs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='abs_of_nonneg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ha'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='abs_of_nonneg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hb'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 612, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 33, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 565, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/functions.lean&#x27;, &#x27;line&#x27;: 192, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/functions.lean&#x27;, &#x27;line&#x27;: 192, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {β : Type ?l_2} [_inst_1 : normed_field.{?l_1} α] [_inst_2 : normed_group.{?l_2} β] [_inst_3 : @normed_space.{?l_1 ?l_2} α β _inst_1 _inst_2] (s : α) (x : β), @eq.{1} real (@has_norm.norm.{?l_2} β (@normed_group.to_has_norm.{?l_2} β _inst_2) (@has_scalar.smul.{?l_1 ?l_2} α β (@mul_action.to_has_scalar.{?l_1 ?l_2} α β (@ring.to_monoid.{?l_1} α (@normed_ring.to_ring.{?l_1} α (@normed_field.to_normed_ring.{?l_1} α _inst_1))) (@distrib_mul_action.to_mul_action.{?l_1 ?l_2} α β (@ring.to_monoid.{?l_1} α (@normed_ring.to_ring.{?l_1} α (@normed_field.to_normed_ring.{?l_1} α _inst_1))) (@add_group.to_add_monoid.{?l_2} β (@add_comm_group.to_add_group.{?l_2} β (@normed_group.to_add_comm_group.{?l_2} β _inst_2))) (@semimodule.to_distrib_mul_action.{?l_1 ?l_2} α β (@ring.to_semiring.{?l_1} α (@normed_ring.to_ring.{?l_1} α (@normed_field.to_normed_ring.{?l_1} α _inst_1))) (@add_comm_group.to_add_comm_monoid.{?l_2} β (@normed_group.to_add_comm_group.{?l_2} β _inst_2)) (@module.to_semimodule.{?l_1 ?l_2} α β (@normed_ring.to_ring.{?l_1} α (@normed_field.to_normed_ring.{?l_1} α _inst_1)) (@normed_group.to_add_comm_group.{?l_2} β _inst_2) (@normed_space.to_module.{?l_1 ?l_2} α β _inst_1 _inst_2 _inst_3))))) s x)) (@has_mul.mul.{0} real (@no_zero_divisors.to_has_mul.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)) (@has_norm.norm.{?l_1} α (@normed_field.to_has_norm.{?l_1} α _inst_1) s) (@has_norm.norm.{?l_2} β (@normed_group.to_has_norm.{?l_2} β _inst_2) x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} [c : normed_group.{?l_1} α] (x y : α), @eq.{1} real (@has_dist.dist.{?l_1} α (@metric_space.to_has_dist.{?l_1} α (@normed_group.to_metric_space.{?l_1} α c)) x y) (@has_norm.norm.{?l_1} α (@normed_group.to_has_norm.{?l_1} α c) (@has_sub.sub.{?l_1} α (@add_group_has_sub.{?l_1} α (@add_comm_group.to_add_group.{?l_1} α (@normed_group.to_add_comm_group.{?l_1} α c))) x y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (r : real), @eq.{1} real (@has_norm.norm.{0} real (@normed_field.to_has_norm.{0} real normed_field.normed_field) r) (@abs.{0} real real.decidable_linear_ordered_comm_group r)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : decidable_linear_ordered_comm_group.{0} α] {a : α}, @ge.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@ordered_comm_group.to_partial_order.{0} α (@decidable_linear_ordered_comm_group.to_ordered_comm_group.{0} α _inst_1)))) a (@has_zero.zero.{0} α (@add_monoid.to_has_zero.{0} α (@add_group.to_add_monoid.{0} α (@add_comm_group.to_add_group.{0} α (@decidable_linear_ordered_comm_group.to_add_comm_group.{0} α _inst_1))))) → @eq.{1} α (@abs.{0} α _inst_1 a) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_le.le.{0} real real.has_le (@has_zero.zero.{0} real (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : decidable_linear_ordered_comm_group.{0} α] {a : α}, @ge.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@ordered_comm_group.to_partial_order.{0} α (@decidable_linear_ordered_comm_group.to_ordered_comm_group.{0} α _inst_1)))) a (@has_zero.zero.{0} α (@add_monoid.to_has_zero.{0} α (@add_group.to_add_monoid.{0} α (@add_comm_group.to_add_group.{0} α (@decidable_linear_ordered_comm_group.to_add_comm_group.{0} α _inst_1))))) → @eq.{1} α (@abs.{0} α _inst_1 a) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_le.le.{0} real real.has_le (@has_zero.zero.{0} real (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))) b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='lime'><a title='E : Type u_2,
_inst_1 : normed_group.{u_2} E,
_inst_2 : @normed_space.{0 u_2} real E normed_field.normed_field _inst_1,
z : E,
s : set.{u_2} E,
hs :
  @convex.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)
    (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2)
    s,
x y : E,
hx : @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x s,
hy : @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y s,
a b : real,
ha :
  @has_le.le.{0} real real.has_le
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    a,
hb :
  @has_le.le.{0} real real.has_le
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    b,
hab :
  @eq.{1} real (@has_add.add.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring)) a b)
    (@has_one.one.{0} real (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain)))
⊢ @eq.{1} real
    (@has_add.add.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
       (@has_norm.norm.{u_2} E (@normed_group.to_has_norm.{u_2} E _inst_1)
          (@has_scalar.smul.{0 u_2} real E
             (@mul_action.to_has_scalar.{0 u_2} real E real.monoid
                (@distrib_mul_action.to_mul_action.{0 u_2} real E real.monoid
                   (@add_group.to_add_monoid.{u_2} E
                      (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)))
                   (@semimodule.to_distrib_mul_action.{0 u_2} real E real.semiring
                      (@add_comm_group.to_add_comm_monoid.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1))
                      (@module.to_semimodule.{0 u_2} real E real.ring (@normed_group.to_add_comm_group.{u_2} E _inst_1)
                         (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2)))))
             a
             (@has_sub.sub.{u_2} E
                (@add_group_has_sub.{u_2} E
                   (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)))
                x
                z)))
       (@has_norm.norm.{u_2} E (@normed_group.to_has_norm.{u_2} E _inst_1)
          (@has_scalar.smul.{0 u_2} real E
             (@mul_action.to_has_scalar.{0 u_2} real E real.monoid
                (@distrib_mul_action.to_mul_action.{0 u_2} real E real.monoid
                   (@add_group.to_add_monoid.{u_2} E
                      (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)))
                   (@semimodule.to_distrib_mul_action.{0 u_2} real E real.semiring
                      (@add_comm_group.to_add_comm_monoid.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1))
                      (@module.to_semimodule.{0 u_2} real E real.ring (@normed_group.to_add_comm_group.{u_2} E _inst_1)
                         (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2)))))
             b
             (@has_sub.sub.{u_2} E
                (@add_group_has_sub.{u_2} E
                   (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)))
                y
                z))))
    (@has_add.add.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
       (@has_mul.mul.{0} real (@no_zero_divisors.to_has_mul.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
          a
          (@has_dist.dist.{u_2} E (@metric_space.to_has_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_1)) x
             z))
       (@has_mul.mul.{0} real (@no_zero_divisors.to_has_mul.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
          b
          (@has_dist.dist.{u_2} E (@metric_space.to_has_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_1)) y
             z)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>140  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='E : Type u_2,
_inst_1 : normed_group.{u_2} E,
_inst_2 : @normed_space.{0 u_2} real E normed_field.normed_field _inst_1,
z : E,
s : set.{u_2} E,
hs :
  @convex.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)
    (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2)
    s,
x y : E,
hx : @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x s,
hy : @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y s,
a b : real,
ha :
  @has_le.le.{0} real real.has_le
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    a,
hb :
  @has_le.le.{0} real real.has_le
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    b,
hab :
  @eq.{1} real (@has_add.add.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring)) a b)
    (@has_one.one.{0} real (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain)))
⊢ @eq.{1} real
    (@has_add.add.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
       (@has_norm.norm.{u_2} E (@normed_group.to_has_norm.{u_2} E _inst_1)
          (@has_scalar.smul.{0 u_2} real E
             (@mul_action.to_has_scalar.{0 u_2} real E real.monoid
                (@distrib_mul_action.to_mul_action.{0 u_2} real E real.monoid
                   (@add_group.to_add_monoid.{u_2} E
                      (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)))
                   (@semimodule.to_distrib_mul_action.{0 u_2} real E real.semiring
                      (@add_comm_group.to_add_comm_monoid.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1))
                      (@module.to_semimodule.{0 u_2} real E real.ring (@normed_group.to_add_comm_group.{u_2} E _inst_1)
                         (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2)))))
             a
             (@has_sub.sub.{u_2} E
                (@add_group_has_sub.{u_2} E
                   (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)))
                x
                z)))
       (@has_norm.norm.{u_2} E (@normed_group.to_has_norm.{u_2} E _inst_1)
          (@has_scalar.smul.{0 u_2} real E
             (@mul_action.to_has_scalar.{0 u_2} real E real.monoid
                (@distrib_mul_action.to_mul_action.{0 u_2} real E real.monoid
                   (@add_group.to_add_monoid.{u_2} E
                      (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)))
                   (@semimodule.to_distrib_mul_action.{0 u_2} real E real.semiring
                      (@add_comm_group.to_add_comm_monoid.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1))
                      (@module.to_semimodule.{0 u_2} real E real.ring (@normed_group.to_add_comm_group.{u_2} E _inst_1)
                         (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2)))))
             b
             (@has_sub.sub.{u_2} E
                (@add_group_has_sub.{u_2} E
                   (@add_comm_group.to_add_group.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)))
                y
                z))))
    (@has_add.add.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
       (@has_mul.mul.{0} real (@no_zero_divisors.to_has_mul.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
          a
          (@has_dist.dist.{u_2} E (@metric_space.to_has_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_1)) x
             z))
       (@has_mul.mul.{0} real (@no_zero_divisors.to_has_mul.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
          b
          (@has_dist.dist.{u_2} E (@metric_space.to_has_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_1)) y
             z)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>141  lemma convex_ball (a : E) (r : ℝ) : convex (metric.ball a r) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='blue'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='convex'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='metric.ball'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='r'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/basic.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/convex/basic.lean&#x27;, &#x27;line&#x27;: 124, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/metric_space/basic.lean&#x27;, &#x27;line&#x27;: 245, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {E : Type u} [_inst_1 : add_comm_group.{u} E] [_inst_2 : @vector_space.{0 u} real E real.discrete_field _inst_1], set.{u} E → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [_inst_1 : metric_space.{u} α], α → real → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='orange'><a title='Convexity of sets'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`ball x ε` is the set of all points `y` with `dist y x &lt; ε`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>142  by simpa only [metric.ball, sep_univ] using (convex_on_dist a _ convex_univ).convex_lt r</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='metric.ball'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.sep_univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='convex_on_dist'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='convex_univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='r'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/metric_space/basic.lean&#x27;, &#x27;line&#x27;: 245, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 585, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 127, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/convex/basic.lean&#x27;, &#x27;line&#x27;: 178, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type ?l_1} [_inst_1 : metric_space.{?l_1} α], α → real → set.{?l_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {p : α → Prop}, @eq.{?l_1+1} (set.{?l_1} α) (@has_sep.sep.{?l_1 ?l_1} α (set.{?l_1} α) (@set.has_sep.{?l_1} α) (λ (a : α), p a) (@set.univ.{?l_1} α)) (@set_of.{?l_1} α (λ (a : α), p a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {E : Type u_2} [_inst_1 : normed_group.{u_2} E] [_inst_2 : @normed_space.{0 u_2} real E normed_field.normed_field _inst_1] (z : E) (s : set.{u_2} E), @convex.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1) (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2) s → @convex_on.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1) (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2) s (λ (z&#x27; : E), @has_dist.dist.{u_2} E (@metric_space.to_has_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_1)) z&#x27; z)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {E : Type u_2} [_inst_1 : add_comm_group.{u_2} E] [_inst_2 : @vector_space.{0 u_2} real E real.discrete_field _inst_1], @convex.{u_2} E _inst_1 _inst_2 (@set.univ.{u_2} E)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`ball x ε` is the set of all points `y` with `dist y x &lt; ε`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='5'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='E : Type u_2,
_inst_1 : normed_group.{u_2} E,
_inst_2 : @normed_space.{0 u_2} real E normed_field.normed_field _inst_1,
a : E,
r : real
⊢ @convex.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)
    (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2)
    (@metric.ball.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_1) a r)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>143  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='5'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='E : Type u_2,
_inst_1 : normed_group.{u_2} E,
_inst_2 : @normed_space.{0 u_2} real E normed_field.normed_field _inst_1,
a : E,
r : real
⊢ @convex.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)
    (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2)
    (@metric.ball.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_1) a r)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>144  lemma convex_closed_ball (a : E) (r : ℝ) : convex (metric.closed_ball a r) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='blue'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='convex'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='metric.closed_ball'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='r'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/basic.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/convex/basic.lean&#x27;, &#x27;line&#x27;: 124, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/metric_space/basic.lean&#x27;, &#x27;line&#x27;: 252, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {E : Type u} [_inst_1 : add_comm_group.{u} E] [_inst_2 : @vector_space.{0 u} real E real.discrete_field _inst_1], set.{u} E → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [_inst_1 : metric_space.{u} α], α → real → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                           </code><font color='orange'><a title='Convexity of sets'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`closed_ball x ε` is the set of all points `y` with `dist y x ≤ ε`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>145  by simpa only [metric.closed_ball, sep_univ] using (convex_on_dist a _ convex_univ).convex_le r</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='metric.closed_ball'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.sep_univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='convex_on_dist'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='convex_univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='r'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/metric_space/basic.lean&#x27;, &#x27;line&#x27;: 252, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 585, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 127, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/convex/basic.lean&#x27;, &#x27;line&#x27;: 178, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type ?l_1} [_inst_1 : metric_space.{?l_1} α], α → real → set.{?l_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {p : α → Prop}, @eq.{?l_1+1} (set.{?l_1} α) (@has_sep.sep.{?l_1 ?l_1} α (set.{?l_1} α) (@set.has_sep.{?l_1} α) (λ (a : α), p a) (@set.univ.{?l_1} α)) (@set_of.{?l_1} α (λ (a : α), p a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {E : Type u_2} [_inst_1 : normed_group.{u_2} E] [_inst_2 : @normed_space.{0 u_2} real E normed_field.normed_field _inst_1] (z : E) (s : set.{u_2} E), @convex.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1) (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2) s → @convex_on.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1) (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2) s (λ (z&#x27; : E), @has_dist.dist.{u_2} E (@metric_space.to_has_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_1)) z&#x27; z)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {E : Type u_2} [_inst_1 : add_comm_group.{u_2} E] [_inst_2 : @vector_space.{0 u_2} real E real.discrete_field _inst_1], @convex.{u_2} E _inst_1 _inst_2 (@set.univ.{u_2} E)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`closed_ball x ε` is the set of all points `y` with `dist y x ≤ ε`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='5'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='E : Type u_2,
_inst_1 : normed_group.{u_2} E,
_inst_2 : @normed_space.{0 u_2} real E normed_field.normed_field _inst_1,
a : E,
r : real
⊢ @convex.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)
    (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2)
    (@metric.closed_ball.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_1) a r)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>146  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='5'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='E : Type u_2,
_inst_1 : normed_group.{u_2} E,
_inst_2 : @normed_space.{0 u_2} real E normed_field.normed_field _inst_1,
a : E,
r : real
⊢ @convex.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)
    (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2)
    (@metric.closed_ball.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_1) a r)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>147  /-- Given a point `x` in the convex hull of `s` and a point `y`, there exists a point</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>148  of `s` at distance at least `dist x y` from `y`. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>149  lemma convex_hull_exists_dist_ge {s : set E} {x : E} (hx : x ∈ convex_hull s) (y : E) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='convex_hull'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/convex/basic.lean&#x27;, &#x27;line&#x27;: 703, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u_2} [c : has_mem.{u_2 u_2} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {E : Type u} [_inst_1 : add_comm_group.{u} E] [_inst_2 : @vector_space.{0 u} real E real.discrete_field _inst_1], set.{u} E → set.{u} E'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_2} E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                               </code><font color='orange'><a title='Convex hull of a set `s` is the minimal convex set that includes `s`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>150    ∃ x&#x27; ∈ s, dist x y ≤ dist x&#x27; y :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_dist.dist'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_le.le'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_dist.dist'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/metric_space/basic.lean&#x27;, &#x27;line&#x27;: 45, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 319, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/metric_space/basic.lean&#x27;, &#x27;line&#x27;: 45, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_2}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='set.{u_2} E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_2}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} [c : has_dist.{u_1} α], α → α → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_le.{0} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} [c : has_dist.{u_1} α], α → α → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>151  (convex_on_dist y _ (convex_convex_hull _)).exists_ge_of_mem_convex_hull hx</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='convex_on_dist'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='convex_convex_hull'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='convex_on.exists_ge_of_mem_convex_hull'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hx'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 127, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/convex/basic.lean&#x27;, &#x27;line&#x27;: 711, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/convex/basic.lean&#x27;, &#x27;line&#x27;: 778, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {E : Type u_2} [_inst_1 : normed_group.{u_2} E] [_inst_2 : @normed_space.{0 u_2} real E normed_field.normed_field _inst_1] (z : E) (s : set.{u_2} E), @convex.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1) (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2) s → @convex_on.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1) (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2) s (λ (z&#x27; : E), @has_dist.dist.{u_2} E (@metric_space.to_has_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_1)) z&#x27; z)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {E : Type u_2} [_inst_1 : add_comm_group.{u_2} E] [_inst_2 : @vector_space.{0 u_2} real E real.discrete_field _inst_1] (s : set.{u_2} E), @convex.{u_2} E _inst_1 _inst_2 (@convex_hull.{u_2} E _inst_1 _inst_2 s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {E : Type u_2} [_inst_1 : add_comm_group.{u_2} E] [_inst_2 : @vector_space.{0 u_2} real E real.discrete_field _inst_1] {s : set.{u_2} E} {f : E → real}, @convex_on.{u_2} E _inst_1 _inst_2 (@convex_hull.{u_2} E _inst_1 _inst_2 s) f → ∀ {x : E}, @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x (@convex_hull.{u_2} E _inst_1 _inst_2 s) → @Exists.{u_2+1} E (λ (y : E), @Exists.{0} (@has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y s) (λ (H : @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y s), @has_le.le.{0} real real.has_le (f x) (f y)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x (@convex_hull.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1) (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2) s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                           </code><font color='orange'><a title=' Maximum principle for convex functions. If a function `f` is convex on the convex hull of `s`,
then `f` can&#x27;t have a maximum on `convex_hull s` outside of `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>152  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>153  /-- Given a point `x` in the convex hull of `s` and a point `y` in the convex hull of `t`,</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>154  there exist points `x&#x27; ∈ s` and `y&#x27; ∈ t` at distance at least `dist x y`. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>155  lemma convex_hull_exists_dist_ge2 {s t : set E} {x y : E}</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>156    (hx : x ∈ convex_hull s) (hy : y ∈ convex_hull t) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='convex_hull'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='convex_hull'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/convex/basic.lean&#x27;, &#x27;line&#x27;: 703, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/convex/basic.lean&#x27;, &#x27;line&#x27;: 703, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u_2} [c : has_mem.{u_2 u_2} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {E : Type u} [_inst_1 : add_comm_group.{u} E] [_inst_2 : @vector_space.{0 u} real E real.discrete_field _inst_1], set.{u} E → set.{u} E'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_2} E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u_2} [c : has_mem.{u_2 u_2} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {E : Type u} [_inst_1 : add_comm_group.{u} E] [_inst_2 : @vector_space.{0 u} real E real.discrete_field _inst_1], set.{u} E → set.{u} E'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_2} E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='Convex hull of a set `s` is the minimal convex set that includes `s`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='Convex hull of a set `s` is the minimal convex set that includes `s`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>157    ∃ (x&#x27; ∈ s) (y&#x27; ∈ t), dist x y ≤ dist x&#x27; y&#x27; :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='y&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_dist.dist'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_le.le'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_dist.dist'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/metric_space/basic.lean&#x27;, &#x27;line&#x27;: 45, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 319, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/metric_space/basic.lean&#x27;, &#x27;line&#x27;: 45, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_2}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='set.{u_2} E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='set.{u_2} E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_2}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} [c : has_dist.{u_1} α], α → α → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_le.{0} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} [c : has_dist.{u_1} α], α → α → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>158  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='E : Type u_2,
_inst_1 : normed_group.{u_2} E,
_inst_2 : @normed_space.{0 u_2} real E normed_field.normed_field _inst_1,
s t : set.{u_2} E,
x y : E,
hx :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x
    (@convex_hull.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)
       (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2)
       s),
hy :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y
    (@convex_hull.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)
       (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2)
       t)
⊢ @Exists.{u_2+1} E
    (λ (x&#x27; : E),
       @Exists.{0} (@has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x&#x27; s)
         (λ (H : @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x&#x27; s),
            @Exists.{u_2+1} E
              (λ (y&#x27; : E),
                 @Exists.{0} (@has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y&#x27; t)
                   (λ (H : @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y&#x27; t),
                      @has_le.le.{0} real real.has_le
                        (@has_dist.dist.{u_2} E
                           (@metric_space.to_has_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_1))
                           x
                           y)
                        (@has_dist.dist.{u_2} E
                           (@metric_space.to_has_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_1))
                           x&#x27;
                           y&#x27;)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>159    rcases convex_hull_exists_dist_ge hx y with ⟨x&#x27;, hx&#x27;, Hx&#x27;⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='convex_hull_exists_dist_ge'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hx'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 149, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {E : Type u_2} [_inst_1 : normed_group.{u_2} E] [_inst_2 : @normed_space.{0 u_2} real E normed_field.normed_field _inst_1] {s : set.{u_2} E} {x : E}, @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x (@convex_hull.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1) (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2) s) → ∀ (y : E), @Exists.{u_2+1} E (λ (x&#x27; : E), @Exists.{0} (@has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x&#x27; s) (λ (H : @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x&#x27; s), @has_le.le.{0} real real.has_le (@has_dist.dist.{u_2} E (@metric_space.to_has_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_1)) x y) (@has_dist.dist.{u_2} E (@metric_space.to_has_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_1)) x&#x27; y)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x (@convex_hull.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1) (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2) s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title=' Given a point `x` in the convex hull of `s` and a point `y`, there exists a point
of `s` at distance at least `dist x y` from `y`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='E : Type u_2,
_inst_1 : normed_group.{u_2} E,
_inst_2 : @normed_space.{0 u_2} real E normed_field.normed_field _inst_1,
s t : set.{u_2} E,
x y : E,
hx :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x
    (@convex_hull.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)
       (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2)
       s),
hy :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y
    (@convex_hull.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)
       (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2)
       t)
⊢ @Exists.{u_2+1} E
    (λ (x&#x27; : E),
       @Exists.{0} (@has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x&#x27; s)
         (λ (H : @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x&#x27; s),
            @Exists.{u_2+1} E
              (λ (y&#x27; : E),
                 @Exists.{0} (@has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y&#x27; t)
                   (λ (H : @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y&#x27; t),
                      @has_le.le.{0} real real.has_le
                        (@has_dist.dist.{u_2} E
                           (@metric_space.to_has_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_1))
                           x
                           y)
                        (@has_dist.dist.{u_2} E
                           (@metric_space.to_has_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_1))
                           x&#x27;
                           y&#x27;)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='E : Type u_2,
_inst_1 : normed_group.{u_2} E,
_inst_2 : @normed_space.{0 u_2} real E normed_field.normed_field _inst_1,
s t : set.{u_2} E,
x y : E,
hx :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x
    (@convex_hull.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)
       (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2)
       s),
hy :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y
    (@convex_hull.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)
       (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2)
       t),
x&#x27; : E,
hx&#x27; : @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x&#x27; s,
Hx&#x27; :
  @has_le.le.{0} real real.has_le
    (@has_dist.dist.{u_2} E (@metric_space.to_has_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_1)) x y)
    (@has_dist.dist.{u_2} E (@metric_space.to_has_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_1)) x&#x27; y)
⊢ @Exists.{u_2+1} E
    (λ (x&#x27; : E),
       @Exists.{0} (@has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x&#x27; s)
         (λ (H : @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x&#x27; s),
            @Exists.{u_2+1} E
              (λ (y&#x27; : E),
                 @Exists.{0} (@has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y&#x27; t)
                   (λ (H : @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y&#x27; t),
                      @has_le.le.{0} real real.has_le
                        (@has_dist.dist.{u_2} E
                           (@metric_space.to_has_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_1))
                           x
                           y)
                        (@has_dist.dist.{u_2} E
                           (@metric_space.to_has_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_1))
                           x&#x27;
                           y&#x27;)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>160    rcases convex_hull_exists_dist_ge hy x&#x27; with ⟨y&#x27;, hy&#x27;, Hy&#x27;⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='convex_hull_exists_dist_ge'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 149, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {E : Type u_2} [_inst_1 : normed_group.{u_2} E] [_inst_2 : @normed_space.{0 u_2} real E normed_field.normed_field _inst_1] {s : set.{u_2} E} {x : E}, @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x (@convex_hull.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1) (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2) s) → ∀ (y : E), @Exists.{u_2+1} E (λ (x&#x27; : E), @Exists.{0} (@has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x&#x27; s) (λ (H : @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x&#x27; s), @has_le.le.{0} real real.has_le (@has_dist.dist.{u_2} E (@metric_space.to_has_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_1)) x y) (@has_dist.dist.{u_2} E (@metric_space.to_has_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_1)) x&#x27; y)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y (@convex_hull.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1) (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2) t)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title=' Given a point `x` in the convex hull of `s` and a point `y`, there exists a point
of `s` at distance at least `dist x y` from `y`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='E : Type u_2,
_inst_1 : normed_group.{u_2} E,
_inst_2 : @normed_space.{0 u_2} real E normed_field.normed_field _inst_1,
s t : set.{u_2} E,
x y : E,
hx :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x
    (@convex_hull.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)
       (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2)
       s),
hy :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y
    (@convex_hull.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)
       (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2)
       t),
x&#x27; : E,
hx&#x27; : @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x&#x27; s,
Hx&#x27; :
  @has_le.le.{0} real real.has_le
    (@has_dist.dist.{u_2} E (@metric_space.to_has_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_1)) x y)
    (@has_dist.dist.{u_2} E (@metric_space.to_has_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_1)) x&#x27; y)
⊢ @Exists.{u_2+1} E
    (λ (x&#x27; : E),
       @Exists.{0} (@has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x&#x27; s)
         (λ (H : @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x&#x27; s),
            @Exists.{u_2+1} E
              (λ (y&#x27; : E),
                 @Exists.{0} (@has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y&#x27; t)
                   (λ (H : @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y&#x27; t),
                      @has_le.le.{0} real real.has_le
                        (@has_dist.dist.{u_2} E
                           (@metric_space.to_has_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_1))
                           x
                           y)
                        (@has_dist.dist.{u_2} E
                           (@metric_space.to_has_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_1))
                           x&#x27;
                           y&#x27;)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='E : Type u_2,
_inst_1 : normed_group.{u_2} E,
_inst_2 : @normed_space.{0 u_2} real E normed_field.normed_field _inst_1,
s t : set.{u_2} E,
x y : E,
hx :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x
    (@convex_hull.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)
       (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2)
       s),
hy :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y
    (@convex_hull.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)
       (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2)
       t),
x&#x27; : E,
hx&#x27; : @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x&#x27; s,
Hx&#x27; :
  @has_le.le.{0} real real.has_le
    (@has_dist.dist.{u_2} E (@metric_space.to_has_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_1)) x y)
    (@has_dist.dist.{u_2} E (@metric_space.to_has_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_1)) x&#x27; y),
y&#x27; : E,
hy&#x27; : @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y&#x27; t,
Hy&#x27; :
  @has_le.le.{0} real real.has_le
    (@has_dist.dist.{u_2} E (@metric_space.to_has_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_1)) y x&#x27;)
    (@has_dist.dist.{u_2} E (@metric_space.to_has_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_1)) y&#x27; x&#x27;)
⊢ @Exists.{u_2+1} E
    (λ (x&#x27; : E),
       @Exists.{0} (@has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x&#x27; s)
         (λ (H : @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x&#x27; s),
            @Exists.{u_2+1} E
              (λ (y&#x27; : E),
                 @Exists.{0} (@has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y&#x27; t)
                   (λ (H : @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y&#x27; t),
                      @has_le.le.{0} real real.has_le
                        (@has_dist.dist.{u_2} E
                           (@metric_space.to_has_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_1))
                           x
                           y)
                        (@has_dist.dist.{u_2} E
                           (@metric_space.to_has_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_1))
                           x&#x27;
                           y&#x27;)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>161    use [x&#x27;, hx&#x27;, y&#x27;, hy&#x27;],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='x&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hx&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='y&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hy&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 623, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 623, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 623, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 623, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 623, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x&#x27; s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y&#x27; t'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Similar to `existsi`. `use x` will instantiate the first term of an `∃` or `Σ` goal with `x`.
It will then try to close the new goal using `triv`, or try to simplify it by applying `exists_prop`.
Unlike `existsi`, `x` is elaborated with respect to the expected type.
`use` will alternatively take a list of terms `[x0, ..., xn]`.

`use` will work with constructors of arbitrary inductive types.

Examples:

example (α : Type) : ∃ S : set α, S = S :=
by use ∅

example : ∃ x : ℤ, x = x :=
by use 42

example : ∃ n &gt; 0, n = n :=
begin
  use 1,
  -- goal is now 1 &gt; 0 ∧ 1 = 1, whereas it would be ∃ (H : 1 &gt; 0), 1 = 1 after existsi 1.
  exact ⟨zero_lt_one, rfl⟩,
end

example : ∃ a b c : ℤ, a + b + c = 6 :=
by use [1, 2, 3]

example : ∃ p : ℤ × ℤ, p.1 = 1 :=
by use ⟨1, 42⟩

example : Σ x y : ℤ, (ℤ × ℤ) × ℤ :=
by use [1, 2, 3, 4, 5]

inductive foo
| mk : ℕ → bool × ℕ → ℕ → foo

example : foo :=
by use [100, tt, 4, 3]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Similar to `existsi`. `use x` will instantiate the first term of an `∃` or `Σ` goal with `x`.
It will then try to close the new goal using `triv`, or try to simplify it by applying `exists_prop`.
Unlike `existsi`, `x` is elaborated with respect to the expected type.
`use` will alternatively take a list of terms `[x0, ..., xn]`.

`use` will work with constructors of arbitrary inductive types.

Examples:

example (α : Type) : ∃ S : set α, S = S :=
by use ∅

example : ∃ x : ℤ, x = x :=
by use 42

example : ∃ n &gt; 0, n = n :=
begin
  use 1,
  -- goal is now 1 &gt; 0 ∧ 1 = 1, whereas it would be ∃ (H : 1 &gt; 0), 1 = 1 after existsi 1.
  exact ⟨zero_lt_one, rfl⟩,
end

example : ∃ a b c : ℤ, a + b + c = 6 :=
by use [1, 2, 3]

example : ∃ p : ℤ × ℤ, p.1 = 1 :=
by use ⟨1, 42⟩

example : Σ x y : ℤ, (ℤ × ℤ) × ℤ :=
by use [1, 2, 3, 4, 5]

inductive foo
| mk : ℕ → bool × ℕ → ℕ → foo

example : foo :=
by use [100, tt, 4, 3]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='Similar to `existsi`. `use x` will instantiate the first term of an `∃` or `Σ` goal with `x`.
It will then try to close the new goal using `triv`, or try to simplify it by applying `exists_prop`.
Unlike `existsi`, `x` is elaborated with respect to the expected type.
`use` will alternatively take a list of terms `[x0, ..., xn]`.

`use` will work with constructors of arbitrary inductive types.

Examples:

example (α : Type) : ∃ S : set α, S = S :=
by use ∅

example : ∃ x : ℤ, x = x :=
by use 42

example : ∃ n &gt; 0, n = n :=
begin
  use 1,
  -- goal is now 1 &gt; 0 ∧ 1 = 1, whereas it would be ∃ (H : 1 &gt; 0), 1 = 1 after existsi 1.
  exact ⟨zero_lt_one, rfl⟩,
end

example : ∃ a b c : ℤ, a + b + c = 6 :=
by use [1, 2, 3]

example : ∃ p : ℤ × ℤ, p.1 = 1 :=
by use ⟨1, 42⟩

example : Σ x y : ℤ, (ℤ × ℤ) × ℤ :=
by use [1, 2, 3, 4, 5]

inductive foo
| mk : ℕ → bool × ℕ → ℕ → foo

example : foo :=
by use [100, tt, 4, 3]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Similar to `existsi`. `use x` will instantiate the first term of an `∃` or `Σ` goal with `x`.
It will then try to close the new goal using `triv`, or try to simplify it by applying `exists_prop`.
Unlike `existsi`, `x` is elaborated with respect to the expected type.
`use` will alternatively take a list of terms `[x0, ..., xn]`.

`use` will work with constructors of arbitrary inductive types.

Examples:

example (α : Type) : ∃ S : set α, S = S :=
by use ∅

example : ∃ x : ℤ, x = x :=
by use 42

example : ∃ n &gt; 0, n = n :=
begin
  use 1,
  -- goal is now 1 &gt; 0 ∧ 1 = 1, whereas it would be ∃ (H : 1 &gt; 0), 1 = 1 after existsi 1.
  exact ⟨zero_lt_one, rfl⟩,
end

example : ∃ a b c : ℤ, a + b + c = 6 :=
by use [1, 2, 3]

example : ∃ p : ℤ × ℤ, p.1 = 1 :=
by use ⟨1, 42⟩

example : Σ x y : ℤ, (ℤ × ℤ) × ℤ :=
by use [1, 2, 3, 4, 5]

inductive foo
| mk : ℕ → bool × ℕ → ℕ → foo

example : foo :=
by use [100, tt, 4, 3]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='Similar to `existsi`. `use x` will instantiate the first term of an `∃` or `Σ` goal with `x`.
It will then try to close the new goal using `triv`, or try to simplify it by applying `exists_prop`.
Unlike `existsi`, `x` is elaborated with respect to the expected type.
`use` will alternatively take a list of terms `[x0, ..., xn]`.

`use` will work with constructors of arbitrary inductive types.

Examples:

example (α : Type) : ∃ S : set α, S = S :=
by use ∅

example : ∃ x : ℤ, x = x :=
by use 42

example : ∃ n &gt; 0, n = n :=
begin
  use 1,
  -- goal is now 1 &gt; 0 ∧ 1 = 1, whereas it would be ∃ (H : 1 &gt; 0), 1 = 1 after existsi 1.
  exact ⟨zero_lt_one, rfl⟩,
end

example : ∃ a b c : ℤ, a + b + c = 6 :=
by use [1, 2, 3]

example : ∃ p : ℤ × ℤ, p.1 = 1 :=
by use ⟨1, 42⟩

example : Σ x y : ℤ, (ℤ × ℤ) × ℤ :=
by use [1, 2, 3, 4, 5]

inductive foo
| mk : ℕ → bool × ℕ → ℕ → foo

example : foo :=
by use [100, tt, 4, 3]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='use'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='use'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='use'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='use'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='use'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='E : Type u_2,
_inst_1 : normed_group.{u_2} E,
_inst_2 : @normed_space.{0 u_2} real E normed_field.normed_field _inst_1,
s t : set.{u_2} E,
x y : E,
hx :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x
    (@convex_hull.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)
       (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2)
       s),
hy :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y
    (@convex_hull.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)
       (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2)
       t),
x&#x27; : E,
hx&#x27; : @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x&#x27; s,
Hx&#x27; :
  @has_le.le.{0} real real.has_le
    (@has_dist.dist.{u_2} E (@metric_space.to_has_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_1)) x y)
    (@has_dist.dist.{u_2} E (@metric_space.to_has_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_1)) x&#x27; y),
y&#x27; : E,
hy&#x27; : @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y&#x27; t,
Hy&#x27; :
  @has_le.le.{0} real real.has_le
    (@has_dist.dist.{u_2} E (@metric_space.to_has_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_1)) y x&#x27;)
    (@has_dist.dist.{u_2} E (@metric_space.to_has_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_1)) y&#x27; x&#x27;)
⊢ @Exists.{u_2+1} E
    (λ (x&#x27; : E),
       @Exists.{0} (@has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x&#x27; s)
         (λ (H : @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x&#x27; s),
            @Exists.{u_2+1} E
              (λ (y&#x27; : E),
                 @Exists.{0} (@has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y&#x27; t)
                   (λ (H : @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y&#x27; t),
                      @has_le.le.{0} real real.has_le
                        (@has_dist.dist.{u_2} E
                           (@metric_space.to_has_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_1))
                           x
                           y)
                        (@has_dist.dist.{u_2} E
                           (@metric_space.to_has_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_1))
                           x&#x27;
                           y&#x27;)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='E : Type u_2,
_inst_1 : normed_group.{u_2} E,
_inst_2 : @normed_space.{0 u_2} real E normed_field.normed_field _inst_1,
s t : set.{u_2} E,
x y : E,
hx :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x
    (@convex_hull.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)
       (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2)
       s),
hy :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y
    (@convex_hull.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)
       (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2)
       t),
x&#x27; : E,
hx&#x27; : @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x&#x27; s,
Hx&#x27; :
  @has_le.le.{0} real real.has_le
    (@has_dist.dist.{u_2} E (@metric_space.to_has_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_1)) x y)
    (@has_dist.dist.{u_2} E (@metric_space.to_has_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_1)) x&#x27; y),
y&#x27; : E,
hy&#x27; : @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y&#x27; t,
Hy&#x27; :
  @has_le.le.{0} real real.has_le
    (@has_dist.dist.{u_2} E (@metric_space.to_has_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_1)) y x&#x27;)
    (@has_dist.dist.{u_2} E (@metric_space.to_has_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_1)) y&#x27; x&#x27;)
⊢ @has_le.le.{0} real real.has_le
    (@has_dist.dist.{u_2} E (@metric_space.to_has_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_1)) x y)
    (@has_dist.dist.{u_2} E (@metric_space.to_has_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_1)) x&#x27; y&#x27;)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>162    exact le_trans Hx&#x27; (dist_comm y x&#x27; ▸ dist_comm y&#x27; x&#x27; ▸ Hy&#x27;)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='le_trans'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Hx&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='eq.subst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='dist_comm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='Hy&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 33, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 190, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/metric_space/basic.lean&#x27;, &#x27;line&#x27;: 88, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : preorder.{0} α] {a b c : α}, @has_le.le.{0} α (@preorder.to_has_le.{0} α _inst_1) a b → @has_le.le.{0} α (@preorder.to_has_le.{0} α _inst_1) b c → @has_le.le.{0} α (@preorder.to_has_le.{0} α _inst_1) a c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_le.le.{0} real real.has_le (@has_dist.dist.{u_2} E (@metric_space.to_has_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_1)) x y) (@has_dist.dist.{u_2} E (@metric_space.to_has_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_1)) x&#x27; y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} {P : α → Prop} {a b : α}, @eq.{1} α a b → P a → P b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_2} [_inst_1 : metric_space.{u_2} α] (x y : α), @eq.{1} real (@has_dist.dist.{u_2} α (@metric_space.to_has_dist.{u_2} α _inst_1) x y) (@has_dist.dist.{u_2} α (@metric_space.to_has_dist.{u_2} α _inst_1) y x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_le.le.{0} real real.has_le (@has_dist.dist.{u_2} E (@metric_space.to_has_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_1)) y x&#x27;) (@has_dist.dist.{u_2} E (@metric_space.to_has_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_1)) y&#x27; x&#x27;)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='E : Type u_2,
_inst_1 : normed_group.{u_2} E,
_inst_2 : @normed_space.{0 u_2} real E normed_field.normed_field _inst_1,
s t : set.{u_2} E,
x y : E,
hx :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x
    (@convex_hull.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)
       (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2)
       s),
hy :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y
    (@convex_hull.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)
       (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2)
       t),
x&#x27; : E,
hx&#x27; : @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x&#x27; s,
Hx&#x27; :
  @has_le.le.{0} real real.has_le
    (@has_dist.dist.{u_2} E (@metric_space.to_has_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_1)) x y)
    (@has_dist.dist.{u_2} E (@metric_space.to_has_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_1)) x&#x27; y),
y&#x27; : E,
hy&#x27; : @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y&#x27; t,
Hy&#x27; :
  @has_le.le.{0} real real.has_le
    (@has_dist.dist.{u_2} E (@metric_space.to_has_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_1)) y x&#x27;)
    (@has_dist.dist.{u_2} E (@metric_space.to_has_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_1)) y&#x27; x&#x27;)
⊢ @has_le.le.{0} real real.has_le
    (@has_dist.dist.{u_2} E (@metric_space.to_has_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_1)) x y)
    (@has_dist.dist.{u_2} E (@metric_space.to_has_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_1)) x&#x27; y&#x27;)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>163  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>164  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>165  /-- Emetric diameter of the convex hull of a set `s` equals the emetric diameter of `s. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>166  @[simp] lemma convex_hull_ediam (s : set E) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>167    emetric.diam (convex_hull s) = emetric.diam s :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='emetric.diam'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='convex_hull'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='emetric.diam'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/metric_space/emetric_space.lean&#x27;, &#x27;line&#x27;: 732, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/convex/basic.lean&#x27;, &#x27;line&#x27;: 703, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/metric_space/emetric_space.lean&#x27;, &#x27;line&#x27;: 732, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [_inst_1 : emetric_space.{u} α], set.{u} α → ennreal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {E : Type u} [_inst_1 : add_comm_group.{u} E] [_inst_2 : @vector_space.{0 u} real E real.discrete_field _inst_1], set.{u} E → set.{u} E'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_2} E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : emetric_space.{u} α], set.{u} α → ennreal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_2} E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The diameter of a set in an emetric space, named `emetric.diam`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Convex hull of a set `s` is the minimal convex set that includes `s`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='The diameter of a set in an emetric space, named `emetric.diam`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>168  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='E : Type u_2,
_inst_1 : normed_group.{u_2} E,
_inst_2 : @normed_space.{0 u_2} real E normed_field.normed_field _inst_1,
s : set.{u_2} E
⊢ @eq.{1} ennreal
    (@emetric.diam.{u_2} E (@metric_space.to_emetric_space.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_1))
       (@convex_hull.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)
          (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2)
          s))
    (@emetric.diam.{u_2} E (@metric_space.to_emetric_space.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_1)) s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>169    refine le_antisymm (emetric.diam_le_of_forall_edist_le $ λ x hx y hy, _)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='le_antisymm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='emetric.diam_le_of_forall_edist_le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 45, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/metric_space/emetric_space.lean&#x27;, &#x27;line&#x27;: 744, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : partial_order.{0} α] {a b : α}, @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α _inst_1)) a b → @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α _inst_1)) b a → @eq.{1} α a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_2} [_inst_1 : emetric_space.{u_2} α] {s : set.{u_2} α} {d : ennreal}, (∀ (x : α), @has_mem.mem.{u_2 u_2} α (set.{u_2} α) (@set.has_mem.{u_2} α) x s → ∀ (y : α), @has_mem.mem.{u_2 u_2} α (set.{u_2} α) (@set.has_mem.{u_2} α) y s → @has_le.le.{0} ennreal (@preorder.to_has_le.{0} ennreal (@partial_order.to_preorder.{0} ennreal (@ordered_comm_monoid.to_partial_order.{0} ennreal (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal ennreal.canonically_ordered_comm_semiring_1))))) (@has_edist.edist.{u_2} α (@emetric_space.to_has_edist.{u_2} α _inst_1) x y) d) → @has_le.le.{0} ennreal (@preorder.to_has_le.{0} ennreal (@partial_order.to_preorder.{0} ennreal (@ordered_comm_monoid.to_partial_order.{0} ennreal (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal ennreal.canonically_ordered_comm_semiring_1))))) (@emetric.diam.{u_2} α _inst_1 s) d'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title=' If the distance between any two points in a set is bounded by some constant, this constant
bounds the diameter.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='E : Type u_2,
_inst_1 : normed_group.{u_2} E,
_inst_2 : @normed_space.{0 u_2} real E normed_field.normed_field _inst_1,
s : set.{u_2} E
⊢ @eq.{1} ennreal
    (@emetric.diam.{u_2} E (@metric_space.to_emetric_space.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_1))
       (@convex_hull.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)
          (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2)
          s))
    (@emetric.diam.{u_2} E (@metric_space.to_emetric_space.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_1)) s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>170      (emetric.diam_mono $ subset_convex_hull s),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='emetric.diam_mono'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='subset_convex_hull'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/metric_space/emetric_space.lean&#x27;, &#x27;line&#x27;: 787, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/convex/basic.lean&#x27;, &#x27;line&#x27;: 708, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_2} [_inst_1 : emetric_space.{u_2} α] {s t : set.{u_2} α}, @has_subset.subset.{u_2} (set.{u_2} α) (@set.has_subset.{u_2} α) s t → @has_le.le.{0} ennreal (@preorder.to_has_le.{0} ennreal (@partial_order.to_preorder.{0} ennreal (@ordered_comm_monoid.to_partial_order.{0} ennreal (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal ennreal.canonically_ordered_comm_semiring_1))))) (@emetric.diam.{u_2} α _inst_1 s) (@emetric.diam.{u_2} α _inst_1 t)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {E : Type u_2} [_inst_1 : add_comm_group.{u_2} E] [_inst_2 : @vector_space.{0 u_2} real E real.discrete_field _inst_1] (s : set.{u_2} E), @has_subset.subset.{u_2} (set.{u_2} E) (@set.has_subset.{u_2} E) s (@convex_hull.{u_2} E _inst_1 _inst_2 s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{u_2} E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The diameter is monotonous with respect to inclusion'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='E : Type u_2,
_inst_1 : normed_group.{u_2} E,
_inst_2 : @normed_space.{0 u_2} real E normed_field.normed_field _inst_1,
s : set.{u_2} E
⊢ @eq.{1} ennreal
    (@emetric.diam.{u_2} E (@metric_space.to_emetric_space.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_1))
       (@convex_hull.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)
          (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2)
          s))
    (@emetric.diam.{u_2} E (@metric_space.to_emetric_space.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_1)) s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='E : Type u_2,
_inst_1 : normed_group.{u_2} E,
_inst_2 : @normed_space.{0 u_2} real E normed_field.normed_field _inst_1,
s : set.{u_2} E,
x : E,
hx :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x
    (@convex_hull.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)
       (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2)
       s),
y : E,
hy :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y
    (@convex_hull.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)
       (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2)
       s)
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@has_edist.edist.{u_2} E
       (@emetric_space.to_has_edist.{u_2} E
          (@metric_space.to_emetric_space.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_1)))
       x
       y)
    (@emetric.diam.{u_2} E (@metric_space.to_emetric_space.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_1)) s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>171    rcases convex_hull_exists_dist_ge2 hx hy with ⟨x&#x27;, hx&#x27;, y&#x27;, hy&#x27;, H⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='convex_hull_exists_dist_ge2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hx'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 155, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {E : Type u_2} [_inst_1 : normed_group.{u_2} E] [_inst_2 : @normed_space.{0 u_2} real E normed_field.normed_field _inst_1] {s t : set.{u_2} E} {x y : E}, @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x (@convex_hull.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1) (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2) s) → @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y (@convex_hull.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1) (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2) t) → @Exists.{u_2+1} E (λ (x&#x27; : E), @Exists.{0} (@has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x&#x27; s) (λ (H : @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x&#x27; s), @Exists.{u_2+1} E (λ (y&#x27; : E), @Exists.{0} (@has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y&#x27; t) (λ (H : @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y&#x27; t), @has_le.le.{0} real real.has_le (@has_dist.dist.{u_2} E (@metric_space.to_has_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_1)) x y) (@has_dist.dist.{u_2} E (@metric_space.to_has_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_1)) x&#x27; y&#x27;)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x (@convex_hull.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1) (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2) s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y (@convex_hull.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1) (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2) s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title=' Given a point `x` in the convex hull of `s` and a point `y` in the convex hull of `t`,
there exist points `x&#x27; ∈ s` and `y&#x27; ∈ t` at distance at least `dist x y`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='E : Type u_2,
_inst_1 : normed_group.{u_2} E,
_inst_2 : @normed_space.{0 u_2} real E normed_field.normed_field _inst_1,
s : set.{u_2} E,
x : E,
hx :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x
    (@convex_hull.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)
       (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2)
       s),
y : E,
hy :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y
    (@convex_hull.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)
       (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2)
       s)
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@has_edist.edist.{u_2} E
       (@emetric_space.to_has_edist.{u_2} E
          (@metric_space.to_emetric_space.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_1)))
       x
       y)
    (@emetric.diam.{u_2} E (@metric_space.to_emetric_space.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_1)) s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='E : Type u_2,
_inst_1 : normed_group.{u_2} E,
_inst_2 : @normed_space.{0 u_2} real E normed_field.normed_field _inst_1,
s : set.{u_2} E,
x : E,
hx :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x
    (@convex_hull.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)
       (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2)
       s),
y : E,
hy :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y
    (@convex_hull.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)
       (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2)
       s),
x&#x27; : E,
hx&#x27; : @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x&#x27; s,
y&#x27; : E,
hy&#x27; : @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y&#x27; s,
H :
  @has_le.le.{0} real real.has_le
    (@has_dist.dist.{u_2} E (@metric_space.to_has_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_1)) x y)
    (@has_dist.dist.{u_2} E (@metric_space.to_has_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_1)) x&#x27; y&#x27;)
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@has_edist.edist.{u_2} E
       (@emetric_space.to_has_edist.{u_2} E
          (@metric_space.to_emetric_space.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_1)))
       x
       y)
    (@emetric.diam.{u_2} E (@metric_space.to_emetric_space.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_1)) s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>172    rw edist_dist,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='edist_dist'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/metric_space/basic.lean&#x27;, &#x27;line&#x27;: 90, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_2} [_inst_1 : metric_space.{u_2} α] (x y : α), @eq.{1} ennreal (@has_edist.edist.{u_2} α (@metric_space.to_has_edist.{u_2} α _inst_1) x y) (ennreal.of_real (@has_dist.dist.{u_2} α (@metric_space.to_has_dist.{u_2} α _inst_1) x y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='E : Type u_2,
_inst_1 : normed_group.{u_2} E,
_inst_2 : @normed_space.{0 u_2} real E normed_field.normed_field _inst_1,
s : set.{u_2} E,
x : E,
hx :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x
    (@convex_hull.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)
       (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2)
       s),
y : E,
hy :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y
    (@convex_hull.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)
       (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2)
       s),
x&#x27; : E,
hx&#x27; : @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x&#x27; s,
y&#x27; : E,
hy&#x27; : @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y&#x27; s,
H :
  @has_le.le.{0} real real.has_le
    (@has_dist.dist.{u_2} E (@metric_space.to_has_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_1)) x y)
    (@has_dist.dist.{u_2} E (@metric_space.to_has_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_1)) x&#x27; y&#x27;)
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@has_edist.edist.{u_2} E
       (@emetric_space.to_has_edist.{u_2} E
          (@metric_space.to_emetric_space.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_1)))
       x
       y)
    (@emetric.diam.{u_2} E (@metric_space.to_emetric_space.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_1)) s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='E : Type u_2,
_inst_1 : normed_group.{u_2} E,
_inst_2 : @normed_space.{0 u_2} real E normed_field.normed_field _inst_1,
s : set.{u_2} E,
x : E,
hx :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x
    (@convex_hull.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)
       (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2)
       s),
y : E,
hy :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y
    (@convex_hull.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)
       (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2)
       s),
x&#x27; : E,
hx&#x27; : @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x&#x27; s,
y&#x27; : E,
hy&#x27; : @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y&#x27; s,
H :
  @has_le.le.{0} real real.has_le
    (@has_dist.dist.{u_2} E (@metric_space.to_has_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_1)) x y)
    (@has_dist.dist.{u_2} E (@metric_space.to_has_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_1)) x&#x27; y&#x27;)
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (ennreal.of_real
       (@has_dist.dist.{u_2} E (@metric_space.to_has_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_1)) x y))
    (@emetric.diam.{u_2} E (@metric_space.to_emetric_space.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_1)) s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>173    apply le_trans (ennreal.of_real_le_of_real H),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='le_trans'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ennreal.of_real_le_of_real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 33, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/ennreal.lean&#x27;, &#x27;line&#x27;: 893, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : preorder.{0} α] {a b c : α}, @has_le.le.{0} α (@preorder.to_has_le.{0} α _inst_1) a b → @has_le.le.{0} α (@preorder.to_has_le.{0} α _inst_1) b c → @has_le.le.{0} α (@preorder.to_has_le.{0} α _inst_1) a c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {p q : real}, @has_le.le.{0} real real.has_le p q → @has_le.le.{0} ennreal (@preorder.to_has_le.{0} ennreal (@partial_order.to_preorder.{0} ennreal (@ordered_comm_monoid.to_partial_order.{0} ennreal (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal ennreal.canonically_ordered_comm_semiring_1))))) (ennreal.of_real p) (ennreal.of_real q)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_le.le.{0} real real.has_le (@has_dist.dist.{u_2} E (@metric_space.to_has_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_1)) x y) (@has_dist.dist.{u_2} E (@metric_space.to_has_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_1)) x&#x27; y&#x27;)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='E : Type u_2,
_inst_1 : normed_group.{u_2} E,
_inst_2 : @normed_space.{0 u_2} real E normed_field.normed_field _inst_1,
s : set.{u_2} E,
x : E,
hx :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x
    (@convex_hull.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)
       (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2)
       s),
y : E,
hy :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y
    (@convex_hull.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)
       (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2)
       s),
x&#x27; : E,
hx&#x27; : @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x&#x27; s,
y&#x27; : E,
hy&#x27; : @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y&#x27; s,
H :
  @has_le.le.{0} real real.has_le
    (@has_dist.dist.{u_2} E (@metric_space.to_has_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_1)) x y)
    (@has_dist.dist.{u_2} E (@metric_space.to_has_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_1)) x&#x27; y&#x27;)
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (ennreal.of_real
       (@has_dist.dist.{u_2} E (@metric_space.to_has_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_1)) x y))
    (@emetric.diam.{u_2} E (@metric_space.to_emetric_space.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_1)) s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='E : Type u_2,
_inst_1 : normed_group.{u_2} E,
_inst_2 : @normed_space.{0 u_2} real E normed_field.normed_field _inst_1,
s : set.{u_2} E,
x : E,
hx :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x
    (@convex_hull.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)
       (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2)
       s),
y : E,
hy :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y
    (@convex_hull.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)
       (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2)
       s),
x&#x27; : E,
hx&#x27; : @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x&#x27; s,
y&#x27; : E,
hy&#x27; : @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y&#x27; s,
H :
  @has_le.le.{0} real real.has_le
    (@has_dist.dist.{u_2} E (@metric_space.to_has_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_1)) x y)
    (@has_dist.dist.{u_2} E (@metric_space.to_has_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_1)) x&#x27; y&#x27;)
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (ennreal.of_real
       (@has_dist.dist.{u_2} E (@metric_space.to_has_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_1)) x&#x27;
          y&#x27;))
    (@emetric.diam.{u_2} E (@metric_space.to_emetric_space.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_1)) s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>174    rw ← edist_dist,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='edist_dist'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/metric_space/basic.lean&#x27;, &#x27;line&#x27;: 90, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_2} [_inst_1 : metric_space.{u_2} α] (x y : α), @eq.{1} ennreal (@has_edist.edist.{u_2} α (@metric_space.to_has_edist.{u_2} α _inst_1) x y) (ennreal.of_real (@has_dist.dist.{u_2} α (@metric_space.to_has_dist.{u_2} α _inst_1) x y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='E : Type u_2,
_inst_1 : normed_group.{u_2} E,
_inst_2 : @normed_space.{0 u_2} real E normed_field.normed_field _inst_1,
s : set.{u_2} E,
x : E,
hx :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x
    (@convex_hull.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)
       (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2)
       s),
y : E,
hy :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y
    (@convex_hull.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)
       (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2)
       s),
x&#x27; : E,
hx&#x27; : @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x&#x27; s,
y&#x27; : E,
hy&#x27; : @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y&#x27; s,
H :
  @has_le.le.{0} real real.has_le
    (@has_dist.dist.{u_2} E (@metric_space.to_has_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_1)) x y)
    (@has_dist.dist.{u_2} E (@metric_space.to_has_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_1)) x&#x27; y&#x27;)
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (ennreal.of_real
       (@has_dist.dist.{u_2} E (@metric_space.to_has_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_1)) x&#x27;
          y&#x27;))
    (@emetric.diam.{u_2} E (@metric_space.to_emetric_space.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_1)) s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='E : Type u_2,
_inst_1 : normed_group.{u_2} E,
_inst_2 : @normed_space.{0 u_2} real E normed_field.normed_field _inst_1,
s : set.{u_2} E,
x : E,
hx :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x
    (@convex_hull.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)
       (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2)
       s),
y : E,
hy :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y
    (@convex_hull.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)
       (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2)
       s),
x&#x27; : E,
hx&#x27; : @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x&#x27; s,
y&#x27; : E,
hy&#x27; : @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y&#x27; s,
H :
  @has_le.le.{0} real real.has_le
    (@has_dist.dist.{u_2} E (@metric_space.to_has_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_1)) x y)
    (@has_dist.dist.{u_2} E (@metric_space.to_has_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_1)) x&#x27; y&#x27;)
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@has_edist.edist.{u_2} E (@metric_space.to_has_edist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_1)) x&#x27;
       y&#x27;)
    (@emetric.diam.{u_2} E (@metric_space.to_emetric_space.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_1)) s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>175    exact emetric.edist_le_diam_of_mem hx&#x27; hy&#x27;</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='emetric.edist_le_diam_of_mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hx&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hy&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/metric_space/emetric_space.lean&#x27;, &#x27;line&#x27;: 739, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_2} [_inst_1 : emetric_space.{u_2} α] {x y : α} {s : set.{u_2} α}, @has_mem.mem.{u_2 u_2} α (set.{u_2} α) (@set.has_mem.{u_2} α) x s → @has_mem.mem.{u_2 u_2} α (set.{u_2} α) (@set.has_mem.{u_2} α) y s → @has_le.le.{0} ennreal (@preorder.to_has_le.{0} ennreal (@partial_order.to_preorder.{0} ennreal (@ordered_comm_monoid.to_partial_order.{0} ennreal (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal ennreal.canonically_ordered_comm_semiring_1))))) (@has_edist.edist.{u_2} α (@emetric_space.to_has_edist.{u_2} α _inst_1) x y) (@emetric.diam.{u_2} α _inst_1 s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x&#x27; s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y&#x27; s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='If two points belong to some set, their edistance is bounded by the diameter of the set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='E : Type u_2,
_inst_1 : normed_group.{u_2} E,
_inst_2 : @normed_space.{0 u_2} real E normed_field.normed_field _inst_1,
s : set.{u_2} E,
x : E,
hx :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x
    (@convex_hull.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)
       (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2)
       s),
y : E,
hy :
  @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y
    (@convex_hull.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)
       (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2)
       s),
x&#x27; : E,
hx&#x27; : @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) x&#x27; s,
y&#x27; : E,
hy&#x27; : @has_mem.mem.{u_2 u_2} E (set.{u_2} E) (@set.has_mem.{u_2} E) y&#x27; s,
H :
  @has_le.le.{0} real real.has_le
    (@has_dist.dist.{u_2} E (@metric_space.to_has_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_1)) x y)
    (@has_dist.dist.{u_2} E (@metric_space.to_has_dist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_1)) x&#x27; y&#x27;)
⊢ @has_le.le.{0} ennreal
    (@preorder.to_has_le.{0} ennreal
       (@partial_order.to_preorder.{0} ennreal
          (@ordered_comm_monoid.to_partial_order.{0} ennreal
             (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} ennreal
                (@canonically_ordered_comm_semiring.to_canonically_ordered_monoid.{0} ennreal
                   ennreal.canonically_ordered_comm_semiring_1)))))
    (@has_edist.edist.{u_2} E (@metric_space.to_has_edist.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_1)) x&#x27;
       y&#x27;)
    (@emetric.diam.{u_2} E (@metric_space.to_emetric_space.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_1)) s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>176  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>177  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>178  /-- Diameter of the convex hull of a set `s` equals the emetric diameter of `s. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>179  @[simp] lemma convex_hull_diam (s : set E) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>180    metric.diam (convex_hull s) = metric.diam s :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='metric.diam'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='convex_hull'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='metric.diam'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/metric_space/basic.lean&#x27;, &#x27;line&#x27;: 1402, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/convex/basic.lean&#x27;, &#x27;line&#x27;: 703, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/metric_space/basic.lean&#x27;, &#x27;line&#x27;: 1402, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [_inst_1 : metric_space.{u} α], set.{u} α → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {E : Type u} [_inst_1 : add_comm_group.{u} E] [_inst_2 : @vector_space.{0 u} real E real.discrete_field _inst_1], set.{u} E → set.{u} E'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_2} E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : metric_space.{u} α], set.{u} α → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_2} E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title=' The diameter of a set in a metric space. To get controllable behavior even when the diameter
should be infinite, we express it in terms of the emetric.diameter'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Convex hull of a set `s` is the minimal convex set that includes `s`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title=' The diameter of a set in a metric space. To get controllable behavior even when the diameter
should be infinite, we express it in terms of the emetric.diameter'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>181  by simp only [metric.diam, convex_hull_ediam]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='metric.diam'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='convex_hull_ediam'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/metric_space/basic.lean&#x27;, &#x27;line&#x27;: 1402, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 166, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type ?l_1} [_inst_1 : metric_space.{?l_1} α], set.{?l_1} α → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {E : Type ?l_1} [_inst_1 : normed_group.{?l_1} E] [_inst_2 : @normed_space.{0 ?l_1} real E normed_field.normed_field _inst_1] (s : set.{?l_1} E), @eq.{1} ennreal (@emetric.diam.{?l_1} E (@metric_space.to_emetric_space.{?l_1} E (@normed_group.to_metric_space.{?l_1} E _inst_1)) (@convex_hull.{?l_1} E (@normed_group.to_add_comm_group.{?l_1} E _inst_1) (@normed_space.to_module.{0 ?l_1} real E normed_field.normed_field _inst_1 _inst_2) s)) (@emetric.diam.{?l_1} E (@metric_space.to_emetric_space.{?l_1} E (@normed_group.to_metric_space.{?l_1} E _inst_1)) s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title=' The diameter of a set in a metric space. To get controllable behavior even when the diameter
should be infinite, we express it in terms of the emetric.diameter'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Emetric diameter of the convex hull of a set `s` equals the emetric diameter of `s.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='E : Type u_2,
_inst_1 : normed_group.{u_2} E,
_inst_2 : @normed_space.{0 u_2} real E normed_field.normed_field _inst_1,
s : set.{u_2} E
⊢ @eq.{1} real
    (@metric.diam.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_1)
       (@convex_hull.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)
          (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2)
          s))
    (@metric.diam.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_1) s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>182  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='E : Type u_2,
_inst_1 : normed_group.{u_2} E,
_inst_2 : @normed_space.{0 u_2} real E normed_field.normed_field _inst_1,
s : set.{u_2} E
⊢ @eq.{1} real
    (@metric.diam.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_1)
       (@convex_hull.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)
          (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2)
          s))
    (@metric.diam.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_1) s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>183  /-- Convex hull of `s` is bounded if and only if `s` is bounded. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>184  @[simp] lemma bounded_convex_hull {s : set E} :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>185    metric.bounded (convex_hull s) ↔ metric.bounded s :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='metric.bounded'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='convex_hull'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='metric.bounded'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/metric_space/basic.lean&#x27;, &#x27;line&#x27;: 1268, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/convex/basic.lean&#x27;, &#x27;line&#x27;: 703, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/metric_space/basic.lean&#x27;, &#x27;line&#x27;: 1268, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [_inst_1 : metric_space.{u} α], set.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {E : Type u} [_inst_1 : add_comm_group.{u} E] [_inst_2 : @vector_space.{0 u} real E real.discrete_field _inst_1], set.{u} E → set.{u} E'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_2} E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : metric_space.{u} α], set.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_2} E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title=' Boundedness of a subset of a metric space. We formulate the definition to work
even in the empty space.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Convex hull of a set `s` is the minimal convex set that includes `s`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title=' Boundedness of a subset of a metric space. We formulate the definition to work
even in the empty space.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>186  by simp only [metric.bounded_iff_ediam_ne_top, convex_hull_ediam]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='metric.bounded_iff_ediam_ne_top'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='convex_hull_ediam'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/metric_space/basic.lean&#x27;, &#x27;line&#x27;: 1459, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 166, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} [_inst_1 : metric_space.{?l_1} α] {s : set.{?l_1} α}, iff (@metric.bounded.{?l_1} α _inst_1 s) (@ne.{1} ennreal (@emetric.diam.{?l_1} α (@metric_space.to_emetric_space.{?l_1} α _inst_1) s) (@lattice.has_top.top.{0} ennreal (@lattice.order_top.to_has_top.{0} ennreal (@lattice.bounded_lattice.to_order_top.{0} ennreal (@lattice.complete_lattice.to_bounded_lattice.{0} ennreal (@lattice.complete_linear_order.to_complete_lattice.{0} ennreal ennreal.complete_linear_order_1))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {E : Type ?l_1} [_inst_1 : normed_group.{?l_1} E] [_inst_2 : @normed_space.{0 ?l_1} real E normed_field.normed_field _inst_1] (s : set.{?l_1} E), @eq.{1} ennreal (@emetric.diam.{?l_1} E (@metric_space.to_emetric_space.{?l_1} E (@normed_group.to_metric_space.{?l_1} E _inst_1)) (@convex_hull.{?l_1} E (@normed_group.to_add_comm_group.{?l_1} E _inst_1) (@normed_space.to_module.{0 ?l_1} real E normed_field.normed_field _inst_1 _inst_2) s)) (@emetric.diam.{?l_1} E (@metric_space.to_emetric_space.{?l_1} E (@normed_group.to_metric_space.{?l_1} E _inst_1)) s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Characterize the boundedness of a set in terms of the finiteness of its emetric.diameter.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Emetric diameter of the convex hull of a set `s` equals the emetric diameter of `s.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='E : Type u_2,
_inst_1 : normed_group.{u_2} E,
_inst_2 : @normed_space.{0 u_2} real E normed_field.normed_field _inst_1,
s : set.{u_2} E
⊢ iff
    (@metric.bounded.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_1)
       (@convex_hull.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)
          (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2)
          s))
    (@metric.bounded.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_1) s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>187  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='E : Type u_2,
_inst_1 : normed_group.{u_2} E,
_inst_2 : @normed_space.{0 u_2} real E normed_field.normed_field _inst_1,
s : set.{u_2} E
⊢ iff
    (@metric.bounded.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_1)
       (@convex_hull.{u_2} E (@normed_group.to_add_comm_group.{u_2} E _inst_1)
          (@normed_space.to_module.{0 u_2} real E normed_field.normed_field _inst_1 _inst_2)
          s))
    (@metric.bounded.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_1) s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>188  end normed_space</code></pre>
</body>